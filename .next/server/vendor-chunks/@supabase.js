/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@supabase";
exports.ids = ["vendor-chunks/@supabase"];
exports.modules = {

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/AuthAdminApi.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/AuthAdminApi.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst GoTrueAdminApi_1 = tslib_1.__importDefault(__webpack_require__(/*! ./GoTrueAdminApi */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/GoTrueAdminApi.js\"));\nconst AuthAdminApi = GoTrueAdminApi_1.default;\nexports[\"default\"] = AuthAdminApi; //# sourceMappingURL=AuthAdminApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL0F1dGhBZG1pbkFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxVQUFVQyxtQkFBT0EsQ0FBQyx1REFBTztBQUMvQixNQUFNQyxtQkFBbUJGLFFBQVFHLGVBQWUsQ0FBQ0YsbUJBQU9BLENBQUMsNEZBQWtCO0FBQzNFLE1BQU1HLGVBQWVGLGlCQUFpQkcsT0FBTztBQUM3Q1Asa0JBQWUsR0FBR00sY0FDbEIsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbWFpbi9BdXRoQWRtaW5BcGkuanM/OTZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5jb25zdCBHb1RydWVBZG1pbkFwaV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vR29UcnVlQWRtaW5BcGlcIikpO1xuY29uc3QgQXV0aEFkbWluQXBpID0gR29UcnVlQWRtaW5BcGlfMS5kZWZhdWx0O1xuZXhwb3J0cy5kZWZhdWx0ID0gQXV0aEFkbWluQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aEFkbWluQXBpLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRzbGliXzEiLCJyZXF1aXJlIiwiR29UcnVlQWRtaW5BcGlfMSIsIl9faW1wb3J0RGVmYXVsdCIsIkF1dGhBZG1pbkFwaSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/AuthAdminApi.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/AuthClient.js":
/*!****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/AuthClient.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst GoTrueClient_1 = tslib_1.__importDefault(__webpack_require__(/*! ./GoTrueClient */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/GoTrueClient.js\"));\nconst AuthClient = GoTrueClient_1.default;\nexports[\"default\"] = AuthClient; //# sourceMappingURL=AuthClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL0F1dGhDbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsVUFBVUMsbUJBQU9BLENBQUMsdURBQU87QUFDL0IsTUFBTUMsaUJBQWlCRixRQUFRRyxlQUFlLENBQUNGLG1CQUFPQSxDQUFDLHdGQUFnQjtBQUN2RSxNQUFNRyxhQUFhRixlQUFlRyxPQUFPO0FBQ3pDUCxrQkFBZSxHQUFHTSxZQUNsQixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL0F1dGhDbGllbnQuanM/OGVlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5jb25zdCBHb1RydWVDbGllbnRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0dvVHJ1ZUNsaWVudFwiKSk7XG5jb25zdCBBdXRoQ2xpZW50ID0gR29UcnVlQ2xpZW50XzEuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IEF1dGhDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdXRoQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRzbGliXzEiLCJyZXF1aXJlIiwiR29UcnVlQ2xpZW50XzEiLCJfX2ltcG9ydERlZmF1bHQiLCJBdXRoQ2xpZW50IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/AuthClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/GoTrueAdminApi.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/GoTrueAdminApi.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst fetch_1 = __webpack_require__(/*! ./lib/fetch */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/fetch.js\");\nconst helpers_1 = __webpack_require__(/*! ./lib/helpers */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/helpers.js\");\nconst types_1 = __webpack_require__(/*! ./lib/types */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/types.js\");\nconst errors_1 = __webpack_require__(/*! ./lib/errors */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/errors.js\");\nclass GoTrueAdminApi {\n    /**\n     * Creates an admin API client that can be used to manage users and OAuth clients.\n     *\n     * @example\n     * ```ts\n     * import { GoTrueAdminApi } from '@supabase/auth-js'\n     *\n     * const admin = new GoTrueAdminApi({\n     *   url: 'https://xyzcompany.supabase.co/auth/v1',\n     *   headers: { Authorization: `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}` },\n     * })\n     * ```\n     */ constructor({ url = \"\", headers = {}, fetch }){\n        this.url = url;\n        this.headers = headers;\n        this.fetch = (0, helpers_1.resolveFetch)(fetch);\n        this.mfa = {\n            listFactors: this._listFactors.bind(this),\n            deleteFactor: this._deleteFactor.bind(this)\n        };\n        this.oauth = {\n            listClients: this._listOAuthClients.bind(this),\n            createClient: this._createOAuthClient.bind(this),\n            getClient: this._getOAuthClient.bind(this),\n            updateClient: this._updateOAuthClient.bind(this),\n            deleteClient: this._deleteOAuthClient.bind(this),\n            regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)\n        };\n    }\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     * @param scope The logout sope.\n     */ async signOut(jwt, scope = types_1.SIGN_OUT_SCOPES[0]) {\n        if (types_1.SIGN_OUT_SCOPES.indexOf(scope) < 0) {\n            throw new Error(`@supabase/auth-js: Parameter scope must be one of ${types_1.SIGN_OUT_SCOPES.join(\", \")}`);\n        }\n        try {\n            await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/logout?scope=${scope}`, {\n                headers: this.headers,\n                jwt,\n                noResolveJson: true\n            });\n            return {\n                data: null,\n                error: null\n            };\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param options Additional options to be included when inviting.\n     */ async inviteUserByEmail(email, options = {}) {\n        try {\n            return await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/invite`, {\n                body: {\n                    email,\n                    data: options.data\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo,\n                xform: fetch_1._userResponse\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates email links and OTPs to be sent via a custom email provider.\n     * @param email The user's email.\n     * @param options.password User password. For signup only.\n     * @param options.data Optional user metadata. For signup only.\n     * @param options.redirectTo The redirect url which should be appended to the generated link\n     */ async generateLink(params) {\n        try {\n            const { options } = params, rest = tslib_1.__rest(params, [\n                \"options\"\n            ]);\n            const body = Object.assign(Object.assign({}, rest), options);\n            if (\"newEmail\" in rest) {\n                // replace newEmail with new_email in request body\n                body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;\n                delete body[\"newEmail\"];\n            }\n            return await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/admin/generate_link`, {\n                body: body,\n                headers: this.headers,\n                xform: fetch_1._generateLinkResponse,\n                redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: {\n                        properties: null,\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    // User Admin API\n    /**\n     * Creates a new user.\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async createUser(attributes) {\n        try {\n            return await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/admin/users`, {\n                body: attributes,\n                headers: this.headers,\n                xform: fetch_1._userResponse\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\n     */ async listUsers(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = {\n                nextPage: null,\n                lastPage: 0,\n                total: 0\n            };\n            const response = await (0, fetch_1._request)(this.fetch, \"GET\", `${this.url}/admin/users`, {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\",\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : \"\"\n                },\n                xform: fetch_1._noResolveJsonResponse\n            });\n            if (response.error) throw response.error;\n            const users = await response.json();\n            const total = (_e = response.headers.get(\"x-total-count\")) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get(\"link\")) === null || _f === void 0 ? void 0 : _f.split(\",\")) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link)=>{\n                    const page = parseInt(link.split(\";\")[0].split(\"=\")[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(\";\")[1].split(\"=\")[1]);\n                    pagination[`${rel}Page`] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return {\n                data: Object.assign(Object.assign({}, users), pagination),\n                error: null\n            };\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: {\n                        users: []\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async getUserById(uid) {\n        (0, helpers_1.validateUUID)(uid);\n        try {\n            return await (0, fetch_1._request)(this.fetch, \"GET\", `${this.url}/admin/users/${uid}`, {\n                headers: this.headers,\n                xform: fetch_1._userResponse\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates the user data. Changes are applied directly without confirmation flows.\n     *\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async updateUserById(uid, attributes) {\n        (0, helpers_1.validateUUID)(uid);\n        try {\n            return await (0, fetch_1._request)(this.fetch, \"PUT\", `${this.url}/admin/users/${uid}`, {\n                body: attributes,\n                headers: this.headers,\n                xform: fetch_1._userResponse\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * @param id The user id you want to remove.\n     * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.\n     * Defaults to false for backward compatibility.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async deleteUser(id, shouldSoftDelete = false) {\n        (0, helpers_1.validateUUID)(id);\n        try {\n            return await (0, fetch_1._request)(this.fetch, \"DELETE\", `${this.url}/admin/users/${id}`, {\n                headers: this.headers,\n                body: {\n                    should_soft_delete: shouldSoftDelete\n                },\n                xform: fetch_1._userResponse\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _listFactors(params) {\n        (0, helpers_1.validateUUID)(params.userId);\n        try {\n            const { data, error } = await (0, fetch_1._request)(this.fetch, \"GET\", `${this.url}/admin/users/${params.userId}/factors`, {\n                headers: this.headers,\n                xform: (factors)=>{\n                    return {\n                        data: {\n                            factors\n                        },\n                        error: null\n                    };\n                }\n            });\n            return {\n                data,\n                error\n            };\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _deleteFactor(params) {\n        (0, helpers_1.validateUUID)(params.userId);\n        (0, helpers_1.validateUUID)(params.id);\n        try {\n            const data = await (0, fetch_1._request)(this.fetch, \"DELETE\", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {\n                headers: this.headers\n            });\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Lists all OAuth clients with optional pagination.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _listOAuthClients(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = {\n                nextPage: null,\n                lastPage: 0,\n                total: 0\n            };\n            const response = await (0, fetch_1._request)(this.fetch, \"GET\", `${this.url}/admin/oauth/clients`, {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\",\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : \"\"\n                },\n                xform: fetch_1._noResolveJsonResponse\n            });\n            if (response.error) throw response.error;\n            const clients = await response.json();\n            const total = (_e = response.headers.get(\"x-total-count\")) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get(\"link\")) === null || _f === void 0 ? void 0 : _f.split(\",\")) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link)=>{\n                    const page = parseInt(link.split(\";\")[0].split(\"=\")[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(\";\")[1].split(\"=\")[1]);\n                    pagination[`${rel}Page`] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return {\n                data: Object.assign(Object.assign({}, clients), pagination),\n                error: null\n            };\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: {\n                        clients: []\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _createOAuthClient(params) {\n        try {\n            return await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/admin/oauth/clients`, {\n                body: params,\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets details of a specific OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _getOAuthClient(clientId) {\n        try {\n            return await (0, fetch_1._request)(this.fetch, \"GET\", `${this.url}/admin/oauth/clients/${clientId}`, {\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates an existing OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _updateOAuthClient(clientId, params) {\n        try {\n            return await (0, fetch_1._request)(this.fetch, \"PUT\", `${this.url}/admin/oauth/clients/${clientId}`, {\n                body: params,\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Deletes an OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _deleteOAuthClient(clientId) {\n        try {\n            await (0, fetch_1._request)(this.fetch, \"DELETE\", `${this.url}/admin/oauth/clients/${clientId}`, {\n                headers: this.headers,\n                noResolveJson: true\n            });\n            return {\n                data: null,\n                error: null\n            };\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Regenerates the secret for an OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _regenerateOAuthClientSecret(clientId) {\n        try {\n            return await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`, {\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n}\nexports[\"default\"] = GoTrueAdminApi; //# sourceMappingURL=GoTrueAdminApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL0dvVHJ1ZUFkbWluQXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLHVEQUFPO0FBQy9CLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLGtGQUFhO0FBQ3JDLE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDLHNGQUFlO0FBQ3pDLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLGtGQUFhO0FBQ3JDLE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDLG9GQUFjO0FBQ3ZDLE1BQU1LO0lBQ0Y7Ozs7Ozs7Ozs7OztLQVlDLEdBQ0RDLFlBQVksRUFBRUMsTUFBTSxFQUFFLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUVDLEtBQUssRUFBRyxDQUFFO1FBQzVDLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsS0FBSyxHQUFHLENBQUMsR0FBR1AsVUFBVVEsWUFBWSxFQUFFRDtRQUN6QyxJQUFJLENBQUNFLEdBQUcsR0FBRztZQUNQQyxhQUFhLElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxJQUFJLENBQUMsSUFBSTtZQUN4Q0MsY0FBYyxJQUFJLENBQUNDLGFBQWEsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDOUM7UUFDQSxJQUFJLENBQUNHLEtBQUssR0FBRztZQUNUQyxhQUFhLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNMLElBQUksQ0FBQyxJQUFJO1lBQzdDTSxjQUFjLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNQLElBQUksQ0FBQyxJQUFJO1lBQy9DUSxXQUFXLElBQUksQ0FBQ0MsZUFBZSxDQUFDVCxJQUFJLENBQUMsSUFBSTtZQUN6Q1UsY0FBYyxJQUFJLENBQUNDLGtCQUFrQixDQUFDWCxJQUFJLENBQUMsSUFBSTtZQUMvQ1ksY0FBYyxJQUFJLENBQUNDLGtCQUFrQixDQUFDYixJQUFJLENBQUMsSUFBSTtZQUMvQ2Msd0JBQXdCLElBQUksQ0FBQ0MsNEJBQTRCLENBQUNmLElBQUksQ0FBQyxJQUFJO1FBQ3ZFO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTWdCLFFBQVFDLEdBQUcsRUFBRUMsUUFBUTdCLFFBQVE4QixlQUFlLENBQUMsRUFBRSxFQUFFO1FBQ25ELElBQUk5QixRQUFROEIsZUFBZSxDQUFDQyxPQUFPLENBQUNGLFNBQVMsR0FBRztZQUM1QyxNQUFNLElBQUlHLE1BQU0sQ0FBQyxrREFBa0QsRUFBRWhDLFFBQVE4QixlQUFlLENBQUNHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDN0c7UUFDQSxJQUFJO1lBQ0EsTUFBTSxDQUFDLEdBQUduQyxRQUFRb0MsUUFBUSxFQUFFLElBQUksQ0FBQzVCLEtBQUssRUFBRSxRQUFRLENBQUMsRUFBRSxJQUFJLENBQUNGLEdBQUcsQ0FBQyxjQUFjLEVBQUV5QixNQUFNLENBQUMsRUFBRTtnQkFDakZ4QixTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDckJ1QjtnQkFDQU8sZUFBZTtZQUNuQjtZQUNBLE9BQU87Z0JBQUVDLE1BQU07Z0JBQU1DLE9BQU87WUFBSztRQUNyQyxFQUNBLE9BQU9BLE9BQU87WUFDVixJQUFJLENBQUMsR0FBR3BDLFNBQVNxQyxXQUFXLEVBQUVELFFBQVE7Z0JBQ2xDLE9BQU87b0JBQUVELE1BQU07b0JBQU1DO2dCQUFNO1lBQy9CO1lBQ0EsTUFBTUE7UUFDVjtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNELE1BQU1FLGtCQUFrQkMsS0FBSyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQ3pDLElBQUk7WUFDQSxPQUFPLE1BQU0sQ0FBQyxHQUFHM0MsUUFBUW9DLFFBQVEsRUFBRSxJQUFJLENBQUM1QixLQUFLLEVBQUUsUUFBUSxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ3pFc0MsTUFBTTtvQkFBRUY7b0JBQU9KLE1BQU1LLFFBQVFMLElBQUk7Z0JBQUM7Z0JBQ2xDL0IsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCc0MsWUFBWUYsUUFBUUUsVUFBVTtnQkFDOUJDLE9BQU85QyxRQUFRK0MsYUFBYTtZQUNoQztRQUNKLEVBQ0EsT0FBT1IsT0FBTztZQUNWLElBQUksQ0FBQyxHQUFHcEMsU0FBU3FDLFdBQVcsRUFBRUQsUUFBUTtnQkFDbEMsT0FBTztvQkFBRUQsTUFBTTt3QkFBRVUsTUFBTTtvQkFBSztvQkFBR1Q7Z0JBQU07WUFDekM7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDRCxNQUFNVSxhQUFhQyxNQUFNLEVBQUU7UUFDdkIsSUFBSTtZQUNBLE1BQU0sRUFBRVAsT0FBTyxFQUFFLEdBQUdPLFFBQVFDLE9BQU9yRCxRQUFRc0QsTUFBTSxDQUFDRixRQUFRO2dCQUFDO2FBQVU7WUFDckUsTUFBTU4sT0FBT2xELE9BQU8yRCxNQUFNLENBQUMzRCxPQUFPMkQsTUFBTSxDQUFDLENBQUMsR0FBR0YsT0FBT1I7WUFDcEQsSUFBSSxjQUFjUSxNQUFNO2dCQUNwQixrREFBa0Q7Z0JBQ2xEUCxLQUFLVSxTQUFTLEdBQUdILFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLSSxRQUFRO2dCQUMxRSxPQUFPWCxJQUFJLENBQUMsV0FBVztZQUMzQjtZQUNBLE9BQU8sTUFBTSxDQUFDLEdBQUc1QyxRQUFRb0MsUUFBUSxFQUFFLElBQUksQ0FBQzVCLEtBQUssRUFBRSxRQUFRLENBQUMsRUFBRSxJQUFJLENBQUNGLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFO2dCQUN0RnNDLE1BQU1BO2dCQUNOckMsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCdUMsT0FBTzlDLFFBQVF3RCxxQkFBcUI7Z0JBQ3BDWCxZQUFZRixZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUUUsVUFBVTtZQUNwRjtRQUNKLEVBQ0EsT0FBT04sT0FBTztZQUNWLElBQUksQ0FBQyxHQUFHcEMsU0FBU3FDLFdBQVcsRUFBRUQsUUFBUTtnQkFDbEMsT0FBTztvQkFDSEQsTUFBTTt3QkFDRm1CLFlBQVk7d0JBQ1pULE1BQU07b0JBQ1Y7b0JBQ0FUO2dCQUNKO1lBQ0o7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQSxpQkFBaUI7SUFDakI7OztLQUdDLEdBQ0QsTUFBTW1CLFdBQVdDLFVBQVUsRUFBRTtRQUN6QixJQUFJO1lBQ0EsT0FBTyxNQUFNLENBQUMsR0FBRzNELFFBQVFvQyxRQUFRLEVBQUUsSUFBSSxDQUFDNUIsS0FBSyxFQUFFLFFBQVEsQ0FBQyxFQUFFLElBQUksQ0FBQ0YsR0FBRyxDQUFDLFlBQVksQ0FBQyxFQUFFO2dCQUM5RXNDLE1BQU1lO2dCQUNOcEQsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCdUMsT0FBTzlDLFFBQVErQyxhQUFhO1lBQ2hDO1FBQ0osRUFDQSxPQUFPUixPQUFPO1lBQ1YsSUFBSSxDQUFDLEdBQUdwQyxTQUFTcUMsV0FBVyxFQUFFRCxRQUFRO2dCQUNsQyxPQUFPO29CQUFFRCxNQUFNO3dCQUFFVSxNQUFNO29CQUFLO29CQUFHVDtnQkFBTTtZQUN6QztZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTXFCLFVBQVVWLE1BQU0sRUFBRTtRQUNwQixJQUFJVyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztRQUM1QixJQUFJO1lBQ0EsTUFBTUMsYUFBYTtnQkFBRUMsVUFBVTtnQkFBTUMsVUFBVTtnQkFBR0MsT0FBTztZQUFFO1lBQzNELE1BQU1DLFdBQVcsTUFBTSxDQUFDLEdBQUd4RSxRQUFRb0MsUUFBUSxFQUFFLElBQUksQ0FBQzVCLEtBQUssRUFBRSxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUNGLEdBQUcsQ0FBQyxZQUFZLENBQUMsRUFBRTtnQkFDdkZDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQjhCLGVBQWU7Z0JBQ2ZvQyxPQUFPO29CQUNIQyxNQUFNLENBQUNaLEtBQUssQ0FBQ0QsS0FBS1gsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU93QixJQUFJLE1BQU0sUUFBUWIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHYyxRQUFRLEVBQUMsTUFBTyxRQUFRYixPQUFPLEtBQUssSUFBSUEsS0FBSztvQkFDcEtjLFVBQVUsQ0FBQ1osS0FBSyxDQUFDRCxLQUFLYixXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBTzJCLE9BQU8sTUFBTSxRQUFRZCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdZLFFBQVEsRUFBQyxNQUFPLFFBQVFYLE9BQU8sS0FBSyxJQUFJQSxLQUFLO2dCQUMvSztnQkFDQWxCLE9BQU85QyxRQUFROEUsc0JBQXNCO1lBQ3pDO1lBQ0EsSUFBSU4sU0FBU2pDLEtBQUssRUFDZCxNQUFNaUMsU0FBU2pDLEtBQUs7WUFDeEIsTUFBTXdDLFFBQVEsTUFBTVAsU0FBU1EsSUFBSTtZQUNqQyxNQUFNVCxRQUFRLENBQUNOLEtBQUtPLFNBQVNqRSxPQUFPLENBQUMwRSxHQUFHLENBQUMsZ0JBQWUsTUFBTyxRQUFRaEIsT0FBTyxLQUFLLElBQUlBLEtBQUs7WUFDNUYsTUFBTWlCLFFBQVEsQ0FBQ2YsS0FBSyxDQUFDRCxLQUFLTSxTQUFTakUsT0FBTyxDQUFDMEUsR0FBRyxDQUFDLE9BQU0sTUFBTyxRQUFRZixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdpQixLQUFLLENBQUMsSUFBRyxNQUFPLFFBQVFoQixPQUFPLEtBQUssSUFBSUEsS0FBSyxFQUFFO1lBQy9JLElBQUllLE1BQU1FLE1BQU0sR0FBRyxHQUFHO2dCQUNsQkYsTUFBTUcsT0FBTyxDQUFDLENBQUNDO29CQUNYLE1BQU1aLE9BQU9hLFNBQVNELEtBQUtILEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDQSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQ0ssU0FBUyxDQUFDLEdBQUc7b0JBQ3BFLE1BQU1DLE1BQU1DLEtBQUtDLEtBQUssQ0FBQ0wsS0FBS0gsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUNBLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDdkRmLFVBQVUsQ0FBQyxDQUFDLEVBQUVxQixJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUdmO2dCQUMvQjtnQkFDQU4sV0FBV0csS0FBSyxHQUFHZ0IsU0FBU2hCO1lBQ2hDO1lBQ0EsT0FBTztnQkFBRWpDLE1BQU01QyxPQUFPMkQsTUFBTSxDQUFDM0QsT0FBTzJELE1BQU0sQ0FBQyxDQUFDLEdBQUcwQixRQUFRWDtnQkFBYTdCLE9BQU87WUFBSztRQUNwRixFQUNBLE9BQU9BLE9BQU87WUFDVixJQUFJLENBQUMsR0FBR3BDLFNBQVNxQyxXQUFXLEVBQUVELFFBQVE7Z0JBQ2xDLE9BQU87b0JBQUVELE1BQU07d0JBQUV5QyxPQUFPLEVBQUU7b0JBQUM7b0JBQUd4QztnQkFBTTtZQUN4QztZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNELE1BQU1xRCxZQUFZQyxHQUFHLEVBQUU7UUFDbEIsSUFBRzVGLFVBQVU2RixZQUFZLEVBQUVEO1FBQzVCLElBQUk7WUFDQSxPQUFPLE1BQU0sQ0FBQyxHQUFHN0YsUUFBUW9DLFFBQVEsRUFBRSxJQUFJLENBQUM1QixLQUFLLEVBQUUsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsYUFBYSxFQUFFdUYsSUFBSSxDQUFDLEVBQUU7Z0JBQ3BGdEYsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCdUMsT0FBTzlDLFFBQVErQyxhQUFhO1lBQ2hDO1FBQ0osRUFDQSxPQUFPUixPQUFPO1lBQ1YsSUFBSSxDQUFDLEdBQUdwQyxTQUFTcUMsV0FBVyxFQUFFRCxRQUFRO2dCQUNsQyxPQUFPO29CQUFFRCxNQUFNO3dCQUFFVSxNQUFNO29CQUFLO29CQUFHVDtnQkFBTTtZQUN6QztZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNELE1BQU13RCxlQUFlRixHQUFHLEVBQUVsQyxVQUFVLEVBQUU7UUFDakMsSUFBRzFELFVBQVU2RixZQUFZLEVBQUVEO1FBQzVCLElBQUk7WUFDQSxPQUFPLE1BQU0sQ0FBQyxHQUFHN0YsUUFBUW9DLFFBQVEsRUFBRSxJQUFJLENBQUM1QixLQUFLLEVBQUUsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsYUFBYSxFQUFFdUYsSUFBSSxDQUFDLEVBQUU7Z0JBQ3BGakQsTUFBTWU7Z0JBQ05wRCxTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDckJ1QyxPQUFPOUMsUUFBUStDLGFBQWE7WUFDaEM7UUFDSixFQUNBLE9BQU9SLE9BQU87WUFDVixJQUFJLENBQUMsR0FBR3BDLFNBQVNxQyxXQUFXLEVBQUVELFFBQVE7Z0JBQ2xDLE9BQU87b0JBQUVELE1BQU07d0JBQUVVLE1BQU07b0JBQUs7b0JBQUdUO2dCQUFNO1lBQ3pDO1lBQ0EsTUFBTUE7UUFDVjtJQUNKO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRCxNQUFNeUQsV0FBV0MsRUFBRSxFQUFFQyxtQkFBbUIsS0FBSyxFQUFFO1FBQzFDLElBQUdqRyxVQUFVNkYsWUFBWSxFQUFFRztRQUM1QixJQUFJO1lBQ0EsT0FBTyxNQUFNLENBQUMsR0FBR2pHLFFBQVFvQyxRQUFRLEVBQUUsSUFBSSxDQUFDNUIsS0FBSyxFQUFFLFVBQVUsQ0FBQyxFQUFFLElBQUksQ0FBQ0YsR0FBRyxDQUFDLGFBQWEsRUFBRTJGLEdBQUcsQ0FBQyxFQUFFO2dCQUN0RjFGLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQnFDLE1BQU07b0JBQ0Z1RCxvQkFBb0JEO2dCQUN4QjtnQkFDQXBELE9BQU85QyxRQUFRK0MsYUFBYTtZQUNoQztRQUNKLEVBQ0EsT0FBT1IsT0FBTztZQUNWLElBQUksQ0FBQyxHQUFHcEMsU0FBU3FDLFdBQVcsRUFBRUQsUUFBUTtnQkFDbEMsT0FBTztvQkFBRUQsTUFBTTt3QkFBRVUsTUFBTTtvQkFBSztvQkFBR1Q7Z0JBQU07WUFDekM7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQSxNQUFNM0IsYUFBYXNDLE1BQU0sRUFBRTtRQUN0QixJQUFHakQsVUFBVTZGLFlBQVksRUFBRTVDLE9BQU9rRCxNQUFNO1FBQ3pDLElBQUk7WUFDQSxNQUFNLEVBQUU5RCxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU0sQ0FBQyxHQUFHdkMsUUFBUW9DLFFBQVEsRUFBRSxJQUFJLENBQUM1QixLQUFLLEVBQUUsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsYUFBYSxFQUFFNEMsT0FBT2tELE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRTtnQkFDdkg3RixTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDckJ1QyxPQUFPLENBQUN1RDtvQkFDSixPQUFPO3dCQUFFL0QsTUFBTTs0QkFBRStEO3dCQUFRO3dCQUFHOUQsT0FBTztvQkFBSztnQkFDNUM7WUFDSjtZQUNBLE9BQU87Z0JBQUVEO2dCQUFNQztZQUFNO1FBQ3pCLEVBQ0EsT0FBT0EsT0FBTztZQUNWLElBQUksQ0FBQyxHQUFHcEMsU0FBU3FDLFdBQVcsRUFBRUQsUUFBUTtnQkFDbEMsT0FBTztvQkFBRUQsTUFBTTtvQkFBTUM7Z0JBQU07WUFDL0I7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQSxNQUFNeEIsY0FBY21DLE1BQU0sRUFBRTtRQUN2QixJQUFHakQsVUFBVTZGLFlBQVksRUFBRTVDLE9BQU9rRCxNQUFNO1FBQ3hDLElBQUduRyxVQUFVNkYsWUFBWSxFQUFFNUMsT0FBTytDLEVBQUU7UUFDckMsSUFBSTtZQUNBLE1BQU0zRCxPQUFPLE1BQU0sQ0FBQyxHQUFHdEMsUUFBUW9DLFFBQVEsRUFBRSxJQUFJLENBQUM1QixLQUFLLEVBQUUsVUFBVSxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsYUFBYSxFQUFFNEMsT0FBT2tELE1BQU0sQ0FBQyxTQUFTLEVBQUVsRCxPQUFPK0MsRUFBRSxDQUFDLENBQUMsRUFBRTtnQkFDNUgxRixTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUN6QjtZQUNBLE9BQU87Z0JBQUUrQjtnQkFBTUMsT0FBTztZQUFLO1FBQy9CLEVBQ0EsT0FBT0EsT0FBTztZQUNWLElBQUksQ0FBQyxHQUFHcEMsU0FBU3FDLFdBQVcsRUFBRUQsUUFBUTtnQkFDbEMsT0FBTztvQkFBRUQsTUFBTTtvQkFBTUM7Z0JBQU07WUFDL0I7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNELE1BQU1yQixrQkFBa0JnQyxNQUFNLEVBQUU7UUFDNUIsSUFBSVcsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUM7UUFDNUIsSUFBSTtZQUNBLE1BQU1DLGFBQWE7Z0JBQUVDLFVBQVU7Z0JBQU1DLFVBQVU7Z0JBQUdDLE9BQU87WUFBRTtZQUMzRCxNQUFNQyxXQUFXLE1BQU0sQ0FBQyxHQUFHeEUsUUFBUW9DLFFBQVEsRUFBRSxJQUFJLENBQUM1QixLQUFLLEVBQUUsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsb0JBQW9CLENBQUMsRUFBRTtnQkFDL0ZDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQjhCLGVBQWU7Z0JBQ2ZvQyxPQUFPO29CQUNIQyxNQUFNLENBQUNaLEtBQUssQ0FBQ0QsS0FBS1gsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU93QixJQUFJLE1BQU0sUUFBUWIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHYyxRQUFRLEVBQUMsTUFBTyxRQUFRYixPQUFPLEtBQUssSUFBSUEsS0FBSztvQkFDcEtjLFVBQVUsQ0FBQ1osS0FBSyxDQUFDRCxLQUFLYixXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBTzJCLE9BQU8sTUFBTSxRQUFRZCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdZLFFBQVEsRUFBQyxNQUFPLFFBQVFYLE9BQU8sS0FBSyxJQUFJQSxLQUFLO2dCQUMvSztnQkFDQWxCLE9BQU85QyxRQUFROEUsc0JBQXNCO1lBQ3pDO1lBQ0EsSUFBSU4sU0FBU2pDLEtBQUssRUFDZCxNQUFNaUMsU0FBU2pDLEtBQUs7WUFDeEIsTUFBTStELFVBQVUsTUFBTTlCLFNBQVNRLElBQUk7WUFDbkMsTUFBTVQsUUFBUSxDQUFDTixLQUFLTyxTQUFTakUsT0FBTyxDQUFDMEUsR0FBRyxDQUFDLGdCQUFlLE1BQU8sUUFBUWhCLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1lBQzVGLE1BQU1pQixRQUFRLENBQUNmLEtBQUssQ0FBQ0QsS0FBS00sU0FBU2pFLE9BQU8sQ0FBQzBFLEdBQUcsQ0FBQyxPQUFNLE1BQU8sUUFBUWYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaUIsS0FBSyxDQUFDLElBQUcsTUFBTyxRQUFRaEIsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtZQUMvSSxJQUFJZSxNQUFNRSxNQUFNLEdBQUcsR0FBRztnQkFDbEJGLE1BQU1HLE9BQU8sQ0FBQyxDQUFDQztvQkFDWCxNQUFNWixPQUFPYSxTQUFTRCxLQUFLSCxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUNLLFNBQVMsQ0FBQyxHQUFHO29CQUNwRSxNQUFNQyxNQUFNQyxLQUFLQyxLQUFLLENBQUNMLEtBQUtILEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDQSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ3ZEZixVQUFVLENBQUMsQ0FBQyxFQUFFcUIsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHZjtnQkFDL0I7Z0JBQ0FOLFdBQVdHLEtBQUssR0FBR2dCLFNBQVNoQjtZQUNoQztZQUNBLE9BQU87Z0JBQUVqQyxNQUFNNUMsT0FBTzJELE1BQU0sQ0FBQzNELE9BQU8yRCxNQUFNLENBQUMsQ0FBQyxHQUFHaUQsVUFBVWxDO2dCQUFhN0IsT0FBTztZQUFLO1FBQ3RGLEVBQ0EsT0FBT0EsT0FBTztZQUNWLElBQUksQ0FBQyxHQUFHcEMsU0FBU3FDLFdBQVcsRUFBRUQsUUFBUTtnQkFDbEMsT0FBTztvQkFBRUQsTUFBTTt3QkFBRWdFLFNBQVMsRUFBRTtvQkFBQztvQkFBRy9EO2dCQUFNO1lBQzFDO1lBQ0EsTUFBTUE7UUFDVjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRCxNQUFNbkIsbUJBQW1COEIsTUFBTSxFQUFFO1FBQzdCLElBQUk7WUFDQSxPQUFPLE1BQU0sQ0FBQyxHQUFHbEQsUUFBUW9DLFFBQVEsRUFBRSxJQUFJLENBQUM1QixLQUFLLEVBQUUsUUFBUSxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsb0JBQW9CLENBQUMsRUFBRTtnQkFDdEZzQyxNQUFNTTtnQkFDTjNDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQnVDLE9BQU8sQ0FBQ3lEO29CQUNKLE9BQU87d0JBQUVqRSxNQUFNaUU7d0JBQVFoRSxPQUFPO29CQUFLO2dCQUN2QztZQUNKO1FBQ0osRUFDQSxPQUFPQSxPQUFPO1lBQ1YsSUFBSSxDQUFDLEdBQUdwQyxTQUFTcUMsV0FBVyxFQUFFRCxRQUFRO2dCQUNsQyxPQUFPO29CQUFFRCxNQUFNO29CQUFNQztnQkFBTTtZQUMvQjtZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTWpCLGdCQUFnQmtGLFFBQVEsRUFBRTtRQUM1QixJQUFJO1lBQ0EsT0FBTyxNQUFNLENBQUMsR0FBR3hHLFFBQVFvQyxRQUFRLEVBQUUsSUFBSSxDQUFDNUIsS0FBSyxFQUFFLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQ0YsR0FBRyxDQUFDLHFCQUFxQixFQUFFa0csU0FBUyxDQUFDLEVBQUU7Z0JBQ2pHakcsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCdUMsT0FBTyxDQUFDeUQ7b0JBQ0osT0FBTzt3QkFBRWpFLE1BQU1pRTt3QkFBUWhFLE9BQU87b0JBQUs7Z0JBQ3ZDO1lBQ0o7UUFDSixFQUNBLE9BQU9BLE9BQU87WUFDVixJQUFJLENBQUMsR0FBR3BDLFNBQVNxQyxXQUFXLEVBQUVELFFBQVE7Z0JBQ2xDLE9BQU87b0JBQUVELE1BQU07b0JBQU1DO2dCQUFNO1lBQy9CO1lBQ0EsTUFBTUE7UUFDVjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRCxNQUFNZixtQkFBbUJnRixRQUFRLEVBQUV0RCxNQUFNLEVBQUU7UUFDdkMsSUFBSTtZQUNBLE9BQU8sTUFBTSxDQUFDLEdBQUdsRCxRQUFRb0MsUUFBUSxFQUFFLElBQUksQ0FBQzVCLEtBQUssRUFBRSxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUNGLEdBQUcsQ0FBQyxxQkFBcUIsRUFBRWtHLFNBQVMsQ0FBQyxFQUFFO2dCQUNqRzVELE1BQU1NO2dCQUNOM0MsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCdUMsT0FBTyxDQUFDeUQ7b0JBQ0osT0FBTzt3QkFBRWpFLE1BQU1pRTt3QkFBUWhFLE9BQU87b0JBQUs7Z0JBQ3ZDO1lBQ0o7UUFDSixFQUNBLE9BQU9BLE9BQU87WUFDVixJQUFJLENBQUMsR0FBR3BDLFNBQVNxQyxXQUFXLEVBQUVELFFBQVE7Z0JBQ2xDLE9BQU87b0JBQUVELE1BQU07b0JBQU1DO2dCQUFNO1lBQy9CO1lBQ0EsTUFBTUE7UUFDVjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRCxNQUFNYixtQkFBbUI4RSxRQUFRLEVBQUU7UUFDL0IsSUFBSTtZQUNBLE1BQU0sQ0FBQyxHQUFHeEcsUUFBUW9DLFFBQVEsRUFBRSxJQUFJLENBQUM1QixLQUFLLEVBQUUsVUFBVSxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMscUJBQXFCLEVBQUVrRyxTQUFTLENBQUMsRUFBRTtnQkFDN0ZqRyxTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDckI4QixlQUFlO1lBQ25CO1lBQ0EsT0FBTztnQkFBRUMsTUFBTTtnQkFBTUMsT0FBTztZQUFLO1FBQ3JDLEVBQ0EsT0FBT0EsT0FBTztZQUNWLElBQUksQ0FBQyxHQUFHcEMsU0FBU3FDLFdBQVcsRUFBRUQsUUFBUTtnQkFDbEMsT0FBTztvQkFBRUQsTUFBTTtvQkFBTUM7Z0JBQU07WUFDL0I7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNELE1BQU1YLDZCQUE2QjRFLFFBQVEsRUFBRTtRQUN6QyxJQUFJO1lBQ0EsT0FBTyxNQUFNLENBQUMsR0FBR3hHLFFBQVFvQyxRQUFRLEVBQUUsSUFBSSxDQUFDNUIsS0FBSyxFQUFFLFFBQVEsQ0FBQyxFQUFFLElBQUksQ0FBQ0YsR0FBRyxDQUFDLHFCQUFxQixFQUFFa0csU0FBUyxrQkFBa0IsQ0FBQyxFQUFFO2dCQUNwSGpHLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQnVDLE9BQU8sQ0FBQ3lEO29CQUNKLE9BQU87d0JBQUVqRSxNQUFNaUU7d0JBQVFoRSxPQUFPO29CQUFLO2dCQUN2QztZQUNKO1FBQ0osRUFDQSxPQUFPQSxPQUFPO1lBQ1YsSUFBSSxDQUFDLEdBQUdwQyxTQUFTcUMsV0FBVyxFQUFFRCxRQUFRO2dCQUNsQyxPQUFPO29CQUFFRCxNQUFNO29CQUFNQztnQkFBTTtZQUMvQjtZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtBQUNKO0FBQ0EzQyxrQkFBZSxHQUFHUSxnQkFDbEIsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbWFpbi9Hb1RydWVBZG1pbkFwaS5qcz84NjNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmNvbnN0IGZldGNoXzEgPSByZXF1aXJlKFwiLi9saWIvZmV0Y2hcIik7XG5jb25zdCBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9saWIvaGVscGVyc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi9saWIvdHlwZXNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2xpYi9lcnJvcnNcIik7XG5jbGFzcyBHb1RydWVBZG1pbkFwaSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhZG1pbiBBUEkgY2xpZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFuYWdlIHVzZXJzIGFuZCBPQXV0aCBjbGllbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IEdvVHJ1ZUFkbWluQXBpIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gICAgICpcbiAgICAgKiBjb25zdCBhZG1pbiA9IG5ldyBHb1RydWVBZG1pbkFwaSh7XG4gICAgICogICB1cmw6ICdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vYXV0aC92MScsXG4gICAgICogICBoZWFkZXJzOiB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtwcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZfWAgfSxcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgdXJsID0gJycsIGhlYWRlcnMgPSB7fSwgZmV0Y2gsIH0pIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSAoMCwgaGVscGVyc18xLnJlc29sdmVGZXRjaCkoZmV0Y2gpO1xuICAgICAgICB0aGlzLm1mYSA9IHtcbiAgICAgICAgICAgIGxpc3RGYWN0b3JzOiB0aGlzLl9saXN0RmFjdG9ycy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZGVsZXRlRmFjdG9yOiB0aGlzLl9kZWxldGVGYWN0b3IuYmluZCh0aGlzKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vYXV0aCA9IHtcbiAgICAgICAgICAgIGxpc3RDbGllbnRzOiB0aGlzLl9saXN0T0F1dGhDbGllbnRzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBjcmVhdGVDbGllbnQ6IHRoaXMuX2NyZWF0ZU9BdXRoQ2xpZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRDbGllbnQ6IHRoaXMuX2dldE9BdXRoQ2xpZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICB1cGRhdGVDbGllbnQ6IHRoaXMuX3VwZGF0ZU9BdXRoQ2xpZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZWxldGVDbGllbnQ6IHRoaXMuX2RlbGV0ZU9BdXRoQ2xpZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICByZWdlbmVyYXRlQ2xpZW50U2VjcmV0OiB0aGlzLl9yZWdlbmVyYXRlT0F1dGhDbGllbnRTZWNyZXQuYmluZCh0aGlzKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGxvZ2dlZC1pbiBzZXNzaW9uLlxuICAgICAqIEBwYXJhbSBqd3QgQSB2YWxpZCwgbG9nZ2VkLWluIEpXVC5cbiAgICAgKiBAcGFyYW0gc2NvcGUgVGhlIGxvZ291dCBzb3BlLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25PdXQoand0LCBzY29wZSA9IHR5cGVzXzEuU0lHTl9PVVRfU0NPUEVTWzBdKSB7XG4gICAgICAgIGlmICh0eXBlc18xLlNJR05fT1VUX1NDT1BFUy5pbmRleE9mKHNjb3BlKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IFBhcmFtZXRlciBzY29wZSBtdXN0IGJlIG9uZSBvZiAke3R5cGVzXzEuU0lHTl9PVVRfU0NPUEVTLmpvaW4oJywgJyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9sb2dvdXQ/c2NvcGU9JHtzY29wZX1gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGp3dCxcbiAgICAgICAgICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGFuIGludml0ZSBsaW5rIHRvIGFuIGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBiZSBpbmNsdWRlZCB3aGVuIGludml0aW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGludml0ZVVzZXJCeUVtYWlsKGVtYWlsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vaW52aXRlYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHsgZW1haWwsIGRhdGE6IG9wdGlvbnMuZGF0YSB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgeGZvcm06IGZldGNoXzEuX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgZW1haWwgbGlua3MgYW5kIE9UUHMgdG8gYmUgc2VudCB2aWEgYSBjdXN0b20gZW1haWwgcHJvdmlkZXIuXG4gICAgICogQHBhcmFtIGVtYWlsIFRoZSB1c2VyJ3MgZW1haWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFzc3dvcmQgVXNlciBwYXNzd29yZC4gRm9yIHNpZ251cCBvbmx5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRhdGEgT3B0aW9uYWwgdXNlciBtZXRhZGF0YS4gRm9yIHNpZ251cCBvbmx5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gVGhlIHJlZGlyZWN0IHVybCB3aGljaCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGdlbmVyYXRlZCBsaW5rXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVMaW5rKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBwYXJhbXMsIHJlc3QgPSB0c2xpYl8xLl9fcmVzdChwYXJhbXMsIFtcIm9wdGlvbnNcIl0pO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCduZXdFbWFpbCcgaW4gcmVzdCkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgbmV3RW1haWwgd2l0aCBuZXdfZW1haWwgaW4gcmVxdWVzdCBib2R5XG4gICAgICAgICAgICAgICAgYm9keS5uZXdfZW1haWwgPSByZXN0ID09PSBudWxsIHx8IHJlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3QubmV3RW1haWw7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ25ld0VtYWlsJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL2dlbmVyYXRlX2xpbmtgLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IGZldGNoXzEuX2dlbmVyYXRlTGlua1Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZXIgQWRtaW4gQVBJXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVXNlcihhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBmZXRjaF8xLl91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgbGlzdCBvZiB1c2Vycy5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICogQHBhcmFtIHBhcmFtcyBBbiBvYmplY3Qgd2hpY2ggc3VwcG9ydHMgYHBhZ2VgIGFuZCBgcGVyUGFnZWAgYXMgbnVtYmVycywgdG8gYWx0ZXIgdGhlIHBhZ2luYXRlZCByZXN1bHRzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RVc2VycyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFnaW5hdGlvbiA9IHsgbmV4dFBhZ2U6IG51bGwsIGxhc3RQYWdlOiAwLCB0b3RhbDogMCB9O1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vyc2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiAoX2IgPSAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBwZXJfcGFnZTogKF9kID0gKF9jID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBlclBhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBmZXRjaF8xLl9ub1Jlc29sdmVKc29uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZS5lcnJvcjtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgdG90YWwgPSAoX2UgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC10b3RhbC1jb3VudCcpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwO1xuICAgICAgICAgICAgY29uc3QgbGlua3MgPSAoX2cgPSAoX2YgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnbGluaycpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc3BsaXQoJywnKSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogW107XG4gICAgICAgICAgICBpZiAobGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmtzLmZvckVhY2goKGxpbmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZSA9IHBhcnNlSW50KGxpbmsuc3BsaXQoJzsnKVswXS5zcGxpdCgnPScpWzFdLnN1YnN0cmluZygwLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbCA9IEpTT04ucGFyc2UobGluay5zcGxpdCgnOycpWzFdLnNwbGl0KCc9JylbMV0pO1xuICAgICAgICAgICAgICAgICAgICBwYWdpbmF0aW9uW2Ake3JlbH1QYWdlYF0gPSBwYWdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhZ2luYXRpb24udG90YWwgPSBwYXJzZUludCh0b3RhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHVzZXJzKSwgcGFnaW5hdGlvbiksIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXJzOiBbXSB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgYnkgaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdWlkIFRoZSB1c2VyJ3MgdW5pcXVlIGlkZW50aWZpZXJcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VXNlckJ5SWQodWlkKSB7XG4gICAgICAgICgwLCBoZWxwZXJzXzEudmFsaWRhdGVVVUlEKSh1aWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7dWlkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IGZldGNoXzEuX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB1c2VyIGRhdGEuIENoYW5nZXMgYXJlIGFwcGxpZWQgZGlyZWN0bHkgd2l0aG91dCBjb25maXJtYXRpb24gZmxvd3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgZGF0YSB5b3Ugd2FudCB0byB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVVzZXJCeUlkKHVpZCwgYXR0cmlidXRlcykge1xuICAgICAgICAoMCwgaGVscGVyc18xLnZhbGlkYXRlVVVJRCkodWlkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BVVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3VpZH1gLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IGZldGNoXzEuX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSB1c2VyLiBSZXF1aXJlcyBhIGBzZXJ2aWNlX3JvbGVgIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgdXNlciBpZCB5b3Ugd2FudCB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHNob3VsZFNvZnREZWxldGUgSWYgdHJ1ZSwgdGhlbiB0aGUgdXNlciB3aWxsIGJlIHNvZnQtZGVsZXRlZCBmcm9tIHRoZSBhdXRoIHNjaGVtYS4gU29mdCBkZWxldGlvbiBhbGxvd3MgdXNlciBpZGVudGlmaWNhdGlvbiBmcm9tIHRoZSBoYXNoZWQgdXNlciBJRCBidXQgaXMgbm90IHJldmVyc2libGUuXG4gICAgICogRGVmYXVsdHMgdG8gZmFsc2UgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZVVzZXIoaWQsIHNob3VsZFNvZnREZWxldGUgPSBmYWxzZSkge1xuICAgICAgICAoMCwgaGVscGVyc18xLnZhbGlkYXRlVVVJRCkoaWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7aWR9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZF9zb2Z0X2RlbGV0ZTogc2hvdWxkU29mdERlbGV0ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBmZXRjaF8xLl91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2xpc3RGYWN0b3JzKHBhcmFtcykge1xuICAgICAgICAoMCwgaGVscGVyc18xLnZhbGlkYXRlVVVJRCkocGFyYW1zLnVzZXJJZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3BhcmFtcy51c2VySWR9L2ZhY3RvcnNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoZmFjdG9ycykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGZhY3RvcnMgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9kZWxldGVGYWN0b3IocGFyYW1zKSB7XG4gICAgICAgICgwLCBoZWxwZXJzXzEudmFsaWRhdGVVVUlEKShwYXJhbXMudXNlcklkKTtcbiAgICAgICAgKDAsIGhlbHBlcnNfMS52YWxpZGF0ZVVVSUQpKHBhcmFtcy5pZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtwYXJhbXMudXNlcklkfS9mYWN0b3JzLyR7cGFyYW1zLmlkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIE9BdXRoIGNsaWVudHMgd2l0aCBvcHRpb25hbCBwYWdpbmF0aW9uLlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIF9saXN0T0F1dGhDbGllbnRzKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYWdpbmF0aW9uID0geyBuZXh0UGFnZTogbnVsbCwgbGFzdFBhZ2U6IDAsIHRvdGFsOiAwIH07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogKF9iID0gKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgcGVyX3BhZ2U6IChfZCA9IChfYyA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wZXJQYWdlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogZmV0Y2hfMS5fbm9SZXNvbHZlSnNvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2UuZXJyb3I7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgdG90YWwgPSAoX2UgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC10b3RhbC1jb3VudCcpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwO1xuICAgICAgICAgICAgY29uc3QgbGlua3MgPSAoX2cgPSAoX2YgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnbGluaycpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc3BsaXQoJywnKSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogW107XG4gICAgICAgICAgICBpZiAobGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmtzLmZvckVhY2goKGxpbmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZSA9IHBhcnNlSW50KGxpbmsuc3BsaXQoJzsnKVswXS5zcGxpdCgnPScpWzFdLnN1YnN0cmluZygwLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbCA9IEpTT04ucGFyc2UobGluay5zcGxpdCgnOycpWzFdLnNwbGl0KCc9JylbMV0pO1xuICAgICAgICAgICAgICAgICAgICBwYWdpbmF0aW9uW2Ake3JlbH1QYWdlYF0gPSBwYWdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhZ2luYXRpb24udG90YWwgPSBwYXJzZUludCh0b3RhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNsaWVudHMpLCBwYWdpbmF0aW9uKSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgY2xpZW50czogW10gfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT0F1dGggY2xpZW50LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIF9jcmVhdGVPQXV0aENsaWVudChwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vb2F1dGgvY2xpZW50c2AsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoY2xpZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGNsaWVudCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBkZXRhaWxzIG9mIGEgc3BlY2lmaWMgT0F1dGggY2xpZW50LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRPQXV0aENsaWVudChjbGllbnRJZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHMvJHtjbGllbnRJZH1gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoY2xpZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGNsaWVudCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbiBleGlzdGluZyBPQXV0aCBjbGllbnQuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgX3VwZGF0ZU9BdXRoQ2xpZW50KGNsaWVudElkLCBwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BVVCcsIGAke3RoaXMudXJsfS9hZG1pbi9vYXV0aC9jbGllbnRzLyR7Y2xpZW50SWR9YCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IChjbGllbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogY2xpZW50LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFuIE9BdXRoIGNsaWVudC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBfZGVsZXRlT0F1dGhDbGllbnQoY2xpZW50SWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHMvJHtjbGllbnRJZH1gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnZW5lcmF0ZXMgdGhlIHNlY3JldCBmb3IgYW4gT0F1dGggY2xpZW50LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIF9yZWdlbmVyYXRlT0F1dGhDbGllbnRTZWNyZXQoY2xpZW50SWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vb2F1dGgvY2xpZW50cy8ke2NsaWVudElkfS9yZWdlbmVyYXRlX3NlY3JldGAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IChjbGllbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogY2xpZW50LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEdvVHJ1ZUFkbWluQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R29UcnVlQWRtaW5BcGkuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidHNsaWJfMSIsInJlcXVpcmUiLCJmZXRjaF8xIiwiaGVscGVyc18xIiwidHlwZXNfMSIsImVycm9yc18xIiwiR29UcnVlQWRtaW5BcGkiLCJjb25zdHJ1Y3RvciIsInVybCIsImhlYWRlcnMiLCJmZXRjaCIsInJlc29sdmVGZXRjaCIsIm1mYSIsImxpc3RGYWN0b3JzIiwiX2xpc3RGYWN0b3JzIiwiYmluZCIsImRlbGV0ZUZhY3RvciIsIl9kZWxldGVGYWN0b3IiLCJvYXV0aCIsImxpc3RDbGllbnRzIiwiX2xpc3RPQXV0aENsaWVudHMiLCJjcmVhdGVDbGllbnQiLCJfY3JlYXRlT0F1dGhDbGllbnQiLCJnZXRDbGllbnQiLCJfZ2V0T0F1dGhDbGllbnQiLCJ1cGRhdGVDbGllbnQiLCJfdXBkYXRlT0F1dGhDbGllbnQiLCJkZWxldGVDbGllbnQiLCJfZGVsZXRlT0F1dGhDbGllbnQiLCJyZWdlbmVyYXRlQ2xpZW50U2VjcmV0IiwiX3JlZ2VuZXJhdGVPQXV0aENsaWVudFNlY3JldCIsInNpZ25PdXQiLCJqd3QiLCJzY29wZSIsIlNJR05fT1VUX1NDT1BFUyIsImluZGV4T2YiLCJFcnJvciIsImpvaW4iLCJfcmVxdWVzdCIsIm5vUmVzb2x2ZUpzb24iLCJkYXRhIiwiZXJyb3IiLCJpc0F1dGhFcnJvciIsImludml0ZVVzZXJCeUVtYWlsIiwiZW1haWwiLCJvcHRpb25zIiwiYm9keSIsInJlZGlyZWN0VG8iLCJ4Zm9ybSIsIl91c2VyUmVzcG9uc2UiLCJ1c2VyIiwiZ2VuZXJhdGVMaW5rIiwicGFyYW1zIiwicmVzdCIsIl9fcmVzdCIsImFzc2lnbiIsIm5ld19lbWFpbCIsIm5ld0VtYWlsIiwiX2dlbmVyYXRlTGlua1Jlc3BvbnNlIiwicHJvcGVydGllcyIsImNyZWF0ZVVzZXIiLCJhdHRyaWJ1dGVzIiwibGlzdFVzZXJzIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJwYWdpbmF0aW9uIiwibmV4dFBhZ2UiLCJsYXN0UGFnZSIsInRvdGFsIiwicmVzcG9uc2UiLCJxdWVyeSIsInBhZ2UiLCJ0b1N0cmluZyIsInBlcl9wYWdlIiwicGVyUGFnZSIsIl9ub1Jlc29sdmVKc29uUmVzcG9uc2UiLCJ1c2VycyIsImpzb24iLCJnZXQiLCJsaW5rcyIsInNwbGl0IiwibGVuZ3RoIiwiZm9yRWFjaCIsImxpbmsiLCJwYXJzZUludCIsInN1YnN0cmluZyIsInJlbCIsIkpTT04iLCJwYXJzZSIsImdldFVzZXJCeUlkIiwidWlkIiwidmFsaWRhdGVVVUlEIiwidXBkYXRlVXNlckJ5SWQiLCJkZWxldGVVc2VyIiwiaWQiLCJzaG91bGRTb2Z0RGVsZXRlIiwic2hvdWxkX3NvZnRfZGVsZXRlIiwidXNlcklkIiwiZmFjdG9ycyIsImNsaWVudHMiLCJjbGllbnQiLCJjbGllbnRJZCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/GoTrueAdminApi.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/GoTrueClient.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/GoTrueClient.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst GoTrueAdminApi_1 = tslib_1.__importDefault(__webpack_require__(/*! ./GoTrueAdminApi */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/GoTrueAdminApi.js\"));\nconst constants_1 = __webpack_require__(/*! ./lib/constants */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/constants.js\");\nconst errors_1 = __webpack_require__(/*! ./lib/errors */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/errors.js\");\nconst fetch_1 = __webpack_require__(/*! ./lib/fetch */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/fetch.js\");\nconst helpers_1 = __webpack_require__(/*! ./lib/helpers */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/helpers.js\");\nconst local_storage_1 = __webpack_require__(/*! ./lib/local-storage */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/local-storage.js\");\nconst locks_1 = __webpack_require__(/*! ./lib/locks */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/locks.js\");\nconst polyfills_1 = __webpack_require__(/*! ./lib/polyfills */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/polyfills.js\");\nconst version_1 = __webpack_require__(/*! ./lib/version */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/version.js\");\nconst base64url_1 = __webpack_require__(/*! ./lib/base64url */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/base64url.js\");\nconst ethereum_1 = __webpack_require__(/*! ./lib/web3/ethereum */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/web3/ethereum.js\");\nconst webauthn_1 = __webpack_require__(/*! ./lib/webauthn */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/webauthn.js\");\n(0, polyfills_1.polyfillGlobalThis)(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: constants_1.GOTRUE_URL,\n    storageKey: constants_1.STORAGE_KEY,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    headers: constants_1.DEFAULT_HEADERS,\n    flowType: \"implicit\",\n    debug: false,\n    hasCustomAuthorizationHeader: false,\n    throwOnError: false,\n    lockAcquireTimeout: 10000\n};\nasync function lockNoOp(name, acquireTimeout, fn) {\n    return await fn();\n}\n/**\n * Caches JWKS values for all clients created in the same environment. This is\n * especially useful for shared-memory execution environments such as Vercel's\n * Fluid Compute, AWS Lambda or Supabase's Edge Functions. Regardless of how\n * many clients are created, if they share the same storage key they will use\n * the same JWKS cache, significantly speeding up getClaims() with asymmetric\n * JWTs.\n */ const GLOBAL_JWKS = {};\nclass GoTrueClient {\n    /**\n     * The JWKS used for verifying asymmetric JWTs\n     */ get jwks() {\n        var _a, _b;\n        return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.jwks) !== null && _b !== void 0 ? _b : {\n            keys: []\n        };\n    }\n    set jwks(value) {\n        GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), {\n            jwks: value\n        });\n    }\n    get jwks_cached_at() {\n        var _a, _b;\n        return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.cachedAt) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;\n    }\n    set jwks_cached_at(value) {\n        GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), {\n            cachedAt: value\n        });\n    }\n    /**\n     * Create a new client for use in the browser.\n     *\n     * @example\n     * ```ts\n     * import { GoTrueClient } from '@supabase/auth-js'\n     *\n     * const auth = new GoTrueClient({\n     *   url: 'https://xyzcompany.supabase.co/auth/v1',\n     *   headers: { apikey: 'public-anon-key' },\n     *   storageKey: 'supabase-auth',\n     * })\n     * ```\n     */ constructor(options){\n        var _a, _b, _c;\n        /**\n         * @experimental\n         */ this.userStorage = null;\n        this.memoryStorage = null;\n        this.stateChangeEmitters = new Map();\n        this.autoRefreshTicker = null;\n        this.autoRefreshTickTimeout = null;\n        this.visibilityChangedCallback = null;\n        this.refreshingDeferred = null;\n        /**\n         * Keeps track of the async client initialization.\n         * When null or not yet resolved the auth state is `unknown`\n         * Once resolved the auth state is known and it's safe to call any further client methods.\n         * Keep extra care to never reject or throw uncaught errors\n         */ this.initializePromise = null;\n        this.detectSessionInUrl = true;\n        this.hasCustomAuthorizationHeader = false;\n        this.suppressGetSessionWarning = false;\n        this.lockAcquired = false;\n        this.pendingInLock = [];\n        /**\n         * Used to broadcast state change events to other tabs listening.\n         */ this.broadcastChannel = null;\n        this.logger = console.log;\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.storageKey = settings.storageKey;\n        this.instanceID = (_a = GoTrueClient.nextInstanceID[this.storageKey]) !== null && _a !== void 0 ? _a : 0;\n        GoTrueClient.nextInstanceID[this.storageKey] = this.instanceID + 1;\n        this.logDebugMessages = !!settings.debug;\n        if (typeof settings.debug === \"function\") {\n            this.logger = settings.debug;\n        }\n        if (this.instanceID > 0 && (0, helpers_1.isBrowser)()) {\n            const message = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;\n            console.warn(message);\n            if (this.logDebugMessages) {\n                console.trace(message);\n            }\n        }\n        this.persistSession = settings.persistSession;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.admin = new GoTrueAdminApi_1.default({\n            url: settings.url,\n            headers: settings.headers,\n            fetch: settings.fetch\n        });\n        this.url = settings.url;\n        this.headers = settings.headers;\n        this.fetch = (0, helpers_1.resolveFetch)(settings.fetch);\n        this.lock = settings.lock || lockNoOp;\n        this.detectSessionInUrl = settings.detectSessionInUrl;\n        this.flowType = settings.flowType;\n        this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;\n        this.throwOnError = settings.throwOnError;\n        this.lockAcquireTimeout = settings.lockAcquireTimeout;\n        if (settings.lock) {\n            this.lock = settings.lock;\n        } else if (this.persistSession && (0, helpers_1.isBrowser)() && ((_b = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _b === void 0 ? void 0 : _b.locks)) {\n            this.lock = locks_1.navigatorLock;\n        } else {\n            this.lock = lockNoOp;\n        }\n        if (!this.jwks) {\n            this.jwks = {\n                keys: []\n            };\n            this.jwks_cached_at = Number.MIN_SAFE_INTEGER;\n        }\n        this.mfa = {\n            verify: this._verify.bind(this),\n            enroll: this._enroll.bind(this),\n            unenroll: this._unenroll.bind(this),\n            challenge: this._challenge.bind(this),\n            listFactors: this._listFactors.bind(this),\n            challengeAndVerify: this._challengeAndVerify.bind(this),\n            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n            webauthn: new webauthn_1.WebAuthnApi(this)\n        };\n        this.oauth = {\n            getAuthorizationDetails: this._getAuthorizationDetails.bind(this),\n            approveAuthorization: this._approveAuthorization.bind(this),\n            denyAuthorization: this._denyAuthorization.bind(this),\n            listGrants: this._listOAuthGrants.bind(this),\n            revokeGrant: this._revokeOAuthGrant.bind(this)\n        };\n        if (this.persistSession) {\n            if (settings.storage) {\n                this.storage = settings.storage;\n            } else {\n                if ((0, helpers_1.supportsLocalStorage)()) {\n                    this.storage = globalThis.localStorage;\n                } else {\n                    this.memoryStorage = {};\n                    this.storage = (0, local_storage_1.memoryLocalStorageAdapter)(this.memoryStorage);\n                }\n            }\n            if (settings.userStorage) {\n                this.userStorage = settings.userStorage;\n            }\n        } else {\n            this.memoryStorage = {};\n            this.storage = (0, local_storage_1.memoryLocalStorageAdapter)(this.memoryStorage);\n        }\n        if ((0, helpers_1.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n            try {\n                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n            } catch (e) {\n                console.error(\"Failed to create a new BroadcastChannel, multi-tab state changes will not be available\", e);\n            }\n            (_c = this.broadcastChannel) === null || _c === void 0 ? void 0 : _c.addEventListener(\"message\", async (event)=>{\n                this._debug(\"received broadcast notification from other tab or client\", event);\n                await this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n            });\n        }\n        this.initialize();\n    }\n    /**\n     * Returns whether error throwing mode is enabled for this client.\n     */ isThrowOnErrorEnabled() {\n        return this.throwOnError;\n    }\n    /**\n     * Centralizes return handling with optional error throwing. When `throwOnError` is enabled\n     * and the provided result contains a non-nullish error, the error is thrown instead of\n     * being returned. This ensures consistent behavior across all public API methods.\n     */ _returnResult(result) {\n        if (this.throwOnError && result && result.error) {\n            throw result.error;\n        }\n        return result;\n    }\n    _logPrefix() {\n        return \"GoTrueClient@\" + `${this.storageKey}:${this.instanceID} (${version_1.version}) ${new Date().toISOString()}`;\n    }\n    _debug(...args) {\n        if (this.logDebugMessages) {\n            this.logger(this._logPrefix(), ...args);\n        }\n        return this;\n    }\n    /**\n     * Initializes the client session either from the url or from storage.\n     * This method is automatically called when instantiating the client, but should also be called\n     * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n     */ async initialize() {\n        if (this.initializePromise) {\n            return await this.initializePromise;\n        }\n        this.initializePromise = (async ()=>{\n            return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n                return await this._initialize();\n            });\n        })();\n        return await this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */ async _initialize() {\n        var _a;\n        try {\n            let params = {};\n            let callbackUrlType = \"none\";\n            if ((0, helpers_1.isBrowser)()) {\n                params = (0, helpers_1.parseParametersFromURL)(window.location.href);\n                if (this._isImplicitGrantCallback(params)) {\n                    callbackUrlType = \"implicit\";\n                } else if (await this._isPKCECallback(params)) {\n                    callbackUrlType = \"pkce\";\n                }\n            }\n            /**\n             * Attempt to get the session from the URL only if these conditions are fulfilled\n             *\n             * Note: If the URL isn't one of the callback url types (implicit or pkce),\n             * then there could be an existing session so we don't want to prematurely remove it\n             */ if ((0, helpers_1.isBrowser)() && this.detectSessionInUrl && callbackUrlType !== \"none\") {\n                const { data, error } = await this._getSessionFromURL(params, callbackUrlType);\n                if (error) {\n                    this._debug(\"#_initialize()\", \"error detecting session from URL\", error);\n                    if ((0, errors_1.isAuthImplicitGrantRedirectError)(error)) {\n                        const errorCode = (_a = error.details) === null || _a === void 0 ? void 0 : _a.code;\n                        if (errorCode === \"identity_already_exists\" || errorCode === \"identity_not_found\" || errorCode === \"single_identity_not_deletable\") {\n                            return {\n                                error\n                            };\n                        }\n                    }\n                    // Don't remove existing session on URL login failure.\n                    // A failed attempt (e.g. reused magic link) shouldn't invalidate a valid session.\n                    return {\n                        error\n                    };\n                }\n                const { session, redirectType } = data;\n                this._debug(\"#_initialize()\", \"detected session in URL\", session, \"redirect type\", redirectType);\n                await this._saveSession(session);\n                setTimeout(async ()=>{\n                    if (redirectType === \"recovery\") {\n                        await this._notifyAllSubscribers(\"PASSWORD_RECOVERY\", session);\n                    } else {\n                        await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n                    }\n                }, 0);\n                return {\n                    error: null\n                };\n            }\n            // no login attempt via callback url try to recover session from storage\n            await this._recoverAndRefresh();\n            return {\n                error: null\n            };\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    error\n                });\n            }\n            return this._returnResult({\n                error: new errors_1.AuthUnknownError(\"Unexpected error during initialization\", error)\n            });\n        } finally{\n            await this._handleVisibilityChange();\n            this._debug(\"#_initialize()\", \"end\");\n        }\n    }\n    /**\n     * Creates a new anonymous user.\n     *\n     * @returns A session where the is_anonymous claim in the access token JWT set to true\n     */ async signInAnonymously(credentials) {\n        var _a, _b, _c;\n        try {\n            const res = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                headers: this.headers,\n                body: {\n                    data: (_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {},\n                    gotrue_meta_security: {\n                        captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken\n                    }\n                },\n                xform: fetch_1._sessionResponse\n            });\n            const { data, error } = res;\n            if (error || !data) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: error\n                });\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new user.\n     *\n     * Be aware that if a user account exists in the system you may get back an\n     * error message that attempts to hide this information from the user.\n     * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */ async signUp(credentials) {\n        var _a, _b, _c;\n        try {\n            let res;\n            if (\"email\" in credentials) {\n                const { email, password, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\") {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0, helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                res = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: {\n                        email,\n                        password,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    },\n                    xform: fetch_1._sessionResponse\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n                        channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : \"sms\",\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: fetch_1._sessionResponse\n                });\n            } else {\n                throw new errors_1.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n            }\n            const { data, error } = res;\n            if (error || !data) {\n                await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: error\n                });\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or that the\n     * email/phone and password combination is wrong or that the account can only\n     * be accessed via social login.\n     */ async signInWithPassword(credentials) {\n        try {\n            let res;\n            if (\"email\" in credentials) {\n                const { email, password, options } = credentials;\n                res = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        password,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: fetch_1._sessionResponsePassword\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: fetch_1._sessionResponsePassword\n                });\n            } else {\n                throw new errors_1.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n            }\n            const { data, error } = res;\n            if (error) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            } else if (!data || !data.session || !data.user) {\n                const invalidTokenError = new errors_1.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign({\n                    user: data.user,\n                    session: data.session\n                }, data.weak_password ? {\n                    weakPassword: data.weak_password\n                } : null),\n                error\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     * This method supports the PKCE flow.\n     */ async signInWithOAuth(credentials) {\n        var _a, _b, _c, _d;\n        return await this._handleProviderSignIn(credentials.provider, {\n            redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n            scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n            queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n            skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect\n        });\n    }\n    /**\n     * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\n     */ async exchangeCodeForSession(authCode) {\n        await this.initializePromise;\n        return this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return this._exchangeCodeForSession(authCode);\n        });\n    }\n    /**\n     * Signs in a user by verifying a message signed by the user's private key.\n     * Supports Ethereum (via Sign-In-With-Ethereum) & Solana (Sign-In-With-Solana) standards,\n     * both of which derive from the EIP-4361 standard\n     * With slight variation on Solana's side.\n     * @reference https://eips.ethereum.org/EIPS/eip-4361\n     */ async signInWithWeb3(credentials) {\n        const { chain } = credentials;\n        switch(chain){\n            case \"ethereum\":\n                return await this.signInWithEthereum(credentials);\n            case \"solana\":\n                return await this.signInWithSolana(credentials);\n            default:\n                throw new Error(`@supabase/auth-js: Unsupported chain \"${chain}\"`);\n        }\n    }\n    async signInWithEthereum(credentials) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        // TODO: flatten type\n        let message;\n        let signature;\n        if (\"message\" in credentials) {\n            message = credentials.message;\n            signature = credentials.signature;\n        } else {\n            const { chain, wallet, statement, options } = credentials;\n            let resolvedWallet;\n            if (!(0, helpers_1.isBrowser)()) {\n                if (typeof wallet !== \"object\" || !(options === null || options === void 0 ? void 0 : options.url)) {\n                    throw new Error(\"@supabase/auth-js: Both wallet and url must be specified in non-browser environments.\");\n                }\n                resolvedWallet = wallet;\n            } else if (typeof wallet === \"object\") {\n                resolvedWallet = wallet;\n            } else {\n                const windowAny = window;\n                if (\"ethereum\" in windowAny && typeof windowAny.ethereum === \"object\" && \"request\" in windowAny.ethereum && typeof windowAny.ethereum.request === \"function\") {\n                    resolvedWallet = windowAny.ethereum;\n                } else {\n                    throw new Error(`@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.`);\n                }\n            }\n            const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);\n            const accounts = await resolvedWallet.request({\n                method: \"eth_requestAccounts\"\n            }).then((accs)=>accs).catch(()=>{\n                throw new Error(`@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid`);\n            });\n            if (!accounts || accounts.length === 0) {\n                throw new Error(`@supabase/auth-js: No accounts available. Please ensure the wallet is connected.`);\n            }\n            const address = (0, ethereum_1.getAddress)(accounts[0]);\n            let chainId = (_b = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _b === void 0 ? void 0 : _b.chainId;\n            if (!chainId) {\n                const chainIdHex = await resolvedWallet.request({\n                    method: \"eth_chainId\"\n                });\n                chainId = (0, ethereum_1.fromHex)(chainIdHex);\n            }\n            const siweMessage = {\n                domain: url.host,\n                address: address,\n                statement: statement,\n                uri: url.href,\n                version: \"1\",\n                chainId: chainId,\n                nonce: (_c = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _c === void 0 ? void 0 : _c.nonce,\n                issuedAt: (_e = (_d = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _d === void 0 ? void 0 : _d.issuedAt) !== null && _e !== void 0 ? _e : new Date(),\n                expirationTime: (_f = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _f === void 0 ? void 0 : _f.expirationTime,\n                notBefore: (_g = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _g === void 0 ? void 0 : _g.notBefore,\n                requestId: (_h = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _h === void 0 ? void 0 : _h.requestId,\n                resources: (_j = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _j === void 0 ? void 0 : _j.resources\n            };\n            message = (0, ethereum_1.createSiweMessage)(siweMessage);\n            // Sign message\n            signature = await resolvedWallet.request({\n                method: \"personal_sign\",\n                params: [\n                    (0, ethereum_1.toHex)(message),\n                    address\n                ]\n            });\n        }\n        try {\n            const { data, error } = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=web3`, {\n                headers: this.headers,\n                body: Object.assign({\n                    chain: \"ethereum\",\n                    message,\n                    signature\n                }, ((_k = credentials.options) === null || _k === void 0 ? void 0 : _k.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: (_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken\n                    }\n                } : null),\n                xform: fetch_1._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                const invalidTokenError = new errors_1.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign({}, data),\n                error\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async signInWithSolana(credentials) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        let message;\n        let signature;\n        if (\"message\" in credentials) {\n            message = credentials.message;\n            signature = credentials.signature;\n        } else {\n            const { chain, wallet, statement, options } = credentials;\n            let resolvedWallet;\n            if (!(0, helpers_1.isBrowser)()) {\n                if (typeof wallet !== \"object\" || !(options === null || options === void 0 ? void 0 : options.url)) {\n                    throw new Error(\"@supabase/auth-js: Both wallet and url must be specified in non-browser environments.\");\n                }\n                resolvedWallet = wallet;\n            } else if (typeof wallet === \"object\") {\n                resolvedWallet = wallet;\n            } else {\n                const windowAny = window;\n                if (\"solana\" in windowAny && typeof windowAny.solana === \"object\" && (\"signIn\" in windowAny.solana && typeof windowAny.solana.signIn === \"function\" || \"signMessage\" in windowAny.solana && typeof windowAny.solana.signMessage === \"function\")) {\n                    resolvedWallet = windowAny.solana;\n                } else {\n                    throw new Error(`@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.`);\n                }\n            }\n            const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);\n            if (\"signIn\" in resolvedWallet && resolvedWallet.signIn) {\n                const output = await resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({\n                    issuedAt: new Date().toISOString()\n                }, options === null || options === void 0 ? void 0 : options.signInWithSolana), {\n                    // non-overridable properties\n                    version: \"1\",\n                    domain: url.host,\n                    uri: url.href\n                }), statement ? {\n                    statement\n                } : null));\n                let outputToProcess;\n                if (Array.isArray(output) && output[0] && typeof output[0] === \"object\") {\n                    outputToProcess = output[0];\n                } else if (output && typeof output === \"object\" && \"signedMessage\" in output && \"signature\" in output) {\n                    outputToProcess = output;\n                } else {\n                    throw new Error(\"@supabase/auth-js: Wallet method signIn() returned unrecognized value\");\n                }\n                if (\"signedMessage\" in outputToProcess && \"signature\" in outputToProcess && (typeof outputToProcess.signedMessage === \"string\" || outputToProcess.signedMessage instanceof Uint8Array) && outputToProcess.signature instanceof Uint8Array) {\n                    message = typeof outputToProcess.signedMessage === \"string\" ? outputToProcess.signedMessage : new TextDecoder().decode(outputToProcess.signedMessage);\n                    signature = outputToProcess.signature;\n                } else {\n                    throw new Error(\"@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields\");\n                }\n            } else {\n                if (!(\"signMessage\" in resolvedWallet) || typeof resolvedWallet.signMessage !== \"function\" || !(\"publicKey\" in resolvedWallet) || typeof resolvedWallet !== \"object\" || !resolvedWallet.publicKey || !(\"toBase58\" in resolvedWallet.publicKey) || typeof resolvedWallet.publicKey.toBase58 !== \"function\") {\n                    throw new Error(\"@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API\");\n                }\n                message = [\n                    `${url.host} wants you to sign in with your Solana account:`,\n                    resolvedWallet.publicKey.toBase58(),\n                    ...statement ? [\n                        \"\",\n                        statement,\n                        \"\"\n                    ] : [\n                        \"\"\n                    ],\n                    \"Version: 1\",\n                    `URI: ${url.href}`,\n                    `Issued At: ${(_c = (_b = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _b === void 0 ? void 0 : _b.issuedAt) !== null && _c !== void 0 ? _c : new Date().toISOString()}`,\n                    ...((_d = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _d === void 0 ? void 0 : _d.notBefore) ? [\n                        `Not Before: ${options.signInWithSolana.notBefore}`\n                    ] : [],\n                    ...((_e = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _e === void 0 ? void 0 : _e.expirationTime) ? [\n                        `Expiration Time: ${options.signInWithSolana.expirationTime}`\n                    ] : [],\n                    ...((_f = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _f === void 0 ? void 0 : _f.chainId) ? [\n                        `Chain ID: ${options.signInWithSolana.chainId}`\n                    ] : [],\n                    ...((_g = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _g === void 0 ? void 0 : _g.nonce) ? [\n                        `Nonce: ${options.signInWithSolana.nonce}`\n                    ] : [],\n                    ...((_h = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _h === void 0 ? void 0 : _h.requestId) ? [\n                        `Request ID: ${options.signInWithSolana.requestId}`\n                    ] : [],\n                    ...((_k = (_j = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _j === void 0 ? void 0 : _j.resources) === null || _k === void 0 ? void 0 : _k.length) ? [\n                        \"Resources\",\n                        ...options.signInWithSolana.resources.map((resource)=>`- ${resource}`)\n                    ] : []\n                ].join(\"\\n\");\n                const maybeSignature = await resolvedWallet.signMessage(new TextEncoder().encode(message), \"utf8\");\n                if (!maybeSignature || !(maybeSignature instanceof Uint8Array)) {\n                    throw new Error(\"@supabase/auth-js: Wallet signMessage() API returned an recognized value\");\n                }\n                signature = maybeSignature;\n            }\n        }\n        try {\n            const { data, error } = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=web3`, {\n                headers: this.headers,\n                body: Object.assign({\n                    chain: \"solana\",\n                    message,\n                    signature: (0, base64url_1.bytesToBase64URL)(signature)\n                }, ((_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: (_m = credentials.options) === null || _m === void 0 ? void 0 : _m.captchaToken\n                    }\n                } : null),\n                xform: fetch_1._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                const invalidTokenError = new errors_1.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign({}, data),\n                error\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async _exchangeCodeForSession(authCode) {\n        const storageItem = await (0, helpers_1.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : \"\").split(\"/\");\n        try {\n            if (!codeVerifier && this.flowType === \"pkce\") {\n                throw new errors_1.AuthPKCECodeVerifierMissingError();\n            }\n            const { data, error } = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=pkce`, {\n                headers: this.headers,\n                body: {\n                    auth_code: authCode,\n                    code_verifier: codeVerifier\n                },\n                xform: fetch_1._sessionResponse\n            });\n            await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                const invalidTokenError = new errors_1.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        redirectType: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                setTimeout(async ()=>{\n                    await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n                }, 0);\n            }\n            return this._returnResult({\n                data: Object.assign(Object.assign({}, data), {\n                    redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null\n                }),\n                error\n            });\n        } catch (error) {\n            await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        redirectType: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Allows signing in with an OIDC ID token. The authentication provider used\n     * should be enabled and configured.\n     */ async signInWithIdToken(credentials) {\n        try {\n            const { options, provider, token, access_token, nonce } = credentials;\n            const res = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=id_token`, {\n                headers: this.headers,\n                body: {\n                    provider,\n                    id_token: token,\n                    access_token,\n                    nonce,\n                    gotrue_meta_security: {\n                        captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                },\n                xform: fetch_1._sessionResponse\n            });\n            const { data, error } = res;\n            if (error) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            } else if (!data || !data.session || !data.user) {\n                const invalidTokenError = new errors_1.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data,\n                error\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     *\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or, that the account\n     * can only be accessed via social login.\n     *\n     * Do note that you will need to configure a Whatsapp sender on Twilio\n     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n     * channel is not supported on other providers\n     * at this time.\n     * This method supports PKCE when an email is passed.\n     */ async signInWithOtp(credentials) {\n        var _a, _b, _c, _d, _e;\n        try {\n            if (\"email\" in credentials) {\n                const { email, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\") {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0, helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { error } = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            if (\"phone\" in credentials) {\n                const { phone, options } = credentials;\n                const { data, error } = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n                        create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : \"sms\"\n                    }\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        messageId: data === null || data === void 0 ? void 0 : data.message_id\n                    },\n                    error\n                });\n            }\n            throw new errors_1.AuthInvalidCredentialsError(\"You must provide either an email or phone number.\");\n        } catch (error) {\n            await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user given a User supplied OTP or TokenHash received through mobile or email.\n     */ async verifyOtp(params) {\n        var _a, _b;\n        try {\n            let redirectTo = undefined;\n            let captchaToken = undefined;\n            if (\"options\" in params) {\n                redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo;\n                captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;\n            }\n            const { data, error } = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/verify`, {\n                headers: this.headers,\n                body: Object.assign(Object.assign({}, params), {\n                    gotrue_meta_security: {\n                        captcha_token: captchaToken\n                    }\n                }),\n                redirectTo,\n                xform: fetch_1._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data) {\n                const tokenVerificationError = new Error(\"An error occurred on token verification.\");\n                throw tokenVerificationError;\n            }\n            const session = data.session;\n            const user = data.user;\n            if (session === null || session === void 0 ? void 0 : session.access_token) {\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(params.type == \"recovery\" ? \"PASSWORD_RECOVERY\" : \"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     */ async signInWithSSO(params) {\n        var _a, _b, _c, _d, _e;\n        try {\n            let codeChallenge = null;\n            let codeChallengeMethod = null;\n            if (this.flowType === \"pkce\") {\n                ;\n                [codeChallenge, codeChallengeMethod] = await (0, helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            }\n            const result = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/sso`, {\n                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, \"providerId\" in params ? {\n                    provider_id: params.providerId\n                } : null), \"domain\" in params ? {\n                    domain: params.domain\n                } : null), {\n                    redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n                }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: params.options.captchaToken\n                    }\n                } : null), {\n                    skip_http_redirect: true,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod\n                }),\n                headers: this.headers,\n                xform: fetch_1._ssoResponse\n            });\n            // Automatically redirect in browser unless skipBrowserRedirect is true\n            if (((_d = result.data) === null || _d === void 0 ? void 0 : _d.url) && (0, helpers_1.isBrowser)() && !((_e = params.options) === null || _e === void 0 ? void 0 : _e.skipBrowserRedirect)) {\n                window.location.assign(result.data.url);\n            }\n            return this._returnResult(result);\n        } catch (error) {\n            await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends a reauthentication OTP to the user's email or phone number.\n     * Requires the user to be signed-in.\n     */ async reauthenticate() {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._reauthenticate();\n        });\n    }\n    async _reauthenticate() {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) throw sessionError;\n                if (!session) throw new errors_1.AuthSessionMissingError();\n                const { error } = await (0, fetch_1._request)(this.fetch, \"GET\", `${this.url}/reauthenticate`, {\n                    headers: this.headers,\n                    jwt: session.access_token\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n     */ async resend(credentials) {\n        try {\n            const endpoint = `${this.url}/resend`;\n            if (\"email\" in credentials) {\n                const { email, type, options } = credentials;\n                const { error } = await (0, fetch_1._request)(this.fetch, \"POST\", endpoint, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        type,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, type, options } = credentials;\n                const { data, error } = await (0, fetch_1._request)(this.fetch, \"POST\", endpoint, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        type,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    }\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        messageId: data === null || data === void 0 ? void 0 : data.message_id\n                    },\n                    error\n                });\n            }\n            throw new errors_1.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a type\");\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     *\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     *\n     * **IMPORTANT:** This method loads values directly from the storage attached\n     * to the client. If that storage is based on request cookies for example,\n     * the values in it may not be authentic and therefore it's strongly advised\n     * against using this method and its results in such circumstances. A warning\n     * will be emitted if this is detected. Use {@link #getUser()} instead.\n     */ async getSession() {\n        await this.initializePromise;\n        const result = await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return this._useSession(async (result)=>{\n                return result;\n            });\n        });\n        return result;\n    }\n    /**\n     * Acquires a global lock based on the storage key.\n     */ async _acquireLock(acquireTimeout, fn) {\n        this._debug(\"#_acquireLock\", \"begin\", acquireTimeout);\n        try {\n            if (this.lockAcquired) {\n                const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();\n                const result = (async ()=>{\n                    await last;\n                    return await fn();\n                })();\n                this.pendingInLock.push((async ()=>{\n                    try {\n                        await result;\n                    } catch (e) {\n                    // we just care if it finished\n                    }\n                })());\n                return result;\n            }\n            return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async ()=>{\n                this._debug(\"#_acquireLock\", \"lock acquired for storage key\", this.storageKey);\n                try {\n                    this.lockAcquired = true;\n                    const result = fn();\n                    this.pendingInLock.push((async ()=>{\n                        try {\n                            await result;\n                        } catch (e) {\n                        // we just care if it finished\n                        }\n                    })());\n                    await result;\n                    // keep draining the queue until there's nothing to wait on\n                    while(this.pendingInLock.length){\n                        const waitOn = [\n                            ...this.pendingInLock\n                        ];\n                        await Promise.all(waitOn);\n                        this.pendingInLock.splice(0, waitOn.length);\n                    }\n                    return await result;\n                } finally{\n                    this._debug(\"#_acquireLock\", \"lock released for storage key\", this.storageKey);\n                    this.lockAcquired = false;\n                }\n            });\n        } finally{\n            this._debug(\"#_acquireLock\", \"end\");\n        }\n    }\n    /**\n     * Use instead of {@link #getSession} inside the library. It is\n     * semantically usually what you want, as getting a session involves some\n     * processing afterwards that requires only one client operating on the\n     * session at once across multiple tabs or processes.\n     */ async _useSession(fn) {\n        this._debug(\"#_useSession\", \"begin\");\n        try {\n            // the use of __loadSession here is the only correct use of the function!\n            const result = await this.__loadSession();\n            return await fn(result);\n        } finally{\n            this._debug(\"#_useSession\", \"end\");\n        }\n    }\n    /**\n     * NEVER USE DIRECTLY!\n     *\n     * Always use {@link #_useSession}.\n     */ async __loadSession() {\n        this._debug(\"#__loadSession()\", \"begin\");\n        if (!this.lockAcquired) {\n            this._debug(\"#__loadSession()\", \"used outside of an acquired lock!\", new Error().stack);\n        }\n        try {\n            let currentSession = null;\n            const maybeSession = await (0, helpers_1.getItemAsync)(this.storage, this.storageKey);\n            this._debug(\"#getSession()\", \"session from storage\", maybeSession);\n            if (maybeSession !== null) {\n                if (this._isValidSession(maybeSession)) {\n                    currentSession = maybeSession;\n                } else {\n                    this._debug(\"#getSession()\", \"session from storage is not valid\");\n                    await this._removeSession();\n                }\n            }\n            if (!currentSession) {\n                return {\n                    data: {\n                        session: null\n                    },\n                    error: null\n                };\n            }\n            // A session is considered expired before the access token _actually_\n            // expires. When the autoRefreshToken option is off (or when the tab is\n            // in the background), very eager users of getSession() -- like\n            // realtime-js -- might send a valid JWT which will expire by the time it\n            // reaches the server.\n            const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1000 - Date.now() < constants_1.EXPIRY_MARGIN_MS : false;\n            this._debug(\"#__loadSession()\", `session has${hasExpired ? \"\" : \" not\"} expired`, \"expires_at\", currentSession.expires_at);\n            if (!hasExpired) {\n                if (this.userStorage) {\n                    const maybeUser = await (0, helpers_1.getItemAsync)(this.userStorage, this.storageKey + \"-user\");\n                    if (maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) {\n                        currentSession.user = maybeUser.user;\n                    } else {\n                        currentSession.user = (0, helpers_1.userNotAvailableProxy)();\n                    }\n                }\n                // Wrap the user object with a warning proxy on the server\n                // This warns when properties of the user are accessed, not when session.user itself is accessed\n                if (this.storage.isServer && currentSession.user && !currentSession.user.__isUserNotAvailableProxy) {\n                    const suppressWarningRef = {\n                        value: this.suppressGetSessionWarning\n                    };\n                    currentSession.user = (0, helpers_1.insecureUserWarningProxy)(currentSession.user, suppressWarningRef);\n                    // Update the client-level suppression flag when the proxy suppresses the warning\n                    if (suppressWarningRef.value) {\n                        this.suppressGetSessionWarning = true;\n                    }\n                }\n                return {\n                    data: {\n                        session: currentSession\n                    },\n                    error: null\n                };\n            }\n            const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n                return this._returnResult({\n                    data: {\n                        session: null\n                    },\n                    error\n                });\n            }\n            return this._returnResult({\n                data: {\n                    session\n                },\n                error: null\n            });\n        } finally{\n            this._debug(\"#__loadSession()\", \"end\");\n        }\n    }\n    /**\n     * Gets the current user details if there is an existing session. This method\n     * performs a network request to the Supabase Auth server, so the returned\n     * value is authentic and can be used to base authorization rules on.\n     *\n     * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.\n     */ async getUser(jwt) {\n        if (jwt) {\n            return await this._getUser(jwt);\n        }\n        await this.initializePromise;\n        const result = await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._getUser();\n        });\n        if (result.data.user) {\n            this.suppressGetSessionWarning = true;\n        }\n        return result;\n    }\n    async _getUser(jwt) {\n        try {\n            if (jwt) {\n                return await (0, fetch_1._request)(this.fetch, \"GET\", `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: jwt,\n                    xform: fetch_1._userResponse\n                });\n            }\n            return await this._useSession(async (result)=>{\n                var _a, _b, _c;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                // returns an error if there is no access_token or custom authorization header\n                if (!((_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) && !this.hasCustomAuthorizationHeader) {\n                    return {\n                        data: {\n                            user: null\n                        },\n                        error: new errors_1.AuthSessionMissingError()\n                    };\n                }\n                return await (0, fetch_1._request)(this.fetch, \"GET\", `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : undefined,\n                    xform: fetch_1._userResponse\n                });\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                if ((0, errors_1.isAuthSessionMissingError)(error)) {\n                    // JWT contains a `session_id` which does not correspond to an active\n                    // session in the database, indicating the user is signed out.\n                    await this._removeSession();\n                    await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n                }\n                return this._returnResult({\n                    data: {\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates user data for a logged in user.\n     */ async updateUser(attributes, options = {}) {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._updateUser(attributes, options);\n        });\n    }\n    async _updateUser(attributes, options = {}) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    throw sessionError;\n                }\n                if (!sessionData.session) {\n                    throw new errors_1.AuthSessionMissingError();\n                }\n                const session = sessionData.session;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\" && attributes.email != null) {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0, helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { data, error: userError } = await (0, fetch_1._request)(this.fetch, \"PUT\", `${this.url}/user`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: Object.assign(Object.assign({}, attributes), {\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    }),\n                    jwt: session.access_token,\n                    xform: fetch_1._userResponse\n                });\n                if (userError) {\n                    throw userError;\n                }\n                session.user = data.user;\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(\"USER_UPDATED\", session);\n                return this._returnResult({\n                    data: {\n                        user: session.user\n                    },\n                    error: null\n                });\n            });\n        } catch (error) {\n            await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */ async setSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._setSession(currentSession);\n        });\n    }\n    async _setSession(currentSession) {\n        try {\n            if (!currentSession.access_token || !currentSession.refresh_token) {\n                throw new errors_1.AuthSessionMissingError();\n            }\n            const timeNow = Date.now() / 1000;\n            let expiresAt = timeNow;\n            let hasExpired = true;\n            let session = null;\n            const { payload } = (0, helpers_1.decodeJWT)(currentSession.access_token);\n            if (payload.exp) {\n                expiresAt = payload.exp;\n                hasExpired = expiresAt <= timeNow;\n            }\n            if (hasExpired) {\n                const { data: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: error\n                    });\n                }\n                if (!refreshedSession) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: null\n                    };\n                }\n                session = refreshedSession;\n            } else {\n                const { data, error } = await this._getUser(currentSession.access_token);\n                if (error) {\n                    throw error;\n                }\n                session = {\n                    access_token: currentSession.access_token,\n                    refresh_token: currentSession.refresh_token,\n                    user: data.user,\n                    token_type: \"bearer\",\n                    expires_in: expiresAt - timeNow,\n                    expires_at: expiresAt\n                };\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user: session.user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        session: null,\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */ async refreshSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._refreshSession(currentSession);\n        });\n    }\n    async _refreshSession(currentSession) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a;\n                if (!currentSession) {\n                    const { data, error } = result;\n                    if (error) {\n                        throw error;\n                    }\n                    currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n                }\n                if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n                    throw new errors_1.AuthSessionMissingError();\n                }\n                const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: error\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: null\n                    });\n                }\n                return this._returnResult({\n                    data: {\n                        user: session.user,\n                        session\n                    },\n                    error: null\n                });\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets the session data from a URL string\n     */ async _getSessionFromURL(params, callbackUrlType) {\n        try {\n            if (!(0, helpers_1.isBrowser)()) throw new errors_1.AuthImplicitGrantRedirectError(\"No browser detected.\");\n            // If there's an error in the URL, it doesn't matter what flow it is, we just return the error.\n            if (params.error || params.error_description || params.error_code) {\n                // The error class returned implies that the redirect is from an implicit grant flow\n                // but it could also be from a redirect error from a PKCE flow.\n                throw new errors_1.AuthImplicitGrantRedirectError(params.error_description || \"Error in URL with unspecified error_description\", {\n                    error: params.error || \"unspecified_error\",\n                    code: params.error_code || \"unspecified_code\"\n                });\n            }\n            // Checks for mismatches between the flowType initialised in the client and the URL parameters\n            switch(callbackUrlType){\n                case \"implicit\":\n                    if (this.flowType === \"pkce\") {\n                        throw new errors_1.AuthPKCEGrantCodeExchangeError(\"Not a valid PKCE flow url.\");\n                    }\n                    break;\n                case \"pkce\":\n                    if (this.flowType === \"implicit\") {\n                        throw new errors_1.AuthImplicitGrantRedirectError(\"Not a valid implicit grant flow url.\");\n                    }\n                    break;\n                default:\n            }\n            // Since this is a redirect for PKCE, we attempt to retrieve the code from the URL for the code exchange\n            if (callbackUrlType === \"pkce\") {\n                this._debug(\"#_initialize()\", \"begin\", \"is PKCE flow\", true);\n                if (!params.code) throw new errors_1.AuthPKCEGrantCodeExchangeError(\"No code detected.\");\n                const { data, error } = await this._exchangeCodeForSession(params.code);\n                if (error) throw error;\n                const url = new URL(window.location.href);\n                url.searchParams.delete(\"code\");\n                window.history.replaceState(window.history.state, \"\", url.toString());\n                return {\n                    data: {\n                        session: data.session,\n                        redirectType: null\n                    },\n                    error: null\n                };\n            }\n            const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;\n            if (!access_token || !expires_in || !refresh_token || !token_type) {\n                throw new errors_1.AuthImplicitGrantRedirectError(\"No session defined in URL\");\n            }\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = parseInt(expires_in);\n            let expiresAt = timeNow + expiresIn;\n            if (expires_at) {\n                expiresAt = parseInt(expires_at);\n            }\n            const actuallyExpiresIn = expiresAt - timeNow;\n            if (actuallyExpiresIn * 1000 <= constants_1.AUTO_REFRESH_TICK_DURATION_MS) {\n                console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);\n            }\n            const issuedAt = expiresAt - expiresIn;\n            if (timeNow - issuedAt >= 120) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale\", issuedAt, expiresAt, timeNow);\n            } else if (timeNow - issuedAt < 0) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew\", issuedAt, expiresAt, timeNow);\n            }\n            const { data, error } = await this._getUser(access_token);\n            if (error) throw error;\n            const session = {\n                provider_token,\n                provider_refresh_token,\n                access_token,\n                expires_in: expiresIn,\n                expires_at: expiresAt,\n                refresh_token,\n                token_type: token_type,\n                user: data.user\n            };\n            // Remove tokens from URL\n            window.location.hash = \"\";\n            this._debug(\"#_getSessionFromURL()\", \"clearing window.location.hash\");\n            return this._returnResult({\n                data: {\n                    session,\n                    redirectType: params.type\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        session: null,\n                        redirectType: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     *\n     * If `detectSessionInUrl` is a function, it will be called with the URL and params to determine\n     * if the URL should be processed as a Supabase auth callback. This allows users to exclude\n     * URLs from other OAuth providers (e.g., Facebook Login) that also return access_token in the fragment.\n     */ _isImplicitGrantCallback(params) {\n        if (typeof this.detectSessionInUrl === \"function\") {\n            return this.detectSessionInUrl(new URL(window.location.href), params);\n        }\n        return Boolean(params.access_token || params.error_description);\n    }\n    /**\n     * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n     */ async _isPKCECallback(params) {\n        const currentStorageContent = await (0, helpers_1.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        return !!(params.code && currentStorageContent);\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     *\n     * If using `others` scope, no `SIGNED_OUT` event is fired!\n     */ async signOut(options = {\n        scope: \"global\"\n    }) {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._signOut(options);\n        });\n    }\n    async _signOut({ scope } = {\n        scope: \"global\"\n    }) {\n        return await this._useSession(async (result)=>{\n            var _a;\n            const { data, error: sessionError } = result;\n            if (sessionError) {\n                return this._returnResult({\n                    error: sessionError\n                });\n            }\n            const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n            if (accessToken) {\n                const { error } = await this.admin.signOut(accessToken, scope);\n                if (error) {\n                    // ignore 404s since user might not exist anymore\n                    // ignore 401s since an invalid or expired JWT should sign out the current session\n                    if (!((0, errors_1.isAuthApiError)(error) && (error.status === 404 || error.status === 401 || error.status === 403))) {\n                        return this._returnResult({\n                            error\n                        });\n                    }\n                }\n            }\n            if (scope !== \"others\") {\n                await this._removeSession();\n                await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            }\n            return this._returnResult({\n                error: null\n            });\n        });\n    }\n    onAuthStateChange(callback) {\n        const id = (0, helpers_1.generateCallbackId)();\n        const subscription = {\n            id,\n            callback,\n            unsubscribe: ()=>{\n                this._debug(\"#unsubscribe()\", \"state change callback with id removed\", id);\n                this.stateChangeEmitters.delete(id);\n            }\n        };\n        this._debug(\"#onAuthStateChange()\", \"registered callback with id\", id);\n        this.stateChangeEmitters.set(id, subscription);\n        (async ()=>{\n            await this.initializePromise;\n            await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n                this._emitInitialSession(id);\n            });\n        })();\n        return {\n            data: {\n                subscription\n            }\n        };\n    }\n    async _emitInitialSession(id) {\n        return await this._useSession(async (result)=>{\n            var _a, _b;\n            try {\n                const { data: { session }, error } = result;\n                if (error) throw error;\n                await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback(\"INITIAL_SESSION\", session));\n                this._debug(\"INITIAL_SESSION\", \"callback id\", id, \"session\", session);\n            } catch (err) {\n                await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback(\"INITIAL_SESSION\", null));\n                this._debug(\"INITIAL_SESSION\", \"callback id\", id, \"error\", err);\n                console.error(err);\n            }\n        });\n    }\n    /**\n     * Sends a password reset request to an email address. This method supports the PKCE flow.\n     *\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */ async resetPasswordForEmail(email, options = {}) {\n        let codeChallenge = null;\n        let codeChallengeMethod = null;\n        if (this.flowType === \"pkce\") {\n            ;\n            [codeChallenge, codeChallengeMethod] = await (0, helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey, true // isPasswordRecovery\n            );\n        }\n        try {\n            return await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/recover`, {\n                body: {\n                    email,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod,\n                    gotrue_meta_security: {\n                        captcha_token: options.captchaToken\n                    }\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo\n            });\n        } catch (error) {\n            await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets all the identities linked to a user.\n     */ async getUserIdentities() {\n        var _a;\n        try {\n            const { data, error } = await this.getUser();\n            if (error) throw error;\n            return this._returnResult({\n                data: {\n                    identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : []\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async linkIdentity(credentials) {\n        if (\"token\" in credentials) {\n            return this.linkIdentityIdToken(credentials);\n        }\n        return this.linkIdentityOAuth(credentials);\n    }\n    async linkIdentityOAuth(credentials) {\n        var _a;\n        try {\n            const { data, error } = await this._useSession(async (result)=>{\n                var _a, _b, _c, _d, _e;\n                const { data, error } = result;\n                if (error) throw error;\n                const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {\n                    redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                    scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                    queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                    skipBrowserRedirect: true\n                });\n                return await (0, fetch_1._request)(this.fetch, \"GET\", url, {\n                    headers: this.headers,\n                    jwt: (_e = (_d = data.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : undefined\n                });\n            });\n            if (error) throw error;\n            if ((0, helpers_1.isBrowser)() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) {\n                window.location.assign(data === null || data === void 0 ? void 0 : data.url);\n            }\n            return this._returnResult({\n                data: {\n                    provider: credentials.provider,\n                    url: data === null || data === void 0 ? void 0 : data.url\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        provider: credentials.provider,\n                        url: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async linkIdentityIdToken(credentials) {\n        return await this._useSession(async (result)=>{\n            var _a;\n            try {\n                const { error: sessionError, data: { session } } = result;\n                if (sessionError) throw sessionError;\n                const { options, provider, token, access_token, nonce } = credentials;\n                const res = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=id_token`, {\n                    headers: this.headers,\n                    jwt: (_a = session === null || session === void 0 ? void 0 : session.access_token) !== null && _a !== void 0 ? _a : undefined,\n                    body: {\n                        provider,\n                        id_token: token,\n                        access_token,\n                        nonce,\n                        link_identity: true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: fetch_1._sessionResponse\n                });\n                const { data, error } = res;\n                if (error) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error\n                    });\n                } else if (!data || !data.session || !data.user) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: new errors_1.AuthInvalidTokenResponseError()\n                    });\n                }\n                if (data.session) {\n                    await this._saveSession(data.session);\n                    await this._notifyAllSubscribers(\"USER_UPDATED\", data.session);\n                }\n                return this._returnResult({\n                    data,\n                    error\n                });\n            } catch (error) {\n                await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n                if ((0, errors_1.isAuthError)(error)) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.\n     */ async unlinkIdentity(identity) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                return await (0, fetch_1._request)(this.fetch, \"DELETE\", `${this.url}/user/identities/${identity.identity_id}`, {\n                    headers: this.headers,\n                    jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined\n                });\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */ async _refreshAccessToken(refreshToken) {\n        const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, \"begin\");\n        try {\n            const startedAt = Date.now();\n            // will attempt to refresh the token with exponential backoff\n            return await (0, helpers_1.retryable)(async (attempt)=>{\n                if (attempt > 0) {\n                    await (0, helpers_1.sleep)(200 * Math.pow(2, attempt - 1)); // 200, 400, 800, ...\n                }\n                this._debug(debugName, \"refreshing attempt\", attempt);\n                return await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=refresh_token`, {\n                    body: {\n                        refresh_token: refreshToken\n                    },\n                    headers: this.headers,\n                    xform: fetch_1._sessionResponse\n                });\n            }, (attempt, error)=>{\n                const nextBackOffInterval = 200 * Math.pow(2, attempt);\n                return error && (0, errors_1.isAuthRetryableFetchError)(error) && // retryable only if the request can be sent before the backoff overflows the tick duration\n                Date.now() + nextBackOffInterval - startedAt < constants_1.AUTO_REFRESH_TICK_DURATION_MS;\n            });\n        } catch (error) {\n            this._debug(debugName, \"error\", error);\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        session: null,\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    _isValidSession(maybeSession) {\n        const isValidSession = typeof maybeSession === \"object\" && maybeSession !== null && \"access_token\" in maybeSession && \"refresh_token\" in maybeSession && \"expires_at\" in maybeSession;\n        return isValidSession;\n    }\n    async _handleProviderSignIn(provider, options) {\n        const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams\n        });\n        this._debug(\"#_handleProviderSignIn()\", \"provider\", provider, \"options\", options, \"url\", url);\n        // try to open on the browser\n        if ((0, helpers_1.isBrowser)() && !options.skipBrowserRedirect) {\n            window.location.assign(url);\n        }\n        return {\n            data: {\n                provider,\n                url\n            },\n            error: null\n        };\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes the token\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */ async _recoverAndRefresh() {\n        var _a, _b;\n        const debugName = \"#_recoverAndRefresh()\";\n        this._debug(debugName, \"begin\");\n        try {\n            const currentSession = await (0, helpers_1.getItemAsync)(this.storage, this.storageKey);\n            if (currentSession && this.userStorage) {\n                let maybeUser = await (0, helpers_1.getItemAsync)(this.userStorage, this.storageKey + \"-user\");\n                if (!this.storage.isServer && Object.is(this.storage, this.userStorage) && !maybeUser) {\n                    // storage and userStorage are the same storage medium, for example\n                    // window.localStorage if userStorage does not have the user from\n                    // storage stored, store it first thereby migrating the user object\n                    // from storage -> userStorage\n                    maybeUser = {\n                        user: currentSession.user\n                    };\n                    await (0, helpers_1.setItemAsync)(this.userStorage, this.storageKey + \"-user\", maybeUser);\n                }\n                currentSession.user = (_a = maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) !== null && _a !== void 0 ? _a : (0, helpers_1.userNotAvailableProxy)();\n            } else if (currentSession && !currentSession.user) {\n                // user storage is not set, let's check if it was previously enabled so\n                // we bring back the storage as it should be\n                if (!currentSession.user) {\n                    // test if userStorage was previously enabled and the storage medium was the same, to move the user back under the same key\n                    const separateUser = await (0, helpers_1.getItemAsync)(this.storage, this.storageKey + \"-user\");\n                    if (separateUser && (separateUser === null || separateUser === void 0 ? void 0 : separateUser.user)) {\n                        currentSession.user = separateUser.user;\n                        await (0, helpers_1.removeItemAsync)(this.storage, this.storageKey + \"-user\");\n                        await (0, helpers_1.setItemAsync)(this.storage, this.storageKey, currentSession);\n                    } else {\n                        currentSession.user = (0, helpers_1.userNotAvailableProxy)();\n                    }\n                }\n            }\n            this._debug(debugName, \"session from storage\", currentSession);\n            if (!this._isValidSession(currentSession)) {\n                this._debug(debugName, \"session is not valid\");\n                if (currentSession !== null) {\n                    await this._removeSession();\n                }\n                return;\n            }\n            const expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== void 0 ? _b : Infinity) * 1000 - Date.now() < constants_1.EXPIRY_MARGIN_MS;\n            this._debug(debugName, `session has${expiresWithMargin ? \"\" : \" not\"} expired with margin of ${constants_1.EXPIRY_MARGIN_MS}s`);\n            if (expiresWithMargin) {\n                if (this.autoRefreshToken && currentSession.refresh_token) {\n                    const { error } = await this._callRefreshToken(currentSession.refresh_token);\n                    if (error) {\n                        console.error(error);\n                        if (!(0, errors_1.isAuthRetryableFetchError)(error)) {\n                            this._debug(debugName, \"refresh failed with a non-retryable error, removing the session\", error);\n                            await this._removeSession();\n                        }\n                    }\n                }\n            } else if (currentSession.user && currentSession.user.__isUserNotAvailableProxy === true) {\n                // If we have a proxy user, try to get the real user data\n                try {\n                    const { data, error: userError } = await this._getUser(currentSession.access_token);\n                    if (!userError && (data === null || data === void 0 ? void 0 : data.user)) {\n                        currentSession.user = data.user;\n                        await this._saveSession(currentSession);\n                        await this._notifyAllSubscribers(\"SIGNED_IN\", currentSession);\n                    } else {\n                        this._debug(debugName, \"could not get user data, skipping SIGNED_IN notification\");\n                    }\n                } catch (getUserError) {\n                    console.error(\"Error getting user data:\", getUserError);\n                    this._debug(debugName, \"error getting user data, skipping SIGNED_IN notification\", getUserError);\n                }\n            } else {\n                // no need to persist currentSession again, as we just loaded it from\n                // local storage; persisting it again may overwrite a value saved by\n                // another client with access to the same local storage\n                await this._notifyAllSubscribers(\"SIGNED_IN\", currentSession);\n            }\n        } catch (err) {\n            this._debug(debugName, \"error\", err);\n            console.error(err);\n            return;\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    async _callRefreshToken(refreshToken) {\n        var _a, _b;\n        if (!refreshToken) {\n            throw new errors_1.AuthSessionMissingError();\n        }\n        // refreshing is already in progress\n        if (this.refreshingDeferred) {\n            return this.refreshingDeferred.promise;\n        }\n        const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, \"begin\");\n        try {\n            this.refreshingDeferred = new helpers_1.Deferred();\n            const { data, error } = await this._refreshAccessToken(refreshToken);\n            if (error) throw error;\n            if (!data.session) throw new errors_1.AuthSessionMissingError();\n            await this._saveSession(data.session);\n            await this._notifyAllSubscribers(\"TOKEN_REFRESHED\", data.session);\n            const result = {\n                data: data.session,\n                error: null\n            };\n            this.refreshingDeferred.resolve(result);\n            return result;\n        } catch (error) {\n            this._debug(debugName, \"error\", error);\n            if ((0, errors_1.isAuthError)(error)) {\n                const result = {\n                    data: null,\n                    error\n                };\n                if (!(0, errors_1.isAuthRetryableFetchError)(error)) {\n                    await this._removeSession();\n                }\n                (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n                return result;\n            }\n            (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n            throw error;\n        } finally{\n            this.refreshingDeferred = null;\n            this._debug(debugName, \"end\");\n        }\n    }\n    async _notifyAllSubscribers(event, session, broadcast = true) {\n        const debugName = `#_notifyAllSubscribers(${event})`;\n        this._debug(debugName, \"begin\", session, `broadcast = ${broadcast}`);\n        try {\n            if (this.broadcastChannel && broadcast) {\n                this.broadcastChannel.postMessage({\n                    event,\n                    session\n                });\n            }\n            const errors = [];\n            const promises = Array.from(this.stateChangeEmitters.values()).map(async (x)=>{\n                try {\n                    await x.callback(event, session);\n                } catch (e) {\n                    errors.push(e);\n                }\n            });\n            await Promise.all(promises);\n            if (errors.length > 0) {\n                for(let i = 0; i < errors.length; i += 1){\n                    console.error(errors[i]);\n                }\n                throw errors[0];\n            }\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */ async _saveSession(session) {\n        this._debug(\"#_saveSession()\", session);\n        // _saveSession is always called whenever a new session has been acquired\n        // so we can safely suppress the warning returned by future getSession calls\n        this.suppressGetSessionWarning = true;\n        await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        // Create a shallow copy to work with, to avoid mutating the original session object if it's used elsewhere\n        const sessionToProcess = Object.assign({}, session);\n        const userIsProxy = sessionToProcess.user && sessionToProcess.user.__isUserNotAvailableProxy === true;\n        if (this.userStorage) {\n            if (!userIsProxy && sessionToProcess.user) {\n                // If it's a real user object, save it to userStorage.\n                await (0, helpers_1.setItemAsync)(this.userStorage, this.storageKey + \"-user\", {\n                    user: sessionToProcess.user\n                });\n            } else if (userIsProxy) {\n            // If it's the proxy, it means user was not found in userStorage.\n            // We should ensure no stale user data for this key exists in userStorage if we were to save null,\n            // or simply not save the proxy. For now, we don't save the proxy here.\n            // If there's a need to clear userStorage if user becomes proxy, that logic would go here.\n            }\n            // Prepare the main session data for primary storage: remove the user property before cloning\n            // This is important because the original session.user might be the proxy\n            const mainSessionData = Object.assign({}, sessionToProcess);\n            delete mainSessionData.user; // Remove user (real or proxy) before cloning for main storage\n            const clonedMainSessionData = (0, helpers_1.deepClone)(mainSessionData);\n            await (0, helpers_1.setItemAsync)(this.storage, this.storageKey, clonedMainSessionData);\n        } else {\n            // No userStorage is configured.\n            // In this case, session.user should ideally not be a proxy.\n            // If it were, structuredClone would fail. This implies an issue elsewhere if user is a proxy here\n            const clonedSession = (0, helpers_1.deepClone)(sessionToProcess); // sessionToProcess still has its original user property\n            await (0, helpers_1.setItemAsync)(this.storage, this.storageKey, clonedSession);\n        }\n    }\n    async _removeSession() {\n        this._debug(\"#_removeSession()\");\n        this.suppressGetSessionWarning = false;\n        await (0, helpers_1.removeItemAsync)(this.storage, this.storageKey);\n        await (0, helpers_1.removeItemAsync)(this.storage, this.storageKey + \"-code-verifier\");\n        await (0, helpers_1.removeItemAsync)(this.storage, this.storageKey + \"-user\");\n        if (this.userStorage) {\n            await (0, helpers_1.removeItemAsync)(this.userStorage, this.storageKey + \"-user\");\n        }\n        await this._notifyAllSubscribers(\"SIGNED_OUT\", null);\n    }\n    /**\n     * Removes any registered visibilitychange callback.\n     *\n     * {@see #startAutoRefresh}\n     * {@see #stopAutoRefresh}\n     */ _removeVisibilityChangedCallback() {\n        this._debug(\"#_removeVisibilityChangedCallback()\");\n        const callback = this.visibilityChangedCallback;\n        this.visibilityChangedCallback = null;\n        try {\n            if (callback && (0, helpers_1.isBrowser)() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n                window.removeEventListener(\"visibilitychange\", callback);\n            }\n        } catch (e) {\n            console.error(\"removing visibilitychange callback failed\", e);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\n     * within the library.\n     */ async _startAutoRefresh() {\n        await this._stopAutoRefresh();\n        this._debug(\"#_startAutoRefresh()\");\n        const ticker = setInterval(()=>this._autoRefreshTokenTick(), constants_1.AUTO_REFRESH_TICK_DURATION_MS);\n        this.autoRefreshTicker = ticker;\n        if (ticker && typeof ticker === \"object\" && typeof ticker.unref === \"function\") {\n            // ticker is a NodeJS Timeout object that has an `unref` method\n            // https://nodejs.org/api/timers.html#timeoutunref\n            // When auto refresh is used in NodeJS (like for testing) the\n            // `setInterval` is preventing the process from being marked as\n            // finished and tests run endlessly. This can be prevented by calling\n            // `unref()` on the returned object.\n            ticker.unref();\n        // @ts-expect-error TS has no context of Deno\n        } else if (typeof Deno !== \"undefined\" && typeof Deno.unrefTimer === \"function\") {\n            // similar like for NodeJS, but with the Deno API\n            // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n            // @ts-expect-error TS has no context of Deno\n            Deno.unrefTimer(ticker);\n        }\n        // run the tick immediately, but in the next pass of the event loop so that\n        // #_initialize can be allowed to complete without recursively waiting on\n        // itself\n        const timeout = setTimeout(async ()=>{\n            await this.initializePromise;\n            await this._autoRefreshTokenTick();\n        }, 0);\n        this.autoRefreshTickTimeout = timeout;\n        if (timeout && typeof timeout === \"object\" && typeof timeout.unref === \"function\") {\n            timeout.unref();\n        // @ts-expect-error TS has no context of Deno\n        } else if (typeof Deno !== \"undefined\" && typeof Deno.unrefTimer === \"function\") {\n            // @ts-expect-error TS has no context of Deno\n            Deno.unrefTimer(timeout);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\n     * within the library.\n     */ async _stopAutoRefresh() {\n        this._debug(\"#_stopAutoRefresh()\");\n        const ticker = this.autoRefreshTicker;\n        this.autoRefreshTicker = null;\n        if (ticker) {\n            clearInterval(ticker);\n        }\n        const timeout = this.autoRefreshTickTimeout;\n        this.autoRefreshTickTimeout = null;\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n    }\n    /**\n     * Starts an auto-refresh process in the background. The session is checked\n     * every few seconds. Close to the time of expiration a process is started to\n     * refresh the session. If refreshing fails it will be retried for as long as\n     * necessary.\n     *\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n     * to call this function, it will be called for you.\n     *\n     * On browsers the refresh process works only when the tab/window is in the\n     * foreground to conserve resources as well as prevent race conditions and\n     * flooding auth with requests. If you call this method any managed\n     * visibility change callback will be removed and you must manage visibility\n     * changes on your own.\n     *\n     * On non-browser platforms the refresh process works *continuously* in the\n     * background, which may not be desirable. You should hook into your\n     * platform's foreground indication mechanism and call these methods\n     * appropriately to conserve resources.\n     *\n     * {@see #stopAutoRefresh}\n     */ async startAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._startAutoRefresh();\n    }\n    /**\n     * Stops an active auto refresh process running in the background (if any).\n     *\n     * If you call this method any managed visibility change callback will be\n     * removed and you must manage visibility changes on your own.\n     *\n     * See {@link #startAutoRefresh} for more details.\n     */ async stopAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._stopAutoRefresh();\n    }\n    /**\n     * Runs the auto refresh token tick.\n     */ async _autoRefreshTokenTick() {\n        this._debug(\"#_autoRefreshTokenTick()\", \"begin\");\n        try {\n            await this._acquireLock(0, async ()=>{\n                try {\n                    const now = Date.now();\n                    try {\n                        return await this._useSession(async (result)=>{\n                            const { data: { session } } = result;\n                            if (!session || !session.refresh_token || !session.expires_at) {\n                                this._debug(\"#_autoRefreshTokenTick()\", \"no session\");\n                                return;\n                            }\n                            // session will expire in this many ticks (or has already expired if <= 0)\n                            const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / constants_1.AUTO_REFRESH_TICK_DURATION_MS);\n                            this._debug(\"#_autoRefreshTokenTick()\", `access token expires in ${expiresInTicks} ticks, a tick lasts ${constants_1.AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${constants_1.AUTO_REFRESH_TICK_THRESHOLD} ticks`);\n                            if (expiresInTicks <= constants_1.AUTO_REFRESH_TICK_THRESHOLD) {\n                                await this._callRefreshToken(session.refresh_token);\n                            }\n                        });\n                    } catch (e) {\n                        console.error(\"Auto refresh tick failed with error. This is likely a transient error.\", e);\n                    }\n                } finally{\n                    this._debug(\"#_autoRefreshTokenTick()\", \"end\");\n                }\n            });\n        } catch (e) {\n            if (e.isAcquireTimeout || e instanceof locks_1.LockAcquireTimeoutError) {\n                this._debug(\"auto refresh token tick lock not available\");\n            } else {\n                throw e;\n            }\n        }\n    }\n    /**\n     * Registers callbacks on the browser / platform, which in-turn run\n     * algorithms when the browser window/tab are in foreground. On non-browser\n     * platforms it assumes always foreground.\n     */ async _handleVisibilityChange() {\n        this._debug(\"#_handleVisibilityChange()\");\n        if (!(0, helpers_1.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            if (this.autoRefreshToken) {\n                // in non-browser environments the refresh token ticker runs always\n                this.startAutoRefresh();\n            }\n            return false;\n        }\n        try {\n            this.visibilityChangedCallback = async ()=>await this._onVisibilityChanged(false);\n            window === null || window === void 0 ? void 0 : window.addEventListener(\"visibilitychange\", this.visibilityChangedCallback);\n            // now immediately call the visbility changed callback to setup with the\n            // current visbility state\n            await this._onVisibilityChanged(true); // initial call\n        } catch (error) {\n            console.error(\"_handleVisibilityChange\", error);\n        }\n    }\n    /**\n     * Callback registered with `window.addEventListener('visibilitychange')`.\n     */ async _onVisibilityChanged(calledFromInitialize) {\n        const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;\n        this._debug(methodName, \"visibilityState\", document.visibilityState);\n        if (document.visibilityState === \"visible\") {\n            if (this.autoRefreshToken) {\n                // in browser environments the refresh token ticker runs only on focused tabs\n                // which prevents race conditions\n                this._startAutoRefresh();\n            }\n            if (!calledFromInitialize) {\n                // called when the visibility has changed, i.e. the browser\n                // transitioned from hidden -> visible so we need to see if the session\n                // should be recovered immediately... but to do that we need to acquire\n                // the lock first asynchronously\n                await this.initializePromise;\n                await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n                    if (document.visibilityState !== \"visible\") {\n                        this._debug(methodName, \"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting\");\n                        // visibility has changed while waiting for the lock, abort\n                        return;\n                    }\n                    // recover the session\n                    await this._recoverAndRefresh();\n                });\n            }\n        } else if (document.visibilityState === \"hidden\") {\n            if (this.autoRefreshToken) {\n                this._stopAutoRefresh();\n            }\n        }\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */ async _getUrlForProvider(url, provider, options) {\n        const urlParams = [\n            `provider=${encodeURIComponent(provider)}`\n        ];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n            urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.scopes) {\n            urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n        }\n        if (this.flowType === \"pkce\") {\n            const [codeChallenge, codeChallengeMethod] = await (0, helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            const flowParams = new URLSearchParams({\n                code_challenge: `${encodeURIComponent(codeChallenge)}`,\n                code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`\n            });\n            urlParams.push(flowParams.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.queryParams) {\n            const query = new URLSearchParams(options.queryParams);\n            urlParams.push(query.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {\n            urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);\n        }\n        return `${url}?${urlParams.join(\"&\")}`;\n    }\n    async _unenroll(params) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                return await (0, fetch_1._request)(this.fetch, \"DELETE\", `${this.url}/factors/${params.factorId}`, {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async _enroll(params) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                const body = Object.assign({\n                    friendly_name: params.friendlyName,\n                    factor_type: params.factorType\n                }, params.factorType === \"phone\" ? {\n                    phone: params.phone\n                } : params.factorType === \"totp\" ? {\n                    issuer: params.issuer\n                } : {});\n                const { data, error } = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/factors`, {\n                    body,\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n                if (error) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                if (params.factorType === \"totp\" && data.type === \"totp\" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {\n                    data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n                }\n                return this._returnResult({\n                    data,\n                    error: null\n                });\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async _verify(params) {\n        return this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            try {\n                return await this._useSession(async (result)=>{\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return this._returnResult({\n                            data: null,\n                            error: sessionError\n                        });\n                    }\n                    const body = Object.assign({\n                        challenge_id: params.challengeId\n                    }, \"webauthn\" in params ? {\n                        webauthn: Object.assign(Object.assign({}, params.webauthn), {\n                            credential_response: params.webauthn.type === \"create\" ? (0, webauthn_1.serializeCredentialCreationResponse)(params.webauthn.credential_response) : (0, webauthn_1.serializeCredentialRequestResponse)(params.webauthn.credential_response)\n                        })\n                    } : {\n                        code: params.code\n                    });\n                    const { data, error } = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/verify`, {\n                        body,\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                    });\n                    if (error) {\n                        return this._returnResult({\n                            data: null,\n                            error\n                        });\n                    }\n                    await this._saveSession(Object.assign({\n                        expires_at: Math.round(Date.now() / 1000) + data.expires_in\n                    }, data));\n                    await this._notifyAllSubscribers(\"MFA_CHALLENGE_VERIFIED\", data);\n                    return this._returnResult({\n                        data,\n                        error\n                    });\n                });\n            } catch (error) {\n                if ((0, errors_1.isAuthError)(error)) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    async _challenge(params) {\n        return this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            try {\n                return await this._useSession(async (result)=>{\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return this._returnResult({\n                            data: null,\n                            error: sessionError\n                        });\n                    }\n                    const response = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/challenge`, {\n                        body: params,\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                    });\n                    if (response.error) {\n                        return response;\n                    }\n                    const { data } = response;\n                    if (data.type !== \"webauthn\") {\n                        return {\n                            data,\n                            error: null\n                        };\n                    }\n                    switch(data.webauthn.type){\n                        case \"create\":\n                            return {\n                                data: Object.assign(Object.assign({}, data), {\n                                    webauthn: Object.assign(Object.assign({}, data.webauthn), {\n                                        credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), {\n                                            publicKey: (0, webauthn_1.deserializeCredentialCreationOptions)(data.webauthn.credential_options.publicKey)\n                                        })\n                                    })\n                                }),\n                                error: null\n                            };\n                        case \"request\":\n                            return {\n                                data: Object.assign(Object.assign({}, data), {\n                                    webauthn: Object.assign(Object.assign({}, data.webauthn), {\n                                        credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), {\n                                            publicKey: (0, webauthn_1.deserializeCredentialRequestOptions)(data.webauthn.credential_options.publicKey)\n                                        })\n                                    })\n                                }),\n                                error: null\n                            };\n                    }\n                });\n            } catch (error) {\n                if ((0, errors_1.isAuthError)(error)) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challengeAndVerify}\n     */ async _challengeAndVerify(params) {\n        // both _challenge and _verify independently acquire the lock, so no need\n        // to acquire it here\n        const { data: challengeData, error: challengeError } = await this._challenge({\n            factorId: params.factorId\n        });\n        if (challengeError) {\n            return this._returnResult({\n                data: null,\n                error: challengeError\n            });\n        }\n        return await this._verify({\n            factorId: params.factorId,\n            challengeId: challengeData.id,\n            code: params.code\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#listFactors}\n     */ async _listFactors() {\n        var _a;\n        // use #getUser instead of #_getUser as the former acquires a lock\n        const { data: { user }, error: userError } = await this.getUser();\n        if (userError) {\n            return {\n                data: null,\n                error: userError\n            };\n        }\n        const data = {\n            all: [],\n            phone: [],\n            totp: [],\n            webauthn: []\n        };\n        // loop over the factors ONCE\n        for (const factor of (_a = user === null || user === void 0 ? void 0 : user.factors) !== null && _a !== void 0 ? _a : []){\n            data.all.push(factor);\n            if (factor.status === \"verified\") {\n                ;\n                data[factor.factor_type].push(factor);\n            }\n        }\n        return {\n            data,\n            error: null\n        };\n    }\n    /**\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n     */ async _getAuthenticatorAssuranceLevel() {\n        var _a, _b;\n        const { data: { session }, error: sessionError } = await this.getSession();\n        if (sessionError) {\n            return this._returnResult({\n                data: null,\n                error: sessionError\n            });\n        }\n        if (!session) {\n            return {\n                data: {\n                    currentLevel: null,\n                    nextLevel: null,\n                    currentAuthenticationMethods: []\n                },\n                error: null\n            };\n        }\n        const { payload } = (0, helpers_1.decodeJWT)(session.access_token);\n        let currentLevel = null;\n        if (payload.aal) {\n            currentLevel = payload.aal;\n        }\n        let nextLevel = currentLevel;\n        const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor)=>factor.status === \"verified\")) !== null && _b !== void 0 ? _b : [];\n        if (verifiedFactors.length > 0) {\n            nextLevel = \"aal2\";\n        }\n        const currentAuthenticationMethods = payload.amr || [];\n        return {\n            data: {\n                currentLevel,\n                nextLevel,\n                currentAuthenticationMethods\n            },\n            error: null\n        };\n    }\n    /**\n     * Retrieves details about an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * Returns authorization details including client info, scopes, and user information.\n     * If the API returns a redirect_uri, it means consent was already given - the caller\n     * should handle the redirect manually if needed.\n     */ async _getAuthorizationDetails(authorizationId) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new errors_1.AuthSessionMissingError()\n                    });\n                }\n                return await (0, fetch_1._request)(this.fetch, \"GET\", `${this.url}/oauth/authorizations/${authorizationId}`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Approves an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _approveAuthorization(authorizationId, options) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new errors_1.AuthSessionMissingError()\n                    });\n                }\n                const response = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    body: {\n                        action: \"approve\"\n                    },\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n                if (response.data && response.data.redirect_url) {\n                    // Automatically redirect in browser unless skipBrowserRedirect is true\n                    if ((0, helpers_1.isBrowser)() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {\n                        window.location.assign(response.data.redirect_url);\n                    }\n                }\n                return response;\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Denies an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _denyAuthorization(authorizationId, options) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new errors_1.AuthSessionMissingError()\n                    });\n                }\n                const response = await (0, fetch_1._request)(this.fetch, \"POST\", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    body: {\n                        action: \"deny\"\n                    },\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n                if (response.data && response.data.redirect_url) {\n                    // Automatically redirect in browser unless skipBrowserRedirect is true\n                    if ((0, helpers_1.isBrowser)() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {\n                        window.location.assign(response.data.redirect_url);\n                    }\n                }\n                return response;\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Lists all OAuth grants that the authenticated user has authorized.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _listOAuthGrants() {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new errors_1.AuthSessionMissingError()\n                    });\n                }\n                return await (0, fetch_1._request)(this.fetch, \"GET\", `${this.url}/user/oauth/grants`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Revokes a user's OAuth grant for a specific client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _revokeOAuthGrant(options) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new errors_1.AuthSessionMissingError()\n                    });\n                }\n                await (0, fetch_1._request)(this.fetch, \"DELETE\", `${this.url}/user/oauth/grants`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    query: {\n                        client_id: options.clientId\n                    },\n                    noResolveJson: true\n                });\n                return {\n                    data: {},\n                    error: null\n                };\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async fetchJwk(kid, jwks = {\n        keys: []\n    }) {\n        // try fetching from the supplied jwks\n        let jwk = jwks.keys.find((key)=>key.kid === kid);\n        if (jwk) {\n            return jwk;\n        }\n        const now = Date.now();\n        // try fetching from cache\n        jwk = this.jwks.keys.find((key)=>key.kid === kid);\n        // jwk exists and jwks isn't stale\n        if (jwk && this.jwks_cached_at + constants_1.JWKS_TTL > now) {\n            return jwk;\n        }\n        // jwk isn't cached in memory so we need to fetch it from the well-known endpoint\n        const { data, error } = await (0, fetch_1._request)(this.fetch, \"GET\", `${this.url}/.well-known/jwks.json`, {\n            headers: this.headers\n        });\n        if (error) {\n            throw error;\n        }\n        if (!data.keys || data.keys.length === 0) {\n            return null;\n        }\n        this.jwks = data;\n        this.jwks_cached_at = now;\n        // Find the signing key\n        jwk = data.keys.find((key)=>key.kid === kid);\n        if (!jwk) {\n            return null;\n        }\n        return jwk;\n    }\n    /**\n     * Extracts the JWT claims present in the access token by first verifying the\n     * JWT against the server's JSON Web Key Set endpoint\n     * `/.well-known/jwks.json` which is often cached, resulting in significantly\n     * faster responses. Prefer this method over {@link #getUser} which always\n     * sends a request to the Auth server for each JWT.\n     *\n     * If the project is not using an asymmetric JWT signing key (like ECC or\n     * RSA) it always sends a request to the Auth server (similar to {@link\n     * #getUser}) to verify the JWT.\n     *\n     * @param jwt An optional specific JWT you wish to verify, not the one you\n     *            can obtain from {@link #getSession}.\n     * @param options Various additional options that allow you to customize the\n     *                behavior of this method.\n     */ async getClaims(jwt, options = {}) {\n        try {\n            let token = jwt;\n            if (!token) {\n                const { data, error } = await this.getSession();\n                if (error || !data.session) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                token = data.session.access_token;\n            }\n            const { header, payload, signature, raw: { header: rawHeader, payload: rawPayload } } = (0, helpers_1.decodeJWT)(token);\n            if (!(options === null || options === void 0 ? void 0 : options.allowExpired)) {\n                // Reject expired JWTs should only happen if jwt argument was passed\n                (0, helpers_1.validateExp)(payload.exp);\n            }\n            const signingKey = !header.alg || header.alg.startsWith(\"HS\") || !header.kid || !(\"crypto\" in globalThis && \"subtle\" in globalThis.crypto) ? null : await this.fetchJwk(header.kid, (options === null || options === void 0 ? void 0 : options.keys) ? {\n                keys: options.keys\n            } : options === null || options === void 0 ? void 0 : options.jwks);\n            // If symmetric algorithm or WebCrypto API is unavailable, fallback to getUser()\n            if (!signingKey) {\n                const { error } = await this.getUser(token);\n                if (error) {\n                    throw error;\n                }\n                // getUser succeeds so the claims in the JWT can be trusted\n                return {\n                    data: {\n                        claims: payload,\n                        header,\n                        signature\n                    },\n                    error: null\n                };\n            }\n            const algorithm = (0, helpers_1.getAlgorithm)(header.alg);\n            // Convert JWK to CryptoKey\n            const publicKey = await crypto.subtle.importKey(\"jwk\", signingKey, algorithm, true, [\n                \"verify\"\n            ]);\n            // Verify the signature\n            const isValid = await crypto.subtle.verify(algorithm, publicKey, signature, (0, base64url_1.stringToUint8Array)(`${rawHeader}.${rawPayload}`));\n            if (!isValid) {\n                throw new errors_1.AuthInvalidJwtError(\"Invalid JWT signature\");\n            }\n            // If verification succeeds, decode and return claims\n            return {\n                data: {\n                    claims: payload,\n                    header,\n                    signature\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n}\nGoTrueClient.nextInstanceID = {};\nexports[\"default\"] = GoTrueClient; //# sourceMappingURL=GoTrueClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL0dvVHJ1ZUNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxVQUFVQyxtQkFBT0EsQ0FBQyx1REFBTztBQUMvQixNQUFNQyxtQkFBbUJGLFFBQVFHLGVBQWUsQ0FBQ0YsbUJBQU9BLENBQUMsNEZBQWtCO0FBQzNFLE1BQU1HLGNBQWNILG1CQUFPQSxDQUFDLDBGQUFpQjtBQUM3QyxNQUFNSSxXQUFXSixtQkFBT0EsQ0FBQyxvRkFBYztBQUN2QyxNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQyxrRkFBYTtBQUNyQyxNQUFNTSxZQUFZTixtQkFBT0EsQ0FBQyxzRkFBZTtBQUN6QyxNQUFNTyxrQkFBa0JQLG1CQUFPQSxDQUFDLGtHQUFxQjtBQUNyRCxNQUFNUSxVQUFVUixtQkFBT0EsQ0FBQyxrRkFBYTtBQUNyQyxNQUFNUyxjQUFjVCxtQkFBT0EsQ0FBQywwRkFBaUI7QUFDN0MsTUFBTVUsWUFBWVYsbUJBQU9BLENBQUMsc0ZBQWU7QUFDekMsTUFBTVcsY0FBY1gsbUJBQU9BLENBQUMsMEZBQWlCO0FBQzdDLE1BQU1ZLGFBQWFaLG1CQUFPQSxDQUFDLGtHQUFxQjtBQUNoRCxNQUFNYSxhQUFhYixtQkFBT0EsQ0FBQyx3RkFBZ0I7QUFDMUMsSUFBR1MsWUFBWUssa0JBQWtCLEtBQUssOEJBQThCO0FBQ3JFLE1BQU1DLGtCQUFrQjtJQUNwQkMsS0FBS2IsWUFBWWMsVUFBVTtJQUMzQkMsWUFBWWYsWUFBWWdCLFdBQVc7SUFDbkNDLGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxvQkFBb0I7SUFDcEJDLFNBQVNwQixZQUFZcUIsZUFBZTtJQUNwQ0MsVUFBVTtJQUNWQyxPQUFPO0lBQ1BDLDhCQUE4QjtJQUM5QkMsY0FBYztJQUNkQyxvQkFBb0I7QUFDeEI7QUFDQSxlQUFlQyxTQUFTQyxJQUFJ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LE9BQU8sSUFBSSxDQUFDUyxhQUFhLENBQUM7b0JBQUVKLE1BQU07b0JBQU1MO2dCQUFNO1lBQ2xEO1lBQ0EsTUFBTUE7UUFDVjtJQUNKO0FBQ0o7QUFDQWxGLGFBQWErQixjQUFjLEdBQUcsQ0FBQztBQUMvQnJFLGtCQUFlLEdBQUdzQyxjQUNsQix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL0dvVHJ1ZUNsaWVudC5qcz9lZDA5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmNvbnN0IEdvVHJ1ZUFkbWluQXBpXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Hb1RydWVBZG1pbkFwaVwiKSk7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2xpYi9jb25zdGFudHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2xpYi9lcnJvcnNcIik7XG5jb25zdCBmZXRjaF8xID0gcmVxdWlyZShcIi4vbGliL2ZldGNoXCIpO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4vbGliL2hlbHBlcnNcIik7XG5jb25zdCBsb2NhbF9zdG9yYWdlXzEgPSByZXF1aXJlKFwiLi9saWIvbG9jYWwtc3RvcmFnZVwiKTtcbmNvbnN0IGxvY2tzXzEgPSByZXF1aXJlKFwiLi9saWIvbG9ja3NcIik7XG5jb25zdCBwb2x5ZmlsbHNfMSA9IHJlcXVpcmUoXCIuL2xpYi9wb2x5ZmlsbHNcIik7XG5jb25zdCB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi9saWIvdmVyc2lvblwiKTtcbmNvbnN0IGJhc2U2NHVybF8xID0gcmVxdWlyZShcIi4vbGliL2Jhc2U2NHVybFwiKTtcbmNvbnN0IGV0aGVyZXVtXzEgPSByZXF1aXJlKFwiLi9saWIvd2ViMy9ldGhlcmV1bVwiKTtcbmNvbnN0IHdlYmF1dGhuXzEgPSByZXF1aXJlKFwiLi9saWIvd2ViYXV0aG5cIik7XG4oMCwgcG9seWZpbGxzXzEucG9seWZpbGxHbG9iYWxUaGlzKSgpOyAvLyBNYWtlIFwiZ2xvYmFsVGhpc1wiIGF2YWlsYWJsZVxuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIHVybDogY29uc3RhbnRzXzEuR09UUlVFX1VSTCxcbiAgICBzdG9yYWdlS2V5OiBjb25zdGFudHNfMS5TVE9SQUdFX0tFWSxcbiAgICBhdXRvUmVmcmVzaFRva2VuOiB0cnVlLFxuICAgIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICAgIGRldGVjdFNlc3Npb25JblVybDogdHJ1ZSxcbiAgICBoZWFkZXJzOiBjb25zdGFudHNfMS5ERUZBVUxUX0hFQURFUlMsXG4gICAgZmxvd1R5cGU6ICdpbXBsaWNpdCcsXG4gICAgZGVidWc6IGZhbHNlLFxuICAgIGhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI6IGZhbHNlLFxuICAgIHRocm93T25FcnJvcjogZmFsc2UsXG4gICAgbG9ja0FjcXVpcmVUaW1lb3V0OiAxMDAwMCwgLy8gMTAgc2Vjb25kc1xufTtcbmFzeW5jIGZ1bmN0aW9uIGxvY2tOb09wKG5hbWUsIGFjcXVpcmVUaW1lb3V0LCBmbikge1xuICAgIHJldHVybiBhd2FpdCBmbigpO1xufVxuLyoqXG4gKiBDYWNoZXMgSldLUyB2YWx1ZXMgZm9yIGFsbCBjbGllbnRzIGNyZWF0ZWQgaW4gdGhlIHNhbWUgZW52aXJvbm1lbnQuIFRoaXMgaXNcbiAqIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBzaGFyZWQtbWVtb3J5IGV4ZWN1dGlvbiBlbnZpcm9ubWVudHMgc3VjaCBhcyBWZXJjZWwnc1xuICogRmx1aWQgQ29tcHV0ZSwgQVdTIExhbWJkYSBvciBTdXBhYmFzZSdzIEVkZ2UgRnVuY3Rpb25zLiBSZWdhcmRsZXNzIG9mIGhvd1xuICogbWFueSBjbGllbnRzIGFyZSBjcmVhdGVkLCBpZiB0aGV5IHNoYXJlIHRoZSBzYW1lIHN0b3JhZ2Uga2V5IHRoZXkgd2lsbCB1c2VcbiAqIHRoZSBzYW1lIEpXS1MgY2FjaGUsIHNpZ25pZmljYW50bHkgc3BlZWRpbmcgdXAgZ2V0Q2xhaW1zKCkgd2l0aCBhc3ltbWV0cmljXG4gKiBKV1RzLlxuICovXG5jb25zdCBHTE9CQUxfSldLUyA9IHt9O1xuY2xhc3MgR29UcnVlQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgSldLUyB1c2VkIGZvciB2ZXJpZnlpbmcgYXN5bW1ldHJpYyBKV1RzXG4gICAgICovXG4gICAgZ2V0IGp3a3MoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuandrcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogeyBrZXlzOiBbXSB9O1xuICAgIH1cbiAgICBzZXQgandrcyh2YWx1ZSkge1xuICAgICAgICBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldKSwgeyBqd2tzOiB2YWx1ZSB9KTtcbiAgICB9XG4gICAgZ2V0IGp3a3NfY2FjaGVkX2F0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gR0xPQkFMX0pXS1NbdGhpcy5zdG9yYWdlS2V5XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhY2hlZEF0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICB9XG4gICAgc2V0IGp3a3NfY2FjaGVkX2F0KHZhbHVlKSB7XG4gICAgICAgIEdMT0JBTF9KV0tTW3RoaXMuc3RvcmFnZUtleV0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEdMT0JBTF9KV0tTW3RoaXMuc3RvcmFnZUtleV0pLCB7IGNhY2hlZEF0OiB2YWx1ZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCBmb3IgdXNlIGluIHRoZSBicm93c2VyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IEdvVHJ1ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICAgICAqXG4gICAgICogY29uc3QgYXV0aCA9IG5ldyBHb1RydWVDbGllbnQoe1xuICAgICAqICAgdXJsOiAnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvL2F1dGgvdjEnLFxuICAgICAqICAgaGVhZGVyczogeyBhcGlrZXk6ICdwdWJsaWMtYW5vbi1rZXknIH0sXG4gICAgICogICBzdG9yYWdlS2V5OiAnc3VwYWJhc2UtYXV0aCcsXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51c2VyU3RvcmFnZSA9IG51bGw7XG4gICAgICAgIHRoaXMubWVtb3J5U3RvcmFnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tlciA9IG51bGw7XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrVGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBhc3luYyBjbGllbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAqIFdoZW4gbnVsbCBvciBub3QgeWV0IHJlc29sdmVkIHRoZSBhdXRoIHN0YXRlIGlzIGB1bmtub3duYFxuICAgICAgICAgKiBPbmNlIHJlc29sdmVkIHRoZSBhdXRoIHN0YXRlIGlzIGtub3duIGFuZCBpdCdzIHNhZmUgdG8gY2FsbCBhbnkgZnVydGhlciBjbGllbnQgbWV0aG9kcy5cbiAgICAgICAgICogS2VlcCBleHRyYSBjYXJlIHRvIG5ldmVyIHJlamVjdCBvciB0aHJvdyB1bmNhdWdodCBlcnJvcnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGVjdFNlc3Npb25JblVybCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2NrQWNxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIGJyb2FkY2FzdCBzdGF0ZSBjaGFuZ2UgZXZlbnRzIHRvIG90aGVyIHRhYnMgbGlzdGVuaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBjb25zb2xlLmxvZztcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnN0b3JhZ2VLZXkgPSBzZXR0aW5ncy5zdG9yYWdlS2V5O1xuICAgICAgICB0aGlzLmluc3RhbmNlSUQgPSAoX2EgPSBHb1RydWVDbGllbnQubmV4dEluc3RhbmNlSURbdGhpcy5zdG9yYWdlS2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEW3RoaXMuc3RvcmFnZUtleV0gPSB0aGlzLmluc3RhbmNlSUQgKyAxO1xuICAgICAgICB0aGlzLmxvZ0RlYnVnTWVzc2FnZXMgPSAhIXNldHRpbmdzLmRlYnVnO1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmRlYnVnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IHNldHRpbmdzLmRlYnVnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlSUQgPiAwICYmICgwLCBoZWxwZXJzXzEuaXNCcm93c2VyKSgpKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7dGhpcy5fbG9nUHJlZml4KCl9IE11bHRpcGxlIEdvVHJ1ZUNsaWVudCBpbnN0YW5jZXMgZGV0ZWN0ZWQgaW4gdGhlIHNhbWUgYnJvd3NlciBjb250ZXh0LiBJdCBpcyBub3QgYW4gZXJyb3IsIGJ1dCB0aGlzIHNob3VsZCBiZSBhdm9pZGVkIGFzIGl0IG1heSBwcm9kdWNlIHVuZGVmaW5lZCBiZWhhdmlvciB3aGVuIHVzZWQgY29uY3VycmVudGx5IHVuZGVyIHRoZSBzYW1lIHN0b3JhZ2Uga2V5LmA7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2dEZWJ1Z01lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS50cmFjZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlcnNpc3RTZXNzaW9uID0gc2V0dGluZ3MucGVyc2lzdFNlc3Npb247XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUb2tlbiA9IHNldHRpbmdzLmF1dG9SZWZyZXNoVG9rZW47XG4gICAgICAgIHRoaXMuYWRtaW4gPSBuZXcgR29UcnVlQWRtaW5BcGlfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIHVybDogc2V0dGluZ3MudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogc2V0dGluZ3MuaGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoOiBzZXR0aW5ncy5mZXRjaCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXJsID0gc2V0dGluZ3MudXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBzZXR0aW5ncy5oZWFkZXJzO1xuICAgICAgICB0aGlzLmZldGNoID0gKDAsIGhlbHBlcnNfMS5yZXNvbHZlRmV0Y2gpKHNldHRpbmdzLmZldGNoKTtcbiAgICAgICAgdGhpcy5sb2NrID0gc2V0dGluZ3MubG9jayB8fCBsb2NrTm9PcDtcbiAgICAgICAgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgPSBzZXR0aW5ncy5kZXRlY3RTZXNzaW9uSW5Vcmw7XG4gICAgICAgIHRoaXMuZmxvd1R5cGUgPSBzZXR0aW5ncy5mbG93VHlwZTtcbiAgICAgICAgdGhpcy5oYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyID0gc2V0dGluZ3MuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcjtcbiAgICAgICAgdGhpcy50aHJvd09uRXJyb3IgPSBzZXR0aW5ncy50aHJvd09uRXJyb3I7XG4gICAgICAgIHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0ID0gc2V0dGluZ3MubG9ja0FjcXVpcmVUaW1lb3V0O1xuICAgICAgICBpZiAoc2V0dGluZ3MubG9jaykge1xuICAgICAgICAgICAgdGhpcy5sb2NrID0gc2V0dGluZ3MubG9jaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBlcnNpc3RTZXNzaW9uICYmICgwLCBoZWxwZXJzXzEuaXNCcm93c2VyKSgpICYmICgoX2IgPSBnbG9iYWxUaGlzID09PSBudWxsIHx8IGdsb2JhbFRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMubmF2aWdhdG9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubG9ja3MpKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2sgPSBsb2Nrc18xLm5hdmlnYXRvckxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvY2sgPSBsb2NrTm9PcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuandrcykge1xuICAgICAgICAgICAgdGhpcy5qd2tzID0geyBrZXlzOiBbXSB9O1xuICAgICAgICAgICAgdGhpcy5qd2tzX2NhY2hlZF9hdCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWZhID0ge1xuICAgICAgICAgICAgdmVyaWZ5OiB0aGlzLl92ZXJpZnkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGVucm9sbDogdGhpcy5fZW5yb2xsLmJpbmQodGhpcyksXG4gICAgICAgICAgICB1bmVucm9sbDogdGhpcy5fdW5lbnJvbGwuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNoYWxsZW5nZTogdGhpcy5fY2hhbGxlbmdlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBsaXN0RmFjdG9yczogdGhpcy5fbGlzdEZhY3RvcnMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNoYWxsZW5nZUFuZFZlcmlmeTogdGhpcy5fY2hhbGxlbmdlQW5kVmVyaWZ5LmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWw6IHRoaXMuX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgd2ViYXV0aG46IG5ldyB3ZWJhdXRobl8xLldlYkF1dGhuQXBpKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9hdXRoID0ge1xuICAgICAgICAgICAgZ2V0QXV0aG9yaXphdGlvbkRldGFpbHM6IHRoaXMuX2dldEF1dGhvcml6YXRpb25EZXRhaWxzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBhcHByb3ZlQXV0aG9yaXphdGlvbjogdGhpcy5fYXBwcm92ZUF1dGhvcml6YXRpb24uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRlbnlBdXRob3JpemF0aW9uOiB0aGlzLl9kZW55QXV0aG9yaXphdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgbGlzdEdyYW50czogdGhpcy5fbGlzdE9BdXRoR3JhbnRzLmJpbmQodGhpcyksXG4gICAgICAgICAgICByZXZva2VHcmFudDogdGhpcy5fcmV2b2tlT0F1dGhHcmFudC5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wZXJzaXN0U2Vzc2lvbikge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzZXR0aW5ncy5zdG9yYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuc3VwcG9ydHNMb2NhbFN0b3JhZ2UpKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlID0gZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbW9yeVN0b3JhZ2UgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlID0gKDAsIGxvY2FsX3N0b3JhZ2VfMS5tZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKSh0aGlzLm1lbW9yeVN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy51c2VyU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlclN0b3JhZ2UgPSBzZXR0aW5ncy51c2VyU3RvcmFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVtb3J5U3RvcmFnZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID0gKDAsIGxvY2FsX3N0b3JhZ2VfMS5tZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKSh0aGlzLm1lbW9yeVN0b3JhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzQnJvd3NlcikoKSAmJiBnbG9iYWxUaGlzLkJyb2FkY2FzdENoYW5uZWwgJiYgdGhpcy5wZXJzaXN0U2Vzc2lvbiAmJiB0aGlzLnN0b3JhZ2VLZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbmV3IGdsb2JhbFRoaXMuQnJvYWRjYXN0Q2hhbm5lbCh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGEgbmV3IEJyb2FkY2FzdENoYW5uZWwsIG11bHRpLXRhYiBzdGF0ZSBjaGFuZ2VzIHdpbGwgbm90IGJlIGF2YWlsYWJsZScsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9jID0gdGhpcy5icm9hZGNhc3RDaGFubmVsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdyZWNlaXZlZCBicm9hZGNhc3Qgbm90aWZpY2F0aW9uIGZyb20gb3RoZXIgdGFiIG9yIGNsaWVudCcsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycyhldmVudC5kYXRhLmV2ZW50LCBldmVudC5kYXRhLnNlc3Npb24sIGZhbHNlKTsgLy8gYnJvYWRjYXN0ID0gZmFsc2Ugc28gd2UgZG9uJ3QgZ2V0IGFuIGVuZGxlc3MgbG9vcCBvZiBtZXNzYWdlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBlcnJvciB0aHJvd2luZyBtb2RlIGlzIGVuYWJsZWQgZm9yIHRoaXMgY2xpZW50LlxuICAgICAqL1xuICAgIGlzVGhyb3dPbkVycm9yRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhyb3dPbkVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDZW50cmFsaXplcyByZXR1cm4gaGFuZGxpbmcgd2l0aCBvcHRpb25hbCBlcnJvciB0aHJvd2luZy4gV2hlbiBgdGhyb3dPbkVycm9yYCBpcyBlbmFibGVkXG4gICAgICogYW5kIHRoZSBwcm92aWRlZCByZXN1bHQgY29udGFpbnMgYSBub24tbnVsbGlzaCBlcnJvciwgdGhlIGVycm9yIGlzIHRocm93biBpbnN0ZWFkIG9mXG4gICAgICogYmVpbmcgcmV0dXJuZWQuIFRoaXMgZW5zdXJlcyBjb25zaXN0ZW50IGJlaGF2aW9yIGFjcm9zcyBhbGwgcHVibGljIEFQSSBtZXRob2RzLlxuICAgICAqL1xuICAgIF9yZXR1cm5SZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLnRocm93T25FcnJvciAmJiByZXN1bHQgJiYgcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX2xvZ1ByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuICgnR29UcnVlQ2xpZW50QCcgK1xuICAgICAgICAgICAgYCR7dGhpcy5zdG9yYWdlS2V5fToke3RoaXMuaW5zdGFuY2VJRH0gKCR7dmVyc2lvbl8xLnZlcnNpb259KSAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgX2RlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMubG9nRGVidWdNZXNzYWdlcykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIodGhpcy5fbG9nUHJlZml4KCksIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY2xpZW50IHNlc3Npb24gZWl0aGVyIGZyb20gdGhlIHVybCBvciBmcm9tIHN0b3JhZ2UuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBjbGllbnQsIGJ1dCBzaG91bGQgYWxzbyBiZSBjYWxsZWRcbiAgICAgKiBtYW51YWxseSB3aGVuIGNoZWNraW5nIGZvciBhbiBlcnJvciBmcm9tIGFuIGF1dGggcmVkaXJlY3QgKG9hdXRoLCBtYWdpY2xpbmssIHBhc3N3b3JkIHJlY292ZXJ5LCBldGMpLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElNUE9SVEFOVDpcbiAgICAgKiAxLiBOZXZlciB0aHJvdyBpbiB0aGlzIG1ldGhvZCwgYXMgaXQgaXMgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgICogMi4gTmV2ZXIgcmV0dXJuIGEgc2Vzc2lvbiBmcm9tIHRoaXMgbWV0aG9kIGFzIGl0IHdvdWxkIGJlIGNhY2hlZCBvdmVyXG4gICAgICogICAgdGhlIHdob2xlIGxpZmV0aW1lIG9mIHRoZSBjbGllbnRcbiAgICAgKi9cbiAgICBhc3luYyBfaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgbGV0IGNhbGxiYWNrVXJsVHlwZSA9ICdub25lJztcbiAgICAgICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzQnJvd3NlcikoKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9ICgwLCBoZWxwZXJzXzEucGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCkod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0ltcGxpY2l0R3JhbnRDYWxsYmFjayhwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrVXJsVHlwZSA9ICdpbXBsaWNpdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF3YWl0IHRoaXMuX2lzUEtDRUNhbGxiYWNrKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tVcmxUeXBlID0gJ3BrY2UnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXR0ZW1wdCB0byBnZXQgdGhlIHNlc3Npb24gZnJvbSB0aGUgVVJMIG9ubHkgaWYgdGhlc2UgY29uZGl0aW9ucyBhcmUgZnVsZmlsbGVkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZTogSWYgdGhlIFVSTCBpc24ndCBvbmUgb2YgdGhlIGNhbGxiYWNrIHVybCB0eXBlcyAoaW1wbGljaXQgb3IgcGtjZSksXG4gICAgICAgICAgICAgKiB0aGVuIHRoZXJlIGNvdWxkIGJlIGFuIGV4aXN0aW5nIHNlc3Npb24gc28gd2UgZG9uJ3Qgd2FudCB0byBwcmVtYXR1cmVseSByZW1vdmUgaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNCcm93c2VyKSgpICYmIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsICYmIGNhbGxiYWNrVXJsVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0U2Vzc2lvbkZyb21VUkwocGFyYW1zLCBjYWxsYmFja1VybFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZXJyb3IgZGV0ZWN0aW5nIHNlc3Npb24gZnJvbSBVUkwnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gKF9hID0gZXJyb3IuZGV0YWlscykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDb2RlID09PSAnaWRlbnRpdHlfYWxyZWFkeV9leGlzdHMnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID09PSAnaWRlbnRpdHlfbm90X2ZvdW5kJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ3NpbmdsZV9pZGVudGl0eV9ub3RfZGVsZXRhYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmVtb3ZlIGV4aXN0aW5nIHNlc3Npb24gb24gVVJMIGxvZ2luIGZhaWx1cmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgZmFpbGVkIGF0dGVtcHQgKGUuZy4gcmV1c2VkIG1hZ2ljIGxpbmspIHNob3VsZG4ndCBpbnZhbGlkYXRlIGEgdmFsaWQgc2Vzc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZXNzaW9uLCByZWRpcmVjdFR5cGUgfSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfaW5pdGlhbGl6ZSgpJywgJ2RldGVjdGVkIHNlc3Npb24gaW4gVVJMJywgc2Vzc2lvbiwgJ3JlZGlyZWN0IHR5cGUnLCByZWRpcmVjdFR5cGUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVkaXJlY3RUeXBlID09PSAncmVjb3ZlcnknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnUEFTU1dPUkRfUkVDT1ZFUlknLCBzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBubyBsb2dpbiBhdHRlbXB0IHZpYSBjYWxsYmFjayB1cmwgdHJ5IHRvIHJlY292ZXIgc2Vzc2lvbiBmcm9tIHN0b3JhZ2VcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlY292ZXJBbmRSZWZyZXNoKCk7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBlcnJvcnNfMS5BdXRoVW5rbm93bkVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGR1cmluZyBpbml0aWFsaXphdGlvbicsIGVycm9yKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5faGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfaW5pdGlhbGl6ZSgpJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYW5vbnltb3VzIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHNlc3Npb24gd2hlcmUgdGhlIGlzX2Fub255bW91cyBjbGFpbSBpbiB0aGUgYWNjZXNzIHRva2VuIEpXVCBzZXQgdG8gdHJ1ZVxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbkFub255bW91c2x5KGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2IgPSAoX2EgPSBjcmVkZW50aWFscyA9PT0gbnVsbCB8fCBjcmVkZW50aWFscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9LFxuICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiAoX2MgPSBjcmVkZW50aWFscyA9PT0gbnVsbCB8fCBjcmVkZW50aWFscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IGZldGNoXzEuX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgaWYgKGVycm9yIHx8ICFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gZGF0YS5zZXNzaW9uO1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IGRhdGEudXNlcjtcbiAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgICAqXG4gICAgICogQmUgYXdhcmUgdGhhdCBpZiBhIHVzZXIgYWNjb3VudCBleGlzdHMgaW4gdGhlIHN5c3RlbSB5b3UgbWF5IGdldCBiYWNrIGFuXG4gICAgICogZXJyb3IgbWVzc2FnZSB0aGF0IGF0dGVtcHRzIHRvIGhpZGUgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyLlxuICAgICAqIFRoaXMgbWV0aG9kIGhhcyBzdXBwb3J0IGZvciBQS0NFIHZpYSBlbWFpbCBzaWdudXBzLiBUaGUgUEtDRSBmbG93IGNhbm5vdCBiZSB1c2VkIHdoZW4gYXV0b2NvbmZpcm0gaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbG9nZ2VkLWluIHNlc3Npb24gaWYgdGhlIHNlcnZlciBoYXMgXCJhdXRvY29uZmlybVwiIE9OXG4gICAgICogQHJldHVybnMgQSB1c2VyIGlmIHRoZSBzZXJ2ZXIgaGFzIFwiYXV0b2NvbmZpcm1cIiBPRkZcbiAgICAgKi9cbiAgICBhc3luYyBzaWduVXAoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgKDAsIGhlbHBlcnNfMS5nZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKSh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogZmV0Y2hfMS5fc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc2lnbnVwYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2hhbm5lbCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJ3NtcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBmZXRjaF8xLl9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICAgICAgICAgIGF3YWl0ICgwLCBoZWxwZXJzXzEucmVtb3ZlSXRlbUFzeW5jKSh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGRhdGEuc2Vzc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXdhaXQgKDAsIGhlbHBlcnNfMS5yZW1vdmVJdGVtQXN5bmMpKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgd2l0aCBhbiBlbWFpbCBhbmQgcGFzc3dvcmQgb3IgcGhvbmUgYW5kIHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQmUgYXdhcmUgdGhhdCB5b3UgbWF5IGdldCBiYWNrIGFuIGVycm9yIG1lc3NhZ2UgdGhhdCB3aWxsIG5vdCBkaXN0aW5ndWlzaFxuICAgICAqIGJldHdlZW4gdGhlIGNhc2VzIHdoZXJlIHRoZSBhY2NvdW50IGRvZXMgbm90IGV4aXN0IG9yIHRoYXQgdGhlXG4gICAgICogZW1haWwvcGhvbmUgYW5kIHBhc3N3b3JkIGNvbWJpbmF0aW9uIGlzIHdyb25nIG9yIHRoYXQgdGhlIGFjY291bnQgY2FuIG9ubHlcbiAgICAgKiBiZSBhY2Nlc3NlZCB2aWEgc29jaWFsIGxvZ2luLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbldpdGhQYXNzd29yZChjcmVkZW50aWFscykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlcztcbiAgICAgICAgICAgIGlmICgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbWFpbCwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXBhc3N3b3JkYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBmZXRjaF8xLl9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBob25lLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgcmVzID0gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IGZldGNoXzEuX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcignWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyIGFuZCBhIHBhc3N3b3JkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXM7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZFRva2VuRXJyb3IgPSBuZXcgZXJyb3JzXzEuQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBpbnZhbGlkVG9rZW5FcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHVzZXI6IGRhdGEudXNlciwgc2Vzc2lvbjogZGF0YS5zZXNzaW9uIH0sIChkYXRhLndlYWtfcGFzc3dvcmQgPyB7IHdlYWtQYXNzd29yZDogZGF0YS53ZWFrX3Bhc3N3b3JkIH0gOiBudWxsKSksXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYW4gZXhpc3RpbmcgdXNlciB2aWEgYSB0aGlyZC1wYXJ0eSBwcm92aWRlci5cbiAgICAgKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgUEtDRSBmbG93LlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbldpdGhPQXV0aChjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9oYW5kbGVQcm92aWRlclNpZ25JbihjcmVkZW50aWFscy5wcm92aWRlciwge1xuICAgICAgICAgICAgcmVkaXJlY3RUbzogKF9hID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICBzY29wZXM6IChfYiA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zY29wZXMsXG4gICAgICAgICAgICBxdWVyeVBhcmFtczogKF9jID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgc2tpcEJyb3dzZXJSZWRpcmVjdDogKF9kID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnNraXBCcm93c2VyUmVkaXJlY3QsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYW4gZXhpc3RpbmcgdXNlciBieSBleGNoYW5naW5nIGFuIEF1dGggQ29kZSBpc3N1ZWQgZHVyaW5nIHRoZSBQS0NFIGZsb3cuXG4gICAgICovXG4gICAgYXN5bmMgZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZSkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIGluIGEgdXNlciBieSB2ZXJpZnlpbmcgYSBtZXNzYWdlIHNpZ25lZCBieSB0aGUgdXNlcidzIHByaXZhdGUga2V5LlxuICAgICAqIFN1cHBvcnRzIEV0aGVyZXVtICh2aWEgU2lnbi1Jbi1XaXRoLUV0aGVyZXVtKSAmIFNvbGFuYSAoU2lnbi1Jbi1XaXRoLVNvbGFuYSkgc3RhbmRhcmRzLFxuICAgICAqIGJvdGggb2Ygd2hpY2ggZGVyaXZlIGZyb20gdGhlIEVJUC00MzYxIHN0YW5kYXJkXG4gICAgICogV2l0aCBzbGlnaHQgdmFyaWF0aW9uIG9uIFNvbGFuYSdzIHNpZGUuXG4gICAgICogQHJlZmVyZW5jZSBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTQzNjFcbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoV2ViMyhjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCB7IGNoYWluIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgc3dpdGNoIChjaGFpbikge1xuICAgICAgICAgICAgY2FzZSAnZXRoZXJldW0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNpZ25JbldpdGhFdGhlcmV1bShjcmVkZW50aWFscyk7XG4gICAgICAgICAgICBjYXNlICdzb2xhbmEnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNpZ25JbldpdGhTb2xhbmEoY3JlZGVudGlhbHMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBVbnN1cHBvcnRlZCBjaGFpbiBcIiR7Y2hhaW59XCJgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzaWduSW5XaXRoRXRoZXJldW0oY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbDtcbiAgICAgICAgLy8gVE9ETzogZmxhdHRlbiB0eXBlXG4gICAgICAgIGxldCBtZXNzYWdlO1xuICAgICAgICBsZXQgc2lnbmF0dXJlO1xuICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gY3JlZGVudGlhbHMubWVzc2FnZTtcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IGNyZWRlbnRpYWxzLnNpZ25hdHVyZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW4sIHdhbGxldCwgc3RhdGVtZW50LCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgIGxldCByZXNvbHZlZFdhbGxldDtcbiAgICAgICAgICAgIGlmICghKDAsIGhlbHBlcnNfMS5pc0Jyb3dzZXIpKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdhbGxldCAhPT0gJ29iamVjdCcgfHwgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudXJsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBCb3RoIHdhbGxldCBhbmQgdXJsIG11c3QgYmUgc3BlY2lmaWVkIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2FsbGV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkV2FsbGV0ID0gd2FsbGV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2luZG93QW55ID0gd2luZG93O1xuICAgICAgICAgICAgICAgIGlmICgnZXRoZXJldW0nIGluIHdpbmRvd0FueSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygd2luZG93QW55LmV0aGVyZXVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAncmVxdWVzdCcgaW4gd2luZG93QW55LmV0aGVyZXVtICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dBbnkuZXRoZXJldW0ucmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFdhbGxldCA9IHdpbmRvd0FueS5ldGhlcmV1bTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IE5vIGNvbXBhdGlibGUgRXRoZXJldW0gd2FsbGV0IGludGVyZmFjZSBvbiB0aGUgd2luZG93IG9iamVjdCAod2luZG93LmV0aGVyZXVtKSBkZXRlY3RlZC4gTWFrZSBzdXJlIHRoZSB1c2VyIGFscmVhZHkgaGFzIGEgd2FsbGV0IGluc3RhbGxlZCBhbmQgY29ubmVjdGVkIGZvciB0aGlzIGFwcC4gUHJlZmVyIHBhc3NpbmcgdGhlIHdhbGxldCBpbnRlcmZhY2Ugb2JqZWN0IGRpcmVjdGx5IHRvIHNpZ25JbldpdGhXZWIzKHsgY2hhaW46ICdldGhlcmV1bScsIHdhbGxldDogcmVzb2x2ZWRVc2VyV2FsbGV0IH0pIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHJlc29sdmVkV2FsbGV0XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9yZXF1ZXN0QWNjb3VudHMnLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoYWNjcykgPT4gYWNjcylcbiAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IFdhbGxldCBtZXRob2QgZXRoX3JlcXVlc3RBY2NvdW50cyBpcyBtaXNzaW5nIG9yIGludmFsaWRgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFhY2NvdW50cyB8fCBhY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBObyBhY2NvdW50cyBhdmFpbGFibGUuIFBsZWFzZSBlbnN1cmUgdGhlIHdhbGxldCBpcyBjb25uZWN0ZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gKDAsIGV0aGVyZXVtXzEuZ2V0QWRkcmVzcykoYWNjb3VudHNbMF0pO1xuICAgICAgICAgICAgbGV0IGNoYWluSWQgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aEV0aGVyZXVtKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hhaW5JZDtcbiAgICAgICAgICAgIGlmICghY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluSWRIZXggPSBhd2FpdCByZXNvbHZlZFdhbGxldC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2NoYWluSWQnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSAoMCwgZXRoZXJldW1fMS5mcm9tSGV4KShjaGFpbklkSGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpd2VNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGRvbWFpbjogdXJsLmhvc3QsXG4gICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnQ6IHN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICB1cmk6IHVybC5ocmVmLFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICcxJyxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkLFxuICAgICAgICAgICAgICAgIG5vbmNlOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aEV0aGVyZXVtKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mubm9uY2UsXG4gICAgICAgICAgICAgICAgaXNzdWVkQXQ6IChfZSA9IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoRXRoZXJldW0pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5pc3N1ZWRBdCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBleHBpcmF0aW9uVGltZTogKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICAgICAgIG5vdEJlZm9yZTogKF9nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLm5vdEJlZm9yZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IChfaCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoRXRoZXJldW0pID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VzOiAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aEV0aGVyZXVtKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2oucmVzb3VyY2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAoMCwgZXRoZXJldW1fMS5jcmVhdGVTaXdlTWVzc2FnZSkoc2l3ZU1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gU2lnbiBtZXNzYWdlXG4gICAgICAgICAgICBzaWduYXR1cmUgPSAoYXdhaXQgcmVzb2x2ZWRXYWxsZXQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAncGVyc29uYWxfc2lnbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbKDAsIGV0aGVyZXVtXzEudG9IZXgpKG1lc3NhZ2UpLCBhZGRyZXNzXSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9d2ViM2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbih7IGNoYWluOiAnZXRoZXJldW0nLCBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgfSwgKCgoX2sgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2suY2FwdGNoYVRva2VuKVxuICAgICAgICAgICAgICAgICAgICA/IHsgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9sID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKSksXG4gICAgICAgICAgICAgICAgeGZvcm06IGZldGNoXzEuX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZFRva2VuRXJyb3IgPSBuZXcgZXJyb3JzXzEuQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBpbnZhbGlkVG9rZW5FcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzaWduSW5XaXRoU29sYW5hKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tO1xuICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgbGV0IHNpZ25hdHVyZTtcbiAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGNyZWRlbnRpYWxzLm1lc3NhZ2U7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSBjcmVkZW50aWFscy5zaWduYXR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGNoYWluLCB3YWxsZXQsIHN0YXRlbWVudCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRXYWxsZXQ7XG4gICAgICAgICAgICBpZiAoISgwLCBoZWxwZXJzXzEuaXNCcm93c2VyKSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3YWxsZXQgIT09ICdvYmplY3QnIHx8ICEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogQm90aCB3YWxsZXQgYW5kIHVybCBtdXN0IGJlIHNwZWNpZmllZCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmVkV2FsbGV0ID0gd2FsbGV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdhbGxldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFdhbGxldCA9IHdhbGxldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpbmRvd0FueSA9IHdpbmRvdztcbiAgICAgICAgICAgICAgICBpZiAoJ3NvbGFuYScgaW4gd2luZG93QW55ICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dBbnkuc29sYW5hID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAoKCdzaWduSW4nIGluIHdpbmRvd0FueS5zb2xhbmEgJiYgdHlwZW9mIHdpbmRvd0FueS5zb2xhbmEuc2lnbkluID09PSAnZnVuY3Rpb24nKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCdzaWduTWVzc2FnZScgaW4gd2luZG93QW55LnNvbGFuYSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dBbnkuc29sYW5hLnNpZ25NZXNzYWdlID09PSAnZnVuY3Rpb24nKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3aW5kb3dBbnkuc29sYW5hO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogTm8gY29tcGF0aWJsZSBTb2xhbmEgd2FsbGV0IGludGVyZmFjZSBvbiB0aGUgd2luZG93IG9iamVjdCAod2luZG93LnNvbGFuYSkgZGV0ZWN0ZWQuIE1ha2Ugc3VyZSB0aGUgdXNlciBhbHJlYWR5IGhhcyBhIHdhbGxldCBpbnN0YWxsZWQgYW5kIGNvbm5lY3RlZCBmb3IgdGhpcyBhcHAuIFByZWZlciBwYXNzaW5nIHRoZSB3YWxsZXQgaW50ZXJmYWNlIG9iamVjdCBkaXJlY3RseSB0byBzaWduSW5XaXRoV2ViMyh7IGNoYWluOiAnc29sYW5hJywgd2FsbGV0OiByZXNvbHZlZFVzZXJXYWxsZXQgfSkgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIGlmICgnc2lnbkluJyBpbiByZXNvbHZlZFdhbGxldCAmJiByZXNvbHZlZFdhbGxldC5zaWduSW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCByZXNvbHZlZFdhbGxldC5zaWduSW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBpc3N1ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSwgeyBcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9uLW92ZXJyaWRhYmxlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogJzEnLCBkb21haW46IHVybC5ob3N0LCB1cmk6IHVybC5ocmVmIH0pLCAoc3RhdGVtZW50ID8geyBzdGF0ZW1lbnQgfSA6IG51bGwpKSk7XG4gICAgICAgICAgICAgICAgbGV0IG91dHB1dFRvUHJvY2VzcztcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdXRwdXQpICYmIG91dHB1dFswXSAmJiB0eXBlb2Ygb3V0cHV0WzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRUb1Byb2Nlc3MgPSBvdXRwdXRbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG91dHB1dCAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3V0cHV0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAnc2lnbmVkTWVzc2FnZScgaW4gb3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICdzaWduYXR1cmUnIGluIG91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRUb1Byb2Nlc3MgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBXYWxsZXQgbWV0aG9kIHNpZ25JbigpIHJldHVybmVkIHVucmVjb2duaXplZCB2YWx1ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ3NpZ25lZE1lc3NhZ2UnIGluIG91dHB1dFRvUHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgICAgICAnc2lnbmF0dXJlJyBpbiBvdXRwdXRUb1Byb2Nlc3MgJiZcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBvdXRwdXRUb1Byb2Nlc3Muc2lnbmVkTWVzc2FnZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFRvUHJvY2Vzcy5zaWduZWRNZXNzYWdlIGluc3RhbmNlb2YgVWludDhBcnJheSkgJiZcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0VG9Qcm9jZXNzLnNpZ25hdHVyZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3V0cHV0VG9Qcm9jZXNzLnNpZ25lZE1lc3NhZ2UgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBvdXRwdXRUb1Byb2Nlc3Muc2lnbmVkTWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG91dHB1dFRvUHJvY2Vzcy5zaWduZWRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gb3V0cHV0VG9Qcm9jZXNzLnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQHN1cGFiYXNlL2F1dGgtanM6IFdhbGxldCBtZXRob2Qgc2lnbkluKCkgQVBJIHJldHVybmVkIG9iamVjdCB3aXRob3V0IHNpZ25lZE1lc3NhZ2UgYW5kIHNpZ25hdHVyZSBmaWVsZHMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoISgnc2lnbk1lc3NhZ2UnIGluIHJlc29sdmVkV2FsbGV0KSB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVzb2x2ZWRXYWxsZXQuc2lnbk1lc3NhZ2UgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgICAgICAgISgncHVibGljS2V5JyBpbiByZXNvbHZlZFdhbGxldCkgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlc29sdmVkV2FsbGV0ICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAhcmVzb2x2ZWRXYWxsZXQucHVibGljS2V5IHx8XG4gICAgICAgICAgICAgICAgICAgICEoJ3RvQmFzZTU4JyBpbiByZXNvbHZlZFdhbGxldC5wdWJsaWNLZXkpIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXNvbHZlZFdhbGxldC5wdWJsaWNLZXkudG9CYXNlNTggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IGRvZXMgbm90IGhhdmUgYSBjb21wYXRpYmxlIHNpZ25NZXNzYWdlKCkgYW5kIHB1YmxpY0tleS50b0Jhc2U1OCgpIEFQSScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gW1xuICAgICAgICAgICAgICAgICAgICBgJHt1cmwuaG9zdH0gd2FudHMgeW91IHRvIHNpZ24gaW4gd2l0aCB5b3VyIFNvbGFuYSBhY2NvdW50OmAsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkV2FsbGV0LnB1YmxpY0tleS50b0Jhc2U1OCgpLFxuICAgICAgICAgICAgICAgICAgICAuLi4oc3RhdGVtZW50ID8gWycnLCBzdGF0ZW1lbnQsICcnXSA6IFsnJ10pLFxuICAgICAgICAgICAgICAgICAgICAnVmVyc2lvbjogMScsXG4gICAgICAgICAgICAgICAgICAgIGBVUkk6ICR7dXJsLmhyZWZ9YCxcbiAgICAgICAgICAgICAgICAgICAgYElzc3VlZCBBdDogJHsoX2MgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlzc3VlZEF0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YCxcbiAgICAgICAgICAgICAgICAgICAgLi4uKCgoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm5vdEJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW2BOb3QgQmVmb3JlOiAke29wdGlvbnMuc2lnbkluV2l0aFNvbGFuYS5ub3RCZWZvcmV9YF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAuLi4oKChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuZXhwaXJhdGlvblRpbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtgRXhwaXJhdGlvbiBUaW1lOiAke29wdGlvbnMuc2lnbkluV2l0aFNvbGFuYS5leHBpcmF0aW9uVGltZX1gXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLigoKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jaGFpbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbYENoYWluIElEOiAke29wdGlvbnMuc2lnbkluV2l0aFNvbGFuYS5jaGFpbklkfWBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKCgoX2cgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLm5vbmNlKSA/IFtgTm9uY2U6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLm5vbmNlfWBdIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAuLi4oKChfaCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2gucmVxdWVzdElkKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbYFJlcXVlc3QgSUQ6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLnJlcXVlc3RJZH1gXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLigoKF9rID0gKF9qID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5yZXNvdXJjZXMpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUmVzb3VyY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLnNpZ25JbldpdGhTb2xhbmEucmVzb3VyY2VzLm1hcCgocmVzb3VyY2UpID0+IGAtICR7cmVzb3VyY2V9YCksXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlU2lnbmF0dXJlID0gYXdhaXQgcmVzb2x2ZWRXYWxsZXQuc2lnbk1lc3NhZ2UobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKG1lc3NhZ2UpLCAndXRmOCcpO1xuICAgICAgICAgICAgICAgIGlmICghbWF5YmVTaWduYXR1cmUgfHwgIShtYXliZVNpZ25hdHVyZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQHN1cGFiYXNlL2F1dGgtanM6IFdhbGxldCBzaWduTWVzc2FnZSgpIEFQSSByZXR1cm5lZCBhbiByZWNvZ25pemVkIHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZSA9IG1heWJlU2lnbmF0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT13ZWIzYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBPYmplY3QuYXNzaWduKHsgY2hhaW46ICdzb2xhbmEnLCBtZXNzYWdlLCBzaWduYXR1cmU6ICgwLCBiYXNlNjR1cmxfMS5ieXRlc1RvQmFzZTY0VVJMKShzaWduYXR1cmUpIH0sICgoKF9sID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLmNhcHRjaGFUb2tlbilcbiAgICAgICAgICAgICAgICAgICAgPyB7IGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IChfbSA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbS5jYXB0Y2hhVG9rZW4gfSB9XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCkpLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBmZXRjaF8xLl9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb2tlbkVycm9yID0gbmV3IGVycm9yc18xLkF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUl0ZW0gPSBhd2FpdCAoMCwgaGVscGVyc18xLmdldEl0ZW1Bc3luYykodGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgY29uc3QgW2NvZGVWZXJpZmllciwgcmVkaXJlY3RUeXBlXSA9IChzdG9yYWdlSXRlbSAhPT0gbnVsbCAmJiBzdG9yYWdlSXRlbSAhPT0gdm9pZCAwID8gc3RvcmFnZUl0ZW0gOiAnJykuc3BsaXQoJy8nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghY29kZVZlcmlmaWVyICYmIHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGtjZWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBhdXRoX2NvZGU6IGF1dGhDb2RlLFxuICAgICAgICAgICAgICAgICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogZmV0Y2hfMS5fc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCAoMCwgaGVscGVyc18xLnJlbW92ZUl0ZW1Bc3luYykodGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb2tlbkVycm9yID0gbmV3IGVycm9yc18xLkF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgcmVkaXJlY3RUeXBlOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBpbnZhbGlkVG9rZW5FcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IHJlZGlyZWN0VHlwZTogcmVkaXJlY3RUeXBlICE9PSBudWxsICYmIHJlZGlyZWN0VHlwZSAhPT0gdm9pZCAwID8gcmVkaXJlY3RUeXBlIDogbnVsbCB9KSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCAoMCwgaGVscGVyc18xLnJlbW92ZUl0ZW1Bc3luYykodGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyBzaWduaW5nIGluIHdpdGggYW4gT0lEQyBJRCB0b2tlbi4gVGhlIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHVzZWRcbiAgICAgKiBzaG91bGQgYmUgZW5hYmxlZCBhbmQgY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoSWRUb2tlbihjcmVkZW50aWFscykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zLCBwcm92aWRlciwgdG9rZW4sIGFjY2Vzc190b2tlbiwgbm9uY2UgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9aWRfdG9rZW5gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgIGlkX3Rva2VuOiB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IGZldGNoXzEuX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb2tlbkVycm9yID0gbmV3IGVycm9yc18xLkF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhLCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIG1hZ2ljbGluayBvciBhIG9uZS10aW1lIHBhc3N3b3JkIChPVFApLlxuICAgICAqXG4gICAgICogSWYgdGhlIGB7eyAuQ29uZmlybWF0aW9uVVJMIH19YCB2YXJpYWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGVtYWlsIHRlbXBsYXRlLCBhIG1hZ2ljbGluayB3aWxsIGJlIHNlbnQuXG4gICAgICogSWYgdGhlIGB7eyAuVG9rZW4gfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGFuIE9UUCB3aWxsIGJlIHNlbnQuXG4gICAgICogSWYgeW91J3JlIHVzaW5nIHBob25lIHNpZ24taW5zLCBvbmx5IGFuIE9UUCB3aWxsIGJlIHNlbnQuIFlvdSB3b24ndCBiZSBhYmxlIHRvIHNlbmQgYSBtYWdpY2xpbmsgZm9yIHBob25lIHNpZ24taW5zLlxuICAgICAqXG4gICAgICogQmUgYXdhcmUgdGhhdCB5b3UgbWF5IGdldCBiYWNrIGFuIGVycm9yIG1lc3NhZ2UgdGhhdCB3aWxsIG5vdCBkaXN0aW5ndWlzaFxuICAgICAqIGJldHdlZW4gdGhlIGNhc2VzIHdoZXJlIHRoZSBhY2NvdW50IGRvZXMgbm90IGV4aXN0IG9yLCB0aGF0IHRoZSBhY2NvdW50XG4gICAgICogY2FuIG9ubHkgYmUgYWNjZXNzZWQgdmlhIHNvY2lhbCBsb2dpbi5cbiAgICAgKlxuICAgICAqIERvIG5vdGUgdGhhdCB5b3Ugd2lsbCBuZWVkIHRvIGNvbmZpZ3VyZSBhIFdoYXRzYXBwIHNlbmRlciBvbiBUd2lsaW9cbiAgICAgKiBpZiB5b3UgYXJlIHVzaW5nIHBob25lIHNpZ24gaW4gd2l0aCB0aGUgJ3doYXRzYXBwJyBjaGFubmVsLiBUaGUgd2hhdHNhcHBcbiAgICAgKiBjaGFubmVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gb3RoZXIgcHJvdmlkZXJzXG4gICAgICogYXQgdGhpcyB0aW1lLlxuICAgICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIFBLQ0Ugd2hlbiBhbiBlbWFpbCBpcyBwYXNzZWQuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aE90cChjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCAoMCwgaGVscGVyc18xLmdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QpKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L290cGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZV91c2VyOiAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2hvdWxkQ3JlYXRlVXNlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vdHBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdXNlcjogKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNob3VsZENyZWF0ZVVzZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiAoX2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2hhbm5lbCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJ3NtcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgbWVzc2FnZUlkOiBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWVzc2FnZV9pZCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGF3YWl0ICgwLCBoZWxwZXJzXzEucmVtb3ZlSXRlbUFzeW5jKSh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgaWYgKCgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgZ2l2ZW4gYSBVc2VyIHN1cHBsaWVkIE9UUCBvciBUb2tlbkhhc2ggcmVjZWl2ZWQgdGhyb3VnaCBtb2JpbGUgb3IgZW1haWwuXG4gICAgICovXG4gICAgYXN5bmMgdmVyaWZ5T3RwKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlZGlyZWN0VG8gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgY2FwdGNoYVRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCdvcHRpb25zJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvID0gKF9hID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvO1xuICAgICAgICAgICAgICAgIGNhcHRjaGFUb2tlbiA9IChfYiA9IHBhcmFtcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FwdGNoYVRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3ZlcmlmeWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IGNhcHRjaGFUb2tlbiB9IH0pLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgeGZvcm06IGZldGNoXzEuX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlblZlcmlmaWNhdGlvbkVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCBvbiB0b2tlbiB2ZXJpZmljYXRpb24uJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgdG9rZW5WZXJpZmljYXRpb25FcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24gPT09IG51bGwgfHwgc2Vzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycyhwYXJhbXMudHlwZSA9PSAncmVjb3ZlcnknID8gJ1BBU1NXT1JEX1JFQ09WRVJZJyA6ICdTSUdORURfSU4nLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgYSBzaW5nbGUtc2lnbiBvbiB1c2luZyBhbiBlbnRlcnByaXNlIElkZW50aXR5IFByb3ZpZGVyLiBBXG4gICAgICogc3VjY2Vzc2Z1bCBTU08gYXR0ZW1wdCB3aWxsIHJlZGlyZWN0IHRoZSBjdXJyZW50IHBhZ2UgdG8gdGhlIGlkZW50aXR5XG4gICAgICogcHJvdmlkZXIgYXV0aG9yaXphdGlvbiBwYWdlLiBUaGUgcmVkaXJlY3QgVVJMIGlzIGltcGxlbWVudGF0aW9uIGFuZCBTU09cbiAgICAgKiBwcm90b2NvbCBzcGVjaWZpYy5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gdXNlIGl0IGJ5IHByb3ZpZGluZyBhIFNTTyBkb21haW4uIFR5cGljYWxseSB5b3UgY2FuIGV4dHJhY3QgdGhpc1xuICAgICAqIGRvbWFpbiBieSBhc2tpbmcgdXNlcnMgZm9yIHRoZWlyIGVtYWlsIGFkZHJlc3MuIElmIHRoaXMgZG9tYWluIGlzXG4gICAgICogcmVnaXN0ZXJlZCBvbiB0aGUgQXV0aCBpbnN0YW5jZSB0aGUgcmVkaXJlY3Qgd2lsbCB1c2UgdGhhdCBvcmdhbml6YXRpb24nc1xuICAgICAqIGN1cnJlbnRseSBhY3RpdmUgU1NPIElkZW50aXR5IFByb3ZpZGVyIGZvciB0aGUgbG9naW4uXG4gICAgICpcbiAgICAgKiBJZiB5b3UgaGF2ZSBidWlsdCBhbiBvcmdhbml6YXRpb24tc3BlY2lmaWMgbG9naW4gcGFnZSwgeW91IGNhbiB1c2UgdGhlXG4gICAgICogb3JnYW5pemF0aW9uJ3MgU1NPIElkZW50aXR5IFByb3ZpZGVyIFVVSUQgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoU1NPKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCAoMCwgaGVscGVyc18xLmdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QpKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zc29gLCB7XG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoJ3Byb3ZpZGVySWQnIGluIHBhcmFtcyA/IHsgcHJvdmlkZXJfaWQ6IHBhcmFtcy5wcm92aWRlcklkIH0gOiBudWxsKSksICgnZG9tYWluJyBpbiBwYXJhbXMgPyB7IGRvbWFpbjogcGFyYW1zLmRvbWFpbiB9IDogbnVsbCkpLCB7IHJlZGlyZWN0X3RvOiAoX2IgPSAoX2EgPSBwYXJhbXMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZCB9KSwgKCgoX2MgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhcHRjaGFUb2tlbilcbiAgICAgICAgICAgICAgICAgICAgPyB7IGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IHBhcmFtcy5vcHRpb25zLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKSksIHsgc2tpcF9odHRwX3JlZGlyZWN0OiB0cnVlLCBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSwgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kIH0pLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogZmV0Y2hfMS5fc3NvUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVkaXJlY3QgaW4gYnJvd3NlciB1bmxlc3Mgc2tpcEJyb3dzZXJSZWRpcmVjdCBpcyB0cnVlXG4gICAgICAgICAgICBpZiAoKChfZCA9IHJlc3VsdC5kYXRhKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudXJsKSAmJiAoMCwgaGVscGVyc18xLmlzQnJvd3NlcikoKSAmJiAhKChfZSA9IHBhcmFtcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uuc2tpcEJyb3dzZXJSZWRpcmVjdCkpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHJlc3VsdC5kYXRhLnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCAoMCwgaGVscGVyc18xLnJlbW92ZUl0ZW1Bc3luYykodGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcmVhdXRoZW50aWNhdGlvbiBPVFAgdG8gdGhlIHVzZXIncyBlbWFpbCBvciBwaG9uZSBudW1iZXIuXG4gICAgICogUmVxdWlyZXMgdGhlIHVzZXIgdG8gYmUgc2lnbmVkLWluLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYXV0aGVudGljYXRlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZWF1dGhlbnRpY2F0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3JlYXV0aGVudGljYXRlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IsIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc2Vzc2lvbkVycm9yO1xuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vcmVhdXRoZW50aWNhdGVgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZW5kcyBhbiBleGlzdGluZyBzaWdudXAgY29uZmlybWF0aW9uIGVtYWlsLCBlbWFpbCBjaGFuZ2UgZW1haWwsIFNNUyBPVFAgb3IgcGhvbmUgY2hhbmdlIE9UUC5cbiAgICAgKi9cbiAgICBhc3luYyByZXNlbmQoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy51cmx9L3Jlc2VuZGA7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHR5cGUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUE9TVCcsIGVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgdHlwZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgbWVzc2FnZUlkOiBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWVzc2FnZV9pZCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2Vzc2lvbiwgcmVmcmVzaGluZyBpdCBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBUaGUgc2Vzc2lvbiByZXR1cm5lZCBjYW4gYmUgbnVsbCBpZiB0aGUgc2Vzc2lvbiBpcyBub3QgZGV0ZWN0ZWQgd2hpY2ggY2FuIGhhcHBlbiBpbiB0aGUgZXZlbnQgYSB1c2VyIGlzIG5vdCBzaWduZWQtaW4gb3IgaGFzIGxvZ2dlZCBvdXQuXG4gICAgICpcbiAgICAgKiAqKklNUE9SVEFOVDoqKiBUaGlzIG1ldGhvZCBsb2FkcyB2YWx1ZXMgZGlyZWN0bHkgZnJvbSB0aGUgc3RvcmFnZSBhdHRhY2hlZFxuICAgICAqIHRvIHRoZSBjbGllbnQuIElmIHRoYXQgc3RvcmFnZSBpcyBiYXNlZCBvbiByZXF1ZXN0IGNvb2tpZXMgZm9yIGV4YW1wbGUsXG4gICAgICogdGhlIHZhbHVlcyBpbiBpdCBtYXkgbm90IGJlIGF1dGhlbnRpYyBhbmQgdGhlcmVmb3JlIGl0J3Mgc3Ryb25nbHkgYWR2aXNlZFxuICAgICAqIGFnYWluc3QgdXNpbmcgdGhpcyBtZXRob2QgYW5kIGl0cyByZXN1bHRzIGluIHN1Y2ggY2lyY3Vtc3RhbmNlcy4gQSB3YXJuaW5nXG4gICAgICogd2lsbCBiZSBlbWl0dGVkIGlmIHRoaXMgaXMgZGV0ZWN0ZWQuIFVzZSB7QGxpbmsgI2dldFVzZXIoKX0gaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTZXNzaW9uKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjcXVpcmVzIGEgZ2xvYmFsIGxvY2sgYmFzZWQgb24gdGhlIHN0b3JhZ2Uga2V5LlxuICAgICAqL1xuICAgIGFzeW5jIF9hY3F1aXJlTG9jayhhY3F1aXJlVGltZW91dCwgZm4pIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnYmVnaW4nLCBhY3F1aXJlVGltZW91dCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2NrQWNxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wZW5kaW5nSW5Mb2NrLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMucGVuZGluZ0luTG9ja1t0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBsYXN0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGp1c3QgY2FyZSBpZiBpdCBmaW5pc2hlZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvY2soYGxvY2s6JHt0aGlzLnN0b3JhZ2VLZXl9YCwgYWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdsb2NrIGFjcXVpcmVkIGZvciBzdG9yYWdlIGtleScsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NrQWNxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2sucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGp1c3QgY2FyZSBpZiBpdCBmaW5pc2hlZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGRyYWluaW5nIHRoZSBxdWV1ZSB1bnRpbCB0aGVyZSdzIG5vdGhpbmcgdG8gd2FpdCBvblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5wZW5kaW5nSW5Mb2NrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FpdE9uID0gWy4uLnRoaXMucGVuZGluZ0luTG9ja107XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh3YWl0T24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnNwbGljZSgwLCB3YWl0T24ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnbG9jayByZWxlYXNlZCBmb3Igc3RvcmFnZSBrZXknLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2tBY3F1aXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlIGluc3RlYWQgb2Yge0BsaW5rICNnZXRTZXNzaW9ufSBpbnNpZGUgdGhlIGxpYnJhcnkuIEl0IGlzXG4gICAgICogc2VtYW50aWNhbGx5IHVzdWFsbHkgd2hhdCB5b3Ugd2FudCwgYXMgZ2V0dGluZyBhIHNlc3Npb24gaW52b2x2ZXMgc29tZVxuICAgICAqIHByb2Nlc3NpbmcgYWZ0ZXJ3YXJkcyB0aGF0IHJlcXVpcmVzIG9ubHkgb25lIGNsaWVudCBvcGVyYXRpbmcgb24gdGhlXG4gICAgICogc2Vzc2lvbiBhdCBvbmNlIGFjcm9zcyBtdWx0aXBsZSB0YWJzIG9yIHByb2Nlc3Nlcy5cbiAgICAgKi9cbiAgICBhc3luYyBfdXNlU2Vzc2lvbihmbikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI191c2VTZXNzaW9uJywgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB0aGUgdXNlIG9mIF9fbG9hZFNlc3Npb24gaGVyZSBpcyB0aGUgb25seSBjb3JyZWN0IHVzZSBvZiB0aGUgZnVuY3Rpb24hXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9fbG9hZFNlc3Npb24oKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfdXNlU2Vzc2lvbicsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBORVZFUiBVU0UgRElSRUNUTFkhXG4gICAgICpcbiAgICAgKiBBbHdheXMgdXNlIHtAbGluayAjX3VzZVNlc3Npb259LlxuICAgICAqL1xuICAgIGFzeW5jIF9fbG9hZFNlc3Npb24oKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ2JlZ2luJyk7XG4gICAgICAgIGlmICghdGhpcy5sb2NrQWNxdWlyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ3VzZWQgb3V0c2lkZSBvZiBhbiBhY3F1aXJlZCBsb2NrIScsIG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRTZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IG1heWJlU2Vzc2lvbiA9IGF3YWl0ICgwLCBoZWxwZXJzXzEuZ2V0SXRlbUFzeW5jKSh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI2dldFNlc3Npb24oKScsICdzZXNzaW9uIGZyb20gc3RvcmFnZScsIG1heWJlU2Vzc2lvbik7XG4gICAgICAgICAgICBpZiAobWF5YmVTZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTZXNzaW9uKG1heWJlU2Vzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24gPSBtYXliZVNlc3Npb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI2dldFNlc3Npb24oKScsICdzZXNzaW9uIGZyb20gc3RvcmFnZSBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEEgc2Vzc2lvbiBpcyBjb25zaWRlcmVkIGV4cGlyZWQgYmVmb3JlIHRoZSBhY2Nlc3MgdG9rZW4gX2FjdHVhbGx5X1xuICAgICAgICAgICAgLy8gZXhwaXJlcy4gV2hlbiB0aGUgYXV0b1JlZnJlc2hUb2tlbiBvcHRpb24gaXMgb2ZmIChvciB3aGVuIHRoZSB0YWIgaXNcbiAgICAgICAgICAgIC8vIGluIHRoZSBiYWNrZ3JvdW5kKSwgdmVyeSBlYWdlciB1c2VycyBvZiBnZXRTZXNzaW9uKCkgLS0gbGlrZVxuICAgICAgICAgICAgLy8gcmVhbHRpbWUtanMgLS0gbWlnaHQgc2VuZCBhIHZhbGlkIEpXVCB3aGljaCB3aWxsIGV4cGlyZSBieSB0aGUgdGltZSBpdFxuICAgICAgICAgICAgLy8gcmVhY2hlcyB0aGUgc2VydmVyLlxuICAgICAgICAgICAgY29uc3QgaGFzRXhwaXJlZCA9IGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXRcbiAgICAgICAgICAgICAgICA/IGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXQgKiAxMDAwIC0gRGF0ZS5ub3coKSA8IGNvbnN0YW50c18xLkVYUElSWV9NQVJHSU5fTVNcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCBgc2Vzc2lvbiBoYXMke2hhc0V4cGlyZWQgPyAnJyA6ICcgbm90J30gZXhwaXJlZGAsICdleHBpcmVzX2F0JywgY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCk7XG4gICAgICAgICAgICBpZiAoIWhhc0V4cGlyZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51c2VyU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXliZVVzZXIgPSAoYXdhaXQgKDAsIGhlbHBlcnNfMS5nZXRJdGVtQXN5bmMpKHRoaXMudXNlclN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlVXNlciA9PT0gbnVsbCB8fCBtYXliZVVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heWJlVXNlci51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyID0gbWF5YmVVc2VyLnVzZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyID0gKDAsIGhlbHBlcnNfMS51c2VyTm90QXZhaWxhYmxlUHJveHkpKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV3JhcCB0aGUgdXNlciBvYmplY3Qgd2l0aCBhIHdhcm5pbmcgcHJveHkgb24gdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2FybnMgd2hlbiBwcm9wZXJ0aWVzIG9mIHRoZSB1c2VyIGFyZSBhY2Nlc3NlZCwgbm90IHdoZW4gc2Vzc2lvbi51c2VyIGl0c2VsZiBpcyBhY2Nlc3NlZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0b3JhZ2UuaXNTZXJ2ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciAmJlxuICAgICAgICAgICAgICAgICAgICAhY3VycmVudFNlc3Npb24udXNlci5fX2lzVXNlck5vdEF2YWlsYWJsZVByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1cHByZXNzV2FybmluZ1JlZiA9IHsgdmFsdWU6IHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyID0gKDAsIGhlbHBlcnNfMS5pbnNlY3VyZVVzZXJXYXJuaW5nUHJveHkpKGN1cnJlbnRTZXNzaW9uLnVzZXIsIHN1cHByZXNzV2FybmluZ1JlZik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY2xpZW50LWxldmVsIHN1cHByZXNzaW9uIGZsYWcgd2hlbiB0aGUgcHJveHkgc3VwcHJlc3NlcyB0aGUgd2FybmluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcHJlc3NXYXJuaW5nUmVmLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogY3VycmVudFNlc3Npb24gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdXNlciBkZXRhaWxzIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHNlc3Npb24uIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBuZXR3b3JrIHJlcXVlc3QgdG8gdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLCBzbyB0aGUgcmV0dXJuZWRcbiAgICAgKiB2YWx1ZSBpcyBhdXRoZW50aWMgYW5kIGNhbiBiZSB1c2VkIHRvIGJhc2UgYXV0aG9yaXphdGlvbiBydWxlcyBvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqd3QgVGFrZXMgaW4gYW4gb3B0aW9uYWwgYWNjZXNzIHRva2VuIEpXVC4gSWYgbm8gSldUIGlzIHByb3ZpZGVkLCB0aGUgSldUIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyB1c2VkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXIoand0KSB7XG4gICAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKGp3dCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0LmRhdGEudXNlcikge1xuICAgICAgICAgICAgdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBfZ2V0VXNlcihqd3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vdXNlcmAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IGp3dCxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IGZldGNoXzEuX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGFuIGVycm9yIGlmIHRoZXJlIGlzIG5vIGFjY2Vzc190b2tlbiBvciBjdXN0b20gYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgICAgICAgICAgICBpZiAoISgoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4pICYmICF0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yOiBuZXcgZXJyb3JzXzEuQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vdXNlcmAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYyA9IChfYiA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFjY2Vzc190b2tlbikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogZmV0Y2hfMS5fdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBKV1QgY29udGFpbnMgYSBgc2Vzc2lvbl9pZGAgd2hpY2ggZG9lcyBub3QgY29ycmVzcG9uZCB0byBhbiBhY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgLy8gc2Vzc2lvbiBpbiB0aGUgZGF0YWJhc2UsIGluZGljYXRpbmcgdGhlIHVzZXIgaXMgc2lnbmVkIG91dC5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCAoMCwgaGVscGVyc18xLnJlbW92ZUl0ZW1Bc3luYykodGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdXNlciBkYXRhIGZvciBhIGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlVXNlcihhdHRyaWJ1dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzZXNzaW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbkRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHNlc3Npb25EYXRhLnNlc3Npb247XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnICYmIGF0dHJpYnV0ZXMuZW1haWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0ICgwLCBoZWxwZXJzXzEuZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCkodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUFVUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKSwgeyBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSwgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kIH0pLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogZmV0Y2hfMS5fdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh1c2VyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdXNlckVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXNzaW9uLnVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1VTRVJfVVBEQVRFRCcsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IHNlc3Npb24udXNlciB9LCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXdhaXQgKDAsIGhlbHBlcnNfMS5yZW1vdmVJdGVtQXN5bmMpKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2Vzc2lvbiBkYXRhIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbi4gSWYgdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyBleHBpcmVkLCBzZXRTZXNzaW9uIHdpbGwgdGFrZSBjYXJlIG9mIHJlZnJlc2hpbmcgaXQgdG8gb2J0YWluIGEgbmV3IHNlc3Npb24uXG4gICAgICogSWYgdGhlIHJlZnJlc2ggdG9rZW4gb3IgYWNjZXNzIHRva2VuIGluIHRoZSBjdXJyZW50IHNlc3Npb24gaXMgaW52YWxpZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgICogQHBhcmFtIGN1cnJlbnRTZXNzaW9uIFRoZSBjdXJyZW50IHNlc3Npb24gdGhhdCBtaW5pbWFsbHkgY29udGFpbnMgYW4gYWNjZXNzIHRva2VuIGFuZCByZWZyZXNoIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIHNldFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4gfHwgIWN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWVOb3cgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgICAgIGxldCBleHBpcmVzQXQgPSB0aW1lTm93O1xuICAgICAgICAgICAgbGV0IGhhc0V4cGlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSAoMCwgaGVscGVyc18xLmRlY29kZUpXVCkoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmV4cCkge1xuICAgICAgICAgICAgICAgIGV4cGlyZXNBdCA9IHBheWxvYWQuZXhwO1xuICAgICAgICAgICAgICAgIGhhc0V4cGlyZWQgPSBleHBpcmVzQXQgPD0gdGltZU5vdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNFeHBpcmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiByZWZyZXNoZWRTZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmVmcmVzaGVkU2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vzc2lvbiA9IHJlZnJlc2hlZFNlc3Npb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9nZXRVc2VyKGN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXNzaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW46IGN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbixcbiAgICAgICAgICAgICAgICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbl90eXBlOiAnYmVhcmVyJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJlc19pbjogZXhwaXJlc0F0IC0gdGltZU5vdyxcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc0F0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgc2Vzc2lvbiwgcmVnYXJkbGVzcyBvZiBleHBpcnkgc3RhdHVzLlxuICAgICAqIFRha2VzIGluIGFuIG9wdGlvbmFsIGN1cnJlbnQgc2Vzc2lvbi4gSWYgbm90IHBhc3NlZCBpbiwgdGhlbiByZWZyZXNoU2Vzc2lvbigpIHdpbGwgYXR0ZW1wdCB0byByZXRyaWV2ZSBpdCBmcm9tIGdldFNlc3Npb24oKS5cbiAgICAgKiBJZiB0aGUgY3VycmVudCBzZXNzaW9uJ3MgcmVmcmVzaCB0b2tlbiBpcyBpbnZhbGlkLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAgKiBAcGFyYW0gY3VycmVudFNlc3Npb24gVGhlIGN1cnJlbnQgc2Vzc2lvbi4gSWYgcGFzc2VkIGluLCBpdCBtdXN0IGNvbnRhaW4gYSByZWZyZXNoIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9yZWZyZXNoU2Vzc2lvbihjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IChfYSA9IGRhdGEuc2Vzc2lvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShjdXJyZW50U2Vzc2lvbiA9PT0gbnVsbCB8fCBjdXJyZW50U2Vzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2Vzc2lvbiBkYXRhIGZyb20gYSBVUkwgc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgX2dldFNlc3Npb25Gcm9tVVJMKHBhcmFtcywgY2FsbGJhY2tVcmxUeXBlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoISgwLCBoZWxwZXJzXzEuaXNCcm93c2VyKSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vIGJyb3dzZXIgZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFuIGVycm9yIGluIHRoZSBVUkwsIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgZmxvdyBpdCBpcywgd2UganVzdCByZXR1cm4gdGhlIGVycm9yLlxuICAgICAgICAgICAgaWYgKHBhcmFtcy5lcnJvciB8fCBwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgcGFyYW1zLmVycm9yX2NvZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXJyb3IgY2xhc3MgcmV0dXJuZWQgaW1wbGllcyB0aGF0IHRoZSByZWRpcmVjdCBpcyBmcm9tIGFuIGltcGxpY2l0IGdyYW50IGZsb3dcbiAgICAgICAgICAgICAgICAvLyBidXQgaXQgY291bGQgYWxzbyBiZSBmcm9tIGEgcmVkaXJlY3QgZXJyb3IgZnJvbSBhIFBLQ0UgZmxvdy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbiB8fCAnRXJyb3IgaW4gVVJMIHdpdGggdW5zcGVjaWZpZWQgZXJyb3JfZGVzY3JpcHRpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBwYXJhbXMuZXJyb3IgfHwgJ3Vuc3BlY2lmaWVkX2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcGFyYW1zLmVycm9yX2NvZGUgfHwgJ3Vuc3BlY2lmaWVkX2NvZGUnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2tzIGZvciBtaXNtYXRjaGVzIGJldHdlZW4gdGhlIGZsb3dUeXBlIGluaXRpYWxpc2VkIGluIHRoZSBjbGllbnQgYW5kIHRoZSBVUkwgcGFyYW1ldGVyc1xuICAgICAgICAgICAgc3dpdGNoIChjYWxsYmFja1VybFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbXBsaWNpdCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ05vdCBhIHZhbGlkIFBLQ0UgZmxvdyB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncGtjZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAnaW1wbGljaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdOb3QgYSB2YWxpZCBpbXBsaWNpdCBncmFudCBmbG93IHVybC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbWlzbWF0Y2ggc28gd2UgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSByZWRpcmVjdCBmb3IgUEtDRSwgd2UgYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgY29kZSBmcm9tIHRoZSBVUkwgZm9yIHRoZSBjb2RlIGV4Y2hhbmdlXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tVcmxUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnYmVnaW4nLCAnaXMgUEtDRSBmbG93JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcignTm8gY29kZSBkZXRlY3RlZC4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKHBhcmFtcy5jb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCdjb2RlJyk7XG4gICAgICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHdpbmRvdy5oaXN0b3J5LnN0YXRlLCAnJywgdXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogZGF0YS5zZXNzaW9uLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXJfdG9rZW4sIHByb3ZpZGVyX3JlZnJlc2hfdG9rZW4sIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiwgZXhwaXJlc19pbiwgZXhwaXJlc19hdCwgdG9rZW5fdHlwZSwgfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGlmICghYWNjZXNzX3Rva2VuIHx8ICFleHBpcmVzX2luIHx8ICFyZWZyZXNoX3Rva2VuIHx8ICF0b2tlbl90eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm8gc2Vzc2lvbiBkZWZpbmVkIGluIFVSTCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luID0gcGFyc2VJbnQoZXhwaXJlc19pbik7XG4gICAgICAgICAgICBsZXQgZXhwaXJlc0F0ID0gdGltZU5vdyArIGV4cGlyZXNJbjtcbiAgICAgICAgICAgIGlmIChleHBpcmVzX2F0KSB7XG4gICAgICAgICAgICAgICAgZXhwaXJlc0F0ID0gcGFyc2VJbnQoZXhwaXJlc19hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxseUV4cGlyZXNJbiA9IGV4cGlyZXNBdCAtIHRpbWVOb3c7XG4gICAgICAgICAgICBpZiAoYWN0dWFsbHlFeHBpcmVzSW4gKiAxMDAwIDw9IGNvbnN0YW50c18xLkFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCBleHBpcmVzIGluICR7YWN0dWFsbHlFeHBpcmVzSW59cywgc2hvdWxkIGhhdmUgYmVlbiBjbG9zZXIgdG8gJHtleHBpcmVzSW59c2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNzdWVkQXQgPSBleHBpcmVzQXQgLSBleHBpcmVzSW47XG4gICAgICAgICAgICBpZiAodGltZU5vdyAtIGlzc3VlZEF0ID49IDEyMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgd2FzIGlzc3VlZCBvdmVyIDEyMHMgYWdvLCBVUkwgY291bGQgYmUgc3RhbGUnLCBpc3N1ZWRBdCwgZXhwaXJlc0F0LCB0aW1lTm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVOb3cgLSBpc3N1ZWRBdCA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIHdhcyBpc3N1ZWQgaW4gdGhlIGZ1dHVyZT8gQ2hlY2sgdGhlIGRldmljZSBjbG9jayBmb3Igc2tldycsIGlzc3VlZEF0LCBleHBpcmVzQXQsIHRpbWVOb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0VXNlcihhY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcl90b2tlbixcbiAgICAgICAgICAgICAgICBwcm92aWRlcl9yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzSW4sXG4gICAgICAgICAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc0F0LFxuICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgICAgICAgdG9rZW5fdHlwZTogdG9rZW5fdHlwZSxcbiAgICAgICAgICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRva2VucyBmcm9tIFVSTFxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2dldFNlc3Npb25Gcm9tVVJMKCknLCAnY2xlYXJpbmcgd2luZG93LmxvY2F0aW9uLmhhc2gnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHNlc3Npb24sIHJlZGlyZWN0VHlwZTogcGFyYW1zLnR5cGUgfSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyBzZXNzaW9uOiBudWxsLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgVVJMIGNvbnRhaW5zIHBhcmFtZXRlcnMgZ2l2ZW4gYnkgYW4gaW1wbGljaXQgb2F1dGggZ3JhbnQgZmxvdyAoaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY3NDkuaHRtbCNzZWN0aW9uLTQuMilcbiAgICAgKlxuICAgICAqIElmIGBkZXRlY3RTZXNzaW9uSW5VcmxgIGlzIGEgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIFVSTCBhbmQgcGFyYW1zIHRvIGRldGVybWluZVxuICAgICAqIGlmIHRoZSBVUkwgc2hvdWxkIGJlIHByb2Nlc3NlZCBhcyBhIFN1cGFiYXNlIGF1dGggY2FsbGJhY2suIFRoaXMgYWxsb3dzIHVzZXJzIHRvIGV4Y2x1ZGVcbiAgICAgKiBVUkxzIGZyb20gb3RoZXIgT0F1dGggcHJvdmlkZXJzIChlLmcuLCBGYWNlYm9vayBMb2dpbikgdGhhdCBhbHNvIHJldHVybiBhY2Nlc3NfdG9rZW4gaW4gdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIF9pc0ltcGxpY2l0R3JhbnRDYWxsYmFjayhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRldGVjdFNlc3Npb25JblVybCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBhcmFtcy5hY2Nlc3NfdG9rZW4gfHwgcGFyYW1zLmVycm9yX2Rlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IFVSTCBhbmQgYmFja2luZyBzdG9yYWdlIGNvbnRhaW4gcGFyYW1ldGVycyBnaXZlbiBieSBhIFBLQ0UgZmxvd1xuICAgICAqL1xuICAgIGFzeW5jIF9pc1BLQ0VDYWxsYmFjayhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0b3JhZ2VDb250ZW50ID0gYXdhaXQgKDAsIGhlbHBlcnNfMS5nZXRJdGVtQXN5bmMpKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgIHJldHVybiAhIShwYXJhbXMuY29kZSAmJiBjdXJyZW50U3RvcmFnZUNvbnRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNpZGUgYSBicm93c2VyIGNvbnRleHQsIGBzaWduT3V0KClgIHdpbGwgcmVtb3ZlIHRoZSBsb2dnZWQgaW4gdXNlciBmcm9tIHRoZSBicm93c2VyIHNlc3Npb24gYW5kIGxvZyB0aGVtIG91dCAtIHJlbW92aW5nIGFsbCBpdGVtcyBmcm9tIGxvY2Fsc3RvcmFnZSBhbmQgdGhlbiB0cmlnZ2VyIGEgYFwiU0lHTkVEX09VVFwiYCBldmVudC5cbiAgICAgKlxuICAgICAqIEZvciBzZXJ2ZXItc2lkZSBtYW5hZ2VtZW50LCB5b3UgY2FuIHJldm9rZSBhbGwgcmVmcmVzaCB0b2tlbnMgZm9yIGEgdXNlciBieSBwYXNzaW5nIGEgdXNlcidzIEpXVCB0aHJvdWdoIHRvIGBhdXRoLmFwaS5zaWduT3V0KEpXVDogc3RyaW5nKWAuXG4gICAgICogVGhlcmUgaXMgbm8gd2F5IHRvIHJldm9rZSBhIHVzZXIncyBhY2Nlc3MgdG9rZW4gand0IHVudGlsIGl0IGV4cGlyZXMuIEl0IGlzIHJlY29tbWVuZGVkIHRvIHNldCBhIHNob3J0ZXIgZXhwaXJ5IG9uIHRoZSBqd3QgZm9yIHRoaXMgcmVhc29uLlxuICAgICAqXG4gICAgICogSWYgdXNpbmcgYG90aGVyc2Agc2NvcGUsIG5vIGBTSUdORURfT1VUYCBldmVudCBpcyBmaXJlZCFcbiAgICAgKi9cbiAgICBhc3luYyBzaWduT3V0KG9wdGlvbnMgPSB7IHNjb3BlOiAnZ2xvYmFsJyB9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NpZ25PdXQob3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfc2lnbk91dCh7IHNjb3BlIH0gPSB7IHNjb3BlOiAnZ2xvYmFsJyB9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBlcnJvcjogc2Vzc2lvbkVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSAoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLmFkbWluLnNpZ25PdXQoYWNjZXNzVG9rZW4sIHNjb3BlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIDQwNHMgc2luY2UgdXNlciBtaWdodCBub3QgZXhpc3QgYW55bW9yZVxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgNDAxcyBzaW5jZSBhbiBpbnZhbGlkIG9yIGV4cGlyZWQgSldUIHNob3VsZCBzaWduIG91dCB0aGUgY3VycmVudCBzZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICghKCgwLCBlcnJvcnNfMS5pc0F1dGhBcGlFcnJvcikoZXJyb3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZXJyb3Iuc3RhdHVzID09PSA0MDQgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDEgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDMpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjb3BlICE9PSAnb3RoZXJzJykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBhd2FpdCAoMCwgaGVscGVyc18xLnJlbW92ZUl0ZW1Bc3luYykodGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uQXV0aFN0YXRlQ2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGlkID0gKDAsIGhlbHBlcnNfMS5nZW5lcmF0ZUNhbGxiYWNrSWQpKCk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjdW5zdWJzY3JpYmUoKScsICdzdGF0ZSBjaGFuZ2UgY2FsbGJhY2sgd2l0aCBpZCByZW1vdmVkJywgaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNvbkF1dGhTdGF0ZUNoYW5nZSgpJywgJ3JlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCBpZCcsIGlkKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLnNldChpZCwgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRJbml0aWFsU2Vzc2lvbihpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzdWJzY3JpcHRpb24gfSB9O1xuICAgIH1cbiAgICBhc3luYyBfZW1pdEluaXRpYWxTZXNzaW9uKGlkKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYSA9IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIHNlc3Npb24pKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdzZXNzaW9uJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYiA9IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIG51bGwpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBwYXNzd29yZCByZXNldCByZXF1ZXN0IHRvIGFuIGVtYWlsIGFkZHJlc3MuIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBUaGUgVVJMIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBjbGljayB0aGUgcGFzc3dvcmQgcmVzZXQgbGluay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jYXB0Y2hhVG9rZW4gVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc2V0UGFzc3dvcmRGb3JFbWFpbChlbWFpbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCAoMCwgaGVscGVyc18xLmdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QpKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCB0cnVlIC8vIGlzUGFzc3dvcmRSZWNvdmVyeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9yZWNvdmVyYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCAoMCwgaGVscGVyc18xLnJlbW92ZUl0ZW1Bc3luYykodGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIHRoZSBpZGVudGl0aWVzIGxpbmtlZCB0byBhIHVzZXIuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VXNlcklkZW50aXRpZXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcigpO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgaWRlbnRpdGllczogKF9hID0gZGF0YS51c2VyLmlkZW50aXRpZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlua0lkZW50aXR5KGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGlmICgndG9rZW4nIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saW5rSWRlbnRpdHlJZFRva2VuKGNyZWRlbnRpYWxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5saW5rSWRlbnRpdHlPQXV0aChjcmVkZW50aWFscyk7XG4gICAgfVxuICAgIGFzeW5jIGxpbmtJZGVudGl0eU9BdXRoKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fZ2V0VXJsRm9yUHJvdmlkZXIoYCR7dGhpcy51cmx9L3VzZXIvaWRlbnRpdGllcy9hdXRob3JpemVgLCBjcmVkZW50aWFscy5wcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiAoX2EgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVzOiAoX2IgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2NvcGVzLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogKF9jID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBza2lwQnJvd3NlclJlZGlyZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ0dFVCcsIHVybCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9lID0gKF9kID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzQnJvd3NlcikoKSAmJiAhKChfYSA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5za2lwQnJvd3NlclJlZGlyZWN0KSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7IHByb3ZpZGVyOiBjcmVkZW50aWFscy5wcm92aWRlciwgdXJsOiBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudXJsIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHByb3ZpZGVyOiBjcmVkZW50aWFscy5wcm92aWRlciwgdXJsOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlua0lkZW50aXR5SWRUb2tlbihjcmVkZW50aWFscykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3I6IHNlc3Npb25FcnJvciwgZGF0YTogeyBzZXNzaW9uIH0sIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc2Vzc2lvbkVycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucywgcHJvdmlkZXIsIHRva2VuLCBhY2Nlc3NfdG9rZW4sIG5vbmNlIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1pZF90b2tlbmAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb24gPT09IG51bGwgfHwgc2Vzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZF90b2tlbjogdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaWRlbnRpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBmZXRjaF8xLl9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgZXJyb3JzXzEuQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1VTRVJfVVBEQVRFRCcsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGF3YWl0ICgwLCBoZWxwZXJzXzEucmVtb3ZlSXRlbUFzeW5jKSh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubGlua3MgYW4gaWRlbnRpdHkgZnJvbSBhIHVzZXIgYnkgZGVsZXRpbmcgaXQuIFRoZSB1c2VyIHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gc2lnbiBpbiB3aXRoIHRoYXQgaWRlbnRpdHkgb25jZSBpdCdzIHVubGlua2VkLlxuICAgICAqL1xuICAgIGFzeW5jIHVubGlua0lkZW50aXR5KGlkZW50aXR5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vdXNlci9pZGVudGl0aWVzLyR7aWRlbnRpdHkuaWRlbnRpdHlfaWR9YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9iID0gKF9hID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBKV1QuXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBBIHZhbGlkIHJlZnJlc2ggdG9rZW4gdGhhdCB3YXMgcmV0dXJuZWQgb24gbG9naW4uXG4gICAgICovXG4gICAgYXN5bmMgX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gYCNfcmVmcmVzaEFjY2Vzc1Rva2VuKCR7cmVmcmVzaFRva2VuLnN1YnN0cmluZygwLCA1KX0uLi4pYDtcbiAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAvLyB3aWxsIGF0dGVtcHQgdG8gcmVmcmVzaCB0aGUgdG9rZW4gd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgKDAsIGhlbHBlcnNfMS5yZXRyeWFibGUpKGFzeW5jIChhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0ICgwLCBoZWxwZXJzXzEuc2xlZXApKDIwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSk7IC8vIDIwMCwgNDAwLCA4MDAsIC4uLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdyZWZyZXNoaW5nIGF0dGVtcHQnLCBhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cmVmcmVzaF90b2tlbmAsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogeyByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogZmV0Y2hfMS5fc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgKGF0dGVtcHQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEJhY2tPZmZJbnRlcnZhbCA9IDIwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKDAsIGVycm9yc18xLmlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IpKGVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyByZXRyeWFibGUgb25seSBpZiB0aGUgcmVxdWVzdCBjYW4gYmUgc2VudCBiZWZvcmUgdGhlIGJhY2tvZmYgb3ZlcmZsb3dzIHRoZSB0aWNrIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIERhdGUubm93KCkgKyBuZXh0QmFja09mZkludGVydmFsIC0gc3RhcnRlZEF0IDwgY29uc3RhbnRzXzEuQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHNlc3Npb246IG51bGwsIHVzZXI6IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pc1ZhbGlkU2Vzc2lvbihtYXliZVNlc3Npb24pIHtcbiAgICAgICAgY29uc3QgaXNWYWxpZFNlc3Npb24gPSB0eXBlb2YgbWF5YmVTZXNzaW9uID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgbWF5YmVTZXNzaW9uICE9PSBudWxsICYmXG4gICAgICAgICAgICAnYWNjZXNzX3Rva2VuJyBpbiBtYXliZVNlc3Npb24gJiZcbiAgICAgICAgICAgICdyZWZyZXNoX3Rva2VuJyBpbiBtYXliZVNlc3Npb24gJiZcbiAgICAgICAgICAgICdleHBpcmVzX2F0JyBpbiBtYXliZVNlc3Npb247XG4gICAgICAgIHJldHVybiBpc1ZhbGlkU2Vzc2lvbjtcbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZVByb3ZpZGVyU2lnbkluKHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuX2dldFVybEZvclByb3ZpZGVyKGAke3RoaXMudXJsfS9hdXRob3JpemVgLCBwcm92aWRlciwge1xuICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgc2NvcGVzOiBvcHRpb25zLnNjb3BlcyxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBvcHRpb25zLnF1ZXJ5UGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfaGFuZGxlUHJvdmlkZXJTaWduSW4oKScsICdwcm92aWRlcicsIHByb3ZpZGVyLCAnb3B0aW9ucycsIG9wdGlvbnMsICd1cmwnLCB1cmwpO1xuICAgICAgICAvLyB0cnkgdG8gb3BlbiBvbiB0aGUgYnJvd3NlclxuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5pc0Jyb3dzZXIpKCkgJiYgIW9wdGlvbnMuc2tpcEJyb3dzZXJSZWRpcmVjdCkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgcHJvdmlkZXIsIHVybCB9LCBlcnJvcjogbnVsbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvdmVycyB0aGUgc2Vzc2lvbiBmcm9tIExvY2FsU3RvcmFnZSBhbmQgcmVmcmVzaGVzIHRoZSB0b2tlblxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIGFzeW5jIHRvIGFjY29tbW9kYXRlIGZvciBBc3luY1N0b3JhZ2UgZS5nLiBpbiBSZWFjdCBuYXRpdmUuXG4gICAgICovXG4gICAgYXN5bmMgX3JlY292ZXJBbmRSZWZyZXNoKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBkZWJ1Z05hbWUgPSAnI19yZWNvdmVyQW5kUmVmcmVzaCgpJztcbiAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTZXNzaW9uID0gKGF3YWl0ICgwLCBoZWxwZXJzXzEuZ2V0SXRlbUFzeW5jKSh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSkpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTZXNzaW9uICYmIHRoaXMudXNlclN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF5YmVVc2VyID0gKGF3YWl0ICgwLCBoZWxwZXJzXzEuZ2V0SXRlbUFzeW5jKSh0aGlzLnVzZXJTdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInKSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0b3JhZ2UuaXNTZXJ2ZXIgJiYgT2JqZWN0LmlzKHRoaXMuc3RvcmFnZSwgdGhpcy51c2VyU3RvcmFnZSkgJiYgIW1heWJlVXNlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yYWdlIGFuZCB1c2VyU3RvcmFnZSBhcmUgdGhlIHNhbWUgc3RvcmFnZSBtZWRpdW0sIGZvciBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpbmRvdy5sb2NhbFN0b3JhZ2UgaWYgdXNlclN0b3JhZ2UgZG9lcyBub3QgaGF2ZSB0aGUgdXNlciBmcm9tXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JhZ2Ugc3RvcmVkLCBzdG9yZSBpdCBmaXJzdCB0aGVyZWJ5IG1pZ3JhdGluZyB0aGUgdXNlciBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSBzdG9yYWdlIC0+IHVzZXJTdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgIG1heWJlVXNlciA9IHsgdXNlcjogY3VycmVudFNlc3Npb24udXNlciB9O1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCAoMCwgaGVscGVyc18xLnNldEl0ZW1Bc3luYykodGhpcy51c2VyU3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJywgbWF5YmVVc2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9IChfYSA9IG1heWJlVXNlciA9PT0gbnVsbCB8fCBtYXliZVVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heWJlVXNlci51c2VyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgaGVscGVyc18xLnVzZXJOb3RBdmFpbGFibGVQcm94eSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRTZXNzaW9uICYmICFjdXJyZW50U2Vzc2lvbi51c2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlciBzdG9yYWdlIGlzIG5vdCBzZXQsIGxldCdzIGNoZWNrIGlmIGl0IHdhcyBwcmV2aW91c2x5IGVuYWJsZWQgc29cbiAgICAgICAgICAgICAgICAvLyB3ZSBicmluZyBiYWNrIHRoZSBzdG9yYWdlIGFzIGl0IHNob3VsZCBiZVxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFNlc3Npb24udXNlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyB0ZXN0IGlmIHVzZXJTdG9yYWdlIHdhcyBwcmV2aW91c2x5IGVuYWJsZWQgYW5kIHRoZSBzdG9yYWdlIG1lZGl1bSB3YXMgdGhlIHNhbWUsIHRvIG1vdmUgdGhlIHVzZXIgYmFjayB1bmRlciB0aGUgc2FtZSBrZXlcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VwYXJhdGVVc2VyID0gKGF3YWl0ICgwLCBoZWxwZXJzXzEuZ2V0SXRlbUFzeW5jKSh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRlVXNlciAmJiAoc2VwYXJhdGVVc2VyID09PSBudWxsIHx8IHNlcGFyYXRlVXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VwYXJhdGVVc2VyLnVzZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyID0gc2VwYXJhdGVVc2VyLnVzZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCAoMCwgaGVscGVyc18xLnJlbW92ZUl0ZW1Bc3luYykodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0ICgwLCBoZWxwZXJzXzEuc2V0SXRlbUFzeW5jKSh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSwgY3VycmVudFNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9ICgwLCBoZWxwZXJzXzEudXNlck5vdEF2YWlsYWJsZVByb3h5KSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnc2Vzc2lvbiBmcm9tIHN0b3JhZ2UnLCBjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3Nlc3Npb24gaXMgbm90IHZhbGlkJyk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXhwaXJlc1dpdGhNYXJnaW4gPSAoKF9iID0gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogSW5maW5pdHkpICogMTAwMCAtIERhdGUubm93KCkgPCBjb25zdGFudHNfMS5FWFBJUllfTUFSR0lOX01TO1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCBgc2Vzc2lvbiBoYXMke2V4cGlyZXNXaXRoTWFyZ2luID8gJycgOiAnIG5vdCd9IGV4cGlyZWQgd2l0aCBtYXJnaW4gb2YgJHtjb25zdGFudHNfMS5FWFBJUllfTUFSR0lOX01TfXNgKTtcbiAgICAgICAgICAgIGlmIChleHBpcmVzV2l0aE1hcmdpbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4gJiYgY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgZXJyb3JzXzEuaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcikoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAncmVmcmVzaCBmYWlsZWQgd2l0aCBhIG5vbi1yZXRyeWFibGUgZXJyb3IsIHJlbW92aW5nIHRoZSBzZXNzaW9uJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRTZXNzaW9uLnVzZXIgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyLl9faXNVc2VyTm90QXZhaWxhYmxlUHJveHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcHJveHkgdXNlciwgdHJ5IHRvIGdldCB0aGUgcmVhbCB1c2VyIGRhdGFcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyRXJyb3IgJiYgKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS51c2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9IGRhdGEudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdjb3VsZCBub3QgZ2V0IHVzZXIgZGF0YSwgc2tpcHBpbmcgU0lHTkVEX0lOIG5vdGlmaWNhdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChnZXRVc2VyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIGRhdGE6JywgZ2V0VXNlckVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3IgZ2V0dGluZyB1c2VyIGRhdGEsIHNraXBwaW5nIFNJR05FRF9JTiBub3RpZmljYXRpb24nLCBnZXRVc2VyRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcGVyc2lzdCBjdXJyZW50U2Vzc2lvbiBhZ2FpbiwgYXMgd2UganVzdCBsb2FkZWQgaXQgZnJvbVxuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHN0b3JhZ2U7IHBlcnNpc3RpbmcgaXQgYWdhaW4gbWF5IG92ZXJ3cml0ZSBhIHZhbHVlIHNhdmVkIGJ5XG4gICAgICAgICAgICAgICAgLy8gYW5vdGhlciBjbGllbnQgd2l0aCBhY2Nlc3MgdG8gdGhlIHNhbWUgbG9jYWwgc3RvcmFnZVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2NhbGxSZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWZyZXNoaW5nIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3NcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaGluZ0RlZmVycmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19jYWxsUmVmcmVzaFRva2VuKCR7cmVmcmVzaFRva2VuLnN1YnN0cmluZygwLCA1KX0uLi4pYDtcbiAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbmV3IGhlbHBlcnNfMS5EZWZlcnJlZCgpO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fcmVmcmVzaEFjY2Vzc1Rva2VuKHJlZnJlc2hUb2tlbik7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBpZiAoIWRhdGEuc2Vzc2lvbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnVE9LRU5fUkVGUkVTSEVEJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgZGF0YTogZGF0YS5zZXNzaW9uLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgaWYgKCgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIGlmICghKDAsIGVycm9yc18xLmlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucmVmcmVzaGluZ0RlZmVycmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9ub3RpZnlBbGxTdWJzY3JpYmVycyhldmVudCwgc2Vzc2lvbiwgYnJvYWRjYXN0ID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19ub3RpZnlBbGxTdWJzY3JpYmVycygke2V2ZW50fSlgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicsIHNlc3Npb24sIGBicm9hZGNhc3QgPSAke2Jyb2FkY2FzdH1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJyb2FkY2FzdENoYW5uZWwgJiYgYnJvYWRjYXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLnBvc3RNZXNzYWdlKHsgZXZlbnQsIHNlc3Npb24gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMudmFsdWVzKCkpLm1hcChhc3luYyAoeCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHguY2FsbGJhY2soZXZlbnQsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0IGN1cnJlbnRTZXNzaW9uIGFuZCBjdXJyZW50VXNlclxuICAgICAqIHByb2Nlc3MgdG8gX3N0YXJ0QXV0b1JlZnJlc2hUb2tlbiBpZiBwb3NzaWJsZVxuICAgICAqL1xuICAgIGFzeW5jIF9zYXZlU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3NhdmVTZXNzaW9uKCknLCBzZXNzaW9uKTtcbiAgICAgICAgLy8gX3NhdmVTZXNzaW9uIGlzIGFsd2F5cyBjYWxsZWQgd2hlbmV2ZXIgYSBuZXcgc2Vzc2lvbiBoYXMgYmVlbiBhY3F1aXJlZFxuICAgICAgICAvLyBzbyB3ZSBjYW4gc2FmZWx5IHN1cHByZXNzIHRoZSB3YXJuaW5nIHJldHVybmVkIGJ5IGZ1dHVyZSBnZXRTZXNzaW9uIGNhbGxzXG4gICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWU7XG4gICAgICAgIGF3YWl0ICgwLCBoZWxwZXJzXzEucmVtb3ZlSXRlbUFzeW5jKSh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAvLyBDcmVhdGUgYSBzaGFsbG93IGNvcHkgdG8gd29yayB3aXRoLCB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgc2Vzc2lvbiBvYmplY3QgaWYgaXQncyB1c2VkIGVsc2V3aGVyZVxuICAgICAgICBjb25zdCBzZXNzaW9uVG9Qcm9jZXNzID0gT2JqZWN0LmFzc2lnbih7fSwgc2Vzc2lvbik7XG4gICAgICAgIGNvbnN0IHVzZXJJc1Byb3h5ID0gc2Vzc2lvblRvUHJvY2Vzcy51c2VyICYmIHNlc3Npb25Ub1Byb2Nlc3MudXNlci5fX2lzVXNlck5vdEF2YWlsYWJsZVByb3h5ID09PSB0cnVlO1xuICAgICAgICBpZiAodGhpcy51c2VyU3RvcmFnZSkge1xuICAgICAgICAgICAgaWYgKCF1c2VySXNQcm94eSAmJiBzZXNzaW9uVG9Qcm9jZXNzLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgcmVhbCB1c2VyIG9iamVjdCwgc2F2ZSBpdCB0byB1c2VyU3RvcmFnZS5cbiAgICAgICAgICAgICAgICBhd2FpdCAoMCwgaGVscGVyc18xLnNldEl0ZW1Bc3luYykodGhpcy51c2VyU3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJywge1xuICAgICAgICAgICAgICAgICAgICB1c2VyOiBzZXNzaW9uVG9Qcm9jZXNzLnVzZXIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1c2VySXNQcm94eSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgdGhlIHByb3h5LCBpdCBtZWFucyB1c2VyIHdhcyBub3QgZm91bmQgaW4gdXNlclN0b3JhZ2UuXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGVuc3VyZSBubyBzdGFsZSB1c2VyIGRhdGEgZm9yIHRoaXMga2V5IGV4aXN0cyBpbiB1c2VyU3RvcmFnZSBpZiB3ZSB3ZXJlIHRvIHNhdmUgbnVsbCxcbiAgICAgICAgICAgICAgICAvLyBvciBzaW1wbHkgbm90IHNhdmUgdGhlIHByb3h5LiBGb3Igbm93LCB3ZSBkb24ndCBzYXZlIHRoZSBwcm94eSBoZXJlLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBuZWVkIHRvIGNsZWFyIHVzZXJTdG9yYWdlIGlmIHVzZXIgYmVjb21lcyBwcm94eSwgdGhhdCBsb2dpYyB3b3VsZCBnbyBoZXJlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJlcGFyZSB0aGUgbWFpbiBzZXNzaW9uIGRhdGEgZm9yIHByaW1hcnkgc3RvcmFnZTogcmVtb3ZlIHRoZSB1c2VyIHByb3BlcnR5IGJlZm9yZSBjbG9uaW5nXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBvcmlnaW5hbCBzZXNzaW9uLnVzZXIgbWlnaHQgYmUgdGhlIHByb3h5XG4gICAgICAgICAgICBjb25zdCBtYWluU2Vzc2lvbkRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBzZXNzaW9uVG9Qcm9jZXNzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBtYWluU2Vzc2lvbkRhdGEudXNlcjsgLy8gUmVtb3ZlIHVzZXIgKHJlYWwgb3IgcHJveHkpIGJlZm9yZSBjbG9uaW5nIGZvciBtYWluIHN0b3JhZ2VcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZE1haW5TZXNzaW9uRGF0YSA9ICgwLCBoZWxwZXJzXzEuZGVlcENsb25lKShtYWluU2Vzc2lvbkRhdGEpO1xuICAgICAgICAgICAgYXdhaXQgKDAsIGhlbHBlcnNfMS5zZXRJdGVtQXN5bmMpKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCBjbG9uZWRNYWluU2Vzc2lvbkRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gdXNlclN0b3JhZ2UgaXMgY29uZmlndXJlZC5cbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgc2Vzc2lvbi51c2VyIHNob3VsZCBpZGVhbGx5IG5vdCBiZSBhIHByb3h5LlxuICAgICAgICAgICAgLy8gSWYgaXQgd2VyZSwgc3RydWN0dXJlZENsb25lIHdvdWxkIGZhaWwuIFRoaXMgaW1wbGllcyBhbiBpc3N1ZSBlbHNld2hlcmUgaWYgdXNlciBpcyBhIHByb3h5IGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZFNlc3Npb24gPSAoMCwgaGVscGVyc18xLmRlZXBDbG9uZSkoc2Vzc2lvblRvUHJvY2Vzcyk7IC8vIHNlc3Npb25Ub1Byb2Nlc3Mgc3RpbGwgaGFzIGl0cyBvcmlnaW5hbCB1c2VyIHByb3BlcnR5XG4gICAgICAgICAgICBhd2FpdCAoMCwgaGVscGVyc18xLnNldEl0ZW1Bc3luYykodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXksIGNsb25lZFNlc3Npb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9yZW1vdmVTZXNzaW9uKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19yZW1vdmVTZXNzaW9uKCknKTtcbiAgICAgICAgdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gZmFsc2U7XG4gICAgICAgIGF3YWl0ICgwLCBoZWxwZXJzXzEucmVtb3ZlSXRlbUFzeW5jKSh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgIGF3YWl0ICgwLCBoZWxwZXJzXzEucmVtb3ZlSXRlbUFzeW5jKSh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctY29kZS12ZXJpZmllcicpO1xuICAgICAgICBhd2FpdCAoMCwgaGVscGVyc18xLnJlbW92ZUl0ZW1Bc3luYykodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInKTtcbiAgICAgICAgaWYgKHRoaXMudXNlclN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGF3YWl0ICgwLCBoZWxwZXJzXzEucmVtb3ZlSXRlbUFzeW5jKSh0aGlzLnVzZXJTdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX09VVCcsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFueSByZWdpc3RlcmVkIHZpc2liaWxpdHljaGFuZ2UgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiB7QHNlZSAjc3RhcnRBdXRvUmVmcmVzaH1cbiAgICAgKiB7QHNlZSAjc3RvcEF1dG9SZWZyZXNofVxuICAgICAqL1xuICAgIF9yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKCknKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgKDAsIGhlbHBlcnNfMS5pc0Jyb3dzZXIpKCkgJiYgKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZW1vdmluZyB2aXNpYmlsaXR5Y2hhbmdlIGNhbGxiYWNrIGZhaWxlZCcsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIHByaXZhdGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rICNzdGFydEF1dG9SZWZyZXNofS4gVXNlIHRoaXNcbiAgICAgKiB3aXRoaW4gdGhlIGxpYnJhcnkuXG4gICAgICovXG4gICAgYXN5bmMgX3N0YXJ0QXV0b1JlZnJlc2goKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0b3BBdXRvUmVmcmVzaCgpO1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19zdGFydEF1dG9SZWZyZXNoKCknKTtcbiAgICAgICAgY29uc3QgdGlja2VyID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5fYXV0b1JlZnJlc2hUb2tlblRpY2soKSwgY29uc3RhbnRzXzEuQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMpO1xuICAgICAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gdGlja2VyO1xuICAgICAgICBpZiAodGlja2VyICYmIHR5cGVvZiB0aWNrZXIgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aWNrZXIudW5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIHRpY2tlciBpcyBhIE5vZGVKUyBUaW1lb3V0IG9iamVjdCB0aGF0IGhhcyBhbiBgdW5yZWZgIG1ldGhvZFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lb3V0dW5yZWZcbiAgICAgICAgICAgIC8vIFdoZW4gYXV0byByZWZyZXNoIGlzIHVzZWQgaW4gTm9kZUpTIChsaWtlIGZvciB0ZXN0aW5nKSB0aGVcbiAgICAgICAgICAgIC8vIGBzZXRJbnRlcnZhbGAgaXMgcHJldmVudGluZyB0aGUgcHJvY2VzcyBmcm9tIGJlaW5nIG1hcmtlZCBhc1xuICAgICAgICAgICAgLy8gZmluaXNoZWQgYW5kIHRlc3RzIHJ1biBlbmRsZXNzbHkuIFRoaXMgY2FuIGJlIHByZXZlbnRlZCBieSBjYWxsaW5nXG4gICAgICAgICAgICAvLyBgdW5yZWYoKWAgb24gdGhlIHJldHVybmVkIG9iamVjdC5cbiAgICAgICAgICAgIHRpY2tlci51bnJlZigpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBoYXMgbm8gY29udGV4dCBvZiBEZW5vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBEZW5vLnVucmVmVGltZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIHNpbWlsYXIgbGlrZSBmb3IgTm9kZUpTLCBidXQgd2l0aCB0aGUgRGVubyBBUElcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGVuby5sYW5kL2FwaUBsYXRlc3Q/dW5zdGFibGUmcz1EZW5vLnVucmVmVGltZXJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgaGFzIG5vIGNvbnRleHQgb2YgRGVub1xuICAgICAgICAgICAgRGVuby51bnJlZlRpbWVyKHRpY2tlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcnVuIHRoZSB0aWNrIGltbWVkaWF0ZWx5LCBidXQgaW4gdGhlIG5leHQgcGFzcyBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0XG4gICAgICAgIC8vICNfaW5pdGlhbGl6ZSBjYW4gYmUgYWxsb3dlZCB0byBjb21wbGV0ZSB3aXRob3V0IHJlY3Vyc2l2ZWx5IHdhaXRpbmcgb25cbiAgICAgICAgLy8gaXRzZWxmXG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hdXRvUmVmcmVzaFRva2VuVGljaygpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tUaW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgaWYgKHRpbWVvdXQgJiYgdHlwZW9mIHRpbWVvdXQgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aW1lb3V0LnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aW1lb3V0LnVucmVmKCk7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGhhcyBubyBjb250ZXh0IG9mIERlbm9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIERlbm8udW5yZWZUaW1lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBoYXMgbm8gY29udGV4dCBvZiBEZW5vXG4gICAgICAgICAgICBEZW5vLnVucmVmVGltZXIodGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgcHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgI3N0b3BBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGFzeW5jIF9zdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3N0b3BBdXRvUmVmcmVzaCgpJyk7XG4gICAgICAgIGNvbnN0IHRpY2tlciA9IHRoaXMuYXV0b1JlZnJlc2hUaWNrZXI7XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrZXIgPSBudWxsO1xuICAgICAgICBpZiAodGlja2VyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpY2tlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuYXV0b1JlZnJlc2hUaWNrVGltZW91dDtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYW4gYXV0by1yZWZyZXNoIHByb2Nlc3MgaW4gdGhlIGJhY2tncm91bmQuIFRoZSBzZXNzaW9uIGlzIGNoZWNrZWRcbiAgICAgKiBldmVyeSBmZXcgc2Vjb25kcy4gQ2xvc2UgdG8gdGhlIHRpbWUgb2YgZXhwaXJhdGlvbiBhIHByb2Nlc3MgaXMgc3RhcnRlZCB0b1xuICAgICAqIHJlZnJlc2ggdGhlIHNlc3Npb24uIElmIHJlZnJlc2hpbmcgZmFpbHMgaXQgd2lsbCBiZSByZXRyaWVkIGZvciBhcyBsb25nIGFzXG4gICAgICogbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogSWYgeW91IHNldCB0aGUge0BsaW5rIEdvVHJ1ZUNsaWVudE9wdGlvbnMjYXV0b1JlZnJlc2hUb2tlbn0geW91IGRvbid0IG5lZWRcbiAgICAgKiB0byBjYWxsIHRoaXMgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIGZvciB5b3UuXG4gICAgICpcbiAgICAgKiBPbiBicm93c2VycyB0aGUgcmVmcmVzaCBwcm9jZXNzIHdvcmtzIG9ubHkgd2hlbiB0aGUgdGFiL3dpbmRvdyBpcyBpbiB0aGVcbiAgICAgKiBmb3JlZ3JvdW5kIHRvIGNvbnNlcnZlIHJlc291cmNlcyBhcyB3ZWxsIGFzIHByZXZlbnQgcmFjZSBjb25kaXRpb25zIGFuZFxuICAgICAqIGZsb29kaW5nIGF1dGggd2l0aCByZXF1ZXN0cy4gSWYgeW91IGNhbGwgdGhpcyBtZXRob2QgYW55IG1hbmFnZWRcbiAgICAgKiB2aXNpYmlsaXR5IGNoYW5nZSBjYWxsYmFjayB3aWxsIGJlIHJlbW92ZWQgYW5kIHlvdSBtdXN0IG1hbmFnZSB2aXNpYmlsaXR5XG4gICAgICogY2hhbmdlcyBvbiB5b3VyIG93bi5cbiAgICAgKlxuICAgICAqIE9uIG5vbi1icm93c2VyIHBsYXRmb3JtcyB0aGUgcmVmcmVzaCBwcm9jZXNzIHdvcmtzICpjb250aW51b3VzbHkqIGluIHRoZVxuICAgICAqIGJhY2tncm91bmQsIHdoaWNoIG1heSBub3QgYmUgZGVzaXJhYmxlLiBZb3Ugc2hvdWxkIGhvb2sgaW50byB5b3VyXG4gICAgICogcGxhdGZvcm0ncyBmb3JlZ3JvdW5kIGluZGljYXRpb24gbWVjaGFuaXNtIGFuZCBjYWxsIHRoZXNlIG1ldGhvZHNcbiAgICAgKiBhcHByb3ByaWF0ZWx5IHRvIGNvbnNlcnZlIHJlc291cmNlcy5cbiAgICAgKlxuICAgICAqIHtAc2VlICNzdG9wQXV0b1JlZnJlc2h9XG4gICAgICovXG4gICAgYXN5bmMgc3RhcnRBdXRvUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpO1xuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydEF1dG9SZWZyZXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFuIGFjdGl2ZSBhdXRvIHJlZnJlc2ggcHJvY2VzcyBydW5uaW5nIGluIHRoZSBiYWNrZ3JvdW5kIChpZiBhbnkpLlxuICAgICAqXG4gICAgICogSWYgeW91IGNhbGwgdGhpcyBtZXRob2QgYW55IG1hbmFnZWQgdmlzaWJpbGl0eSBjaGFuZ2UgY2FsbGJhY2sgd2lsbCBiZVxuICAgICAqIHJlbW92ZWQgYW5kIHlvdSBtdXN0IG1hbmFnZSB2aXNpYmlsaXR5IGNoYW5nZXMgb24geW91ciBvd24uXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rICNzdGFydEF1dG9SZWZyZXNofSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHN0b3BBdXRvUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpO1xuICAgICAgICBhd2FpdCB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgYXV0byByZWZyZXNoIHRva2VuIHRpY2suXG4gICAgICovXG4gICAgYXN5bmMgX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygwLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbiB8fCAhc2Vzc2lvbi5yZWZyZXNoX3Rva2VuIHx8ICFzZXNzaW9uLmV4cGlyZXNfYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdubyBzZXNzaW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2Vzc2lvbiB3aWxsIGV4cGlyZSBpbiB0aGlzIG1hbnkgdGlja3MgKG9yIGhhcyBhbHJlYWR5IGV4cGlyZWQgaWYgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBpcmVzSW5UaWNrcyA9IE1hdGguZmxvb3IoKHNlc3Npb24uZXhwaXJlc19hdCAqIDEwMDAgLSBub3cpIC8gY29uc3RhbnRzXzEuQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCBgYWNjZXNzIHRva2VuIGV4cGlyZXMgaW4gJHtleHBpcmVzSW5UaWNrc30gdGlja3MsIGEgdGljayBsYXN0cyAke2NvbnN0YW50c18xLkFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TfW1zLCByZWZyZXNoIHRocmVzaG9sZCBpcyAke2NvbnN0YW50c18xLkFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRH0gdGlja3NgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwaXJlc0luVGlja3MgPD0gY29uc3RhbnRzXzEuQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oc2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQXV0byByZWZyZXNoIHRpY2sgZmFpbGVkIHdpdGggZXJyb3IuIFRoaXMgaXMgbGlrZWx5IGEgdHJhbnNpZW50IGVycm9yLicsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgJ2VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5pc0FjcXVpcmVUaW1lb3V0IHx8IGUgaW5zdGFuY2VvZiBsb2Nrc18xLkxvY2tBY3F1aXJlVGltZW91dEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ2F1dG8gcmVmcmVzaCB0b2tlbiB0aWNrIGxvY2sgbm90IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIG9uIHRoZSBicm93c2VyIC8gcGxhdGZvcm0sIHdoaWNoIGluLXR1cm4gcnVuXG4gICAgICogYWxnb3JpdGhtcyB3aGVuIHRoZSBicm93c2VyIHdpbmRvdy90YWIgYXJlIGluIGZvcmVncm91bmQuIE9uIG5vbi1icm93c2VyXG4gICAgICogcGxhdGZvcm1zIGl0IGFzc3VtZXMgYWx3YXlzIGZvcmVncm91bmQuXG4gICAgICovXG4gICAgYXN5bmMgX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKScpO1xuICAgICAgICBpZiAoISgwLCBoZWxwZXJzXzEuaXNCcm93c2VyKSgpIHx8ICEod2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzIHRoZSByZWZyZXNoIHRva2VuIHRpY2tlciBydW5zIGFsd2F5c1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRBdXRvUmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2sgPSBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2VkKGZhbHNlKTtcbiAgICAgICAgICAgIHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKTtcbiAgICAgICAgICAgIC8vIG5vdyBpbW1lZGlhdGVseSBjYWxsIHRoZSB2aXNiaWxpdHkgY2hhbmdlZCBjYWxsYmFjayB0byBzZXR1cCB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCB2aXNiaWxpdHkgc3RhdGVcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZWQodHJ1ZSk7IC8vIGluaXRpYWwgY2FsbFxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UnLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgcmVnaXN0ZXJlZCB3aXRoIGB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScpYC5cbiAgICAgKi9cbiAgICBhc3luYyBfb25WaXNpYmlsaXR5Q2hhbmdlZChjYWxsZWRGcm9tSW5pdGlhbGl6ZSkge1xuICAgICAgICBjb25zdCBtZXRob2ROYW1lID0gYCNfb25WaXNpYmlsaXR5Q2hhbmdlZCgke2NhbGxlZEZyb21Jbml0aWFsaXplfSlgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhtZXRob2ROYW1lLCAndmlzaWJpbGl0eVN0YXRlJywgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlKTtcbiAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gYnJvd3NlciBlbnZpcm9ubWVudHMgdGhlIHJlZnJlc2ggdG9rZW4gdGlja2VyIHJ1bnMgb25seSBvbiBmb2N1c2VkIHRhYnNcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBwcmV2ZW50cyByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydEF1dG9SZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNhbGxlZEZyb21Jbml0aWFsaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbGVkIHdoZW4gdGhlIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQsIGkuZS4gdGhlIGJyb3dzZXJcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2l0aW9uZWQgZnJvbSBoaWRkZW4gLT4gdmlzaWJsZSBzbyB3ZSBuZWVkIHRvIHNlZSBpZiB0aGUgc2Vzc2lvblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSByZWNvdmVyZWQgaW1tZWRpYXRlbHkuLi4gYnV0IHRvIGRvIHRoYXQgd2UgbmVlZCB0byBhY3F1aXJlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxvY2sgZmlyc3QgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgIT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcobWV0aG9kTmFtZSwgJ2FjcXVpcmVkIHRoZSBsb2NrIHRvIHJlY292ZXIgdGhlIHNlc3Npb24sIGJ1dCB0aGUgYnJvd3NlciB2aXNpYmlsaXR5U3RhdGUgaXMgbm8gbG9uZ2VyIHZpc2libGUsIGFib3J0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBsb2NrLCBhYm9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY292ZXIgdGhlIHNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVjb3ZlckFuZFJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSByZWxldmFudCBsb2dpbiBVUkwgZm9yIGEgdGhpcmQtcGFydHkgcHJvdmlkZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBBIFVSTCBvciBtb2JpbGUgYWRkcmVzcyB0byBzZW5kIHRoZSB1c2VyIHRvIGFmdGVyIHRoZXkgYXJlIGNvbmZpcm1lZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zY29wZXMgQSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiBzY29wZXMgZ3JhbnRlZCB0byB0aGUgT0F1dGggYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMucXVlcnlQYXJhbXMgQW4gb2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyBjb250YWluaW5nIHF1ZXJ5IHBhcmFtZXRlcnMgZ3JhbnRlZCB0byB0aGUgT0F1dGggYXBwbGljYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgX2dldFVybEZvclByb3ZpZGVyKHVybCwgcHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gW2Bwcm92aWRlcj0ke2VuY29kZVVSSUNvbXBvbmVudChwcm92aWRlcil9YF07XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVkaXJlY3RUbykge1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2goYHJlZGlyZWN0X3RvPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMucmVkaXJlY3RUbyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY29wZXMpIHtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKGBzY29wZXM9JHtlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5zY29wZXMpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgIGNvbnN0IFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0ICgwLCBoZWxwZXJzXzEuZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCkodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgY29uc3QgZmxvd1BhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBgJHtlbmNvZGVVUklDb21wb25lbnQoY29kZUNoYWxsZW5nZSl9YCxcbiAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGAke2VuY29kZVVSSUNvbXBvbmVudChjb2RlQ2hhbGxlbmdlTWV0aG9kKX1gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChmbG93UGFyYW1zLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zLnF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKHF1ZXJ5LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2tpcEJyb3dzZXJSZWRpcmVjdCkge1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2goYHNraXBfaHR0cF9yZWRpcmVjdD0ke29wdGlvbnMuc2tpcEJyb3dzZXJSZWRpcmVjdH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dXJsfT8ke3VybFBhcmFtcy5qb2luKCcmJyl9YDtcbiAgICB9XG4gICAgYXN5bmMgX3VuZW5yb2xsKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9hID0gc2Vzc2lvbkRhdGEgPT09IG51bGwgfHwgc2Vzc2lvbkRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25EYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9lbnJvbGwocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IE9iamVjdC5hc3NpZ24oeyBmcmllbmRseV9uYW1lOiBwYXJhbXMuZnJpZW5kbHlOYW1lLCBmYWN0b3JfdHlwZTogcGFyYW1zLmZhY3RvclR5cGUgfSwgKHBhcmFtcy5mYWN0b3JUeXBlID09PSAncGhvbmUnXG4gICAgICAgICAgICAgICAgICAgID8geyBwaG9uZTogcGFyYW1zLnBob25lIH1cbiAgICAgICAgICAgICAgICAgICAgOiBwYXJhbXMuZmFjdG9yVHlwZSA9PT0gJ3RvdHAnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgaXNzdWVyOiBwYXJhbXMuaXNzdWVyIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDoge30pKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSAoYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ZhY3RvcnNgLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2EgPSBzZXNzaW9uRGF0YSA9PT0gbnVsbCB8fCBzZXNzaW9uRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbkRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5mYWN0b3JUeXBlID09PSAndG90cCcgJiYgZGF0YS50eXBlID09PSAndG90cCcgJiYgKChfYiA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS50b3RwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucXJfY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50b3RwLnFyX2NvZGUgPSBgZGF0YTppbWFnZS9zdmcreG1sO3V0Zi04LCR7ZGF0YS50b3RwLnFyX2NvZGV9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGEsIGVycm9yOiBudWxsIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfdmVyaWZ5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IE9iamVjdC5hc3NpZ24oeyBjaGFsbGVuZ2VfaWQ6IHBhcmFtcy5jaGFsbGVuZ2VJZCB9LCAoJ3dlYmF1dGhuJyBpbiBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYmF1dGhuOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcy53ZWJhdXRobiksIHsgY3JlZGVudGlhbF9yZXNwb25zZTogcGFyYW1zLndlYmF1dGhuLnR5cGUgPT09ICdjcmVhdGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICgwLCB3ZWJhdXRobl8xLnNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvblJlc3BvbnNlKShwYXJhbXMud2ViYXV0aG4uY3JlZGVudGlhbF9yZXNwb25zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKDAsIHdlYmF1dGhuXzEuc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RSZXNwb25zZSkocGFyYW1zLndlYmF1dGhuLmNyZWRlbnRpYWxfcmVzcG9uc2UpIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IGNvZGU6IHBhcmFtcy5jb2RlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9L3ZlcmlmeWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oT2JqZWN0LmFzc2lnbih7IGV4cGlyZXNfYXQ6IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApICsgZGF0YS5leHBpcmVzX2luIH0sIGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ01GQV9DSEFMTEVOR0VfVkVSSUZJRUQnLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGEsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfY2hhbGxlbmdlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9L2NoYWxsZW5nZWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGp3dDogKF9hID0gc2Vzc2lvbkRhdGEgPT09IG51bGwgfHwgc2Vzc2lvbkRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25EYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEudHlwZSAhPT0gJ3dlYmF1dGhuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGRhdGEud2ViYXV0aG4udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY3JlYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IHdlYmF1dGhuOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEud2ViYXV0aG4pLCB7IGNyZWRlbnRpYWxfb3B0aW9uczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucyksIHsgcHVibGljS2V5OiAoMCwgd2ViYXV0aG5fMS5kZXNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMpKGRhdGEud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zLnB1YmxpY0tleSkgfSkgfSkgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXF1ZXN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IHdlYmF1dGhuOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEud2ViYXV0aG4pLCB7IGNyZWRlbnRpYWxfb3B0aW9uczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucyksIHsgcHVibGljS2V5OiAoMCwgd2ViYXV0aG5fMS5kZXNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucykoZGF0YS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMucHVibGljS2V5KSB9KSB9KSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBlcnJvcnNfMS5pc0F1dGhFcnJvcikoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjY2hhbGxlbmdlQW5kVmVyaWZ5fVxuICAgICAqL1xuICAgIGFzeW5jIF9jaGFsbGVuZ2VBbmRWZXJpZnkocGFyYW1zKSB7XG4gICAgICAgIC8vIGJvdGggX2NoYWxsZW5nZSBhbmQgX3ZlcmlmeSBpbmRlcGVuZGVudGx5IGFjcXVpcmUgdGhlIGxvY2ssIHNvIG5vIG5lZWRcbiAgICAgICAgLy8gdG8gYWNxdWlyZSBpdCBoZXJlXG4gICAgICAgIGNvbnN0IHsgZGF0YTogY2hhbGxlbmdlRGF0YSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLl9jaGFsbGVuZ2Uoe1xuICAgICAgICAgICAgZmFjdG9ySWQ6IHBhcmFtcy5mYWN0b3JJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjaGFsbGVuZ2VFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdmVyaWZ5KHtcbiAgICAgICAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlRGF0YS5pZCxcbiAgICAgICAgICAgIGNvZGU6IHBhcmFtcy5jb2RlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI2xpc3RGYWN0b3JzfVxuICAgICAqL1xuICAgIGFzeW5jIF9saXN0RmFjdG9ycygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyB1c2UgI2dldFVzZXIgaW5zdGVhZCBvZiAjX2dldFVzZXIgYXMgdGhlIGZvcm1lciBhY3F1aXJlcyBhIGxvY2tcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IHVzZXJFcnJvciwgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcigpO1xuICAgICAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogdXNlckVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGFsbDogW10sXG4gICAgICAgICAgICBwaG9uZTogW10sXG4gICAgICAgICAgICB0b3RwOiBbXSxcbiAgICAgICAgICAgIHdlYmF1dGhuOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gbG9vcCBvdmVyIHRoZSBmYWN0b3JzIE9OQ0VcbiAgICAgICAgZm9yIChjb25zdCBmYWN0b3Igb2YgKF9hID0gdXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLmZhY3RvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSB7XG4gICAgICAgICAgICBkYXRhLmFsbC5wdXNoKGZhY3Rvcik7XG4gICAgICAgICAgICBpZiAoZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJykge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBkYXRhW2ZhY3Rvci5mYWN0b3JfdHlwZV0ucHVzaChmYWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWx9XG4gICAgICovXG4gICAgYXN5bmMgX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciwgfSA9IGF3YWl0IHRoaXMuZ2V0U2Vzc2lvbigpO1xuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBjdXJyZW50TGV2ZWw6IG51bGwsIG5leHRMZXZlbDogbnVsbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kczogW10gfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSAoMCwgaGVscGVyc18xLmRlY29kZUpXVCkoc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICBsZXQgY3VycmVudExldmVsID0gbnVsbDtcbiAgICAgICAgaWYgKHBheWxvYWQuYWFsKSB7XG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBwYXlsb2FkLmFhbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dExldmVsID0gY3VycmVudExldmVsO1xuICAgICAgICBjb25zdCB2ZXJpZmllZEZhY3RvcnMgPSAoX2IgPSAoX2EgPSBzZXNzaW9uLnVzZXIuZmFjdG9ycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcigoZmFjdG9yKSA9PiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgICAgIGlmICh2ZXJpZmllZEZhY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbmV4dExldmVsID0gJ2FhbDInO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgPSBwYXlsb2FkLmFtciB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBjdXJyZW50TGV2ZWwsIG5leHRMZXZlbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyB9LCBlcnJvcjogbnVsbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgZGV0YWlscyBhYm91dCBhbiBPQXV0aCBhdXRob3JpemF0aW9uIHJlcXVlc3QuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYXV0aG9yaXphdGlvbiBkZXRhaWxzIGluY2x1ZGluZyBjbGllbnQgaW5mbywgc2NvcGVzLCBhbmQgdXNlciBpbmZvcm1hdGlvbi5cbiAgICAgKiBJZiB0aGUgQVBJIHJldHVybnMgYSByZWRpcmVjdF91cmksIGl0IG1lYW5zIGNvbnNlbnQgd2FzIGFscmVhZHkgZ2l2ZW4gLSB0aGUgY2FsbGVyXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgcmVkaXJlY3QgbWFudWFsbHkgaWYgbmVlZGVkLlxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRBdXRob3JpemF0aW9uRGV0YWlscyhhdXRob3JpemF0aW9uSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IG5ldyBlcnJvcnNfMS5BdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgKDAsIGZldGNoXzEuX3JlcXVlc3QpKHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vb2F1dGgvYXV0aG9yaXphdGlvbnMvJHthdXRob3JpemF0aW9uSWR9YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiAoZGF0YSkgPT4gKHsgZGF0YSwgZXJyb3I6IG51bGwgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcHJvdmVzIGFuIE9BdXRoIGF1dGhvcml6YXRpb24gcmVxdWVzdC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqL1xuICAgIGFzeW5jIF9hcHByb3ZlQXV0aG9yaXphdGlvbihhdXRob3JpemF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IG5ldyBlcnJvcnNfMS5BdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vYXV0aC9hdXRob3JpemF0aW9ucy8ke2F1dGhvcml6YXRpb25JZH0vY29uc2VudGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7IGFjdGlvbjogJ2FwcHJvdmUnIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiAoZGF0YSkgPT4gKHsgZGF0YSwgZXJyb3I6IG51bGwgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEgJiYgcmVzcG9uc2UuZGF0YS5yZWRpcmVjdF91cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXV0b21hdGljYWxseSByZWRpcmVjdCBpbiBicm93c2VyIHVubGVzcyBza2lwQnJvd3NlclJlZGlyZWN0IGlzIHRydWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBoZWxwZXJzXzEuaXNCcm93c2VyKSgpICYmICEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHJlc3BvbnNlLmRhdGEucmVkaXJlY3RfdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbmllcyBhbiBPQXV0aCBhdXRob3JpemF0aW9uIHJlcXVlc3QuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKi9cbiAgICBhc3luYyBfZGVueUF1dGhvcml6YXRpb24oYXV0aG9yaXphdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBuZXcgZXJyb3JzXzEuQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vb2F1dGgvYXV0aG9yaXphdGlvbnMvJHthdXRob3JpemF0aW9uSWR9L2NvbnNlbnRgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYm9keTogeyBhY3Rpb246ICdkZW55JyB9LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogKGRhdGEpID0+ICh7IGRhdGEsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhICYmIHJlc3BvbnNlLmRhdGEucmVkaXJlY3RfdXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVkaXJlY3QgaW4gYnJvd3NlciB1bmxlc3Mgc2tpcEJyb3dzZXJSZWRpcmVjdCBpcyB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaGVscGVyc18xLmlzQnJvd3NlcikoKSAmJiAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihyZXNwb25zZS5kYXRhLnJlZGlyZWN0X3VybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgT0F1dGggZ3JhbnRzIHRoYXQgdGhlIGF1dGhlbnRpY2F0ZWQgdXNlciBoYXMgYXV0aG9yaXplZC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqL1xuICAgIGFzeW5jIF9saXN0T0F1dGhHcmFudHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBuZXcgZXJyb3JzXzEuQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L3VzZXIvb2F1dGgvZ3JhbnRzYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiAoZGF0YSkgPT4gKHsgZGF0YSwgZXJyb3I6IG51bGwgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldm9rZXMgYSB1c2VyJ3MgT0F1dGggZ3JhbnQgZm9yIGEgc3BlY2lmaWMgY2xpZW50LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICovXG4gICAgYXN5bmMgX3Jldm9rZU9BdXRoR3JhbnQob3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IsIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogbmV3IGVycm9yc18xLkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0ICgwLCBmZXRjaF8xLl9yZXF1ZXN0KSh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L3VzZXIvb2F1dGgvZ3JhbnRzYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7IGNsaWVudF9pZDogb3B0aW9ucy5jbGllbnRJZCB9LFxuICAgICAgICAgICAgICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHt9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmZXRjaEp3ayhraWQsIGp3a3MgPSB7IGtleXM6IFtdIH0pIHtcbiAgICAgICAgLy8gdHJ5IGZldGNoaW5nIGZyb20gdGhlIHN1cHBsaWVkIGp3a3NcbiAgICAgICAgbGV0IGp3ayA9IGp3a3Mua2V5cy5maW5kKChrZXkpID0+IGtleS5raWQgPT09IGtpZCk7XG4gICAgICAgIGlmIChqd2spIHtcbiAgICAgICAgICAgIHJldHVybiBqd2s7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgLy8gdHJ5IGZldGNoaW5nIGZyb20gY2FjaGVcbiAgICAgICAgandrID0gdGhpcy5qd2tzLmtleXMuZmluZCgoa2V5KSA9PiBrZXkua2lkID09PSBraWQpO1xuICAgICAgICAvLyBqd2sgZXhpc3RzIGFuZCBqd2tzIGlzbid0IHN0YWxlXG4gICAgICAgIGlmIChqd2sgJiYgdGhpcy5qd2tzX2NhY2hlZF9hdCArIGNvbnN0YW50c18xLkpXS1NfVFRMID4gbm93KSB7XG4gICAgICAgICAgICByZXR1cm4gandrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGp3ayBpc24ndCBjYWNoZWQgaW4gbWVtb3J5IHNvIHdlIG5lZWQgdG8gZmV0Y2ggaXQgZnJvbSB0aGUgd2VsbC1rbm93biBlbmRwb2ludFxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCAoMCwgZmV0Y2hfMS5fcmVxdWVzdCkodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS8ud2VsbC1rbm93bi9qd2tzLmpzb25gLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YS5rZXlzIHx8IGRhdGEua2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuandrcyA9IGRhdGE7XG4gICAgICAgIHRoaXMuandrc19jYWNoZWRfYXQgPSBub3c7XG4gICAgICAgIC8vIEZpbmQgdGhlIHNpZ25pbmcga2V5XG4gICAgICAgIGp3ayA9IGRhdGEua2V5cy5maW5kKChrZXkpID0+IGtleS5raWQgPT09IGtpZCk7XG4gICAgICAgIGlmICghandrKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gandrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgSldUIGNsYWltcyBwcmVzZW50IGluIHRoZSBhY2Nlc3MgdG9rZW4gYnkgZmlyc3QgdmVyaWZ5aW5nIHRoZVxuICAgICAqIEpXVCBhZ2FpbnN0IHRoZSBzZXJ2ZXIncyBKU09OIFdlYiBLZXkgU2V0IGVuZHBvaW50XG4gICAgICogYC8ud2VsbC1rbm93bi9qd2tzLmpzb25gIHdoaWNoIGlzIG9mdGVuIGNhY2hlZCwgcmVzdWx0aW5nIGluIHNpZ25pZmljYW50bHlcbiAgICAgKiBmYXN0ZXIgcmVzcG9uc2VzLiBQcmVmZXIgdGhpcyBtZXRob2Qgb3ZlciB7QGxpbmsgI2dldFVzZXJ9IHdoaWNoIGFsd2F5c1xuICAgICAqIHNlbmRzIGEgcmVxdWVzdCB0byB0aGUgQXV0aCBzZXJ2ZXIgZm9yIGVhY2ggSldULlxuICAgICAqXG4gICAgICogSWYgdGhlIHByb2plY3QgaXMgbm90IHVzaW5nIGFuIGFzeW1tZXRyaWMgSldUIHNpZ25pbmcga2V5IChsaWtlIEVDQyBvclxuICAgICAqIFJTQSkgaXQgYWx3YXlzIHNlbmRzIGEgcmVxdWVzdCB0byB0aGUgQXV0aCBzZXJ2ZXIgKHNpbWlsYXIgdG8ge0BsaW5rXG4gICAgICogI2dldFVzZXJ9KSB0byB2ZXJpZnkgdGhlIEpXVC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqd3QgQW4gb3B0aW9uYWwgc3BlY2lmaWMgSldUIHlvdSB3aXNoIHRvIHZlcmlmeSwgbm90IHRoZSBvbmUgeW91XG4gICAgICogICAgICAgICAgICBjYW4gb2J0YWluIGZyb20ge0BsaW5rICNnZXRTZXNzaW9ufS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBWYXJpb3VzIGFkZGl0aW9uYWwgb3B0aW9ucyB0aGF0IGFsbG93IHlvdSB0byBjdXN0b21pemUgdGhlXG4gICAgICogICAgICAgICAgICAgICAgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q2xhaW1zKGp3dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSBqd3Q7XG4gICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5nZXRTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIHx8ICFkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbiA9IGRhdGEuc2Vzc2lvbi5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGhlYWRlciwgcGF5bG9hZCwgc2lnbmF0dXJlLCByYXc6IHsgaGVhZGVyOiByYXdIZWFkZXIsIHBheWxvYWQ6IHJhd1BheWxvYWQgfSwgfSA9ICgwLCBoZWxwZXJzXzEuZGVjb2RlSldUKSh0b2tlbik7XG4gICAgICAgICAgICBpZiAoIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWxsb3dFeHBpcmVkKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlamVjdCBleHBpcmVkIEpXVHMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIGp3dCBhcmd1bWVudCB3YXMgcGFzc2VkXG4gICAgICAgICAgICAgICAgKDAsIGhlbHBlcnNfMS52YWxpZGF0ZUV4cCkocGF5bG9hZC5leHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2lnbmluZ0tleSA9ICFoZWFkZXIuYWxnIHx8XG4gICAgICAgICAgICAgICAgaGVhZGVyLmFsZy5zdGFydHNXaXRoKCdIUycpIHx8XG4gICAgICAgICAgICAgICAgIWhlYWRlci5raWQgfHxcbiAgICAgICAgICAgICAgICAhKCdjcnlwdG8nIGluIGdsb2JhbFRoaXMgJiYgJ3N1YnRsZScgaW4gZ2xvYmFsVGhpcy5jcnlwdG8pXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBhd2FpdCB0aGlzLmZldGNoSndrKGhlYWRlci5raWQsIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMua2V5cykgPyB7IGtleXM6IG9wdGlvbnMua2V5cyB9IDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmp3a3MpO1xuICAgICAgICAgICAgLy8gSWYgc3ltbWV0cmljIGFsZ29yaXRobSBvciBXZWJDcnlwdG8gQVBJIGlzIHVuYXZhaWxhYmxlLCBmYWxsYmFjayB0byBnZXRVc2VyKClcbiAgICAgICAgICAgIGlmICghc2lnbmluZ0tleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcih0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBnZXRVc2VyIHN1Y2NlZWRzIHNvIHRoZSBjbGFpbXMgaW4gdGhlIEpXVCBjYW4gYmUgdHJ1c3RlZFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYWltczogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFsZ29yaXRobSA9ICgwLCBoZWxwZXJzXzEuZ2V0QWxnb3JpdGhtKShoZWFkZXIuYWxnKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgSldLIHRvIENyeXB0b0tleVxuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ2p3aycsIHNpZ25pbmdLZXksIGFsZ29yaXRobSwgdHJ1ZSwgW1xuICAgICAgICAgICAgICAgICd2ZXJpZnknLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhlIHNpZ25hdHVyZVxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUudmVyaWZ5KGFsZ29yaXRobSwgcHVibGljS2V5LCBzaWduYXR1cmUsICgwLCBiYXNlNjR1cmxfMS5zdHJpbmdUb1VpbnQ4QXJyYXkpKGAke3Jhd0hlYWRlcn0uJHtyYXdQYXlsb2FkfWApKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdXRoSW52YWxpZEp3dEVycm9yKCdJbnZhbGlkIEpXVCBzaWduYXR1cmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHZlcmlmaWNhdGlvbiBzdWNjZWVkcywgZGVjb2RlIGFuZCByZXR1cm4gY2xhaW1zXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhaW1zOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEID0ge307XG5leHBvcnRzLmRlZmF1bHQgPSBHb1RydWVDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Hb1RydWVDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidHNsaWJfMSIsInJlcXVpcmUiLCJHb1RydWVBZG1pbkFwaV8xIiwiX19pbXBvcnREZWZhdWx0IiwiY29uc3RhbnRzXzEiLCJlcnJvcnNfMSIsImZldGNoXzEiLCJoZWxwZXJzXzEiLCJsb2NhbF9zdG9yYWdlXzEiLCJsb2Nrc18xIiwicG9seWZpbGxzXzEiLCJ2ZXJzaW9uXzEiLCJiYXNlNjR1cmxfMSIsImV0aGVyZXVtXzEiLCJ3ZWJhdXRobl8xIiwicG9seWZpbGxHbG9iYWxUaGlzIiwiREVGQVVMVF9PUFRJT05TIiwidXJsIiwiR09UUlVFX1VSTCIsInN0b3JhZ2VLZXkiLCJTVE9SQUdFX0tFWSIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsImRldGVjdFNlc3Npb25JblVybCIsImhlYWRlcnMiLCJERUZBVUxUX0hFQURFUlMiLCJmbG93VHlwZSIsImRlYnVnIiwiaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciIsInRocm93T25FcnJvciIsImxvY2tBY3F1aXJlVGltZW91dCIsImxvY2tOb09wIiwibmFtZSIsImFjcXVpcmVUaW1lb3V0IiwiZm4iLCJHTE9CQUxfSldLUyIsIkdvVHJ1ZUNsaWVudCIsImp3a3MiLCJfYSIsIl9iIiwia2V5cyIsImFzc2lnbiIsImp3a3NfY2FjaGVkX2F0IiwiY2FjaGVkQXQiLCJOdW1iZXIiLCJNSU5fU0FGRV9JTlRFR0VSIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX2MiLCJ1c2VyU3RvcmFnZSIsIm1lbW9yeVN0b3JhZ2UiLCJzdGF0ZUNoYW5nZUVtaXR0ZXJzIiwiTWFwIiwiYXV0b1JlZnJlc2hUaWNrZXIiLCJhdXRvUmVmcmVzaFRpY2tUaW1lb3V0IiwidmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayIsInJlZnJlc2hpbmdEZWZlcnJlZCIsImluaXRpYWxpemVQcm9taXNlIiwic3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyIsImxvY2tBY3F1aXJlZCIsInBlbmRpbmdJbkxvY2siLCJicm9hZGNhc3RDaGFubmVsIiwibG9nZ2VyIiwiY29uc29sZSIsImxvZyIsInNldHRpbmdzIiwiaW5zdGFuY2VJRCIsIm5leHRJbnN0YW5jZUlEIiwibG9nRGVidWdNZXNzYWdlcyIsImlzQnJvd3NlciIsIm1lc3NhZ2UiLCJfbG9nUHJlZml4Iiwid2FybiIsInRyYWNlIiwiYWRtaW4iLCJkZWZhdWx0IiwiZmV0Y2giLCJyZXNvbHZlRmV0Y2giLCJsb2NrIiwiZ2xvYmFsVGhpcyIsIm5hdmlnYXRvciIsImxvY2tzIiwibmF2aWdhdG9yTG9jayIsIm1mYSIsInZlcmlmeSIsIl92ZXJpZnkiLCJiaW5kIiwiZW5yb2xsIiwiX2Vucm9sbCIsInVuZW5yb2xsIiwiX3VuZW5yb2xsIiwiY2hhbGxlbmdlIiwiX2NoYWxsZW5nZSIsImxpc3RGYWN0b3JzIiwiX2xpc3RGYWN0b3JzIiwiY2hhbGxlbmdlQW5kVmVyaWZ5IiwiX2NoYWxsZW5nZUFuZFZlcmlmeSIsImdldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbCIsIl9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwiLCJ3ZWJhdXRobiIsIldlYkF1dGhuQXBpIiwib2F1dGgiLCJnZXRBdXRob3JpemF0aW9uRGV0YWlscyIsIl9nZXRBdXRob3JpemF0aW9uRGV0YWlscyIsImFwcHJvdmVBdXRob3JpemF0aW9uIiwiX2FwcHJvdmVBdXRob3JpemF0aW9uIiwiZGVueUF1dGhvcml6YXRpb24iLCJfZGVueUF1dGhvcml6YXRpb24iLCJsaXN0R3JhbnRzIiwiX2xpc3RPQXV0aEdyYW50cyIsInJldm9rZUdyYW50IiwiX3Jldm9rZU9BdXRoR3JhbnQiLCJzdG9yYWdlIiwic3VwcG9ydHNMb2NhbFN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2UiLCJtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyIiwiQnJvYWRjYXN0Q2hhbm5lbCIsImUiLCJlcnJvciIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIl9kZWJ1ZyIsIl9ub3RpZnlBbGxTdWJzY3JpYmVycyIsImRhdGEiLCJzZXNzaW9uIiwiaW5pdGlhbGl6ZSIsImlzVGhyb3dPbkVycm9yRW5hYmxlZCIsIl9yZXR1cm5SZXN1bHQiLCJyZXN1bHQiLCJ2ZXJzaW9uIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiYXJncyIsIl9hY3F1aXJlTG9jayIsIl9pbml0aWFsaXplIiwicGFyYW1zIiwiY2FsbGJhY2tVcmxUeXBlIiwicGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsIl9pc0ltcGxpY2l0R3JhbnRDYWxsYmFjayIsIl9pc1BLQ0VDYWxsYmFjayIsIl9nZXRTZXNzaW9uRnJvbVVSTCIsImlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIiwiZXJyb3JDb2RlIiwiZGV0YWlscyIsImNvZGUiLCJyZWRpcmVjdFR5cGUiLCJfc2F2ZVNlc3Npb24iLCJzZXRUaW1lb3V0IiwiX3JlY292ZXJBbmRSZWZyZXNoIiwiaXNBdXRoRXJyb3IiLCJBdXRoVW5rbm93bkVycm9yIiwiX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UiLCJzaWduSW5Bbm9ueW1vdXNseSIsImNyZWRlbnRpYWxzIiwicmVzIiwiX3JlcXVlc3QiLCJib2R5IiwiZ290cnVlX21ldGFfc2VjdXJpdHkiLCJjYXB0Y2hhX3Rva2VuIiwiY2FwdGNoYVRva2VuIiwieGZvcm0iLCJfc2Vzc2lvblJlc3BvbnNlIiwidXNlciIsInNpZ25VcCIsImVtYWlsIiwicGFzc3dvcmQiLCJjb2RlQ2hhbGxlbmdlIiwiY29kZUNoYWxsZW5nZU1ldGhvZCIsImdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QiLCJyZWRpcmVjdFRvIiwiZW1haWxSZWRpcmVjdFRvIiwiY29kZV9jaGFsbGVuZ2UiLCJjb2RlX2NoYWxsZW5nZV9tZXRob2QiLCJwaG9uZSIsImNoYW5uZWwiLCJBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IiLCJyZW1vdmVJdGVtQXN5bmMiLCJzaWduSW5XaXRoUGFzc3dvcmQiLCJfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQiLCJpbnZhbGlkVG9rZW5FcnJvciIsIkF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yIiwid2Vha19wYXNzd29yZCIsIndlYWtQYXNzd29yZCIsInNpZ25JbldpdGhPQXV0aCIsIl9kIiwiX2hhbmRsZVByb3ZpZGVyU2lnbkluIiwicHJvdmlkZXIiLCJzY29wZXMiLCJxdWVyeVBhcmFtcyIsInNraXBCcm93c2VyUmVkaXJlY3QiLCJleGNoYW5nZUNvZGVGb3JTZXNzaW9uIiwiYXV0aENvZGUiLCJfZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbiIsInNpZ25JbldpdGhXZWIzIiwiY2hhaW4iLCJzaWduSW5XaXRoRXRoZXJldW0iLCJzaWduSW5XaXRoU29sYW5hIiwiRXJyb3IiLCJfZSIsIl9mIiwiX2ciLCJfaCIsIl9qIiwiX2siLCJfbCIsInNpZ25hdHVyZSIsIndhbGxldCIsInN0YXRlbWVudCIsInJlc29sdmVkV2FsbGV0Iiwid2luZG93QW55IiwiZXRoZXJldW0iLCJyZXF1ZXN0IiwiVVJMIiwiYWNjb3VudHMiLCJtZXRob2QiLCJ0aGVuIiwiYWNjcyIsImNhdGNoIiwibGVuZ3RoIiwiYWRkcmVzcyIsImdldEFkZHJlc3MiLCJjaGFpbklkIiwiY2hhaW5JZEhleCIsImZyb21IZXgiLCJzaXdlTWVzc2FnZSIsImRvbWFpbiIsImhvc3QiLCJ1cmkiLCJub25jZSIsImlzc3VlZEF0IiwiZXhwaXJhdGlvblRpbWUiLCJub3RCZWZvcmUiLCJyZXF1ZXN0SWQiLCJyZXNvdXJjZXMiLCJjcmVhdGVTaXdlTWVzc2FnZSIsInRvSGV4IiwiX20iLCJzb2xhbmEiLCJzaWduSW4iLCJzaWduTWVzc2FnZSIsIm91dHB1dCIsIm91dHB1dFRvUHJvY2VzcyIsIkFycmF5IiwiaXNBcnJheSIsInNpZ25lZE1lc3NhZ2UiLCJVaW50OEFycmF5IiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJwdWJsaWNLZXkiLCJ0b0Jhc2U1OCIsIm1hcCIsInJlc291cmNlIiwiam9pbiIsIm1heWJlU2lnbmF0dXJlIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJieXRlc1RvQmFzZTY0VVJMIiwic3RvcmFnZUl0ZW0iLCJnZXRJdGVtQXN5bmMiLCJjb2RlVmVyaWZpZXIiLCJzcGxpdCIsIkF1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yIiwiYXV0aF9jb2RlIiwiY29kZV92ZXJpZmllciIsInNpZ25JbldpdGhJZFRva2VuIiwidG9rZW4iLCJhY2Nlc3NfdG9rZW4iLCJpZF90b2tlbiIsInNpZ25JbldpdGhPdHAiLCJjcmVhdGVfdXNlciIsInNob3VsZENyZWF0ZVVzZXIiLCJtZXNzYWdlSWQiLCJtZXNzYWdlX2lkIiwidmVyaWZ5T3RwIiwidW5kZWZpbmVkIiwidG9rZW5WZXJpZmljYXRpb25FcnJvciIsInR5cGUiLCJzaWduSW5XaXRoU1NPIiwicHJvdmlkZXJfaWQiLCJwcm92aWRlcklkIiwicmVkaXJlY3RfdG8iLCJza2lwX2h0dHBfcmVkaXJlY3QiLCJfc3NvUmVzcG9uc2UiLCJyZWF1dGhlbnRpY2F0ZSIsIl9yZWF1dGhlbnRpY2F0ZSIsIl91c2VTZXNzaW9uIiwic2Vzc2lvbkVycm9yIiwiQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IiLCJqd3QiLCJyZXNlbmQiLCJlbmRwb2ludCIsImdldFNlc3Npb24iLCJsYXN0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJwdXNoIiwid2FpdE9uIiwiYWxsIiwic3BsaWNlIiwiX19sb2FkU2Vzc2lvbiIsInN0YWNrIiwiY3VycmVudFNlc3Npb24iLCJtYXliZVNlc3Npb24iLCJfaXNWYWxpZFNlc3Npb24iLCJfcmVtb3ZlU2Vzc2lvbiIsImhhc0V4cGlyZWQiLCJleHBpcmVzX2F0Iiwibm93IiwiRVhQSVJZX01BUkdJTl9NUyIsIm1heWJlVXNlciIsInVzZXJOb3RBdmFpbGFibGVQcm94eSIsImlzU2VydmVyIiwiX19pc1VzZXJOb3RBdmFpbGFibGVQcm94eSIsInN1cHByZXNzV2FybmluZ1JlZiIsImluc2VjdXJlVXNlcldhcm5pbmdQcm94eSIsIl9jYWxsUmVmcmVzaFRva2VuIiwicmVmcmVzaF90b2tlbiIsImdldFVzZXIiLCJfZ2V0VXNlciIsIl91c2VyUmVzcG9uc2UiLCJpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIiwidXBkYXRlVXNlciIsImF0dHJpYnV0ZXMiLCJfdXBkYXRlVXNlciIsInNlc3Npb25EYXRhIiwidXNlckVycm9yIiwic2V0U2Vzc2lvbiIsIl9zZXRTZXNzaW9uIiwidGltZU5vdyIsImV4cGlyZXNBdCIsInBheWxvYWQiLCJkZWNvZGVKV1QiLCJleHAiLCJyZWZyZXNoZWRTZXNzaW9uIiwidG9rZW5fdHlwZSIsImV4cGlyZXNfaW4iLCJyZWZyZXNoU2Vzc2lvbiIsIl9yZWZyZXNoU2Vzc2lvbiIsIkF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciIsImVycm9yX2Rlc2NyaXB0aW9uIiwiZXJyb3JfY29kZSIsIkF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciIsInNlYXJjaFBhcmFtcyIsImRlbGV0ZSIsImhpc3RvcnkiLCJyZXBsYWNlU3RhdGUiLCJzdGF0ZSIsInRvU3RyaW5nIiwicHJvdmlkZXJfdG9rZW4iLCJwcm92aWRlcl9yZWZyZXNoX3Rva2VuIiwiTWF0aCIsInJvdW5kIiwiZXhwaXJlc0luIiwicGFyc2VJbnQiLCJhY3R1YWxseUV4cGlyZXNJbiIsIkFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TIiwiaGFzaCIsIkJvb2xlYW4iLCJjdXJyZW50U3RvcmFnZUNvbnRlbnQiLCJzaWduT3V0Iiwic2NvcGUiLCJfc2lnbk91dCIsImFjY2Vzc1Rva2VuIiwiaXNBdXRoQXBpRXJyb3IiLCJzdGF0dXMiLCJvbkF1dGhTdGF0ZUNoYW5nZSIsImNhbGxiYWNrIiwiaWQiLCJnZW5lcmF0ZUNhbGxiYWNrSWQiLCJzdWJzY3JpcHRpb24iLCJ1bnN1YnNjcmliZSIsInNldCIsIl9lbWl0SW5pdGlhbFNlc3Npb24iLCJnZXQiLCJlcnIiLCJyZXNldFBhc3N3b3JkRm9yRW1haWwiLCJnZXRVc2VySWRlbnRpdGllcyIsImlkZW50aXRpZXMiLCJsaW5rSWRlbnRpdHkiLCJsaW5rSWRlbnRpdHlJZFRva2VuIiwibGlua0lkZW50aXR5T0F1dGgiLCJfZ2V0VXJsRm9yUHJvdmlkZXIiLCJsaW5rX2lkZW50aXR5IiwidW5saW5rSWRlbnRpdHkiLCJpZGVudGl0eSIsImlkZW50aXR5X2lkIiwiX3JlZnJlc2hBY2Nlc3NUb2tlbiIsInJlZnJlc2hUb2tlbiIsImRlYnVnTmFtZSIsInN1YnN0cmluZyIsInN0YXJ0ZWRBdCIsInJldHJ5YWJsZSIsImF0dGVtcHQiLCJzbGVlcCIsInBvdyIsIm5leHRCYWNrT2ZmSW50ZXJ2YWwiLCJpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yIiwiaXNWYWxpZFNlc3Npb24iLCJpcyIsInNldEl0ZW1Bc3luYyIsInNlcGFyYXRlVXNlciIsImV4cGlyZXNXaXRoTWFyZ2luIiwiSW5maW5pdHkiLCJnZXRVc2VyRXJyb3IiLCJwcm9taXNlIiwiRGVmZXJyZWQiLCJyZWplY3QiLCJicm9hZGNhc3QiLCJwb3N0TWVzc2FnZSIsImVycm9ycyIsInByb21pc2VzIiwiZnJvbSIsInZhbHVlcyIsIngiLCJpIiwic2Vzc2lvblRvUHJvY2VzcyIsInVzZXJJc1Byb3h5IiwibWFpblNlc3Npb25EYXRhIiwiY2xvbmVkTWFpblNlc3Npb25EYXRhIiwiZGVlcENsb25lIiwiY2xvbmVkU2Vzc2lvbiIsIl9yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl9zdGFydEF1dG9SZWZyZXNoIiwiX3N0b3BBdXRvUmVmcmVzaCIsInRpY2tlciIsInNldEludGVydmFsIiwiX2F1dG9SZWZyZXNoVG9rZW5UaWNrIiwidW5yZWYiLCJEZW5vIiwidW5yZWZUaW1lciIsInRpbWVvdXQiLCJjbGVhckludGVydmFsIiwiY2xlYXJUaW1lb3V0Iiwic3RhcnRBdXRvUmVmcmVzaCIsInN0b3BBdXRvUmVmcmVzaCIsImV4cGlyZXNJblRpY2tzIiwiZmxvb3IiLCJBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQiLCJpc0FjcXVpcmVUaW1lb3V0IiwiTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IiLCJfb25WaXNpYmlsaXR5Q2hhbmdlZCIsImNhbGxlZEZyb21Jbml0aWFsaXplIiwibWV0aG9kTmFtZSIsImRvY3VtZW50IiwidmlzaWJpbGl0eVN0YXRlIiwidXJsUGFyYW1zIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZmxvd1BhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInF1ZXJ5IiwiZmFjdG9ySWQiLCJmcmllbmRseV9uYW1lIiwiZnJpZW5kbHlOYW1lIiwiZmFjdG9yX3R5cGUiLCJmYWN0b3JUeXBlIiwiaXNzdWVyIiwidG90cCIsInFyX2NvZGUiLCJjaGFsbGVuZ2VfaWQiLCJjaGFsbGVuZ2VJZCIsImNyZWRlbnRpYWxfcmVzcG9uc2UiLCJzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25SZXNwb25zZSIsInNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0UmVzcG9uc2UiLCJyZXNwb25zZSIsImNyZWRlbnRpYWxfb3B0aW9ucyIsImRlc2VyaWFsaXplQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyIsImRlc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zIiwiY2hhbGxlbmdlRGF0YSIsImNoYWxsZW5nZUVycm9yIiwiZmFjdG9yIiwiZmFjdG9ycyIsImN1cnJlbnRMZXZlbCIsIm5leHRMZXZlbCIsImN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMiLCJhYWwiLCJ2ZXJpZmllZEZhY3RvcnMiLCJmaWx0ZXIiLCJhbXIiLCJhdXRob3JpemF0aW9uSWQiLCJhY3Rpb24iLCJyZWRpcmVjdF91cmwiLCJjbGllbnRfaWQiLCJjbGllbnRJZCIsIm5vUmVzb2x2ZUpzb24iLCJmZXRjaEp3ayIsImtpZCIsImp3ayIsImZpbmQiLCJrZXkiLCJKV0tTX1RUTCIsImdldENsYWltcyIsImhlYWRlciIsInJhdyIsInJhd0hlYWRlciIsInJhd1BheWxvYWQiLCJhbGxvd0V4cGlyZWQiLCJ2YWxpZGF0ZUV4cCIsInNpZ25pbmdLZXkiLCJhbGciLCJzdGFydHNXaXRoIiwiY3J5cHRvIiwiY2xhaW1zIiwiYWxnb3JpdGhtIiwiZ2V0QWxnb3JpdGhtIiwic3VidGxlIiwiaW1wb3J0S2V5IiwiaXNWYWxpZCIsInN0cmluZ1RvVWludDhBcnJheSIsIkF1dGhJbnZhbGlkSnd0RXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/GoTrueClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.processLock = exports.lockInternals = exports.NavigatorLockAcquireTimeoutError = exports.navigatorLock = exports.AuthClient = exports.AuthAdminApi = exports.GoTrueClient = exports.GoTrueAdminApi = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst GoTrueAdminApi_1 = tslib_1.__importDefault(__webpack_require__(/*! ./GoTrueAdminApi */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/GoTrueAdminApi.js\"));\nexports.GoTrueAdminApi = GoTrueAdminApi_1.default;\nconst GoTrueClient_1 = tslib_1.__importDefault(__webpack_require__(/*! ./GoTrueClient */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/GoTrueClient.js\"));\nexports.GoTrueClient = GoTrueClient_1.default;\nconst AuthAdminApi_1 = tslib_1.__importDefault(__webpack_require__(/*! ./AuthAdminApi */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/AuthAdminApi.js\"));\nexports.AuthAdminApi = AuthAdminApi_1.default;\nconst AuthClient_1 = tslib_1.__importDefault(__webpack_require__(/*! ./AuthClient */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/AuthClient.js\"));\nexports.AuthClient = AuthClient_1.default;\ntslib_1.__exportStar(__webpack_require__(/*! ./lib/types */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/types.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./lib/errors */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/errors.js\"), exports);\nvar locks_1 = __webpack_require__(/*! ./lib/locks */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/locks.js\");\nObject.defineProperty(exports, \"navigatorLock\", ({\n    enumerable: true,\n    get: function() {\n        return locks_1.navigatorLock;\n    }\n}));\nObject.defineProperty(exports, \"NavigatorLockAcquireTimeoutError\", ({\n    enumerable: true,\n    get: function() {\n        return locks_1.NavigatorLockAcquireTimeoutError;\n    }\n}));\nObject.defineProperty(exports, \"lockInternals\", ({\n    enumerable: true,\n    get: function() {\n        return locks_1.internals;\n    }\n}));\nObject.defineProperty(exports, \"processLock\", ({\n    enumerable: true,\n    get: function() {\n        return locks_1.processLock;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBR0EscUJBQXFCLEdBQUdBLHdDQUF3QyxHQUFHQSxxQkFBcUIsR0FBR0Esa0JBQWtCLEdBQUdBLG9CQUFvQixHQUFHQSxvQkFBb0IsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUNsTixNQUFNVSxVQUFVQyxtQkFBT0EsQ0FBQyx1REFBTztBQUMvQixNQUFNQyxtQkFBbUJGLFFBQVFHLGVBQWUsQ0FBQ0YsbUJBQU9BLENBQUMsNEZBQWtCO0FBQzNFWCxzQkFBc0IsR0FBR1ksaUJBQWlCRSxPQUFPO0FBQ2pELE1BQU1DLGlCQUFpQkwsUUFBUUcsZUFBZSxDQUFDRixtQkFBT0EsQ0FBQyx3RkFBZ0I7QUFDdkVYLG9CQUFvQixHQUFHZSxlQUFlRCxPQUFPO0FBQzdDLE1BQU1FLGlCQUFpQk4sUUFBUUcsZUFBZSxDQUFDRixtQkFBT0EsQ0FBQyx3RkFBZ0I7QUFDdkVYLG9CQUFvQixHQUFHZ0IsZUFBZUYsT0FBTztBQUM3QyxNQUFNRyxlQUFlUCxRQUFRRyxlQUFlLENBQUNGLG1CQUFPQSxDQUFDLG9GQUFjO0FBQ25FWCxrQkFBa0IsR0FBR2lCLGFBQWFILE9BQU87QUFDekNKLFFBQVFRLFlBQVksQ0FBQ1AsbUJBQU9BLENBQUMsa0ZBQWEsR0FBR1g7QUFDN0NVLFFBQVFRLFlBQVksQ0FBQ1AsbUJBQU9BLENBQUMsb0ZBQWMsR0FBR1g7QUFDOUMsSUFBSW1CLFVBQVVSLG1CQUFPQSxDQUFDLGtGQUFhO0FBQ25DYixpREFBZ0Q7SUFBRXNCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLFFBQVFkLGFBQWE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN6SFAsb0VBQW1FO0lBQUVzQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixRQUFRZixnQ0FBZ0M7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMvSk4saURBQWdEO0lBQUVzQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixRQUFRRyxTQUFTO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDckh4QiwrQ0FBOEM7SUFBRXNCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLFFBQVFqQixXQUFXO0lBQUU7QUFBRSxDQUFDLEVBQUMsRUFDckgsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbWFpbi9pbmRleC5qcz9hODQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcm9jZXNzTG9jayA9IGV4cG9ydHMubG9ja0ludGVybmFscyA9IGV4cG9ydHMuTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgPSBleHBvcnRzLm5hdmlnYXRvckxvY2sgPSBleHBvcnRzLkF1dGhDbGllbnQgPSBleHBvcnRzLkF1dGhBZG1pbkFwaSA9IGV4cG9ydHMuR29UcnVlQ2xpZW50ID0gZXhwb3J0cy5Hb1RydWVBZG1pbkFwaSA9IHZvaWQgMDtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5jb25zdCBHb1RydWVBZG1pbkFwaV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vR29UcnVlQWRtaW5BcGlcIikpO1xuZXhwb3J0cy5Hb1RydWVBZG1pbkFwaSA9IEdvVHJ1ZUFkbWluQXBpXzEuZGVmYXVsdDtcbmNvbnN0IEdvVHJ1ZUNsaWVudF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vR29UcnVlQ2xpZW50XCIpKTtcbmV4cG9ydHMuR29UcnVlQ2xpZW50ID0gR29UcnVlQ2xpZW50XzEuZGVmYXVsdDtcbmNvbnN0IEF1dGhBZG1pbkFwaV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vQXV0aEFkbWluQXBpXCIpKTtcbmV4cG9ydHMuQXV0aEFkbWluQXBpID0gQXV0aEFkbWluQXBpXzEuZGVmYXVsdDtcbmNvbnN0IEF1dGhDbGllbnRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0F1dGhDbGllbnRcIikpO1xuZXhwb3J0cy5BdXRoQ2xpZW50ID0gQXV0aENsaWVudF8xLmRlZmF1bHQ7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvdHlwZXNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGliL2Vycm9yc1wiKSwgZXhwb3J0cyk7XG52YXIgbG9ja3NfMSA9IHJlcXVpcmUoXCIuL2xpYi9sb2Nrc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5hdmlnYXRvckxvY2tcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvY2tzXzEubmF2aWdhdG9yTG9jazsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2Nrc18xLk5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9ja0ludGVybmFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9ja3NfMS5pbnRlcm5hbHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm9jZXNzTG9ja1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9ja3NfMS5wcm9jZXNzTG9jazsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInByb2Nlc3NMb2NrIiwibG9ja0ludGVybmFscyIsIk5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yIiwibmF2aWdhdG9yTG9jayIsIkF1dGhDbGllbnQiLCJBdXRoQWRtaW5BcGkiLCJHb1RydWVDbGllbnQiLCJHb1RydWVBZG1pbkFwaSIsInRzbGliXzEiLCJyZXF1aXJlIiwiR29UcnVlQWRtaW5BcGlfMSIsIl9faW1wb3J0RGVmYXVsdCIsImRlZmF1bHQiLCJHb1RydWVDbGllbnRfMSIsIkF1dGhBZG1pbkFwaV8xIiwiQXV0aENsaWVudF8xIiwiX19leHBvcnRTdGFyIiwibG9ja3NfMSIsImVudW1lcmFibGUiLCJnZXQiLCJpbnRlcm5hbHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/base64url.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/lib/base64url.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.byteToBase64URL = byteToBase64URL;\nexports.byteFromBase64URL = byteFromBase64URL;\nexports.stringToBase64URL = stringToBase64URL;\nexports.stringFromBase64URL = stringFromBase64URL;\nexports.codepointToUTF8 = codepointToUTF8;\nexports.stringToUTF8 = stringToUTF8;\nexports.stringFromUTF8 = stringFromUTF8;\nexports.base64UrlToUint8Array = base64UrlToUint8Array;\nexports.stringToUint8Array = stringToUint8Array;\nexports.bytesToBase64URL = bytesToBase64URL;\n/**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */ const TO_BASE64URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".split(\"\");\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */ const IGNORE_BASE64URL = \" \t\\n\\r=\".split(\"\");\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */ const FROM_BASE64URL = (()=>{\n    const charMap = new Array(128);\n    for(let i = 0; i < charMap.length; i += 1){\n        charMap[i] = -1;\n    }\n    for(let i = 0; i < IGNORE_BASE64URL.length; i += 1){\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n    }\n    for(let i = 0; i < TO_BASE64URL.length; i += 1){\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n    }\n    return charMap;\n})();\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */ function byteToBase64URL(byte, state, emit) {\n    if (byte !== null) {\n        state.queue = state.queue << 8 | byte;\n        state.queuedBits += 8;\n        while(state.queuedBits >= 6){\n            const pos = state.queue >> state.queuedBits - 6 & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    } else if (state.queuedBits > 0) {\n        state.queue = state.queue << 6 - state.queuedBits;\n        state.queuedBits = 6;\n        while(state.queuedBits >= 6){\n            const pos = state.queue >> state.queuedBits - 6 & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    }\n}\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */ function byteFromBase64URL(charCode, state, emit) {\n    const bits = FROM_BASE64URL[charCode];\n    if (bits > -1) {\n        // valid Base64-URL character\n        state.queue = state.queue << 6 | bits;\n        state.queuedBits += 6;\n        while(state.queuedBits >= 8){\n            emit(state.queue >> state.queuedBits - 8 & 0xff);\n            state.queuedBits -= 8;\n        }\n    } else if (bits === -2) {\n        // ignore spaces, tabs, newlines, =\n        return;\n    } else {\n        throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`);\n    }\n}\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */ function stringToBase64URL(str) {\n    const base64 = [];\n    const emitter = (char)=>{\n        base64.push(char);\n    };\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    stringToUTF8(str, (byte)=>{\n        byteToBase64URL(byte, state, emitter);\n    });\n    byteToBase64URL(null, state, emitter);\n    return base64.join(\"\");\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */ function stringFromBase64URL(str) {\n    const conv = [];\n    const utf8Emit = (codepoint)=>{\n        conv.push(String.fromCodePoint(codepoint));\n    };\n    const utf8State = {\n        utf8seq: 0,\n        codepoint: 0\n    };\n    const b64State = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const byteEmit = (byte)=>{\n        stringFromUTF8(byte, utf8State, utf8Emit);\n    };\n    for(let i = 0; i < str.length; i += 1){\n        byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\n    }\n    return conv.join(\"\");\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */ function codepointToUTF8(codepoint, emit) {\n    if (codepoint <= 0x7f) {\n        emit(codepoint);\n        return;\n    } else if (codepoint <= 0x7ff) {\n        emit(0xc0 | codepoint >> 6);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0xffff) {\n        emit(0xe0 | codepoint >> 12);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0x10ffff) {\n        emit(0xf0 | codepoint >> 18);\n        emit(0x80 | codepoint >> 12 & 0x3f);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    }\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */ function stringToUTF8(str, emit) {\n    for(let i = 0; i < str.length; i += 1){\n        let codepoint = str.charCodeAt(i);\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\n            // range where the next UTF-16 codepoint needs to be combined with the\n            // current one to get the Unicode codepoint\n            const highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;\n            const lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n            i += 1;\n        }\n        codepointToUTF8(codepoint, emit);\n    }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */ function stringFromUTF8(byte, state, emit) {\n    if (state.utf8seq === 0) {\n        if (byte <= 0x7f) {\n            emit(byte);\n            return;\n        }\n        // count the number of 1 leading bits until you reach 0\n        for(let leadingBit = 1; leadingBit < 6; leadingBit += 1){\n            if ((byte >> 7 - leadingBit & 1) === 0) {\n                state.utf8seq = leadingBit;\n                break;\n            }\n        }\n        if (state.utf8seq === 2) {\n            state.codepoint = byte & 31;\n        } else if (state.utf8seq === 3) {\n            state.codepoint = byte & 15;\n        } else if (state.utf8seq === 4) {\n            state.codepoint = byte & 7;\n        } else {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.utf8seq -= 1;\n    } else if (state.utf8seq > 0) {\n        if (byte <= 0x7f) {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.codepoint = state.codepoint << 6 | byte & 63;\n        state.utf8seq -= 1;\n        if (state.utf8seq === 0) {\n            emit(state.codepoint);\n        }\n    }\n}\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */ function base64UrlToUint8Array(str) {\n    const result = [];\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const onByte = (byte)=>{\n        result.push(byte);\n    };\n    for(let i = 0; i < str.length; i += 1){\n        byteFromBase64URL(str.charCodeAt(i), state, onByte);\n    }\n    return new Uint8Array(result);\n}\nfunction stringToUint8Array(str) {\n    const result = [];\n    stringToUTF8(str, (byte)=>result.push(byte));\n    return new Uint8Array(result);\n}\nfunction bytesToBase64URL(bytes) {\n    const result = [];\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const onChar = (char)=>{\n        result.push(char);\n    };\n    bytes.forEach((byte)=>byteToBase64URL(byte, state, onChar));\n    // always call with `null` after processing all bytes\n    byteToBase64URL(null, state, onChar);\n    return result.join(\"\");\n} //# sourceMappingURL=base64url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi9iYXNlNjR1cmwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7OztDQUlDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1QkFBdUIsR0FBR0U7QUFDMUJGLHlCQUF5QixHQUFHRztBQUM1QkgseUJBQXlCLEdBQUdJO0FBQzVCSiwyQkFBMkIsR0FBR0s7QUFDOUJMLHVCQUF1QixHQUFHTTtBQUMxQk4sb0JBQW9CLEdBQUdPO0FBQ3ZCUCxzQkFBc0IsR0FBR1E7QUFDekJSLDZCQUE2QixHQUFHUztBQUNoQ1QsMEJBQTBCLEdBQUdVO0FBQzdCVix3QkFBd0IsR0FBR1c7QUFDM0I7OztDQUdDLEdBQ0QsTUFBTUMsZUFBZSxtRUFBbUVDLEtBQUssQ0FBQztBQUM5Rjs7O0NBR0MsR0FDRCxNQUFNQyxtQkFBbUIsVUFBV0QsS0FBSyxDQUFDO0FBQzFDOzs7Q0FHQyxHQUNELE1BQU1FLGlCQUFpQixDQUFDO0lBQ3BCLE1BQU1DLFVBQVUsSUFBSUMsTUFBTTtJQUMxQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsUUFBUUcsTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDeENGLE9BQU8sQ0FBQ0UsRUFBRSxHQUFHLENBQUM7SUFDbEI7SUFDQSxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSUosaUJBQWlCSyxNQUFNLEVBQUVELEtBQUssRUFBRztRQUNqREYsT0FBTyxDQUFDRixnQkFBZ0IsQ0FBQ0ksRUFBRSxDQUFDRSxVQUFVLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDbEQ7SUFDQSxJQUFLLElBQUlGLElBQUksR0FBR0EsSUFBSU4sYUFBYU8sTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDN0NGLE9BQU8sQ0FBQ0osWUFBWSxDQUFDTSxFQUFFLENBQUNFLFVBQVUsQ0FBQyxHQUFHLEdBQUdGO0lBQzdDO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBOzs7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QSxJQUFJYyxJQUFJYixNQUFNLEVBQUVELEtBQUssRUFBRztRQUNwQ2Ysa0JBQWtCNkIsSUFBSVosVUFBVSxDQUFDRixJQUFJSSxPQUFPNkI7SUFDaEQ7SUFDQSxPQUFPLElBQUlDLFdBQVdGO0FBQzFCO0FBQ0EsU0FBU3hDLG1CQUFtQnNCLEdBQUc7SUFDM0IsTUFBTWtCLFNBQVMsRUFBRTtJQUNqQjNDLGFBQWF5QixLQUFLLENBQUNYLE9BQVM2QixPQUFPZCxJQUFJLENBQUNmO0lBQ3hDLE9BQU8sSUFBSStCLFdBQVdGO0FBQzFCO0FBQ0EsU0FBU3ZDLGlCQUFpQjBDLEtBQUs7SUFDM0IsTUFBTUgsU0FBUyxFQUFFO0lBQ2pCLE1BQU01QixRQUFRO1FBQUVFLE9BQU87UUFBR0MsWUFBWTtJQUFFO0lBQ3hDLE1BQU02QixTQUFTLENBQUNuQjtRQUNaZSxPQUFPZCxJQUFJLENBQUNEO0lBQ2hCO0lBQ0FrQixNQUFNRSxPQUFPLENBQUMsQ0FBQ2xDLE9BQVNuQixnQkFBZ0JtQixNQUFNQyxPQUFPZ0M7SUFDckQscURBQXFEO0lBQ3JEcEQsZ0JBQWdCLE1BQU1vQixPQUFPZ0M7SUFDN0IsT0FBT0osT0FBT2IsSUFBSSxDQUFDO0FBQ3ZCLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbWFpbi9saWIvYmFzZTY0dXJsLmpzPzU5ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEF2b2lkIG1vZGlmeWluZyB0aGlzIGZpbGUuIEl0J3MgcGFydCBvZlxuICogaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlLWNvbW11bml0eS9iYXNlNjR1cmwtanMuICBTdWJtaXQgYWxsIGZpeGVzIG9uXG4gKiB0aGF0IHJlcG8hXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnl0ZVRvQmFzZTY0VVJMID0gYnl0ZVRvQmFzZTY0VVJMO1xuZXhwb3J0cy5ieXRlRnJvbUJhc2U2NFVSTCA9IGJ5dGVGcm9tQmFzZTY0VVJMO1xuZXhwb3J0cy5zdHJpbmdUb0Jhc2U2NFVSTCA9IHN0cmluZ1RvQmFzZTY0VVJMO1xuZXhwb3J0cy5zdHJpbmdGcm9tQmFzZTY0VVJMID0gc3RyaW5nRnJvbUJhc2U2NFVSTDtcbmV4cG9ydHMuY29kZXBvaW50VG9VVEY4ID0gY29kZXBvaW50VG9VVEY4O1xuZXhwb3J0cy5zdHJpbmdUb1VURjggPSBzdHJpbmdUb1VURjg7XG5leHBvcnRzLnN0cmluZ0Zyb21VVEY4ID0gc3RyaW5nRnJvbVVURjg7XG5leHBvcnRzLmJhc2U2NFVybFRvVWludDhBcnJheSA9IGJhc2U2NFVybFRvVWludDhBcnJheTtcbmV4cG9ydHMuc3RyaW5nVG9VaW50OEFycmF5ID0gc3RyaW5nVG9VaW50OEFycmF5O1xuZXhwb3J0cy5ieXRlc1RvQmFzZTY0VVJMID0gYnl0ZXNUb0Jhc2U2NFVSTDtcbi8qKlxuICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGVuY29kZSA2IGJpdHMgaW50byBhIEJhc2U2NC1VUkwgYWxwaGFiZXRcbiAqIGNoYXJhY3Rlci5cbiAqL1xuY29uc3QgVE9fQkFTRTY0VVJMID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nLnNwbGl0KCcnKTtcbi8qKlxuICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGNhbiBhcHBlYXIgaW4gYSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nIGJ1dFxuICogc2hvdWxkIGJlIGlnbm9yZWQuXG4gKi9cbmNvbnN0IElHTk9SRV9CQVNFNjRVUkwgPSAnIFxcdFxcblxccj0nLnNwbGl0KCcnKTtcbi8qKlxuICogQW4gYXJyYXkgb2YgMTI4IG51bWJlcnMgdGhhdCBtYXAgYSBCYXNlNjQtVVJMIGNoYXJhY3RlciB0byA2IGJpdHMsIG9yIGlmIC0yXG4gKiB1c2VkIHRvIHNraXAgdGhlIGNoYXJhY3Rlciwgb3IgaWYgLTEgdXNlZCB0byBlcnJvciBvdXQuXG4gKi9cbmNvbnN0IEZST01fQkFTRTY0VVJMID0gKCgpID0+IHtcbiAgICBjb25zdCBjaGFyTWFwID0gbmV3IEFycmF5KDEyOCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyTWFwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbaV0gPSAtMTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBJR05PUkVfQkFTRTY0VVJMLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbSUdOT1JFX0JBU0U2NFVSTFtpXS5jaGFyQ29kZUF0KDApXSA9IC0yO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRPX0JBU0U2NFVSTC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjaGFyTWFwW1RPX0JBU0U2NFVSTFtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBjaGFyTWFwO1xufSkoKTtcbi8qKlxuICogQ29udmVydHMgYSBieXRlIHRvIGEgQmFzZTY0LVVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGUgVGhlIGJ5dGUgdG8gY29udmVydCwgb3IgbnVsbCB0byBmbHVzaCBhdCB0aGUgZW5kIG9mIHRoZSBieXRlIHNlcXVlbmNlLlxuICogQHBhcmFtIHN0YXRlIFRoZSBCYXNlNjQgY29udmVyc2lvbiBzdGF0ZS4gUGFzcyBhbiBpbml0aWFsIHZhbHVlIG9mIGB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH1gLlxuICogQHBhcmFtIGVtaXQgQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgbmV4dCBCYXNlNjQgY2hhcmFjdGVyIHdoZW4gcmVhZHkuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVUb0Jhc2U2NFVSTChieXRlLCBzdGF0ZSwgZW1pdCkge1xuICAgIGlmIChieXRlICE9PSBudWxsKSB7XG4gICAgICAgIHN0YXRlLnF1ZXVlID0gKHN0YXRlLnF1ZXVlIDw8IDgpIHwgYnl0ZTtcbiAgICAgICAgc3RhdGUucXVldWVkQml0cyArPSA4O1xuICAgICAgICB3aGlsZSAoc3RhdGUucXVldWVkQml0cyA+PSA2KSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSAoc3RhdGUucXVldWUgPj4gKHN0YXRlLnF1ZXVlZEJpdHMgLSA2KSkgJiA2MztcbiAgICAgICAgICAgIGVtaXQoVE9fQkFTRTY0VVJMW3Bvc10pO1xuICAgICAgICAgICAgc3RhdGUucXVldWVkQml0cyAtPSA2O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlLnF1ZXVlZEJpdHMgPiAwKSB7XG4gICAgICAgIHN0YXRlLnF1ZXVlID0gc3RhdGUucXVldWUgPDwgKDYgLSBzdGF0ZS5xdWV1ZWRCaXRzKTtcbiAgICAgICAgc3RhdGUucXVldWVkQml0cyA9IDY7XG4gICAgICAgIHdoaWxlIChzdGF0ZS5xdWV1ZWRCaXRzID49IDYpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IChzdGF0ZS5xdWV1ZSA+PiAoc3RhdGUucXVldWVkQml0cyAtIDYpKSAmIDYzO1xuICAgICAgICAgICAgZW1pdChUT19CQVNFNjRVUkxbcG9zXSk7XG4gICAgICAgICAgICBzdGF0ZS5xdWV1ZWRCaXRzIC09IDY7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgU3RyaW5nIGNoYXIgY29kZSAoZXh0cmFjdGVkIHVzaW5nIGBzdHJpbmcuY2hhckNvZGVBdChwb3NpdGlvbilgKSB0byBhIHNlcXVlbmNlIG9mIEJhc2U2NC1VUkwgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gY2hhckNvZGUgVGhlIGNoYXIgY29kZSBvZiB0aGUgSmF2YVNjcmlwdCBzdHJpbmcuXG4gKiBAcGFyYW0gc3RhdGUgVGhlIEJhc2U2NCBzdGF0ZS4gUGFzcyBhbiBpbml0aWFsIHZhbHVlIG9mIGB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH1gLlxuICogQHBhcmFtIGVtaXQgQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgbmV4dCBieXRlLlxuICovXG5mdW5jdGlvbiBieXRlRnJvbUJhc2U2NFVSTChjaGFyQ29kZSwgc3RhdGUsIGVtaXQpIHtcbiAgICBjb25zdCBiaXRzID0gRlJPTV9CQVNFNjRVUkxbY2hhckNvZGVdO1xuICAgIGlmIChiaXRzID4gLTEpIHtcbiAgICAgICAgLy8gdmFsaWQgQmFzZTY0LVVSTCBjaGFyYWN0ZXJcbiAgICAgICAgc3RhdGUucXVldWUgPSAoc3RhdGUucXVldWUgPDwgNikgfCBiaXRzO1xuICAgICAgICBzdGF0ZS5xdWV1ZWRCaXRzICs9IDY7XG4gICAgICAgIHdoaWxlIChzdGF0ZS5xdWV1ZWRCaXRzID49IDgpIHtcbiAgICAgICAgICAgIGVtaXQoKHN0YXRlLnF1ZXVlID4+IChzdGF0ZS5xdWV1ZWRCaXRzIC0gOCkpICYgMHhmZik7XG4gICAgICAgICAgICBzdGF0ZS5xdWV1ZWRCaXRzIC09IDg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYml0cyA9PT0gLTIpIHtcbiAgICAgICAgLy8gaWdub3JlIHNwYWNlcywgdGFicywgbmV3bGluZXMsID1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEJhc2U2NC1VUkwgY2hhcmFjdGVyIFwiJHtTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKX1cImApO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgYSBKYXZhU2NyaXB0IHN0cmluZyAod2hpY2ggbWF5IGluY2x1ZGUgYW55IHZhbGlkIGNoYXJhY3RlcikgaW50byBhXG4gKiBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nLiBUaGUgc3RyaW5nIGlzIGZpcnN0IGVuY29kZWQgaW4gVVRGLTggd2hpY2ggaXNcbiAqIHRoZW4gZW5jb2RlZCBhcyBCYXNlNjQtVVJMLlxuICpcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0Jhc2U2NFVSTChzdHIpIHtcbiAgICBjb25zdCBiYXNlNjQgPSBbXTtcbiAgICBjb25zdCBlbWl0dGVyID0gKGNoYXIpID0+IHtcbiAgICAgICAgYmFzZTY0LnB1c2goY2hhcik7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfTtcbiAgICBzdHJpbmdUb1VURjgoc3RyLCAoYnl0ZSkgPT4ge1xuICAgICAgICBieXRlVG9CYXNlNjRVUkwoYnl0ZSwgc3RhdGUsIGVtaXR0ZXIpO1xuICAgIH0pO1xuICAgIGJ5dGVUb0Jhc2U2NFVSTChudWxsLCBzdGF0ZSwgZW1pdHRlcik7XG4gICAgcmV0dXJuIGJhc2U2NC5qb2luKCcnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IHN0cmluZy4gSXQgaXMgYXNzdW1lZFxuICogdGhhdCB0aGUgdW5kZXJseWluZyBzdHJpbmcgaGFzIGJlZW4gZW5jb2RlZCBhcyBVVEYtOC5cbiAqXG4gKiBAcGFyYW0gc3RyIFRoZSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHJpbmdGcm9tQmFzZTY0VVJMKHN0cikge1xuICAgIGNvbnN0IGNvbnYgPSBbXTtcbiAgICBjb25zdCB1dGY4RW1pdCA9IChjb2RlcG9pbnQpID0+IHtcbiAgICAgICAgY29udi5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVwb2ludCkpO1xuICAgIH07XG4gICAgY29uc3QgdXRmOFN0YXRlID0ge1xuICAgICAgICB1dGY4c2VxOiAwLFxuICAgICAgICBjb2RlcG9pbnQ6IDAsXG4gICAgfTtcbiAgICBjb25zdCBiNjRTdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfTtcbiAgICBjb25zdCBieXRlRW1pdCA9IChieXRlKSA9PiB7XG4gICAgICAgIHN0cmluZ0Zyb21VVEY4KGJ5dGUsIHV0ZjhTdGF0ZSwgdXRmOEVtaXQpO1xuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYnl0ZUZyb21CYXNlNjRVUkwoc3RyLmNoYXJDb2RlQXQoaSksIGI2NFN0YXRlLCBieXRlRW1pdCk7XG4gICAgfVxuICAgIHJldHVybiBjb252LmpvaW4oJycpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgY29kZXBvaW50IHRvIGEgbXVsdGktYnl0ZSBVVEYtOCBzZXF1ZW5jZS5cbiAqXG4gKiBAcGFyYW0gY29kZXBvaW50IFRoZSBVbmljb2RlIGNvZGVwb2ludC5cbiAqIEBwYXJhbSBlbWl0ICAgICAgRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggVVRGLTggYnl0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvZGVwb2ludC5cbiAqL1xuZnVuY3Rpb24gY29kZXBvaW50VG9VVEY4KGNvZGVwb2ludCwgZW1pdCkge1xuICAgIGlmIChjb2RlcG9pbnQgPD0gMHg3Zikge1xuICAgICAgICBlbWl0KGNvZGVwb2ludCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZXBvaW50IDw9IDB4N2ZmKSB7XG4gICAgICAgIGVtaXQoMHhjMCB8IChjb2RlcG9pbnQgPj4gNikpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoY29kZXBvaW50ICYgMHgzZikpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVwb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgZW1pdCgweGUwIHwgKGNvZGVwb2ludCA+PiAxMikpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoKGNvZGVwb2ludCA+PiA2KSAmIDB4M2YpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKGNvZGVwb2ludCAmIDB4M2YpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlcG9pbnQgPD0gMHgxMGZmZmYpIHtcbiAgICAgICAgZW1pdCgweGYwIHwgKGNvZGVwb2ludCA+PiAxOCkpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoKGNvZGVwb2ludCA+PiAxMikgJiAweDNmKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8ICgoY29kZXBvaW50ID4+IDYpICYgMHgzZikpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoY29kZXBvaW50ICYgMHgzZikpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIFVuaWNvZGUgY29kZXBvaW50OiAke2NvZGVwb2ludC50b1N0cmluZygxNil9YCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgSmF2YVNjcmlwdCBzdHJpbmcgdG8gYSBzZXF1ZW5jZSBvZiBVVEYtOCBieXRlcy5cbiAqXG4gKiBAcGFyYW0gc3RyICBUaGUgc3RyaW5nIHRvIGNvbnZlcnQgdG8gVVRGLTguXG4gKiBAcGFyYW0gZW1pdCBGdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBVVEYtOCBieXRlIG9mIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsIGVtaXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgY29kZXBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlcG9pbnQgPiAweGQ3ZmYgJiYgY29kZXBvaW50IDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgLy8gbW9zdCBVVEYtMTYgY29kZXBvaW50cyBhcmUgVW5pY29kZSBjb2RlcG9pbnRzLCBleGNlcHQgdmFsdWVzIGluIHRoaXNcbiAgICAgICAgICAgIC8vIHJhbmdlIHdoZXJlIHRoZSBuZXh0IFVURi0xNiBjb2RlcG9pbnQgbmVlZHMgdG8gYmUgY29tYmluZWQgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgb25lIHRvIGdldCB0aGUgVW5pY29kZSBjb2RlcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hTdXJyb2dhdGUgPSAoKGNvZGVwb2ludCAtIDB4ZDgwMCkgKiAweDQwMCkgJiAweGZmZmY7XG4gICAgICAgICAgICBjb25zdCBsb3dTdXJyb2dhdGUgPSAoc3RyLmNoYXJDb2RlQXQoaSArIDEpIC0gMHhkYzAwKSAmIDB4ZmZmZjtcbiAgICAgICAgICAgIGNvZGVwb2ludCA9IChsb3dTdXJyb2dhdGUgfCBoaWdoU3Vycm9nYXRlKSArIDB4MTAwMDA7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29kZXBvaW50VG9VVEY4KGNvZGVwb2ludCwgZW1pdCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVURi04IGJ5dGUgdG8gYSBVbmljb2RlIGNvZGVwb2ludC5cbiAqXG4gKiBAcGFyYW0gYnl0ZSAgVGhlIFVURi04IGJ5dGUgbmV4dCBpbiB0aGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0gc3RhdGUgVGhlIHNoYXJlZCBzdGF0ZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIFVURi04IGJ5dGVzIGluIHRoZVxuICogICAgICAgICAgICAgIHNlcXVlbmNlLCBhbiBvYmplY3Qgd2l0aCB0aGUgc2hhcGUgYHsgdXRmOHNlcTogMCwgY29kZXBvaW50OiAwIH1gLlxuICogQHBhcmFtIGVtaXQgIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGNvZGVwb2ludC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nRnJvbVVURjgoYnl0ZSwgc3RhdGUsIGVtaXQpIHtcbiAgICBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMCkge1xuICAgICAgICBpZiAoYnl0ZSA8PSAweDdmKSB7XG4gICAgICAgICAgICBlbWl0KGJ5dGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgMSBsZWFkaW5nIGJpdHMgdW50aWwgeW91IHJlYWNoIDBcbiAgICAgICAgZm9yIChsZXQgbGVhZGluZ0JpdCA9IDE7IGxlYWRpbmdCaXQgPCA2OyBsZWFkaW5nQml0ICs9IDEpIHtcbiAgICAgICAgICAgIGlmICgoKGJ5dGUgPj4gKDcgLSBsZWFkaW5nQml0KSkgJiAxKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnV0ZjhzZXEgPSBsZWFkaW5nQml0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS51dGY4c2VxID09PSAyKSB7XG4gICAgICAgICAgICBzdGF0ZS5jb2RlcG9pbnQgPSBieXRlICYgMzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMykge1xuICAgICAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gYnl0ZSAmIDE1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDQpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvZGVwb2ludCA9IGJ5dGUgJiA3O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFVURi04IHNlcXVlbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUudXRmOHNlcSAtPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZS51dGY4c2VxID4gMCkge1xuICAgICAgICBpZiAoYnl0ZSA8PSAweDdmKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVVRGLTggc2VxdWVuY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5jb2RlcG9pbnQgPSAoc3RhdGUuY29kZXBvaW50IDw8IDYpIHwgKGJ5dGUgJiA2Myk7XG4gICAgICAgIHN0YXRlLnV0ZjhzZXEgLT0gMTtcbiAgICAgICAgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDApIHtcbiAgICAgICAgICAgIGVtaXQoc3RhdGUuY29kZXBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGRpZmZlcmVudCB0eXBlcyBvZiBzdHJpbmdzIHRvIFVpbnQ4QXJyYXlcbiAqL1xuZnVuY3Rpb24gYmFzZTY0VXJsVG9VaW50OEFycmF5KHN0cikge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHN0YXRlID0geyBxdWV1ZTogMCwgcXVldWVkQml0czogMCB9O1xuICAgIGNvbnN0IG9uQnl0ZSA9IChieXRlKSA9PiB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGJ5dGUpO1xuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYnl0ZUZyb21CYXNlNjRVUkwoc3RyLmNoYXJDb2RlQXQoaSksIHN0YXRlLCBvbkJ5dGUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvVWludDhBcnJheShzdHIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBzdHJpbmdUb1VURjgoc3RyLCAoYnl0ZSkgPT4gcmVzdWx0LnB1c2goYnl0ZSkpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuZnVuY3Rpb24gYnl0ZXNUb0Jhc2U2NFVSTChieXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHN0YXRlID0geyBxdWV1ZTogMCwgcXVldWVkQml0czogMCB9O1xuICAgIGNvbnN0IG9uQ2hhciA9IChjaGFyKSA9PiB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNoYXIpO1xuICAgIH07XG4gICAgYnl0ZXMuZm9yRWFjaCgoYnl0ZSkgPT4gYnl0ZVRvQmFzZTY0VVJMKGJ5dGUsIHN0YXRlLCBvbkNoYXIpKTtcbiAgICAvLyBhbHdheXMgY2FsbCB3aXRoIGBudWxsYCBhZnRlciBwcm9jZXNzaW5nIGFsbCBieXRlc1xuICAgIGJ5dGVUb0Jhc2U2NFVSTChudWxsLCBzdGF0ZSwgb25DaGFyKTtcbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0dXJsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImJ5dGVUb0Jhc2U2NFVSTCIsImJ5dGVGcm9tQmFzZTY0VVJMIiwic3RyaW5nVG9CYXNlNjRVUkwiLCJzdHJpbmdGcm9tQmFzZTY0VVJMIiwiY29kZXBvaW50VG9VVEY4Iiwic3RyaW5nVG9VVEY4Iiwic3RyaW5nRnJvbVVURjgiLCJiYXNlNjRVcmxUb1VpbnQ4QXJyYXkiLCJzdHJpbmdUb1VpbnQ4QXJyYXkiLCJieXRlc1RvQmFzZTY0VVJMIiwiVE9fQkFTRTY0VVJMIiwic3BsaXQiLCJJR05PUkVfQkFTRTY0VVJMIiwiRlJPTV9CQVNFNjRVUkwiLCJjaGFyTWFwIiwiQXJyYXkiLCJpIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImJ5dGUiLCJzdGF0ZSIsImVtaXQiLCJxdWV1ZSIsInF1ZXVlZEJpdHMiLCJwb3MiLCJjaGFyQ29kZSIsImJpdHMiLCJFcnJvciIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInN0ciIsImJhc2U2NCIsImVtaXR0ZXIiLCJjaGFyIiwicHVzaCIsImpvaW4iLCJjb252IiwidXRmOEVtaXQiLCJjb2RlcG9pbnQiLCJmcm9tQ29kZVBvaW50IiwidXRmOFN0YXRlIiwidXRmOHNlcSIsImI2NFN0YXRlIiwiYnl0ZUVtaXQiLCJ0b1N0cmluZyIsImhpZ2hTdXJyb2dhdGUiLCJsb3dTdXJyb2dhdGUiLCJsZWFkaW5nQml0IiwicmVzdWx0Iiwib25CeXRlIiwiVWludDhBcnJheSIsImJ5dGVzIiwib25DaGFyIiwiZm9yRWFjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/base64url.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/constants.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/lib/constants.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.JWKS_TTL = exports.BASE64URL_REGEX = exports.API_VERSIONS = exports.API_VERSION_HEADER_NAME = exports.NETWORK_FAILURE = exports.DEFAULT_HEADERS = exports.AUDIENCE = exports.STORAGE_KEY = exports.GOTRUE_URL = exports.EXPIRY_MARGIN_MS = exports.AUTO_REFRESH_TICK_THRESHOLD = exports.AUTO_REFRESH_TICK_DURATION_MS = void 0;\nconst version_1 = __webpack_require__(/*! ./version */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/version.js\");\n/** Current session will be checked for refresh at this interval. */ exports.AUTO_REFRESH_TICK_DURATION_MS = 30 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */ exports.AUTO_REFRESH_TICK_THRESHOLD = 3;\n/*\n * Earliest time before an access token expires that the session should be refreshed.\n */ exports.EXPIRY_MARGIN_MS = exports.AUTO_REFRESH_TICK_THRESHOLD * exports.AUTO_REFRESH_TICK_DURATION_MS;\nexports.GOTRUE_URL = \"http://localhost:9999\";\nexports.STORAGE_KEY = \"supabase.auth.token\";\nexports.AUDIENCE = \"\";\nexports.DEFAULT_HEADERS = {\n    \"X-Client-Info\": `gotrue-js/${version_1.version}`\n};\nexports.NETWORK_FAILURE = {\n    MAX_RETRIES: 10,\n    RETRY_INTERVAL: 2\n};\nexports.API_VERSION_HEADER_NAME = \"X-Supabase-Api-Version\";\nexports.API_VERSIONS = {\n    \"2024-01-01\": {\n        timestamp: Date.parse(\"2024-01-01T00:00:00.0Z\"),\n        name: \"2024-01-01\"\n    }\n};\nexports.BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;\nexports.JWKS_TTL = 10 * 60 * 1000; // 10 minutes\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHQSx1QkFBdUIsR0FBR0Esb0JBQW9CLEdBQUdBLCtCQUErQixHQUFHQSx1QkFBdUIsR0FBR0EsdUJBQXVCLEdBQUdBLGdCQUFnQixHQUFHQSxtQkFBbUIsR0FBR0Esa0JBQWtCLEdBQUdBLHdCQUF3QixHQUFHQSxtQ0FBbUMsR0FBR0EscUNBQXFDLEdBQUcsS0FBSztBQUN0VSxNQUFNYyxZQUFZQyxtQkFBT0EsQ0FBQyxrRkFBVztBQUNyQyxrRUFBa0UsR0FDbEVmLHFDQUFxQyxHQUFHLEtBQUs7QUFDN0M7eUZBQ3lGLEdBQ3pGQSxtQ0FBbUMsR0FBRztBQUN0Qzs7Q0FFQyxHQUNEQSx3QkFBd0IsR0FBR0EsUUFBUVksMkJBQTJCLEdBQUdaLFFBQVFhLDZCQUE2QjtBQUN0R2Isa0JBQWtCLEdBQUc7QUFDckJBLG1CQUFtQixHQUFHO0FBQ3RCQSxnQkFBZ0IsR0FBRztBQUNuQkEsdUJBQXVCLEdBQUc7SUFBRSxpQkFBaUIsQ0FBQyxVQUFVLEVBQUVjLFVBQVVFLE9BQU8sQ0FBQyxDQUFDO0FBQUM7QUFDOUVoQix1QkFBdUIsR0FBRztJQUN0QmlCLGFBQWE7SUFDYkMsZ0JBQWdCO0FBQ3BCO0FBQ0FsQiwrQkFBK0IsR0FBRztBQUNsQ0Esb0JBQW9CLEdBQUc7SUFDbkIsY0FBYztRQUNWbUIsV0FBV0MsS0FBS0MsS0FBSyxDQUFDO1FBQ3RCQyxNQUFNO0lBQ1Y7QUFDSjtBQUNBdEIsdUJBQXVCLEdBQUc7QUFDMUJBLGdCQUFnQixHQUFHLEtBQUssS0FBSyxNQUFNLGFBQWE7Q0FDaEQscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbWFpbi9saWIvY29uc3RhbnRzLmpzPzQwM2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpXS1NfVFRMID0gZXhwb3J0cy5CQVNFNjRVUkxfUkVHRVggPSBleHBvcnRzLkFQSV9WRVJTSU9OUyA9IGV4cG9ydHMuQVBJX1ZFUlNJT05fSEVBREVSX05BTUUgPSBleHBvcnRzLk5FVFdPUktfRkFJTFVSRSA9IGV4cG9ydHMuREVGQVVMVF9IRUFERVJTID0gZXhwb3J0cy5BVURJRU5DRSA9IGV4cG9ydHMuU1RPUkFHRV9LRVkgPSBleHBvcnRzLkdPVFJVRV9VUkwgPSBleHBvcnRzLkVYUElSWV9NQVJHSU5fTVMgPSBleHBvcnRzLkFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCA9IGV4cG9ydHMuQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMgPSB2b2lkIDA7XG5jb25zdCB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuLyoqIEN1cnJlbnQgc2Vzc2lvbiB3aWxsIGJlIGNoZWNrZWQgZm9yIHJlZnJlc2ggYXQgdGhpcyBpbnRlcnZhbC4gKi9cbmV4cG9ydHMuQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMgPSAzMCAqIDEwMDA7XG4vKipcbiAqIEEgdG9rZW4gcmVmcmVzaCB3aWxsIGJlIGF0dGVtcHRlZCB0aGlzIG1hbnkgdGlja3MgYmVmb3JlIHRoZSBjdXJyZW50IHNlc3Npb24gZXhwaXJlcy4gKi9cbmV4cG9ydHMuQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEID0gMztcbi8qXG4gKiBFYXJsaWVzdCB0aW1lIGJlZm9yZSBhbiBhY2Nlc3MgdG9rZW4gZXhwaXJlcyB0aGF0IHRoZSBzZXNzaW9uIHNob3VsZCBiZSByZWZyZXNoZWQuXG4gKi9cbmV4cG9ydHMuRVhQSVJZX01BUkdJTl9NUyA9IGV4cG9ydHMuQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEICogZXhwb3J0cy5BVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUztcbmV4cG9ydHMuR09UUlVFX1VSTCA9ICdodHRwOi8vbG9jYWxob3N0Ojk5OTknO1xuZXhwb3J0cy5TVE9SQUdFX0tFWSA9ICdzdXBhYmFzZS5hdXRoLnRva2VuJztcbmV4cG9ydHMuQVVESUVOQ0UgPSAnJztcbmV4cG9ydHMuREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBnb3RydWUtanMvJHt2ZXJzaW9uXzEudmVyc2lvbn1gIH07XG5leHBvcnRzLk5FVFdPUktfRkFJTFVSRSA9IHtcbiAgICBNQVhfUkVUUklFUzogMTAsXG4gICAgUkVUUllfSU5URVJWQUw6IDIsIC8vIGluIGRlY2lzZWNvbmRzXG59O1xuZXhwb3J0cy5BUElfVkVSU0lPTl9IRUFERVJfTkFNRSA9ICdYLVN1cGFiYXNlLUFwaS1WZXJzaW9uJztcbmV4cG9ydHMuQVBJX1ZFUlNJT05TID0ge1xuICAgICcyMDI0LTAxLTAxJzoge1xuICAgICAgICB0aW1lc3RhbXA6IERhdGUucGFyc2UoJzIwMjQtMDEtMDFUMDA6MDA6MDAuMFonKSxcbiAgICAgICAgbmFtZTogJzIwMjQtMDEtMDEnLFxuICAgIH0sXG59O1xuZXhwb3J0cy5CQVNFNjRVUkxfUkVHRVggPSAvXihbYS16MC05Xy1dezR9KSooJHxbYS16MC05Xy1dezN9JHxbYS16MC05Xy1dezJ9JCkkL2k7XG5leHBvcnRzLkpXS1NfVFRMID0gMTAgKiA2MCAqIDEwMDA7IC8vIDEwIG1pbnV0ZXNcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJKV0tTX1RUTCIsIkJBU0U2NFVSTF9SRUdFWCIsIkFQSV9WRVJTSU9OUyIsIkFQSV9WRVJTSU9OX0hFQURFUl9OQU1FIiwiTkVUV09SS19GQUlMVVJFIiwiREVGQVVMVF9IRUFERVJTIiwiQVVESUVOQ0UiLCJTVE9SQUdFX0tFWSIsIkdPVFJVRV9VUkwiLCJFWFBJUllfTUFSR0lOX01TIiwiQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEIiwiQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMiLCJ2ZXJzaW9uXzEiLCJyZXF1aXJlIiwidmVyc2lvbiIsIk1BWF9SRVRSSUVTIiwiUkVUUllfSU5URVJWQUwiLCJ0aW1lc3RhbXAiLCJEYXRlIiwicGFyc2UiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/errors.js":
/*!****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/lib/errors.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AuthInvalidJwtError = exports.AuthWeakPasswordError = exports.AuthRetryableFetchError = exports.AuthPKCECodeVerifierMissingError = exports.AuthPKCEGrantCodeExchangeError = exports.AuthImplicitGrantRedirectError = exports.AuthInvalidCredentialsError = exports.AuthInvalidTokenResponseError = exports.AuthSessionMissingError = exports.CustomAuthError = exports.AuthUnknownError = exports.AuthApiError = exports.AuthError = void 0;\nexports.isAuthError = isAuthError;\nexports.isAuthApiError = isAuthApiError;\nexports.isAuthSessionMissingError = isAuthSessionMissingError;\nexports.isAuthImplicitGrantRedirectError = isAuthImplicitGrantRedirectError;\nexports.isAuthPKCECodeVerifierMissingError = isAuthPKCECodeVerifierMissingError;\nexports.isAuthRetryableFetchError = isAuthRetryableFetchError;\nexports.isAuthWeakPasswordError = isAuthWeakPasswordError;\n/**\n * Base error thrown by Supabase Auth helpers.\n *\n * @example\n * ```ts\n * import { AuthError } from '@supabase/auth-js'\n *\n * throw new AuthError('Unexpected auth error', 500, 'unexpected')\n * ```\n */ class AuthError extends Error {\n    constructor(message, status, code){\n        super(message);\n        this.__isAuthError = true;\n        this.name = \"AuthError\";\n        this.status = status;\n        this.code = code;\n    }\n}\nexports.AuthError = AuthError;\nfunction isAuthError(error) {\n    return typeof error === \"object\" && error !== null && \"__isAuthError\" in error;\n}\n/**\n * Error returned directly from the GoTrue REST API.\n *\n * @example\n * ```ts\n * import { AuthApiError } from '@supabase/auth-js'\n *\n * throw new AuthApiError('Invalid credentials', 400, 'invalid_credentials')\n * ```\n */ class AuthApiError extends AuthError {\n    constructor(message, status, code){\n        super(message, status, code);\n        this.name = \"AuthApiError\";\n        this.status = status;\n        this.code = code;\n    }\n}\nexports.AuthApiError = AuthApiError;\nfunction isAuthApiError(error) {\n    return isAuthError(error) && error.name === \"AuthApiError\";\n}\n/**\n * Wraps non-standard errors so callers can inspect the root cause.\n *\n * @example\n * ```ts\n * import { AuthUnknownError } from '@supabase/auth-js'\n *\n * try {\n *   await someAuthCall()\n * } catch (err) {\n *   throw new AuthUnknownError('Auth failed', err)\n * }\n * ```\n */ class AuthUnknownError extends AuthError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"AuthUnknownError\";\n        this.originalError = originalError;\n    }\n}\nexports.AuthUnknownError = AuthUnknownError;\n/**\n * Flexible error class used to create named auth errors at runtime.\n *\n * @example\n * ```ts\n * import { CustomAuthError } from '@supabase/auth-js'\n *\n * throw new CustomAuthError('My custom auth error', 'MyAuthError', 400, 'custom_code')\n * ```\n */ class CustomAuthError extends AuthError {\n    constructor(message, name, status, code){\n        super(message, status, code);\n        this.name = name;\n        this.status = status;\n    }\n}\nexports.CustomAuthError = CustomAuthError;\n/**\n * Error thrown when an operation requires a session but none is present.\n *\n * @example\n * ```ts\n * import { AuthSessionMissingError } from '@supabase/auth-js'\n *\n * throw new AuthSessionMissingError()\n * ```\n */ class AuthSessionMissingError extends CustomAuthError {\n    constructor(){\n        super(\"Auth session missing!\", \"AuthSessionMissingError\", 400, undefined);\n    }\n}\nexports.AuthSessionMissingError = AuthSessionMissingError;\nfunction isAuthSessionMissingError(error) {\n    return isAuthError(error) && error.name === \"AuthSessionMissingError\";\n}\n/**\n * Error thrown when the token response is malformed.\n *\n * @example\n * ```ts\n * import { AuthInvalidTokenResponseError } from '@supabase/auth-js'\n *\n * throw new AuthInvalidTokenResponseError()\n * ```\n */ class AuthInvalidTokenResponseError extends CustomAuthError {\n    constructor(){\n        super(\"Auth session or user missing\", \"AuthInvalidTokenResponseError\", 500, undefined);\n    }\n}\nexports.AuthInvalidTokenResponseError = AuthInvalidTokenResponseError;\n/**\n * Error thrown when email/password credentials are invalid.\n *\n * @example\n * ```ts\n * import { AuthInvalidCredentialsError } from '@supabase/auth-js'\n *\n * throw new AuthInvalidCredentialsError('Email or password is incorrect')\n * ```\n */ class AuthInvalidCredentialsError extends CustomAuthError {\n    constructor(message){\n        super(message, \"AuthInvalidCredentialsError\", 400, undefined);\n    }\n}\nexports.AuthInvalidCredentialsError = AuthInvalidCredentialsError;\n/**\n * Error thrown when implicit grant redirects contain an error.\n *\n * @example\n * ```ts\n * import { AuthImplicitGrantRedirectError } from '@supabase/auth-js'\n *\n * throw new AuthImplicitGrantRedirectError('OAuth redirect failed', {\n *   error: 'access_denied',\n *   code: 'oauth_error',\n * })\n * ```\n */ class AuthImplicitGrantRedirectError extends CustomAuthError {\n    constructor(message, details = null){\n        super(message, \"AuthImplicitGrantRedirectError\", 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details\n        };\n    }\n}\nexports.AuthImplicitGrantRedirectError = AuthImplicitGrantRedirectError;\nfunction isAuthImplicitGrantRedirectError(error) {\n    return isAuthError(error) && error.name === \"AuthImplicitGrantRedirectError\";\n}\n/**\n * Error thrown during PKCE code exchanges.\n *\n * @example\n * ```ts\n * import { AuthPKCEGrantCodeExchangeError } from '@supabase/auth-js'\n *\n * throw new AuthPKCEGrantCodeExchangeError('PKCE exchange failed')\n * ```\n */ class AuthPKCEGrantCodeExchangeError extends CustomAuthError {\n    constructor(message, details = null){\n        super(message, \"AuthPKCEGrantCodeExchangeError\", 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details\n        };\n    }\n}\nexports.AuthPKCEGrantCodeExchangeError = AuthPKCEGrantCodeExchangeError;\n/**\n * Error thrown when the PKCE code verifier is not found in storage.\n * This typically happens when the auth flow was initiated in a different\n * browser, device, or the storage was cleared.\n *\n * @example\n * ```ts\n * import { AuthPKCECodeVerifierMissingError } from '@supabase/auth-js'\n *\n * throw new AuthPKCECodeVerifierMissingError()\n * ```\n */ class AuthPKCECodeVerifierMissingError extends CustomAuthError {\n    constructor(){\n        super(\"PKCE code verifier not found in storage. \" + \"This can happen if the auth flow was initiated in a different browser or device, \" + \"or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), \" + \"use @supabase/ssr on both the server and client to store the code verifier in cookies.\", \"AuthPKCECodeVerifierMissingError\", 400, \"pkce_code_verifier_not_found\");\n    }\n}\nexports.AuthPKCECodeVerifierMissingError = AuthPKCECodeVerifierMissingError;\nfunction isAuthPKCECodeVerifierMissingError(error) {\n    return isAuthError(error) && error.name === \"AuthPKCECodeVerifierMissingError\";\n}\n/**\n * Error thrown when a transient fetch issue occurs.\n *\n * @example\n * ```ts\n * import { AuthRetryableFetchError } from '@supabase/auth-js'\n *\n * throw new AuthRetryableFetchError('Service temporarily unavailable', 503)\n * ```\n */ class AuthRetryableFetchError extends CustomAuthError {\n    constructor(message, status){\n        super(message, \"AuthRetryableFetchError\", status, undefined);\n    }\n}\nexports.AuthRetryableFetchError = AuthRetryableFetchError;\nfunction isAuthRetryableFetchError(error) {\n    return isAuthError(error) && error.name === \"AuthRetryableFetchError\";\n}\n/**\n * This error is thrown on certain methods when the password used is deemed\n * weak. Inspect the reasons to identify what password strength rules are\n * inadequate.\n */ /**\n * Error thrown when a supplied password is considered weak.\n *\n * @example\n * ```ts\n * import { AuthWeakPasswordError } from '@supabase/auth-js'\n *\n * throw new AuthWeakPasswordError('Password too short', 400, ['min_length'])\n * ```\n */ class AuthWeakPasswordError extends CustomAuthError {\n    constructor(message, status, reasons){\n        super(message, \"AuthWeakPasswordError\", status, \"weak_password\");\n        this.reasons = reasons;\n    }\n}\nexports.AuthWeakPasswordError = AuthWeakPasswordError;\nfunction isAuthWeakPasswordError(error) {\n    return isAuthError(error) && error.name === \"AuthWeakPasswordError\";\n}\n/**\n * Error thrown when a JWT cannot be verified or parsed.\n *\n * @example\n * ```ts\n * import { AuthInvalidJwtError } from '@supabase/auth-js'\n *\n * throw new AuthInvalidJwtError('Token signature is invalid')\n * ```\n */ class AuthInvalidJwtError extends CustomAuthError {\n    constructor(message){\n        super(message, \"AuthInvalidJwtError\", 400, \"invalid_jwt\");\n    }\n}\nexports.AuthInvalidJwtError = AuthInvalidJwtError; //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSw2QkFBNkIsR0FBR0EsK0JBQStCLEdBQUdBLHdDQUF3QyxHQUFHQSxzQ0FBc0MsR0FBR0Esc0NBQXNDLEdBQUdBLG1DQUFtQyxHQUFHQSxxQ0FBcUMsR0FBR0EsK0JBQStCLEdBQUdBLHVCQUF1QixHQUFHQSx3QkFBd0IsR0FBR0Esb0JBQW9CLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFDbGJBLG1CQUFtQixHQUFHZTtBQUN0QmYsc0JBQXNCLEdBQUdnQjtBQUN6QmhCLGlDQUFpQyxHQUFHaUI7QUFDcENqQix3Q0FBd0MsR0FBR2tCO0FBQzNDbEIsMENBQTBDLEdBQUdtQjtBQUM3Q25CLGlDQUFpQyxHQUFHb0I7QUFDcENwQiwrQkFBK0IsR0FBR3FCO0FBQ2xDOzs7Ozs7Ozs7Q0FTQyxHQUNELE1BQU1QLGtCQUFrQlE7SUFDcEJDLFlBQVlDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLENBQUU7UUFDL0IsS0FBSyxDQUFDRjtRQUNOLElBQUksQ0FBQ0csYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO0lBQ2hCO0FBQ0o7QUFDQTFCLGlCQUFpQixHQUFHYztBQUNwQixTQUFTQyxZQUFZYyxLQUFLO0lBQ3RCLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsbUJBQW1CQTtBQUM3RTtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNELE1BQU1oQixxQkFBcUJDO0lBQ3ZCUyxZQUFZQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxDQUFFO1FBQy9CLEtBQUssQ0FBQ0YsU0FBU0MsUUFBUUM7UUFDdkIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNILE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLElBQUksR0FBR0E7SUFDaEI7QUFDSjtBQUNBMUIsb0JBQW9CLEdBQUdhO0FBQ3ZCLFNBQVNHLGVBQWVhLEtBQUs7SUFDekIsT0FBT2QsWUFBWWMsVUFBVUEsTUFBTUQsSUFBSSxLQUFLO0FBQ2hEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELE1BQU1oQix5QkFBeUJFO0lBQzNCUyxZQUFZQyxPQUFPLEVBQUVNLGFBQWEsQ0FBRTtRQUNoQyxLQUFLLENBQUNOO1FBQ04sSUFBSSxDQUFDSSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNFLGFBQWEsR0FBR0E7SUFDekI7QUFDSjtBQUNBOUIsd0JBQXdCLEdBQUdZO0FBQzNCOzs7Ozs7Ozs7Q0FTQyxHQUNELE1BQU1ELHdCQUF3Qkc7SUFDMUJTLFlBQVlDLE9BQU8sRUFBRUksSUFBSSxFQUFFSCxNQUFNLEVBQUVDLElBQUksQ0FBRTtRQUNyQyxLQUFLLENBQUNGLFNBQVNDLFFBQVFDO1FBQ3ZCLElBQUksQ0FBQ0UsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0gsTUFBTSxHQUFHQTtJQUNsQjtBQUNKO0FBQ0F6Qix1QkFBdUIsR0FBR1c7QUFDMUI7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTUQsZ0NBQWdDQztJQUNsQ1ksYUFBYztRQUNWLEtBQUssQ0FBQyx5QkFBeUIsMkJBQTJCLEtBQUtRO0lBQ25FO0FBQ0o7QUFDQS9CLCtCQUErQixHQUFHVTtBQUNsQyxTQUFTTywwQkFBMEJZLEtBQUs7SUFDcEMsT0FBT2QsWUFBWWMsVUFBVUEsTUFBTUQsSUFBSSxLQUFLO0FBQ2hEO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTW5CLHNDQUFzQ0U7SUFDeENZLGFBQWM7UUFDVixLQUFLLENBQUMsZ0NBQWdDLGlDQUFpQyxLQUFLUTtJQUNoRjtBQUNKO0FBQ0EvQixxQ0FBcUMsR0FBR1M7QUFDeEM7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTUQsb0NBQW9DRztJQUN0Q1ksWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0EsU0FBUywrQkFBK0IsS0FBS087SUFDdkQ7QUFDSjtBQUNBL0IsbUNBQW1DLEdBQUdRO0FBQ3RDOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELE1BQU1ELHVDQUF1Q0k7SUFDekNZLFlBQVlDLE9BQU8sRUFBRVEsVUFBVSxJQUFJLENBQUU7UUFDakMsS0FBSyxDQUFDUixTQUFTLGtDQUFrQyxLQUFLTztRQUN0RCxJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNuQjtJQUNBQyxTQUFTO1FBQ0wsT0FBTztZQUNITCxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmSixTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQkMsUUFBUSxJQUFJLENBQUNBLE1BQU07WUFDbkJPLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1FBQ3pCO0lBQ0o7QUFDSjtBQUNBaEMsc0NBQXNDLEdBQUdPO0FBQ3pDLFNBQVNXLGlDQUFpQ1csS0FBSztJQUMzQyxPQUFPZCxZQUFZYyxVQUFVQSxNQUFNRCxJQUFJLEtBQUs7QUFDaEQ7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDRCxNQUFNdEIsdUNBQXVDSztJQUN6Q1ksWUFBWUMsT0FBTyxFQUFFUSxVQUFVLElBQUksQ0FBRTtRQUNqQyxLQUFLLENBQUNSLFNBQVMsa0NBQWtDLEtBQUtPO1FBQ3RELElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0FDLFNBQVM7UUFDTCxPQUFPO1lBQ0hMLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZKLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCQyxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQk8sU0FBUyxJQUFJLENBQUNBLE9BQU87UUFDekI7SUFDSjtBQUNKO0FBQ0FoQyxzQ0FBc0MsR0FBR007QUFDekM7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxNQUFNRCx5Q0FBeUNNO0lBQzNDWSxhQUFjO1FBQ1YsS0FBSyxDQUFDLDhDQUNGLHNGQUNBLG1GQUNBLDBGQUEwRixvQ0FBb0MsS0FBSztJQUMzSTtBQUNKO0FBQ0F2Qix3Q0FBd0MsR0FBR0s7QUFDM0MsU0FBU2MsbUNBQW1DVSxLQUFLO0lBQzdDLE9BQU9kLFlBQVljLFVBQVVBLE1BQU1ELElBQUksS0FBSztBQUNoRDtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNELE1BQU14QixnQ0FBZ0NPO0lBQ2xDWSxZQUFZQyxPQUFPLEVBQUVDLE1BQU0sQ0FBRTtRQUN6QixLQUFLLENBQUNELFNBQVMsMkJBQTJCQyxRQUFRTTtJQUN0RDtBQUNKO0FBQ0EvQiwrQkFBK0IsR0FBR0k7QUFDbEMsU0FBU2dCLDBCQUEwQlMsS0FBSztJQUNwQyxPQUFPZCxZQUFZYyxVQUFVQSxNQUFNRCxJQUFJLEtBQUs7QUFDaEQ7QUFDQTs7OztDQUlDLEdBQ0Q7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTXpCLDhCQUE4QlE7SUFDaENZLFlBQVlDLE9BQU8sRUFBRUMsTUFBTSxFQUFFUyxPQUFPLENBQUU7UUFDbEMsS0FBSyxDQUFDVixTQUFTLHlCQUF5QkMsUUFBUTtRQUNoRCxJQUFJLENBQUNTLE9BQU8sR0FBR0E7SUFDbkI7QUFDSjtBQUNBbEMsNkJBQTZCLEdBQUdHO0FBQ2hDLFNBQVNrQix3QkFBd0JRLEtBQUs7SUFDbEMsT0FBT2QsWUFBWWMsVUFBVUEsTUFBTUQsSUFBSSxLQUFLO0FBQ2hEO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTTFCLDRCQUE0QlM7SUFDOUJZLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBLFNBQVMsdUJBQXVCLEtBQUs7SUFDL0M7QUFDSjtBQUNBeEIsMkJBQTJCLEdBQUdFLHFCQUM5QixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi9lcnJvcnMuanM/OWZkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXV0aEludmFsaWRKd3RFcnJvciA9IGV4cG9ydHMuQXV0aFdlYWtQYXNzd29yZEVycm9yID0gZXhwb3J0cy5BdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciA9IGV4cG9ydHMuQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IgPSBleHBvcnRzLkF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciA9IGV4cG9ydHMuQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yID0gZXhwb3J0cy5BdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IgPSBleHBvcnRzLkF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yID0gZXhwb3J0cy5BdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciA9IGV4cG9ydHMuQ3VzdG9tQXV0aEVycm9yID0gZXhwb3J0cy5BdXRoVW5rbm93bkVycm9yID0gZXhwb3J0cy5BdXRoQXBpRXJyb3IgPSBleHBvcnRzLkF1dGhFcnJvciA9IHZvaWQgMDtcbmV4cG9ydHMuaXNBdXRoRXJyb3IgPSBpc0F1dGhFcnJvcjtcbmV4cG9ydHMuaXNBdXRoQXBpRXJyb3IgPSBpc0F1dGhBcGlFcnJvcjtcbmV4cG9ydHMuaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciA9IGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3I7XG5leHBvcnRzLmlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yID0gaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3I7XG5leHBvcnRzLmlzQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IgPSBpc0F1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yO1xuZXhwb3J0cy5pc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yID0gaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcjtcbmV4cG9ydHMuaXNBdXRoV2Vha1Bhc3N3b3JkRXJyb3IgPSBpc0F1dGhXZWFrUGFzc3dvcmRFcnJvcjtcbi8qKlxuICogQmFzZSBlcnJvciB0aHJvd24gYnkgU3VwYWJhc2UgQXV0aCBoZWxwZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhFcnJvcignVW5leHBlY3RlZCBhdXRoIGVycm9yJywgNTAwLCAndW5leHBlY3RlZCcpXG4gKiBgYGBcbiAqL1xuY2xhc3MgQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgY29kZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fX2lzQXV0aEVycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0F1dGhFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuQXV0aEVycm9yID0gQXV0aEVycm9yO1xuZnVuY3Rpb24gaXNBdXRoRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnX19pc0F1dGhFcnJvcicgaW4gZXJyb3I7XG59XG4vKipcbiAqIEVycm9yIHJldHVybmVkIGRpcmVjdGx5IGZyb20gdGhlIEdvVHJ1ZSBSRVNUIEFQSS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhBcGlFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoQXBpRXJyb3IoJ0ludmFsaWQgY3JlZGVudGlhbHMnLCA0MDAsICdpbnZhbGlkX2NyZWRlbnRpYWxzJylcbiAqIGBgYFxuICovXG5jbGFzcyBBdXRoQXBpRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgY29kZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBzdGF0dXMsIGNvZGUpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aEFwaUVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuZXhwb3J0cy5BdXRoQXBpRXJyb3IgPSBBdXRoQXBpRXJyb3I7XG5mdW5jdGlvbiBpc0F1dGhBcGlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhBcGlFcnJvcic7XG59XG4vKipcbiAqIFdyYXBzIG5vbi1zdGFuZGFyZCBlcnJvcnMgc28gY2FsbGVycyBjYW4gaW5zcGVjdCB0aGUgcm9vdCBjYXVzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhVbmtub3duRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0cnkge1xuICogICBhd2FpdCBzb21lQXV0aENhbGwoKVxuICogfSBjYXRjaCAoZXJyKSB7XG4gKiAgIHRocm93IG5ldyBBdXRoVW5rbm93bkVycm9yKCdBdXRoIGZhaWxlZCcsIGVycilcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBBdXRoVW5rbm93bkVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aFVua25vd25FcnJvcic7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5BdXRoVW5rbm93bkVycm9yID0gQXV0aFVua25vd25FcnJvcjtcbi8qKlxuICogRmxleGlibGUgZXJyb3IgY2xhc3MgdXNlZCB0byBjcmVhdGUgbmFtZWQgYXV0aCBlcnJvcnMgYXQgcnVudGltZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEN1c3RvbUF1dGhFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBDdXN0b21BdXRoRXJyb3IoJ015IGN1c3RvbSBhdXRoIGVycm9yJywgJ015QXV0aEVycm9yJywgNDAwLCAnY3VzdG9tX2NvZGUnKVxuICogYGBgXG4gKi9cbmNsYXNzIEN1c3RvbUF1dGhFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbmFtZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIHN0YXR1cywgY29kZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydHMuQ3VzdG9tQXV0aEVycm9yID0gQ3VzdG9tQXV0aEVycm9yO1xuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gcmVxdWlyZXMgYSBzZXNzaW9uIGJ1dCBub25lIGlzIHByZXNlbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG4gKiBgYGBcbiAqL1xuY2xhc3MgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQXV0aCBzZXNzaW9uIG1pc3NpbmchJywgJ0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yJywgNDAwLCB1bmRlZmluZWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IgPSBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcjtcbmZ1bmN0aW9uIGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcic7XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSB0b2tlbiByZXNwb25zZSBpcyBtYWxmb3JtZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpXG4gKiBgYGBcbiAqL1xuY2xhc3MgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQXV0aCBzZXNzaW9uIG9yIHVzZXIgbWlzc2luZycsICdBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnRzLkF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yID0gQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3I7XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIGVtYWlsL3Bhc3N3b3JkIGNyZWRlbnRpYWxzIGFyZSBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcignRW1haWwgb3IgcGFzc3dvcmQgaXMgaW5jb3JyZWN0JylcbiAqIGBgYFxuICovXG5jbGFzcyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcicsIDQwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnRzLkF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvciA9IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcjtcbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gaW1wbGljaXQgZ3JhbnQgcmVkaXJlY3RzIGNvbnRhaW4gYW4gZXJyb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdPQXV0aCByZWRpcmVjdCBmYWlsZWQnLCB7XG4gKiAgIGVycm9yOiAnYWNjZXNzX2RlbmllZCcsXG4gKiAgIGNvZGU6ICdvYXV0aF9lcnJvcicsXG4gKiB9KVxuICogYGBgXG4gKi9cbmNsYXNzIEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscyA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciA9IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcjtcbmZ1bmN0aW9uIGlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yJztcbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIGR1cmluZyBQS0NFIGNvZGUgZXhjaGFuZ2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcignUEtDRSBleGNoYW5nZSBmYWlsZWQnKVxuICogYGBgXG4gKi9cbmNsYXNzIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscyA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciA9IEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcjtcbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIFBLQ0UgY29kZSB2ZXJpZmllciBpcyBub3QgZm91bmQgaW4gc3RvcmFnZS5cbiAqIFRoaXMgdHlwaWNhbGx5IGhhcHBlbnMgd2hlbiB0aGUgYXV0aCBmbG93IHdhcyBpbml0aWF0ZWQgaW4gYSBkaWZmZXJlbnRcbiAqIGJyb3dzZXIsIGRldmljZSwgb3IgdGhlIHN0b3JhZ2Ugd2FzIGNsZWFyZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvcigpXG4gKiBgYGBcbiAqL1xuY2xhc3MgQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignUEtDRSBjb2RlIHZlcmlmaWVyIG5vdCBmb3VuZCBpbiBzdG9yYWdlLiAnICtcbiAgICAgICAgICAgICdUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIGF1dGggZmxvdyB3YXMgaW5pdGlhdGVkIGluIGEgZGlmZmVyZW50IGJyb3dzZXIgb3IgZGV2aWNlLCAnICtcbiAgICAgICAgICAgICdvciBpZiB0aGUgc3RvcmFnZSB3YXMgY2xlYXJlZC4gRm9yIFNTUiBmcmFtZXdvcmtzIChOZXh0LmpzLCBTdmVsdGVLaXQsIGV0Yy4pLCAnICtcbiAgICAgICAgICAgICd1c2UgQHN1cGFiYXNlL3NzciBvbiBib3RoIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudCB0byBzdG9yZSB0aGUgY29kZSB2ZXJpZmllciBpbiBjb29raWVzLicsICdBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvcicsIDQwMCwgJ3BrY2VfY29kZV92ZXJpZmllcl9ub3RfZm91bmQnKTtcbiAgICB9XG59XG5leHBvcnRzLkF1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yID0gQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3I7XG5mdW5jdGlvbiBpc0F1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3InO1xufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhIHRyYW5zaWVudCBmZXRjaCBpc3N1ZSBvY2N1cnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcignU2VydmljZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZScsIDUwMylcbiAqIGBgYFxuICovXG5jbGFzcyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcicsIHN0YXR1cywgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnRzLkF1dGhSZXRyeWFibGVGZXRjaEVycm9yID0gQXV0aFJldHJ5YWJsZUZldGNoRXJyb3I7XG5mdW5jdGlvbiBpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFJldHJ5YWJsZUZldGNoRXJyb3InO1xufVxuLyoqXG4gKiBUaGlzIGVycm9yIGlzIHRocm93biBvbiBjZXJ0YWluIG1ldGhvZHMgd2hlbiB0aGUgcGFzc3dvcmQgdXNlZCBpcyBkZWVtZWRcbiAqIHdlYWsuIEluc3BlY3QgdGhlIHJlYXNvbnMgdG8gaWRlbnRpZnkgd2hhdCBwYXNzd29yZCBzdHJlbmd0aCBydWxlcyBhcmVcbiAqIGluYWRlcXVhdGUuXG4gKi9cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gYSBzdXBwbGllZCBwYXNzd29yZCBpcyBjb25zaWRlcmVkIHdlYWsuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aFdlYWtQYXNzd29yZEVycm9yKCdQYXNzd29yZCB0b28gc2hvcnQnLCA0MDAsIFsnbWluX2xlbmd0aCddKVxuICogYGBgXG4gKi9cbmNsYXNzIEF1dGhXZWFrUGFzc3dvcmRFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCByZWFzb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InLCBzdGF0dXMsICd3ZWFrX3Bhc3N3b3JkJyk7XG4gICAgICAgIHRoaXMucmVhc29ucyA9IHJlYXNvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5BdXRoV2Vha1Bhc3N3b3JkRXJyb3IgPSBBdXRoV2Vha1Bhc3N3b3JkRXJyb3I7XG5mdW5jdGlvbiBpc0F1dGhXZWFrUGFzc3dvcmRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhXZWFrUGFzc3dvcmRFcnJvcic7XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIGEgSldUIGNhbm5vdCBiZSB2ZXJpZmllZCBvciBwYXJzZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoSW52YWxpZEp3dEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhJbnZhbGlkSnd0RXJyb3IoJ1Rva2VuIHNpZ25hdHVyZSBpcyBpbnZhbGlkJylcbiAqIGBgYFxuICovXG5jbGFzcyBBdXRoSW52YWxpZEp3dEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoSW52YWxpZEp3dEVycm9yJywgNDAwLCAnaW52YWxpZF9qd3QnKTtcbiAgICB9XG59XG5leHBvcnRzLkF1dGhJbnZhbGlkSnd0RXJyb3IgPSBBdXRoSW52YWxpZEp3dEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkF1dGhJbnZhbGlkSnd0RXJyb3IiLCJBdXRoV2Vha1Bhc3N3b3JkRXJyb3IiLCJBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciIsIkF1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yIiwiQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yIiwiQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIiwiQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIiwiQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IiLCJBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciIsIkN1c3RvbUF1dGhFcnJvciIsIkF1dGhVbmtub3duRXJyb3IiLCJBdXRoQXBpRXJyb3IiLCJBdXRoRXJyb3IiLCJpc0F1dGhFcnJvciIsImlzQXV0aEFwaUVycm9yIiwiaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciIsImlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIiwiaXNBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvciIsImlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IiLCJpc0F1dGhXZWFrUGFzc3dvcmRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwic3RhdHVzIiwiY29kZSIsIl9faXNBdXRoRXJyb3IiLCJuYW1lIiwiZXJyb3IiLCJvcmlnaW5hbEVycm9yIiwidW5kZWZpbmVkIiwiZGV0YWlscyIsInRvSlNPTiIsInJlYXNvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/fetch.js":
/*!***************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/lib/fetch.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.handleError = handleError;\nexports._request = _request;\nexports._sessionResponse = _sessionResponse;\nexports._sessionResponsePassword = _sessionResponsePassword;\nexports._userResponse = _userResponse;\nexports._ssoResponse = _ssoResponse;\nexports._generateLinkResponse = _generateLinkResponse;\nexports._noResolveJsonResponse = _noResolveJsonResponse;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/constants.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/helpers.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/errors.js\");\nconst _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst NETWORK_ERROR_CODES = [\n    502,\n    503,\n    504\n];\nasync function handleError(error) {\n    var _a;\n    if (!(0, helpers_1.looksLikeFetchResponse)(error)) {\n        throw new errors_1.AuthRetryableFetchError(_getErrorMessage(error), 0);\n    }\n    if (NETWORK_ERROR_CODES.includes(error.status)) {\n        // status in 500...599 range - server had an error, request might be retryed.\n        throw new errors_1.AuthRetryableFetchError(_getErrorMessage(error), error.status);\n    }\n    let data;\n    try {\n        data = await error.json();\n    } catch (e) {\n        throw new errors_1.AuthUnknownError(_getErrorMessage(e), e);\n    }\n    let errorCode = undefined;\n    const responseAPIVersion = (0, helpers_1.parseResponseAPIVersion)(error);\n    if (responseAPIVersion && responseAPIVersion.getTime() >= constants_1.API_VERSIONS[\"2024-01-01\"].timestamp && typeof data === \"object\" && data && typeof data.code === \"string\") {\n        errorCode = data.code;\n    } else if (typeof data === \"object\" && data && typeof data.error_code === \"string\") {\n        errorCode = data.error_code;\n    }\n    if (!errorCode) {\n        // Legacy support for weak password errors, when there were no error codes\n        if (typeof data === \"object\" && data && typeof data.weak_password === \"object\" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i)=>a && typeof i === \"string\", true)) {\n            throw new errors_1.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);\n        }\n    } else if (errorCode === \"weak_password\") {\n        throw new errors_1.AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);\n    } else if (errorCode === \"session_not_found\") {\n        // The `session_id` inside the JWT does not correspond to a row in the\n        // `sessions` table. This usually means the user has signed out, has been\n        // deleted, or their session has somehow been terminated.\n        throw new errors_1.AuthSessionMissingError();\n    }\n    throw new errors_1.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);\n}\nconst _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\") {\n        return params;\n    }\n    params.headers = Object.assign({\n        \"Content-Type\": \"application/json;charset=UTF-8\"\n    }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return Object.assign(Object.assign({}, params), parameters);\n};\nasync function _request(fetcher, method, url, options) {\n    var _a;\n    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);\n    if (!headers[constants_1.API_VERSION_HEADER_NAME]) {\n        headers[constants_1.API_VERSION_HEADER_NAME] = constants_1.API_VERSIONS[\"2024-01-01\"].name;\n    }\n    if (options === null || options === void 0 ? void 0 : options.jwt) {\n        headers[\"Authorization\"] = `Bearer ${options.jwt}`;\n    }\n    const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        qs[\"redirect_to\"] = options.redirectTo;\n    }\n    const queryString = Object.keys(qs).length ? \"?\" + new URLSearchParams(qs).toString() : \"\";\n    const data = await _handleRequest(fetcher, method, url + queryString, {\n        headers,\n        noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson\n    }, {}, options === null || options === void 0 ? void 0 : options.body);\n    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : {\n        data: Object.assign({}, data),\n        error: null\n    };\n}\nasync function _handleRequest(fetcher, method, url, options, parameters, body) {\n    const requestParams = _getRequestParams(method, options, parameters, body);\n    let result;\n    try {\n        result = await fetcher(url, Object.assign({}, requestParams));\n    } catch (e) {\n        console.error(e);\n        // fetch failed, likely due to a network or CORS error\n        throw new errors_1.AuthRetryableFetchError(_getErrorMessage(e), 0);\n    }\n    if (!result.ok) {\n        await handleError(result);\n    }\n    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {\n        return result;\n    }\n    try {\n        return await result.json();\n    } catch (e) {\n        await handleError(e);\n    }\n}\nfunction _sessionResponse(data) {\n    var _a;\n    let session = null;\n    if (hasSession(data)) {\n        session = Object.assign({}, data);\n        if (!data.expires_at) {\n            session.expires_at = (0, helpers_1.expiresAt)(data.expires_in);\n        }\n    }\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return {\n        data: {\n            session,\n            user\n        },\n        error: null\n    };\n}\nfunction _sessionResponsePassword(data) {\n    const response = _sessionResponse(data);\n    if (!response.error && data.weak_password && typeof data.weak_password === \"object\" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === \"string\" && data.weak_password.reasons.reduce((a, i)=>a && typeof i === \"string\", true)) {\n        response.data.weak_password = data.weak_password;\n    }\n    return response;\n}\nfunction _userResponse(data) {\n    var _a;\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return {\n        data: {\n            user\n        },\n        error: null\n    };\n}\nfunction _ssoResponse(data) {\n    return {\n        data,\n        error: null\n    };\n}\nfunction _generateLinkResponse(data) {\n    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = tslib_1.__rest(data, [\n        \"action_link\",\n        \"email_otp\",\n        \"hashed_token\",\n        \"redirect_to\",\n        \"verification_type\"\n    ]);\n    const properties = {\n        action_link,\n        email_otp,\n        hashed_token,\n        redirect_to,\n        verification_type\n    };\n    const user = Object.assign({}, rest);\n    return {\n        data: {\n            properties,\n            user\n        },\n        error: null\n    };\n}\nfunction _noResolveJsonResponse(data) {\n    return data;\n}\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */ function hasSession(data) {\n    return data.access_token && data.refresh_token && data.expires_in;\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdFO0FBQ3RCRixnQkFBZ0IsR0FBR0c7QUFDbkJILHdCQUF3QixHQUFHSTtBQUMzQkosZ0NBQWdDLEdBQUdLO0FBQ25DTCxxQkFBcUIsR0FBR007QUFDeEJOLG9CQUFvQixHQUFHTztBQUN2QlAsNkJBQTZCLEdBQUdRO0FBQ2hDUiw4QkFBOEIsR0FBR1M7QUFDakMsTUFBTUMsVUFBVUMsbUJBQU9BLENBQUMsdURBQU87QUFDL0IsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsc0ZBQWE7QUFDekMsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUMsa0ZBQVc7QUFDckMsTUFBTUcsV0FBV0gsbUJBQU9BLENBQUMsZ0ZBQVU7QUFDbkMsTUFBTUksbUJBQW1CLENBQUNDLE1BQVFBLElBQUlDLEdBQUcsSUFBSUQsSUFBSUUsT0FBTyxJQUFJRixJQUFJRyxpQkFBaUIsSUFBSUgsSUFBSUksS0FBSyxJQUFJQyxLQUFLQyxTQUFTLENBQUNOO0FBQ2pILE1BQU1PLHNCQUFzQjtJQUFDO0lBQUs7SUFBSztDQUFJO0FBQzNDLGVBQWVyQixZQUFZa0IsS0FBSztJQUM1QixJQUFJSTtJQUNKLElBQUksQ0FBQyxDQUFDLEdBQUdYLFVBQVVZLHNCQUFzQixFQUFFTCxRQUFRO1FBQy9DLE1BQU0sSUFBSU4sU0FBU1ksdUJBQXVCLENBQUNYLGlCQUFpQkssUUFBUTtJQUN4RTtJQUNBLElBQUlHLG9CQUFvQkksUUFBUSxDQUFDUCxNQUFNUSxNQUFNLEdBQUc7UUFDNUMsNkVBQTZFO1FBQzdFLE1BQU0sSUFBSWQsU0FBU1ksdUJBQXVCLENBQUNYLGlCQUFpQkssUUFBUUEsTUFBTVEsTUFBTTtJQUNwRjtJQUNBLElBQUlDO0lBQ0osSUFBSTtRQUNBQSxPQUFP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ZTtLQUFvQjtJQUNuTSxNQUFNaUUsYUFBYTtRQUNmUDtRQUNBQztRQUNBQztRQUNBQztRQUNBQztJQUNKO0lBQ0EsTUFBTU4sT0FBT3ZGLE9BQU84RCxNQUFNLENBQUMsQ0FBQyxHQUFHZ0M7SUFDL0IsT0FBTztRQUNIL0QsTUFBTTtZQUNGaUU7WUFDQVQ7UUFDSjtRQUNBakUsT0FBTztJQUNYO0FBQ0o7QUFDQSxTQUFTWCx1QkFBdUJvQixJQUFJO0lBQ2hDLE9BQU9BO0FBQ1g7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU29ELFdBQVdwRCxJQUFJO0lBQ3BCLE9BQU9BLEtBQUtrRSxZQUFZLElBQUlsRSxLQUFLbUUsYUFBYSxJQUFJbkUsS0FBS3VELFVBQVU7QUFDckUsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi9mZXRjaC5qcz9lMDU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYW5kbGVFcnJvciA9IGhhbmRsZUVycm9yO1xuZXhwb3J0cy5fcmVxdWVzdCA9IF9yZXF1ZXN0O1xuZXhwb3J0cy5fc2Vzc2lvblJlc3BvbnNlID0gX3Nlc3Npb25SZXNwb25zZTtcbmV4cG9ydHMuX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkID0gX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkO1xuZXhwb3J0cy5fdXNlclJlc3BvbnNlID0gX3VzZXJSZXNwb25zZTtcbmV4cG9ydHMuX3Nzb1Jlc3BvbnNlID0gX3Nzb1Jlc3BvbnNlO1xuZXhwb3J0cy5fZ2VuZXJhdGVMaW5rUmVzcG9uc2UgPSBfZ2VuZXJhdGVMaW5rUmVzcG9uc2U7XG5leHBvcnRzLl9ub1Jlc29sdmVKc29uUmVzcG9uc2UgPSBfbm9SZXNvbHZlSnNvblJlc3BvbnNlO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgX2dldEVycm9yTWVzc2FnZSA9IChlcnIpID0+IGVyci5tc2cgfHwgZXJyLm1lc3NhZ2UgfHwgZXJyLmVycm9yX2Rlc2NyaXB0aW9uIHx8IGVyci5lcnJvciB8fCBKU09OLnN0cmluZ2lmeShlcnIpO1xuY29uc3QgTkVUV09SS19FUlJPUl9DT0RFUyA9IFs1MDIsIDUwMywgNTA0XTtcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghKDAsIGhlbHBlcnNfMS5sb29rc0xpa2VGZXRjaFJlc3BvbnNlKShlcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCAwKTtcbiAgICB9XG4gICAgaWYgKE5FVFdPUktfRVJST1JfQ09ERVMuaW5jbHVkZXMoZXJyb3Iuc3RhdHVzKSkge1xuICAgICAgICAvLyBzdGF0dXMgaW4gNTAwLi4uNTk5IHJhbmdlIC0gc2VydmVyIGhhZCBhbiBlcnJvciwgcmVxdWVzdCBtaWdodCBiZSByZXRyeWVkLlxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yLnN0YXR1cyk7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCBlcnJvci5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdXRoVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIGUpO1xuICAgIH1cbiAgICBsZXQgZXJyb3JDb2RlID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlc3BvbnNlQVBJVmVyc2lvbiA9ICgwLCBoZWxwZXJzXzEucGFyc2VSZXNwb25zZUFQSVZlcnNpb24pKGVycm9yKTtcbiAgICBpZiAocmVzcG9uc2VBUElWZXJzaW9uICYmXG4gICAgICAgIHJlc3BvbnNlQVBJVmVyc2lvbi5nZXRUaW1lKCkgPj0gY29uc3RhbnRzXzEuQVBJX1ZFUlNJT05TWycyMDI0LTAxLTAxJ10udGltZXN0YW1wICYmXG4gICAgICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBkYXRhICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLmNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yQ29kZSA9IGRhdGEuY29kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgJiYgdHlwZW9mIGRhdGEuZXJyb3JfY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3JDb2RlID0gZGF0YS5lcnJvcl9jb2RlO1xuICAgIH1cbiAgICBpZiAoIWVycm9yQ29kZSkge1xuICAgICAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3Igd2VhayBwYXNzd29yZCBlcnJvcnMsIHdoZW4gdGhlcmUgd2VyZSBubyBlcnJvciBjb2Rlc1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBkYXRhICYmXG4gICAgICAgICAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKSAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5yZWR1Y2UoKGEsIGkpID0+IGEgJiYgdHlwZW9mIGkgPT09ICdzdHJpbmcnLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF1dGhXZWFrUGFzc3dvcmRFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLCBlcnJvci5zdGF0dXMsIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvckNvZGUgPT09ICd3ZWFrX3Bhc3N3b3JkJykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aFdlYWtQYXNzd29yZEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksIGVycm9yLnN0YXR1cywgKChfYSA9IGRhdGEud2Vha19wYXNzd29yZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYXNvbnMpIHx8IFtdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3JDb2RlID09PSAnc2Vzc2lvbl9ub3RfZm91bmQnKSB7XG4gICAgICAgIC8vIFRoZSBgc2Vzc2lvbl9pZGAgaW5zaWRlIHRoZSBKV1QgZG9lcyBub3QgY29ycmVzcG9uZCB0byBhIHJvdyBpbiB0aGVcbiAgICAgICAgLy8gYHNlc3Npb25zYCB0YWJsZS4gVGhpcyB1c3VhbGx5IG1lYW5zIHRoZSB1c2VyIGhhcyBzaWduZWQgb3V0LCBoYXMgYmVlblxuICAgICAgICAvLyBkZWxldGVkLCBvciB0aGVpciBzZXNzaW9uIGhhcyBzb21laG93IGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdXRoQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZShkYXRhKSwgZXJyb3Iuc3RhdHVzIHx8IDUwMCwgZXJyb3JDb2RlKTtcbn1cbmNvbnN0IF9nZXRSZXF1ZXN0UGFyYW1zID0gKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkgPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgbWV0aG9kLCBoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9IH07XG4gICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyYW1zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9VVRGLTgnIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcbiAgICBwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHBhcmFtZXRlcnMpO1xufTtcbmFzeW5jIGZ1bmN0aW9uIF9yZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKCFoZWFkZXJzW2NvbnN0YW50c18xLkFQSV9WRVJTSU9OX0hFQURFUl9OQU1FXSkge1xuICAgICAgICBoZWFkZXJzW2NvbnN0YW50c18xLkFQSV9WRVJTSU9OX0hFQURFUl9OQU1FXSA9IGNvbnN0YW50c18xLkFQSV9WRVJTSU9OU1snMjAyNC0wMS0wMSddLm5hbWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuand0KSB7XG4gICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHtvcHRpb25zLmp3dH1gO1xuICAgIH1cbiAgICBjb25zdCBxcyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5xdWVyeSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWRpcmVjdFRvKSB7XG4gICAgICAgIHFzWydyZWRpcmVjdF90byddID0gb3B0aW9ucy5yZWRpcmVjdFRvO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IE9iamVjdC5rZXlzKHFzKS5sZW5ndGggPyAnPycgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHFzKS50b1N0cmluZygpIDogJyc7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsICsgcXVlcnlTdHJpbmcsIHtcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgbm9SZXNvbHZlSnNvbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vUmVzb2x2ZUpzb24sXG4gICAgfSwge30sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ib2R5KTtcbiAgICByZXR1cm4gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy54Zm9ybSkgPyBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMueGZvcm0oZGF0YSkgOiB7IGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCBlcnJvcjogbnVsbCB9O1xufVxuYXN5bmMgZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpIHtcbiAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gX2dldFJlcXVlc3RQYXJhbXMobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IGZldGNoZXIodXJsLCBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0UGFyYW1zKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIC8vIGZldGNoIGZhaWxlZCwgbGlrZWx5IGR1ZSB0byBhIG5ldHdvcmsgb3IgQ09SUyBlcnJvclxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlKSwgMCk7XG4gICAgfVxuICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gX3Nlc3Npb25SZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBzZXNzaW9uID0gbnVsbDtcbiAgICBpZiAoaGFzU2Vzc2lvbihkYXRhKSkge1xuICAgICAgICBzZXNzaW9uID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YSk7XG4gICAgICAgIGlmICghZGF0YS5leHBpcmVzX2F0KSB7XG4gICAgICAgICAgICBzZXNzaW9uLmV4cGlyZXNfYXQgPSAoMCwgaGVscGVyc18xLmV4cGlyZXNBdCkoZGF0YS5leHBpcmVzX2luKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1c2VyID0gKF9hID0gZGF0YS51c2VyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRhO1xuICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbiwgdXNlciB9LCBlcnJvcjogbnVsbCB9O1xufVxuZnVuY3Rpb24gX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkKGRhdGEpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IF9zZXNzaW9uUmVzcG9uc2UoZGF0YSk7XG4gICAgaWYgKCFyZXNwb25zZS5lcnJvciAmJlxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQgJiZcbiAgICAgICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucykgJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgICAgIGRhdGEud2Vha19wYXNzd29yZC5tZXNzYWdlICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMucmVkdWNlKChhLCBpKSA9PiBhICYmIHR5cGVvZiBpID09PSAnc3RyaW5nJywgdHJ1ZSkpIHtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS53ZWFrX3Bhc3N3b3JkID0gZGF0YS53ZWFrX3Bhc3N3b3JkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5mdW5jdGlvbiBfdXNlclJlc3BvbnNlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdXNlciA9IChfYSA9IGRhdGEudXNlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YTtcbiAgICByZXR1cm4geyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IG51bGwgfTtcbn1cbmZ1bmN0aW9uIF9zc29SZXNwb25zZShkYXRhKSB7XG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbn1cbmZ1bmN0aW9uIF9nZW5lcmF0ZUxpbmtSZXNwb25zZShkYXRhKSB7XG4gICAgY29uc3QgeyBhY3Rpb25fbGluaywgZW1haWxfb3RwLCBoYXNoZWRfdG9rZW4sIHJlZGlyZWN0X3RvLCB2ZXJpZmljYXRpb25fdHlwZSB9ID0gZGF0YSwgcmVzdCA9IHRzbGliXzEuX19yZXN0KGRhdGEsIFtcImFjdGlvbl9saW5rXCIsIFwiZW1haWxfb3RwXCIsIFwiaGFzaGVkX3Rva2VuXCIsIFwicmVkaXJlY3RfdG9cIiwgXCJ2ZXJpZmljYXRpb25fdHlwZVwiXSk7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgYWN0aW9uX2xpbmssXG4gICAgICAgIGVtYWlsX290cCxcbiAgICAgICAgaGFzaGVkX3Rva2VuLFxuICAgICAgICByZWRpcmVjdF90byxcbiAgICAgICAgdmVyaWZpY2F0aW9uX3R5cGUsXG4gICAgfTtcbiAgICBjb25zdCB1c2VyID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgIHVzZXIsXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgIH07XG59XG5mdW5jdGlvbiBfbm9SZXNvbHZlSnNvblJlc3BvbnNlKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogaGFzU2Vzc2lvbiBjaGVja3MgaWYgdGhlIHJlc3BvbnNlIG9iamVjdCBjb250YWlucyBhIHZhbGlkIHNlc3Npb25cbiAqIEBwYXJhbSBkYXRhIEEgcmVzcG9uc2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgc2Vzc2lvbiBpcyBpbiB0aGUgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gaGFzU2Vzc2lvbihkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEuYWNjZXNzX3Rva2VuICYmIGRhdGEucmVmcmVzaF90b2tlbiAmJiBkYXRhLmV4cGlyZXNfaW47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJoYW5kbGVFcnJvciIsIl9yZXF1ZXN0IiwiX3Nlc3Npb25SZXNwb25zZSIsIl9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCIsIl91c2VyUmVzcG9uc2UiLCJfc3NvUmVzcG9uc2UiLCJfZ2VuZXJhdGVMaW5rUmVzcG9uc2UiLCJfbm9SZXNvbHZlSnNvblJlc3BvbnNlIiwidHNsaWJfMSIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsImhlbHBlcnNfMSIsImVycm9yc18xIiwiX2dldEVycm9yTWVzc2FnZSIsImVyciIsIm1zZyIsIm1lc3NhZ2UiLCJlcnJvcl9kZXNjcmlwdGlvbiIsImVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsIk5FVFdPUktfRVJST1JfQ09ERVMiLCJfYSIsImxvb2tzTGlrZUZldGNoUmVzcG9uc2UiLCJBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciIsImluY2x1ZGVzIiwic3RhdHVzIiwiZGF0YSIsImpzb24iLCJlIiwiQXV0aFVua25vd25FcnJvciIsImVycm9yQ29kZSIsInVuZGVmaW5lZCIsInJlc3BvbnNlQVBJVmVyc2lvbiIsInBhcnNlUmVzcG9uc2VBUElWZXJzaW9uIiwiZ2V0VGltZSIsIkFQSV9WRVJTSU9OUyIsInRpbWVzdGFtcCIsImNvZGUiLCJlcnJvcl9jb2RlIiwid2Vha19wYXNzd29yZCIsIkFycmF5IiwiaXNBcnJheSIsInJlYXNvbnMiLCJsZW5ndGgiLCJyZWR1Y2UiLCJhIiwiaSIsIkF1dGhXZWFrUGFzc3dvcmRFcnJvciIsIkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIiwiQXV0aEFwaUVycm9yIiwiX2dldFJlcXVlc3RQYXJhbXMiLCJtZXRob2QiLCJvcHRpb25zIiwicGFyYW1ldGVycyIsImJvZHkiLCJwYXJhbXMiLCJoZWFkZXJzIiwiYXNzaWduIiwiZmV0Y2hlciIsInVybCIsIkFQSV9WRVJTSU9OX0hFQURFUl9OQU1FIiwibmFtZSIsImp3dCIsInFzIiwicXVlcnkiLCJyZWRpcmVjdFRvIiwicXVlcnlTdHJpbmciLCJrZXlzIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJfaGFuZGxlUmVxdWVzdCIsIm5vUmVzb2x2ZUpzb24iLCJ4Zm9ybSIsInJlcXVlc3RQYXJhbXMiLCJyZXN1bHQiLCJjb25zb2xlIiwib2siLCJzZXNzaW9uIiwiaGFzU2Vzc2lvbiIsImV4cGlyZXNfYXQiLCJleHBpcmVzQXQiLCJleHBpcmVzX2luIiwidXNlciIsInJlc3BvbnNlIiwiYWN0aW9uX2xpbmsiLCJlbWFpbF9vdHAiLCJoYXNoZWRfdG9rZW4iLCJyZWRpcmVjdF90byIsInZlcmlmaWNhdGlvbl90eXBlIiwicmVzdCIsIl9fcmVzdCIsInByb3BlcnRpZXMiLCJhY2Nlc3NfdG9rZW4iLCJyZWZyZXNoX3Rva2VuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/helpers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/lib/helpers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Deferred = exports.removeItemAsync = exports.getItemAsync = exports.setItemAsync = exports.looksLikeFetchResponse = exports.resolveFetch = exports.supportsLocalStorage = exports.isBrowser = void 0;\nexports.expiresAt = expiresAt;\nexports.generateCallbackId = generateCallbackId;\nexports.parseParametersFromURL = parseParametersFromURL;\nexports.decodeJWT = decodeJWT;\nexports.sleep = sleep;\nexports.retryable = retryable;\nexports.generatePKCEVerifier = generatePKCEVerifier;\nexports.generatePKCEChallenge = generatePKCEChallenge;\nexports.getCodeChallengeAndMethod = getCodeChallengeAndMethod;\nexports.parseResponseAPIVersion = parseResponseAPIVersion;\nexports.validateExp = validateExp;\nexports.getAlgorithm = getAlgorithm;\nexports.validateUUID = validateUUID;\nexports.userNotAvailableProxy = userNotAvailableProxy;\nexports.insecureUserWarningProxy = insecureUserWarningProxy;\nexports.deepClone = deepClone;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/constants.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/errors.js\");\nconst base64url_1 = __webpack_require__(/*! ./base64url */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/base64url.js\");\nfunction expiresAt(expiresIn) {\n    const timeNow = Math.round(Date.now() / 1000);\n    return timeNow + expiresIn;\n}\n/**\n * Generates a unique identifier for internal callback subscriptions.\n *\n * This function uses JavaScript Symbols to create guaranteed-unique identifiers\n * for auth state change callbacks. Symbols are ideal for this use case because:\n * - They are guaranteed unique by the JavaScript runtime\n * - They work in all environments (browser, SSR, Node.js)\n * - They avoid issues with Next.js 16 deterministic rendering requirements\n * - They are perfect for internal, non-serializable identifiers\n *\n * Note: This function is only used for internal subscription management,\n * not for security-critical operations like session tokens.\n */ function generateCallbackId() {\n    return Symbol(\"auth-callback\");\n}\nconst isBrowser = ()=> false && 0;\nexports.isBrowser = isBrowser;\nconst localStorageWriteTests = {\n    tested: false,\n    writable: false\n};\n/**\n * Checks whether localStorage is supported on this browser.\n */ const supportsLocalStorage = ()=>{\n    if (!(0, exports.isBrowser)()) {\n        return false;\n    }\n    try {\n        if (typeof globalThis.localStorage !== \"object\") {\n            return false;\n        }\n    } catch (e) {\n        // DOM exception when accessing `localStorage`\n        return false;\n    }\n    if (localStorageWriteTests.tested) {\n        return localStorageWriteTests.writable;\n    }\n    const randomKey = `lswt-${Math.random()}${Math.random()}`;\n    try {\n        globalThis.localStorage.setItem(randomKey, randomKey);\n        globalThis.localStorage.removeItem(randomKey);\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = true;\n    } catch (e) {\n        // localStorage can't be written to\n        // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = false;\n    }\n    return localStorageWriteTests.writable;\n};\nexports.supportsLocalStorage = supportsLocalStorage;\n/**\n * Extracts parameters encoded in the URL both in the query and fragment.\n */ function parseParametersFromURL(href) {\n    const result = {};\n    const url = new URL(href);\n    if (url.hash && url.hash[0] === \"#\") {\n        try {\n            const hashSearchParams = new URLSearchParams(url.hash.substring(1));\n            hashSearchParams.forEach((value, key)=>{\n                result[key] = value;\n            });\n        } catch (e) {\n        // hash is not a query string\n        }\n    }\n    // search parameters take precedence over hash parameters\n    url.searchParams.forEach((value, key)=>{\n        result[key] = value;\n    });\n    return result;\n}\nconst resolveFetch = (customFetch)=>{\n    if (customFetch) {\n        return (...args)=>customFetch(...args);\n    }\n    return (...args)=>fetch(...args);\n};\nexports.resolveFetch = resolveFetch;\nconst looksLikeFetchResponse = (maybeResponse)=>{\n    return typeof maybeResponse === \"object\" && maybeResponse !== null && \"status\" in maybeResponse && \"ok\" in maybeResponse && \"json\" in maybeResponse && typeof maybeResponse.json === \"function\";\n};\nexports.looksLikeFetchResponse = looksLikeFetchResponse;\n// Storage helpers\nconst setItemAsync = async (storage, key, data)=>{\n    await storage.setItem(key, JSON.stringify(data));\n};\nexports.setItemAsync = setItemAsync;\nconst getItemAsync = async (storage, key)=>{\n    const value = await storage.getItem(key);\n    if (!value) {\n        return null;\n    }\n    try {\n        return JSON.parse(value);\n    } catch (_a) {\n        return value;\n    }\n};\nexports.getItemAsync = getItemAsync;\nconst removeItemAsync = async (storage, key)=>{\n    await storage.removeItem(key);\n};\nexports.removeItemAsync = removeItemAsync;\n/**\n * A deferred represents some asynchronous work that is not yet finished, which\n * may or may not culminate in a value.\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\n */ class Deferred {\n    constructor(){\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        this.promise = new Deferred.promiseConstructor((res, rej)=>{\n            // eslint-disable-next-line @typescript-eslint/no-extra-semi\n            ;\n            this.resolve = res;\n            this.reject = rej;\n        });\n    }\n}\nexports.Deferred = Deferred;\nDeferred.promiseConstructor = Promise;\nfunction decodeJWT(token) {\n    const parts = token.split(\".\");\n    if (parts.length !== 3) {\n        throw new errors_1.AuthInvalidJwtError(\"Invalid JWT structure\");\n    }\n    // Regex checks for base64url format\n    for(let i = 0; i < parts.length; i++){\n        if (!constants_1.BASE64URL_REGEX.test(parts[i])) {\n            throw new errors_1.AuthInvalidJwtError(\"JWT not in base64url format\");\n        }\n    }\n    const data = {\n        // using base64url lib\n        header: JSON.parse((0, base64url_1.stringFromBase64URL)(parts[0])),\n        payload: JSON.parse((0, base64url_1.stringFromBase64URL)(parts[1])),\n        signature: (0, base64url_1.base64UrlToUint8Array)(parts[2]),\n        raw: {\n            header: parts[0],\n            payload: parts[1]\n        }\n    };\n    return data;\n}\n/**\n * Creates a promise that resolves to null after some time.\n */ async function sleep(time) {\n    return await new Promise((accept)=>{\n        setTimeout(()=>accept(null), time);\n    });\n}\n/**\n * Converts the provided async function into a retryable function. Each result\n * or thrown error is sent to the isRetryable function which should return true\n * if the function should run again.\n */ function retryable(fn, isRetryable) {\n    const promise = new Promise((accept, reject)=>{\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        (async ()=>{\n            for(let attempt = 0; attempt < Infinity; attempt++){\n                try {\n                    const result = await fn(attempt);\n                    if (!isRetryable(attempt, null, result)) {\n                        accept(result);\n                        return;\n                    }\n                } catch (e) {\n                    if (!isRetryable(attempt, e)) {\n                        reject(e);\n                        return;\n                    }\n                }\n            }\n        })();\n    });\n    return promise;\n}\nfunction dec2hex(dec) {\n    return (\"0\" + dec.toString(16)).substr(-2);\n}\n// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs\nfunction generatePKCEVerifier() {\n    const verifierLength = 56;\n    const array = new Uint32Array(verifierLength);\n    if (typeof crypto === \"undefined\") {\n        const charSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\";\n        const charSetLen = charSet.length;\n        let verifier = \"\";\n        for(let i = 0; i < verifierLength; i++){\n            verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));\n        }\n        return verifier;\n    }\n    crypto.getRandomValues(array);\n    return Array.from(array, dec2hex).join(\"\");\n}\nasync function sha256(randomString) {\n    const encoder = new TextEncoder();\n    const encodedData = encoder.encode(randomString);\n    const hash = await crypto.subtle.digest(\"SHA-256\", encodedData);\n    const bytes = new Uint8Array(hash);\n    return Array.from(bytes).map((c)=>String.fromCharCode(c)).join(\"\");\n}\nasync function generatePKCEChallenge(verifier) {\n    const hasCryptoSupport = typeof crypto !== \"undefined\" && typeof crypto.subtle !== \"undefined\" && typeof TextEncoder !== \"undefined\";\n    if (!hasCryptoSupport) {\n        console.warn(\"WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.\");\n        return verifier;\n    }\n    const hashed = await sha256(verifier);\n    return btoa(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nasync function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {\n    const codeVerifier = generatePKCEVerifier();\n    let storedCodeVerifier = codeVerifier;\n    if (isPasswordRecovery) {\n        storedCodeVerifier += \"/PASSWORD_RECOVERY\";\n    }\n    await (0, exports.setItemAsync)(storage, `${storageKey}-code-verifier`, storedCodeVerifier);\n    const codeChallenge = await generatePKCEChallenge(codeVerifier);\n    const codeChallengeMethod = codeVerifier === codeChallenge ? \"plain\" : \"s256\";\n    return [\n        codeChallenge,\n        codeChallengeMethod\n    ];\n}\n/** Parses the API version which is 2YYY-MM-DD. */ const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;\nfunction parseResponseAPIVersion(response) {\n    const apiVersion = response.headers.get(constants_1.API_VERSION_HEADER_NAME);\n    if (!apiVersion) {\n        return null;\n    }\n    if (!apiVersion.match(API_VERSION_REGEX)) {\n        return null;\n    }\n    try {\n        const date = new Date(`${apiVersion}T00:00:00.0Z`);\n        return date;\n    } catch (e) {\n        return null;\n    }\n}\nfunction validateExp(exp) {\n    if (!exp) {\n        throw new Error(\"Missing exp claim\");\n    }\n    const timeNow = Math.floor(Date.now() / 1000);\n    if (exp <= timeNow) {\n        throw new Error(\"JWT has expired\");\n    }\n}\nfunction getAlgorithm(alg) {\n    switch(alg){\n        case \"RS256\":\n            return {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            };\n        case \"ES256\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: \"P-256\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            };\n        default:\n            throw new Error(\"Invalid alg claim\");\n    }\n}\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;\nfunction validateUUID(str) {\n    if (!UUID_REGEX.test(str)) {\n        throw new Error(\"@supabase/auth-js: Expected parameter to be UUID but is not\");\n    }\n}\nfunction userNotAvailableProxy() {\n    const proxyTarget = {};\n    return new Proxy(proxyTarget, {\n        get: (target, prop)=>{\n            if (prop === \"__isUserNotAvailableProxy\") {\n                return true;\n            }\n            // Preventative check for common problematic symbols during cloning/inspection\n            // These symbols might be accessed by structuredClone or other internal mechanisms.\n            if (typeof prop === \"symbol\") {\n                const sProp = prop.toString();\n                if (sProp === \"Symbol(Symbol.toPrimitive)\" || sProp === \"Symbol(Symbol.toStringTag)\" || sProp === \"Symbol(util.inspect.custom)\") {\n                    // Node.js util.inspect\n                    return undefined;\n                }\n            }\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the \"${prop}\" property of the session object is not supported. Please use getUser() instead.`);\n        },\n        set: (_target, prop)=>{\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the \"${prop}\" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);\n        },\n        deleteProperty: (_target, prop)=>{\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the \"${prop}\" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);\n        }\n    });\n}\n/**\n * Creates a proxy around a user object that warns when properties are accessed on the server.\n * This is used to alert developers that using user data from getSession() on the server is insecure.\n *\n * @param user The actual user object to wrap\n * @param suppressWarningRef An object with a 'value' property that controls warning suppression\n * @returns A proxied user object that warns on property access\n */ function insecureUserWarningProxy(user, suppressWarningRef) {\n    return new Proxy(user, {\n        get: (target, prop, receiver)=>{\n            // Allow internal checks without warning\n            if (prop === \"__isInsecureUserWarningProxy\") {\n                return true;\n            }\n            // Preventative check for common problematic symbols during cloning/inspection\n            // These symbols might be accessed by structuredClone or other internal mechanisms\n            if (typeof prop === \"symbol\") {\n                const sProp = prop.toString();\n                if (sProp === \"Symbol(Symbol.toPrimitive)\" || sProp === \"Symbol(Symbol.toStringTag)\" || sProp === \"Symbol(util.inspect.custom)\" || sProp === \"Symbol(nodejs.util.inspect.custom)\") {\n                    // Return the actual value for these symbols to allow proper inspection\n                    return Reflect.get(target, prop, receiver);\n                }\n            }\n            // Emit warning on first property access\n            if (!suppressWarningRef.value && typeof prop === \"string\") {\n                console.warn(\"Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.\");\n                suppressWarningRef.value = true;\n            }\n            return Reflect.get(target, prop, receiver);\n        }\n    });\n}\n/**\n * Deep clones a JSON-serializable object using JSON.parse(JSON.stringify(obj)).\n * Note: Only works for JSON-safe data.\n */ function deepClone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBR0EsdUJBQXVCLEdBQUdBLG9CQUFvQixHQUFHQSxvQkFBb0IsR0FBR0EsOEJBQThCLEdBQUdBLG9CQUFvQixHQUFHQSw0QkFBNEIsR0FBR0EsaUJBQWlCLEdBQUcsS0FBSztBQUMzTUEsaUJBQWlCLEdBQUdVO0FBQ3BCViwwQkFBMEIsR0FBR1c7QUFDN0JYLDhCQUE4QixHQUFHWTtBQUNqQ1osaUJBQWlCLEdBQUdhO0FBQ3BCYixhQUFhLEdBQUdjO0FBQ2hCZCxpQkFBaUIsR0FBR2U7QUFDcEJmLDRCQUE0QixHQUFHZ0I7QUFDL0JoQiw2QkFBNkIsR0FBR2lCO0FBQ2hDakIsaUNBQWlDLEdBQUdrQjtBQUNwQ2xCLCtCQUErQixHQUFHbUI7QUFDbENuQixtQkFBbUIsR0FBR29CO0FBQ3RCcEIsb0JBQW9CLEdBQUdxQjtBQUN2QnJCLG9CQUFvQixHQUFHc0I7QUFDdkJ0Qiw2QkFBNkIsR0FBR3VCO0FBQ2hDdkIsZ0NBQWdDLEdBQUd3QjtBQUNuQ3hCLGlCQUFpQixHQUFHeUI7QUFDcEIsTUFBTUMsY0FBY0MsbUJBQU9BLENBQUMsc0ZBQWE7QUFDekMsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsZ0ZBQVU7QUFDbkMsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsc0ZBQWE7QUFDekMsU0FBU2pCLFVBQVVvQixTQUFTO0lBQ3hCLE1BQU1DLFVBQVVDLEtBQUtDLEtBQUssQ0FBQ0MsS0FBS0MsR0FBRyxLQUFLO0lBQ3hDLE9BQU9KLFVBQVVEO0FBQ3JCO0FBQ0E7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsU0FBU25CO0lBQ0wsT0FBT3lCLE9BQU87QUFDbEI7QUFDQSxNQUFNM0IsWUFBWSxJQUFNLE1BQWtCLElBQWUsQ0FBb0I7QUFDN0VULGlCQUFpQixHQUFHUztBQUNwQixNQUFNNkIseUJBQXlCO0lBQzNCQyxRQUFRO0lBQ1JDLFVBQVU7QUFDZDtBQUNBOztDQUVDLEdBQ0QsTUFBTWhDLHVCQUF1QjtJQUN6QixJQUFJLENBQUMsQ0FBQyxHQUFHUixRQUFRUyxTQUFTLEtBQUs7UUFDM0IsT0FBTztJQUNYO0lBQ0EsSUFBSTtRQUNBLElBQUksT0FBT2dDLFdBQVdDLFlBQVksS0FBSyxVQUFVO1lBQzdDLE9BQU87UUFDWDtJQUNKLEVBQ0EsT0FBT0MsR0FBRztRQUNOLDhDQUE4QztRQUM5QyxPQUFPO0lBQ1g7SUFDQSxJQUFJTCx1QkFBdUJDLE1BQU0sRUFBRTtRQUMvQixPQUFPRCx1QkFBdUJFLFFBQVE7SUFDMUM7SUFDQSxNQUFNSSxZQUFZLENBQUMsS0FBSyxFQUFFWixLQUFLYSxNQUFNLEdBQUcsRUFBRWIsS0FBS2EsTUFBTSxHQUFHLENBQUM7SUFDekQsSUFBSTtRQUNBSixXQUFXQyxZQUFZLENBQUNJLE9BQU8sQ0FBQ0YsV0FBV0E7UUFDM0NILFdBQVdDLFlBQVksQ0FBQ0ssVUFBVSxDQUFDSDtRQUNuQ04sdUJBQXVCQyxNQUFNLEdBQUc7UUFDaENELHVCQUF1QkUsUUFBUSxHQUFHO0lBQ3RDLEVBQ0EsT0FBT0csR0FBRztRQUNOLG1DQUFtQztRQUNuQywrS0FBK0s7UUFDL0tMLHVCQUF1QkMsTUFBTSxHQUFHO1FBQ2hDRCx1QkFBdUJFLFFBQVEsR0FBRztJQUN0QztJQUNBLE9BQU9GLHVCQUF1QkUsUUFBUTtBQUMxQztBQUNBeEMsNEJBQTRCLEdBQUdRO0FBQy9COztDQUVDLEdBQ0QsU0FBU0ksdUJBQXVCb0MsSUFBSTtJQUNoQyxNQUFNQyxTQUFTLENBQUM7SUFDaEIsTUFBTUMsTUFBTSxJQUFJQyxJQUFJSDtJQUNwQixJQUFJRSxJQUFJRSxJQUFJLElBQUlGLElBQUlFLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBSztRQUNqQyxJQUFJO1lBQ0EsTUFBTUMsbUJBQW1CLElBQUlDLGdCQUFnQkosSUFBSUUsSUFBSSxDQUFDRyxTQUFTLENBQUM7WUFDaEVGLGlCQUFpQkcsT0FBTyxDQUFDLENBQUN2RCxPQUFPd0Q7Z0JBQzdCUixNQUFNLENBQUNRLElBQUksR0FBR3hEO1lBQ2xCO1FBQ0osRUFDQSxPQUFPMEMsR0FBRztRQUNOLDZCQUE2QjtRQUNqQztJQUNKO0lBQ0EseURBQXlEO0lBQ3pETyxJQUFJUSxZQUFZLENBQUNGLE9BQU8sQ0FBQyxDQUFDdkQsT0FBT3dEO1FBQzdCUixNQUFNLENBQUNRLElBQUksR0FBR3hEO0lBQ2xCO0lBQ0EsT0FBT2dEO0FBQ1g7QUFDQSxNQUFNMUMsZUFBZSxDQUFDb0Q7SUFDbEIsSUFBSUEsYUFBYTtRQUNiLE9BQU8sQ0FBQyxHQUFHQyxPQUFTRCxlQUFlQztJQUN2QztJQUNBLE9BQU8sQ0FBQyxHQUFHQSxPQUFTQyxTQUFTRDtBQUNqQztBQUNBNUQsb0JBQW9CLEdBQUdPO0FBQ3ZCLE1BQU1ELHlCQUF5QixDQUFDd0Q7SUFDNUIsT0FBUSxPQUFPQSxrQkFBa0IsWUFDN0JBLGtCQUFrQixRQUNsQixZQUFZQSxpQkFDWixRQUFRQSxpQkFDUixVQUFVQSxpQkFDVixPQUFPQSxjQUFjQyxJQUFJLEtBQUs7QUFDdEM7QUFDQS9ELDhCQUE4QixHQUFHTTtBQUNqQyxrQkFBa0I7QUFDbEIsTUFBTUQsZUFBZSxPQUFPMkQsU0FBU1AsS0FBS1E7SUFDdEMsTUFBTUQsUUFBUWxCLE9BQU8sQ0FBQ1csS0FBS1MsS0FBS0MsU0FBUyxDQUFDRjtBQUM5QztBQUNBakUsb0JBQW9CLEdBQUdLO0FBQ3ZCLE1BQU1ELGVBQWUsT0FBTzRELFNBQVNQO0lBQ2pDLE1BQU14RCxRQUFRLE1BQU0rRCxRQUFRSSxPQUFPLENBQUNYO0lBQ3BDLElBQUksQ0FBQ3hELE9BQU87UUFDUixPQUFPO0lBQ1g7SUFDQSxJQUFJO1FBQ0EsT0FBT2lFLEtBQUtHLEtBQUssQ0FBQ3BFO0lBQ3RCLEVBQ0EsT0FBT3FFLElBQUk7UUFDUCxPQUFPckU7SUFDWDtBQUNKO0FBQ0FELG9CQUFvQixHQUFHSTtBQUN2QixNQUFNRCxrQkFBa0IsT0FBTzZELFNBQVNQO0lBQ3BDLE1BQU1PLFFBQVFqQixVQUFVLENBQUNVO0FBQzdCO0FBQ0F6RCx1QkFBdUIsR0FBR0c7QUFDMUI7Ozs7Q0FJQyxHQUNELE1BQU1EO0lBQ0ZxRSxhQUFjO1FBQ1YsNERBQTREOztRQUU1RCxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJdEUsU0FBU3VFLGtCQUFrQixDQUFDLENBQUNDLEtBQUtDO1lBQ2pELDREQUE0RDs7WUFFNUQsSUFBSSxDQUFDQyxPQUFPLEdBQUdGO1lBQ2YsSUFBSSxDQUFDRyxNQUFNLEdBQUdGO1FBQ2xCO0lBQ0o7QUFDSjtBQUNBM0UsZ0JBQWdCLEdBQUdFO0FBQ25CQSxTQUFTdUUsa0JBQWtCLEdBQUdLO0FBQzlCLFNBQVNqRSxVQUFVa0UsS0FBSztJQUNwQixNQUFNQyxRQUFRRCxNQUFNRSxLQUFLLENBQUM7SUFDMUIsSUFBSUQsTUFBTUUsTUFBTSxLQUFLLEdBQUc7UUFDcEIsTUFBTSxJQUFJdEQsU0FBU3VELG1CQUFtQixDQUFDO0lBQzNDO0lBQ0Esb0NBQW9DO0lBQ3BDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixNQUFNRSxNQUFNLEVBQUVFLElBQUs7UUFDbkMsSUFBSSxDQUFDMUQsWUFBWTJELGVBQWUsQ0FBQ0MsSUFBSSxDQUFDTixLQUFLLENBQUNJLEVBQUUsR0FBRztZQUM3QyxNQUFNLElBQUl4RCxTQUFTdUQsbUJBQW1CLENBQUM7UUFDM0M7SUFDSjtJQUNBLE1BQU1sQixPQUFPO1FBQ1Qsc0JBQXNCO1FBQ3RCc0IsUUFBUXJCLEtBQUtHLEtBQUssQ0FBQyxDQUFDLEdBQUd4QyxZQUFZMkQsbUJBQW1CLEVBQUVSLEtBQUssQ0FBQyxFQUFFO1FBQ2hFUyxTQUFTdkIsS0FBS0csS0FBSyxDQUFDLENBQUMsR0FBR3hDLFlBQVkyRCxtQkFBbUIsRUFBRVIsS0FBSyxDQUFDLEVBQUU7UUFDakVVLFdBQVcsQ0FBQyxHQUFHN0QsWUFBWThELHFCQUFxQixFQUFFWCxLQUFLLENBQUMsRUFBRTtRQUMxRFksS0FBSztZQUNETCxRQUFRUCxLQUFLLENBQUMsRUFBRTtZQUNoQlMsU0FBU1QsS0FBSyxDQUFDLEVBQUU7UUFDckI7SUFDSjtJQUNBLE9BQU9mO0FBQ1g7QUFDQTs7Q0FFQyxHQUNELGVBQWVuRCxNQUFNK0UsSUFBSTtJQUNyQixPQUFPLE1BQU0sSUFBSWYsUUFBUSxDQUFDZ0I7UUFDdEJDLFdBQVcsSUFBTUQsT0FBTyxPQUFPRDtJQUNuQztBQUNKO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVM5RSxVQUFVaUYsRUFBRSxFQUFFQyxXQUFXO0lBQzlCLE1BQU16QixVQUFVLElBQUlNLFFBQVEsQ0FBQ2dCLFFBQVFqQjtRQUNqQyw0REFBNEQ7O1FBRTNEO1lBQ0csSUFBSyxJQUFJcUIsVUFBVSxHQUFHQSxVQUFVQyxVQUFVRCxVQUFXO2dCQUNqRCxJQUFJO29CQUNBLE1BQU1qRCxTQUFTLE1BQU0rQyxHQUFHRTtvQkFDeEIsSUFBSSxDQUFDRCxZQUFZQyxTQUFTLE1BQU1qRCxTQUFTO3dCQUNyQzZDLE9BQU83Qzt3QkFDUDtvQkFDSjtnQkFDSixFQUNBLE9BQU9OLEdBQUc7b0JBQ04sSUFBSSxDQUFDc0QsWUFBWUMsU0FBU3ZELElBQUk7d0JBQzFCa0MsT0FBT2xDO3dCQUNQO29CQUNKO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBTzZCO0FBQ1g7QUFDQSxTQUFTNEIsUUFBUUMsR0FBRztJQUNoQixPQUFPLENBQUMsTUFBTUEsSUFBSUMsUUFBUSxDQUFDLEdBQUUsRUFBR0MsTUFBTSxDQUFDLENBQUM7QUFDNUM7QUFDQSwwSkFBMEo7QUFDMUosU0FBU3ZGO0lBQ0wsTUFBTXdGLGlCQUFpQjtJQUN2QixNQUFNQyxRQUFRLElBQUlDLFlBQVlGO0lBQzlCLElBQUksT0FBT0csV0FBVyxhQUFhO1FBQy9CLE1BQU1DLFVBQVU7UUFDaEIsTUFBTUMsYUFBYUQsUUFBUTFCLE1BQU07UUFDakMsSUFBSTRCLFdBQVc7UUFDZixJQUFLLElBQUkxQixJQUFJLEdBQUdBLElBQUlvQixnQkFBZ0JwQixJQUFLO1lBQ3JDMEIsWUFBWUYsUUFBUUcsTUFBTSxDQUFDL0UsS0FBS2dGLEtBQUssQ0FBQ2hGLEtBQUthLE1BQU0sS0FBS2dFO1FBQzFEO1FBQ0EsT0FBT0M7SUFDWDtJQUNBSCxPQUFPTSxlQUFlLENBQUNSO0lBQ3ZCLE9BQU9TLE1BQU1DLElBQUksQ0FBQ1YsT0FBT0wsU0FBU2dCLElBQUksQ0FBQztBQUMzQztBQUNBLGVBQWVDLE9BQU9DLFlBQVk7SUFDOUIsTUFBTUMsVUFBVSxJQUFJQztJQUNwQixNQUFNQyxjQUFjRixRQUFRRyxNQUFNLENBQUNKO0lBQ25DLE1BQU1sRSxPQUFPLE1BQU11RCxPQUFPZ0IsTUFBTSxDQUFDQyxNQUFNLENBQUMsV0FBV0g7SUFDbkQsTUFBTUksUUFBUSxJQUFJQyxXQUFXMUU7SUFDN0IsT0FBTzhELE1BQU1DLElBQUksQ0FBQ1UsT0FDYkUsR0FBRyxDQUFDLENBQUNDLElBQU1DLE9BQU9DLFlBQVksQ0FBQ0YsSUFDL0JaLElBQUksQ0FBQztBQUNkO0FBQ0EsZUFBZW5HLHNCQUFzQjZGLFFBQVE7SUFDekMsTUFBTXFCLG1CQUFtQixPQUFPeEIsV0FBVyxlQUN2QyxPQUFPQSxPQUFPZ0IsTUFBTSxLQUFLLGVBQ3pCLE9BQU9ILGdCQUFnQjtJQUMzQixJQUFJLENBQUNXLGtCQUFrQjtRQUNuQkMsUUFBUUMsSUFBSSxDQUFDO1FBQ2IsT0FBT3ZCO0lBQ1g7SUFDQSxNQUFNd0IsU0FBUyxNQUFNakIsT0FBT1A7SUFDNUIsT0FBT3lCLEtBQUtELFFBQVFFLE9BQU8sQ0FBQyxPQUFPLEtBQUtBLE9BQU8sQ0FBQyxPQUFPLEtBQUtBLE9BQU8sQ0FBQyxPQUFPO0FBQy9FO0FBQ0EsZUFBZXRILDBCQUEwQjhDLE9BQU8sRUFBRXlFLFVBQVUsRUFBRUMscUJBQXFCLEtBQUs7SUFDcEYsTUFBTUMsZUFBZTNIO0lBQ3JCLElBQUk0SCxxQkFBcUJEO0lBQ3pCLElBQUlELG9CQUFvQjtRQUNwQkUsc0JBQXNCO0lBQzFCO0lBQ0EsTUFBTSxDQUFDLEdBQUc1SSxRQUFRSyxZQUFZLEVBQUUyRCxTQUFTLENBQUMsRUFBRXlFLFdBQVcsY0FBYyxDQUFDLEVBQUVHO0lBQ3hFLE1BQU1DLGdCQUFnQixNQUFNNUgsc0JBQXNCMEg7SUFDbEQsTUFBTUcsc0JBQXNCSCxpQkFBaUJFLGdCQUFnQixVQUFVO0lBQ3ZFLE9BQU87UUFBQ0E7UUFBZUM7S0FBb0I7QUFDL0M7QUFDQSxnREFBZ0QsR0FDaEQsTUFBTUMsb0JBQW9CO0FBQzFCLFNBQVM1SCx3QkFBd0I2SCxRQUFRO0lBQ3JDLE1BQU1DLGFBQWFELFNBQVNFLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDekgsWUFBWTBILHVCQUF1QjtJQUMzRSxJQUFJLENBQUNILFlBQVk7UUFDYixPQUFPO0lBQ1g7SUFDQSxJQUFJLENBQUNBLFdBQVdJLEtBQUssQ0FBQ04sb0JBQW9CO1FBQ3RDLE9BQU87SUFDWDtJQUNBLElBQUk7UUFDQSxNQUFNTyxPQUFPLElBQUlwSCxLQUFLLENBQUMsRUFBRStHLFdBQVcsWUFBWSxDQUFDO1FBQ2pELE9BQU9LO0lBQ1gsRUFDQSxPQUFPM0csR0FBRztRQUNOLE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU3ZCLFlBQVltSSxHQUFHO0lBQ3BCLElBQUksQ0FBQ0EsS0FBSztRQUNOLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBLE1BQU16SCxVQUFVQyxLQUFLZ0YsS0FBSyxDQUFDOUUsS0FBS0MsR0FBRyxLQUFLO0lBQ3hDLElBQUlvSCxPQUFPeEgsU0FBUztRQUNoQixNQUFNLElBQUl5SCxNQUFNO0lBQ3BCO0FBQ0o7QUFDQSxTQUFTbkksYUFBYW9JLEdBQUc7SUFDckIsT0FBUUE7UUFDSixLQUFLO1lBQ0QsT0FBTztnQkFDSEMsTUFBTTtnQkFDTnRHLE1BQU07b0JBQUVzRyxNQUFNO2dCQUFVO1lBQzVCO1FBQ0osS0FBSztZQUNELE9BQU87Z0JBQ0hBLE1BQU07Z0JBQ05DLFlBQVk7Z0JBQ1p2RyxNQUFNO29CQUFFc0csTUFBTTtnQkFBVTtZQUM1QjtRQUNKO1lBQ0ksTUFBTSxJQUFJRixNQUFNO0lBQ3hCO0FBQ0o7QUFDQSxNQUFNSSxhQUFhO0FBQ25CLFNBQVN0SSxhQUFhdUksR0FBRztJQUNyQixJQUFJLENBQUNELFdBQVd0RSxJQUFJLENBQUN1RSxNQUFNO1FBQ3ZCLE1BQU0sSUFBSUwsTUFBTTtJQUNwQjtBQUNKO0FBQ0EsU0FBU2pJO0lBQ0wsTUFBTXVJLGNBQWMsQ0FBQztJQUNyQixPQUFPLElBQUlDLE1BQU1ELGFBQWE7UUFDMUJYLEtBQUssQ0FBQ2EsUUFBUUM7WUFDVixJQUFJQSxTQUFTLDZCQUE2QjtnQkFDdEMsT0FBTztZQUNYO1lBQ0EsOEVBQThFO1lBQzlFLG1GQUFtRjtZQUNuRixJQUFJLE9BQU9BLFNBQVMsVUFBVTtnQkFDMUIsTUFBTUMsUUFBUUQsS0FBSzNELFFBQVE7Z0JBQzNCLElBQUk0RCxVQUFVLGdDQUNWQSxVQUFVLGdDQUNWQSxVQUFVLCtCQUErQjtvQkFDekMsdUJBQXVCO29CQUN2QixPQUFPQztnQkFDWDtZQUNKO1lBQ0EsTUFBTSxJQUFJWCxNQUFNLENBQUMsK0hBQStILEVBQUVTLEtBQUssZ0ZBQWdGLENBQUM7UUFDNU87UUFDQUcsS0FBSyxDQUFDQyxTQUFTSjtZQUNYLE1BQU0sSUFBSVQsTUFBTSxDQUFDLDZIQUE2SCxFQUFFUyxLQUFLLGtIQUFrSCxDQUFDO1FBQzVRO1FBQ0FLLGdCQUFnQixDQUFDRCxTQUFTSjtZQUN0QixNQUFNLElBQUlULE1BQU0sQ0FBQyw4SEFBOEgsRUFBRVMsS0FBSyxrSEFBa0gsQ0FBQztRQUM3UTtJQUNKO0FBQ0o7QUFDQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU3pJLHlCQUF5QitJLElBQUksRUFBRUMsa0JBQWtCO0lBQ3RELE9BQU8sSUFBSVQsTUFBTVEsTUFBTTtRQUNuQnBCLEtBQUssQ0FBQ2EsUUFBUUMsTUFBTVE7WUFDaEIsd0NBQXdDO1lBQ3hDLElBQUlSLFNBQVMsZ0NBQWdDO2dCQUN6QyxPQUFPO1lBQ1g7WUFDQSw4RUFBOEU7WUFDOUUsa0ZBQWtGO1lBQ2xGLElBQUksT0FBT0EsU0FBUyxVQUFVO2dCQUMxQixNQUFNQyxRQUFRRCxLQUFLM0QsUUFBUTtnQkFDM0IsSUFBSTRELFVBQVUsZ0NBQ1ZBLFVBQVUsZ0NBQ1ZBLFVBQVUsaUNBQ1ZBLFVBQVUsc0NBQXNDO29CQUNoRCx1RUFBdUU7b0JBQ3ZFLE9BQU9RLFFBQVF2QixHQUFHLENBQUNhLFFBQVFDLE1BQU1RO2dCQUNyQztZQUNKO1lBQ0Esd0NBQXdDO1lBQ3hDLElBQUksQ0FBQ0QsbUJBQW1CdkssS0FBSyxJQUFJLE9BQU9nSyxTQUFTLFVBQVU7Z0JBQ3ZEN0IsUUFBUUMsSUFBSSxDQUFDO2dCQUNibUMsbUJBQW1CdkssS0FBSyxHQUFHO1lBQy9CO1lBQ0EsT0FBT3lLLFFBQVF2QixHQUFHLENBQUNhLFFBQVFDLE1BQU1RO1FBQ3JDO0lBQ0o7QUFDSjtBQUNBOzs7Q0FHQyxHQUNELFNBQVNoSixVQUFVa0osR0FBRztJQUNsQixPQUFPekcsS0FBS0csS0FBSyxDQUFDSCxLQUFLQyxTQUFTLENBQUN3RztBQUNyQyxFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21haW4vbGliL2hlbHBlcnMuanM/Y2M2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVmZXJyZWQgPSBleHBvcnRzLnJlbW92ZUl0ZW1Bc3luYyA9IGV4cG9ydHMuZ2V0SXRlbUFzeW5jID0gZXhwb3J0cy5zZXRJdGVtQXN5bmMgPSBleHBvcnRzLmxvb2tzTGlrZUZldGNoUmVzcG9uc2UgPSBleHBvcnRzLnJlc29sdmVGZXRjaCA9IGV4cG9ydHMuc3VwcG9ydHNMb2NhbFN0b3JhZ2UgPSBleHBvcnRzLmlzQnJvd3NlciA9IHZvaWQgMDtcbmV4cG9ydHMuZXhwaXJlc0F0ID0gZXhwaXJlc0F0O1xuZXhwb3J0cy5nZW5lcmF0ZUNhbGxiYWNrSWQgPSBnZW5lcmF0ZUNhbGxiYWNrSWQ7XG5leHBvcnRzLnBhcnNlUGFyYW1ldGVyc0Zyb21VUkwgPSBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMO1xuZXhwb3J0cy5kZWNvZGVKV1QgPSBkZWNvZGVKV1Q7XG5leHBvcnRzLnNsZWVwID0gc2xlZXA7XG5leHBvcnRzLnJldHJ5YWJsZSA9IHJldHJ5YWJsZTtcbmV4cG9ydHMuZ2VuZXJhdGVQS0NFVmVyaWZpZXIgPSBnZW5lcmF0ZVBLQ0VWZXJpZmllcjtcbmV4cG9ydHMuZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlID0gZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlO1xuZXhwb3J0cy5nZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kID0gZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZDtcbmV4cG9ydHMucGFyc2VSZXNwb25zZUFQSVZlcnNpb24gPSBwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbjtcbmV4cG9ydHMudmFsaWRhdGVFeHAgPSB2YWxpZGF0ZUV4cDtcbmV4cG9ydHMuZ2V0QWxnb3JpdGhtID0gZ2V0QWxnb3JpdGhtO1xuZXhwb3J0cy52YWxpZGF0ZVVVSUQgPSB2YWxpZGF0ZVVVSUQ7XG5leHBvcnRzLnVzZXJOb3RBdmFpbGFibGVQcm94eSA9IHVzZXJOb3RBdmFpbGFibGVQcm94eTtcbmV4cG9ydHMuaW5zZWN1cmVVc2VyV2FybmluZ1Byb3h5ID0gaW5zZWN1cmVVc2VyV2FybmluZ1Byb3h5O1xuZXhwb3J0cy5kZWVwQ2xvbmUgPSBkZWVwQ2xvbmU7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgYmFzZTY0dXJsXzEgPSByZXF1aXJlKFwiLi9iYXNlNjR1cmxcIik7XG5mdW5jdGlvbiBleHBpcmVzQXQoZXhwaXJlc0luKSB7XG4gICAgY29uc3QgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIHJldHVybiB0aW1lTm93ICsgZXhwaXJlc0luO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgaW50ZXJuYWwgY2FsbGJhY2sgc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHVzZXMgSmF2YVNjcmlwdCBTeW1ib2xzIHRvIGNyZWF0ZSBndWFyYW50ZWVkLXVuaXF1ZSBpZGVudGlmaWVyc1xuICogZm9yIGF1dGggc3RhdGUgY2hhbmdlIGNhbGxiYWNrcy4gU3ltYm9scyBhcmUgaWRlYWwgZm9yIHRoaXMgdXNlIGNhc2UgYmVjYXVzZTpcbiAqIC0gVGhleSBhcmUgZ3VhcmFudGVlZCB1bmlxdWUgYnkgdGhlIEphdmFTY3JpcHQgcnVudGltZVxuICogLSBUaGV5IHdvcmsgaW4gYWxsIGVudmlyb25tZW50cyAoYnJvd3NlciwgU1NSLCBOb2RlLmpzKVxuICogLSBUaGV5IGF2b2lkIGlzc3VlcyB3aXRoIE5leHQuanMgMTYgZGV0ZXJtaW5pc3RpYyByZW5kZXJpbmcgcmVxdWlyZW1lbnRzXG4gKiAtIFRoZXkgYXJlIHBlcmZlY3QgZm9yIGludGVybmFsLCBub24tc2VyaWFsaXphYmxlIGlkZW50aWZpZXJzXG4gKlxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgZm9yIGludGVybmFsIHN1YnNjcmlwdGlvbiBtYW5hZ2VtZW50LFxuICogbm90IGZvciBzZWN1cml0eS1jcml0aWNhbCBvcGVyYXRpb25zIGxpa2Ugc2Vzc2lvbiB0b2tlbnMuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlQ2FsbGJhY2tJZCgpIHtcbiAgICByZXR1cm4gU3ltYm9sKCdhdXRoLWNhbGxiYWNrJyk7XG59XG5jb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG5jb25zdCBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzID0ge1xuICAgIHRlc3RlZDogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxufTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgbG9jYWxTdG9yYWdlIGlzIHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuXG4gKi9cbmNvbnN0IHN1cHBvcnRzTG9jYWxTdG9yYWdlID0gKCkgPT4ge1xuICAgIGlmICghKDAsIGV4cG9ydHMuaXNCcm93c2VyKSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBET00gZXhjZXB0aW9uIHdoZW4gYWNjZXNzaW5nIGBsb2NhbFN0b3JhZ2VgXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlO1xuICAgIH1cbiAgICBjb25zdCByYW5kb21LZXkgPSBgbHN3dC0ke01hdGgucmFuZG9tKCl9JHtNYXRoLnJhbmRvbSgpfWA7XG4gICAgdHJ5IHtcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShyYW5kb21LZXksIHJhbmRvbUtleSk7XG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0ocmFuZG9tS2V5KTtcbiAgICAgICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy50ZXN0ZWQgPSB0cnVlO1xuICAgICAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbG9jYWxTdG9yYWdlIGNhbid0IGJlIHdyaXR0ZW4gdG9cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cuY2hyb21pdW0ub3JnL2Zvci10ZXN0ZXJzL2J1Zy1yZXBvcnRpbmctZ3VpZGVsaW5lcy91bmNhdWdodC1zZWN1cml0eWVycm9yLWZhaWxlZC10by1yZWFkLXRoZS1sb2NhbHN0b3JhZ2UtcHJvcGVydHktZnJvbS13aW5kb3ctYWNjZXNzLWlzLWRlbmllZC1mb3ItdGhpcy1kb2N1bWVudFxuICAgICAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCA9IHRydWU7XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGU7XG59O1xuZXhwb3J0cy5zdXBwb3J0c0xvY2FsU3RvcmFnZSA9IHN1cHBvcnRzTG9jYWxTdG9yYWdlO1xuLyoqXG4gKiBFeHRyYWN0cyBwYXJhbWV0ZXJzIGVuY29kZWQgaW4gdGhlIFVSTCBib3RoIGluIHRoZSBxdWVyeSBhbmQgZnJhZ21lbnQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwoaHJlZikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZik7XG4gICAgaWYgKHVybC5oYXNoICYmIHVybC5oYXNoWzBdID09PSAnIycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2hTZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5oYXNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICBoYXNoU2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGhhc2ggaXMgbm90IGEgcXVlcnkgc3RyaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2VhcmNoIHBhcmFtZXRlcnMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgaGFzaCBwYXJhbWV0ZXJzXG4gICAgdXJsLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xufTtcbmV4cG9ydHMucmVzb2x2ZUZldGNoID0gcmVzb2x2ZUZldGNoO1xuY29uc3QgbG9va3NMaWtlRmV0Y2hSZXNwb25zZSA9IChtYXliZVJlc3BvbnNlKSA9PiB7XG4gICAgcmV0dXJuICh0eXBlb2YgbWF5YmVSZXNwb25zZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgbWF5YmVSZXNwb25zZSAhPT0gbnVsbCAmJlxuICAgICAgICAnc3RhdHVzJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgICAgICdvaycgaW4gbWF5YmVSZXNwb25zZSAmJlxuICAgICAgICAnanNvbicgaW4gbWF5YmVSZXNwb25zZSAmJlxuICAgICAgICB0eXBlb2YgbWF5YmVSZXNwb25zZS5qc29uID09PSAnZnVuY3Rpb24nKTtcbn07XG5leHBvcnRzLmxvb2tzTGlrZUZldGNoUmVzcG9uc2UgPSBsb29rc0xpa2VGZXRjaFJlc3BvbnNlO1xuLy8gU3RvcmFnZSBoZWxwZXJzXG5jb25zdCBzZXRJdGVtQXN5bmMgPSBhc3luYyAoc3RvcmFnZSwga2V5LCBkYXRhKSA9PiB7XG4gICAgYXdhaXQgc3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xufTtcbmV4cG9ydHMuc2V0SXRlbUFzeW5jID0gc2V0SXRlbUFzeW5jO1xuY29uc3QgZ2V0SXRlbUFzeW5jID0gYXN5bmMgKHN0b3JhZ2UsIGtleSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG5leHBvcnRzLmdldEl0ZW1Bc3luYyA9IGdldEl0ZW1Bc3luYztcbmNvbnN0IHJlbW92ZUl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXkpID0+IHtcbiAgICBhd2FpdCBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbn07XG5leHBvcnRzLnJlbW92ZUl0ZW1Bc3luYyA9IHJlbW92ZUl0ZW1Bc3luYztcbi8qKlxuICogQSBkZWZlcnJlZCByZXByZXNlbnRzIHNvbWUgYXN5bmNocm9ub3VzIHdvcmsgdGhhdCBpcyBub3QgeWV0IGZpbmlzaGVkLCB3aGljaFxuICogbWF5IG9yIG1heSBub3QgY3VsbWluYXRlIGluIGEgdmFsdWUuXG4gKiBUYWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbWlrZS1ub3J0aC90eXBlcy9ibG9iL21hc3Rlci9zcmMvYXN5bmMudHNcbiAqL1xuY2xhc3MgRGVmZXJyZWQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgICAgO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgRGVmZXJyZWQucHJvbWlzZUNvbnN0cnVjdG9yKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXM7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlajtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5EZWZlcnJlZCA9IERlZmVycmVkO1xuRGVmZXJyZWQucHJvbWlzZUNvbnN0cnVjdG9yID0gUHJvbWlzZTtcbmZ1bmN0aW9uIGRlY29kZUpXVCh0b2tlbikge1xuICAgIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5BdXRoSW52YWxpZEp3dEVycm9yKCdJbnZhbGlkIEpXVCBzdHJ1Y3R1cmUnKTtcbiAgICB9XG4gICAgLy8gUmVnZXggY2hlY2tzIGZvciBiYXNlNjR1cmwgZm9ybWF0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWNvbnN0YW50c18xLkJBU0U2NFVSTF9SRUdFWC50ZXN0KHBhcnRzW2ldKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkF1dGhJbnZhbGlkSnd0RXJyb3IoJ0pXVCBub3QgaW4gYmFzZTY0dXJsIGZvcm1hdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIC8vIHVzaW5nIGJhc2U2NHVybCBsaWJcbiAgICAgICAgaGVhZGVyOiBKU09OLnBhcnNlKCgwLCBiYXNlNjR1cmxfMS5zdHJpbmdGcm9tQmFzZTY0VVJMKShwYXJ0c1swXSkpLFxuICAgICAgICBwYXlsb2FkOiBKU09OLnBhcnNlKCgwLCBiYXNlNjR1cmxfMS5zdHJpbmdGcm9tQmFzZTY0VVJMKShwYXJ0c1sxXSkpLFxuICAgICAgICBzaWduYXR1cmU6ICgwLCBiYXNlNjR1cmxfMS5iYXNlNjRVcmxUb1VpbnQ4QXJyYXkpKHBhcnRzWzJdKSxcbiAgICAgICAgcmF3OiB7XG4gICAgICAgICAgICBoZWFkZXI6IHBhcnRzWzBdLFxuICAgICAgICAgICAgcGF5bG9hZDogcGFydHNbMV0sXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBudWxsIGFmdGVyIHNvbWUgdGltZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2xlZXAodGltZSkge1xuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgoYWNjZXB0KSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gYWNjZXB0KG51bGwpLCB0aW1lKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ29udmVydHMgdGhlIHByb3ZpZGVkIGFzeW5jIGZ1bmN0aW9uIGludG8gYSByZXRyeWFibGUgZnVuY3Rpb24uIEVhY2ggcmVzdWx0XG4gKiBvciB0aHJvd24gZXJyb3IgaXMgc2VudCB0byB0aGUgaXNSZXRyeWFibGUgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIHJldHVybiB0cnVlXG4gKiBpZiB0aGUgZnVuY3Rpb24gc2hvdWxkIHJ1biBhZ2Fpbi5cbiAqL1xuZnVuY3Rpb24gcmV0cnlhYmxlKGZuLCBpc1JldHJ5YWJsZSkge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgICAgIDtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgSW5maW5pdHk7IGF0dGVtcHQrKykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmV0cnlhYmxlKGF0dGVtcHQsIG51bGwsIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXRyeWFibGUoYXR0ZW1wdCwgZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGRlYzJoZXgoZGVjKSB7XG4gICAgcmV0dXJuICgnMCcgKyBkZWMudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTIpO1xufVxuLy8gRnVuY3Rpb25zIGJlbG93IHRha2VuIGZyb206IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYzMzA5NDA5L2NyZWF0aW5nLWEtY29kZS12ZXJpZmllci1hbmQtY2hhbGxlbmdlLWZvci1wa2NlLWF1dGgtb24tc3BvdGlmeS1hcGktaW4tcmVhY3Rqc1xuZnVuY3Rpb24gZ2VuZXJhdGVQS0NFVmVyaWZpZXIoKSB7XG4gICAgY29uc3QgdmVyaWZpZXJMZW5ndGggPSA1NjtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50MzJBcnJheSh2ZXJpZmllckxlbmd0aCk7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGNoYXJTZXQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktLl9+JztcbiAgICAgICAgY29uc3QgY2hhclNldExlbiA9IGNoYXJTZXQubGVuZ3RoO1xuICAgICAgICBsZXQgdmVyaWZpZXIgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJpZmllckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJpZmllciArPSBjaGFyU2V0LmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyU2V0TGVuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlcmlmaWVyO1xuICAgIH1cbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnJheSwgZGVjMmhleCkuam9pbignJyk7XG59XG5hc3luYyBmdW5jdGlvbiBzaGEyNTYocmFuZG9tU3RyaW5nKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZWREYXRhID0gZW5jb2Rlci5lbmNvZGUocmFuZG9tU3RyaW5nKTtcbiAgICBjb25zdCBoYXNoID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBlbmNvZGVkRGF0YSk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoYXNoKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShieXRlcylcbiAgICAgICAgLm1hcCgoYykgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShjKSlcbiAgICAgICAgLmpvaW4oJycpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlKHZlcmlmaWVyKSB7XG4gICAgY29uc3QgaGFzQ3J5cHRvU3VwcG9ydCA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBjcnlwdG8uc3VidGxlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnO1xuICAgIGlmICghaGFzQ3J5cHRvU3VwcG9ydCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dlYkNyeXB0byBBUEkgaXMgbm90IHN1cHBvcnRlZC4gQ29kZSBjaGFsbGVuZ2UgbWV0aG9kIHdpbGwgZGVmYXVsdCB0byB1c2UgcGxhaW4gaW5zdGVhZCBvZiBzaGEyNTYuJyk7XG4gICAgICAgIHJldHVybiB2ZXJpZmllcjtcbiAgICB9XG4gICAgY29uc3QgaGFzaGVkID0gYXdhaXQgc2hhMjU2KHZlcmlmaWVyKTtcbiAgICByZXR1cm4gYnRvYShoYXNoZWQpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpLnJlcGxhY2UoLz0rJC8sICcnKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2Qoc3RvcmFnZSwgc3RvcmFnZUtleSwgaXNQYXNzd29yZFJlY292ZXJ5ID0gZmFsc2UpIHtcbiAgICBjb25zdCBjb2RlVmVyaWZpZXIgPSBnZW5lcmF0ZVBLQ0VWZXJpZmllcigpO1xuICAgIGxldCBzdG9yZWRDb2RlVmVyaWZpZXIgPSBjb2RlVmVyaWZpZXI7XG4gICAgaWYgKGlzUGFzc3dvcmRSZWNvdmVyeSkge1xuICAgICAgICBzdG9yZWRDb2RlVmVyaWZpZXIgKz0gJy9QQVNTV09SRF9SRUNPVkVSWSc7XG4gICAgfVxuICAgIGF3YWl0ICgwLCBleHBvcnRzLnNldEl0ZW1Bc3luYykoc3RvcmFnZSwgYCR7c3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmAsIHN0b3JlZENvZGVWZXJpZmllcik7XG4gICAgY29uc3QgY29kZUNoYWxsZW5nZSA9IGF3YWl0IGdlbmVyYXRlUEtDRUNoYWxsZW5nZShjb2RlVmVyaWZpZXIpO1xuICAgIGNvbnN0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBjb2RlVmVyaWZpZXIgPT09IGNvZGVDaGFsbGVuZ2UgPyAncGxhaW4nIDogJ3MyNTYnO1xuICAgIHJldHVybiBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF07XG59XG4vKiogUGFyc2VzIHRoZSBBUEkgdmVyc2lvbiB3aGljaCBpcyAyWVlZLU1NLURELiAqL1xuY29uc3QgQVBJX1ZFUlNJT05fUkVHRVggPSAvXjJbMC05XXszfS0oMFsxLTldfDFbMC0yXSktKDBbMS05XXwxWzAtOV18MlswLTldfDNbMC0xXSkkL2k7XG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbihyZXNwb25zZSkge1xuICAgIGNvbnN0IGFwaVZlcnNpb24gPSByZXNwb25zZS5oZWFkZXJzLmdldChjb25zdGFudHNfMS5BUElfVkVSU0lPTl9IRUFERVJfTkFNRSk7XG4gICAgaWYgKCFhcGlWZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWFwaVZlcnNpb24ubWF0Y2goQVBJX1ZFUlNJT05fUkVHRVgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7YXBpVmVyc2lvbn1UMDA6MDA6MDAuMFpgKTtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwKGV4cCkge1xuICAgIGlmICghZXhwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBleHAgY2xhaW0nKTtcbiAgICB9XG4gICAgY29uc3QgdGltZU5vdyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIGlmIChleHAgPD0gdGltZU5vdykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBoYXMgZXhwaXJlZCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEFsZ29yaXRobShhbGcpIHtcbiAgICBzd2l0Y2ggKGFsZykge1xuICAgICAgICBjYXNlICdSUzI1Nic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gICAgICAgICAgICAgICAgaGFzaDogeyBuYW1lOiAnU0hBLTI1NicgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ0VTMjU2JzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ0VDRFNBJyxcbiAgICAgICAgICAgICAgICBuYW1lZEN1cnZlOiAnUC0yNTYnLFxuICAgICAgICAgICAgICAgIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFsZyBjbGFpbScpO1xuICAgIH1cbn1cbmNvbnN0IFVVSURfUkVHRVggPSAvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezEyfSQvO1xuZnVuY3Rpb24gdmFsaWRhdGVVVUlEKHN0cikge1xuICAgIGlmICghVVVJRF9SRUdFWC50ZXN0KHN0cikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogRXhwZWN0ZWQgcGFyYW1ldGVyIHRvIGJlIFVVSUQgYnV0IGlzIG5vdCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVzZXJOb3RBdmFpbGFibGVQcm94eSgpIHtcbiAgICBjb25zdCBwcm94eVRhcmdldCA9IHt9O1xuICAgIHJldHVybiBuZXcgUHJveHkocHJveHlUYXJnZXQsIHtcbiAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ19faXNVc2VyTm90QXZhaWxhYmxlUHJveHknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmV2ZW50YXRpdmUgY2hlY2sgZm9yIGNvbW1vbiBwcm9ibGVtYXRpYyBzeW1ib2xzIGR1cmluZyBjbG9uaW5nL2luc3BlY3Rpb25cbiAgICAgICAgICAgIC8vIFRoZXNlIHN5bWJvbHMgbWlnaHQgYmUgYWNjZXNzZWQgYnkgc3RydWN0dXJlZENsb25lIG9yIG90aGVyIGludGVybmFsIG1lY2hhbmlzbXMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc1Byb3AgPSBwcm9wLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNQcm9wID09PSAnU3ltYm9sKFN5bWJvbC50b1ByaW1pdGl2ZSknIHx8XG4gICAgICAgICAgICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKFN5bWJvbC50b1N0cmluZ1RhZyknIHx8XG4gICAgICAgICAgICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKHV0aWwuaW5zcGVjdC5jdXN0b20pJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb2RlLmpzIHV0aWwuaW5zcGVjdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IGNsaWVudCB3YXMgY3JlYXRlZCB3aXRoIHVzZXJTdG9yYWdlIG9wdGlvbiBhbmQgdGhlcmUgd2FzIG5vIHVzZXIgc3RvcmVkIGluIHRoZSB1c2VyIHN0b3JhZ2UuIEFjY2Vzc2luZyB0aGUgXCIke3Byb3B9XCIgcHJvcGVydHkgb2YgdGhlIHNlc3Npb24gb2JqZWN0IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgZ2V0VXNlcigpIGluc3RlYWQuYCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogKF90YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IGNsaWVudCB3YXMgY3JlYXRlZCB3aXRoIHVzZXJTdG9yYWdlIG9wdGlvbiBhbmQgdGhlcmUgd2FzIG5vIHVzZXIgc3RvcmVkIGluIHRoZSB1c2VyIHN0b3JhZ2UuIFNldHRpbmcgdGhlIFwiJHtwcm9wfVwiIHByb3BlcnR5IG9mIHRoZSBzZXNzaW9uIG9iamVjdCBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIGdldFVzZXIoKSB0byBmZXRjaCBhIHVzZXIgb2JqZWN0IHlvdSBjYW4gbWFuaXB1bGF0ZS5gKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlUHJvcGVydHk6IChfdGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBjbGllbnQgd2FzIGNyZWF0ZWQgd2l0aCB1c2VyU3RvcmFnZSBvcHRpb24gYW5kIHRoZXJlIHdhcyBubyB1c2VyIHN0b3JlZCBpbiB0aGUgdXNlciBzdG9yYWdlLiBEZWxldGluZyB0aGUgXCIke3Byb3B9XCIgcHJvcGVydHkgb2YgdGhlIHNlc3Npb24gb2JqZWN0IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgZ2V0VXNlcigpIHRvIGZldGNoIGEgdXNlciBvYmplY3QgeW91IGNhbiBtYW5pcHVsYXRlLmApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgcHJveHkgYXJvdW5kIGEgdXNlciBvYmplY3QgdGhhdCB3YXJucyB3aGVuIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkIG9uIHRoZSBzZXJ2ZXIuXG4gKiBUaGlzIGlzIHVzZWQgdG8gYWxlcnQgZGV2ZWxvcGVycyB0aGF0IHVzaW5nIHVzZXIgZGF0YSBmcm9tIGdldFNlc3Npb24oKSBvbiB0aGUgc2VydmVyIGlzIGluc2VjdXJlLlxuICpcbiAqIEBwYXJhbSB1c2VyIFRoZSBhY3R1YWwgdXNlciBvYmplY3QgdG8gd3JhcFxuICogQHBhcmFtIHN1cHByZXNzV2FybmluZ1JlZiBBbiBvYmplY3Qgd2l0aCBhICd2YWx1ZScgcHJvcGVydHkgdGhhdCBjb250cm9scyB3YXJuaW5nIHN1cHByZXNzaW9uXG4gKiBAcmV0dXJucyBBIHByb3hpZWQgdXNlciBvYmplY3QgdGhhdCB3YXJucyBvbiBwcm9wZXJ0eSBhY2Nlc3NcbiAqL1xuZnVuY3Rpb24gaW5zZWN1cmVVc2VyV2FybmluZ1Byb3h5KHVzZXIsIHN1cHByZXNzV2FybmluZ1JlZikge1xuICAgIHJldHVybiBuZXcgUHJveHkodXNlciwge1xuICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAvLyBBbGxvdyBpbnRlcm5hbCBjaGVja3Mgd2l0aG91dCB3YXJuaW5nXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ19faXNJbnNlY3VyZVVzZXJXYXJuaW5nUHJveHknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmV2ZW50YXRpdmUgY2hlY2sgZm9yIGNvbW1vbiBwcm9ibGVtYXRpYyBzeW1ib2xzIGR1cmluZyBjbG9uaW5nL2luc3BlY3Rpb25cbiAgICAgICAgICAgIC8vIFRoZXNlIHN5bWJvbHMgbWlnaHQgYmUgYWNjZXNzZWQgYnkgc3RydWN0dXJlZENsb25lIG9yIG90aGVyIGludGVybmFsIG1lY2hhbmlzbXNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzUHJvcCA9IHByb3AudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoc1Byb3AgPT09ICdTeW1ib2woU3ltYm9sLnRvUHJpbWl0aXZlKScgfHxcbiAgICAgICAgICAgICAgICAgICAgc1Byb3AgPT09ICdTeW1ib2woU3ltYm9sLnRvU3RyaW5nVGFnKScgfHxcbiAgICAgICAgICAgICAgICAgICAgc1Byb3AgPT09ICdTeW1ib2wodXRpbC5pbnNwZWN0LmN1c3RvbSknIHx8XG4gICAgICAgICAgICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKG5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tKScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBhY3R1YWwgdmFsdWUgZm9yIHRoZXNlIHN5bWJvbHMgdG8gYWxsb3cgcHJvcGVyIGluc3BlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVtaXQgd2FybmluZyBvbiBmaXJzdCBwcm9wZXJ0eSBhY2Nlc3NcbiAgICAgICAgICAgIGlmICghc3VwcHJlc3NXYXJuaW5nUmVmLnZhbHVlICYmIHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVXNpbmcgdGhlIHVzZXIgb2JqZWN0IGFzIHJldHVybmVkIGZyb20gc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCkgb3IgZnJvbSBzb21lIHN1cGFiYXNlLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoKSBldmVudHMgY291bGQgYmUgaW5zZWN1cmUhIFRoaXMgdmFsdWUgY29tZXMgZGlyZWN0bHkgZnJvbSB0aGUgc3RvcmFnZSBtZWRpdW0gKHVzdWFsbHkgY29va2llcyBvbiB0aGUgc2VydmVyKSBhbmQgbWF5IG5vdCBiZSBhdXRoZW50aWMuIFVzZSBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKSBpbnN0ZWFkIHdoaWNoIGF1dGhlbnRpY2F0ZXMgdGhlIGRhdGEgYnkgY29udGFjdGluZyB0aGUgU3VwYWJhc2UgQXV0aCBzZXJ2ZXIuJyk7XG4gICAgICAgICAgICAgICAgc3VwcHJlc3NXYXJuaW5nUmVmLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRGVlcCBjbG9uZXMgYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgdXNpbmcgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKS5cbiAqIE5vdGU6IE9ubHkgd29ya3MgZm9yIEpTT04tc2FmZSBkYXRhLlxuICovXG5mdW5jdGlvbiBkZWVwQ2xvbmUob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkRlZmVycmVkIiwicmVtb3ZlSXRlbUFzeW5jIiwiZ2V0SXRlbUFzeW5jIiwic2V0SXRlbUFzeW5jIiwibG9va3NMaWtlRmV0Y2hSZXNwb25zZSIsInJlc29sdmVGZXRjaCIsInN1cHBvcnRzTG9jYWxTdG9yYWdlIiwiaXNCcm93c2VyIiwiZXhwaXJlc0F0IiwiZ2VuZXJhdGVDYWxsYmFja0lkIiwicGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCIsImRlY29kZUpXVCIsInNsZWVwIiwicmV0cnlhYmxlIiwiZ2VuZXJhdGVQS0NFVmVyaWZpZXIiLCJnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UiLCJnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kIiwicGFyc2VSZXNwb25zZUFQSVZlcnNpb24iLCJ2YWxpZGF0ZUV4cCIsImdldEFsZ29yaXRobSIsInZhbGlkYXRlVVVJRCIsInVzZXJOb3RBdmFpbGFibGVQcm94eSIsImluc2VjdXJlVXNlcldhcm5pbmdQcm94eSIsImRlZXBDbG9uZSIsImNvbnN0YW50c18xIiwicmVxdWlyZSIsImVycm9yc18xIiwiYmFzZTY0dXJsXzEiLCJleHBpcmVzSW4iLCJ0aW1lTm93IiwiTWF0aCIsInJvdW5kIiwiRGF0ZSIsIm5vdyIsIlN5bWJvbCIsImRvY3VtZW50IiwibG9jYWxTdG9yYWdlV3JpdGVUZXN0cyIsInRlc3RlZCIsIndyaXRhYmxlIiwiZ2xvYmFsVGhpcyIsImxvY2FsU3RvcmFnZSIsImUiLCJyYW5kb21LZXkiLCJyYW5kb20iLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImhyZWYiLCJyZXN1bHQiLCJ1cmwiLCJVUkwiLCJoYXNoIiwiaGFzaFNlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInN1YnN0cmluZyIsImZvckVhY2giLCJrZXkiLCJzZWFyY2hQYXJhbXMiLCJjdXN0b21GZXRjaCIsImFyZ3MiLCJmZXRjaCIsIm1heWJlUmVzcG9uc2UiLCJqc29uIiwic3RvcmFnZSIsImRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0SXRlbSIsInBhcnNlIiwiX2EiLCJjb25zdHJ1Y3RvciIsInByb21pc2UiLCJwcm9taXNlQ29uc3RydWN0b3IiLCJyZXMiLCJyZWoiLCJyZXNvbHZlIiwicmVqZWN0IiwiUHJvbWlzZSIsInRva2VuIiwicGFydHMiLCJzcGxpdCIsImxlbmd0aCIsIkF1dGhJbnZhbGlkSnd0RXJyb3IiLCJpIiwiQkFTRTY0VVJMX1JFR0VYIiwidGVzdCIsImhlYWRlciIsInN0cmluZ0Zyb21CYXNlNjRVUkwiLCJwYXlsb2FkIiwic2lnbmF0dXJlIiwiYmFzZTY0VXJsVG9VaW50OEFycmF5IiwicmF3IiwidGltZSIsImFjY2VwdCIsInNldFRpbWVvdXQiLCJmbiIsImlzUmV0cnlhYmxlIiwiYXR0ZW1wdCIsIkluZmluaXR5IiwiZGVjMmhleCIsImRlYyIsInRvU3RyaW5nIiwic3Vic3RyIiwidmVyaWZpZXJMZW5ndGgiLCJhcnJheSIsIlVpbnQzMkFycmF5IiwiY3J5cHRvIiwiY2hhclNldCIsImNoYXJTZXRMZW4iLCJ2ZXJpZmllciIsImNoYXJBdCIsImZsb29yIiwiZ2V0UmFuZG9tVmFsdWVzIiwiQXJyYXkiLCJmcm9tIiwiam9pbiIsInNoYTI1NiIsInJhbmRvbVN0cmluZyIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZWREYXRhIiwiZW5jb2RlIiwic3VidGxlIiwiZGlnZXN0IiwiYnl0ZXMiLCJVaW50OEFycmF5IiwibWFwIiwiYyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImhhc0NyeXB0b1N1cHBvcnQiLCJjb25zb2xlIiwid2FybiIsImhhc2hlZCIsImJ0b2EiLCJyZXBsYWNlIiwic3RvcmFnZUtleSIsImlzUGFzc3dvcmRSZWNvdmVyeSIsImNvZGVWZXJpZmllciIsInN0b3JlZENvZGVWZXJpZmllciIsImNvZGVDaGFsbGVuZ2UiLCJjb2RlQ2hhbGxlbmdlTWV0aG9kIiwiQVBJX1ZFUlNJT05fUkVHRVgiLCJyZXNwb25zZSIsImFwaVZlcnNpb24iLCJoZWFkZXJzIiwiZ2V0IiwiQVBJX1ZFUlNJT05fSEVBREVSX05BTUUiLCJtYXRjaCIsImRhdGUiLCJleHAiLCJFcnJvciIsImFsZyIsIm5hbWUiLCJuYW1lZEN1cnZlIiwiVVVJRF9SRUdFWCIsInN0ciIsInByb3h5VGFyZ2V0IiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwic1Byb3AiLCJ1bmRlZmluZWQiLCJzZXQiLCJfdGFyZ2V0IiwiZGVsZXRlUHJvcGVydHkiLCJ1c2VyIiwic3VwcHJlc3NXYXJuaW5nUmVmIiwicmVjZWl2ZXIiLCJSZWZsZWN0Iiwib2JqIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/local-storage.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/lib/local-storage.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.memoryLocalStorageAdapter = memoryLocalStorageAdapter;\n/**\n * Returns a localStorage-like object that stores the key-value pairs in\n * memory.\n */ function memoryLocalStorageAdapter(store = {}) {\n    return {\n        getItem: (key)=>{\n            return store[key] || null;\n        },\n        setItem: (key, value)=>{\n            store[key] = value;\n        },\n        removeItem: (key)=>{\n            delete store[key];\n        }\n    };\n} //# sourceMappingURL=local-storage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi9sb2NhbC1zdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQ0FBaUMsR0FBR0U7QUFDcEM7OztDQUdDLEdBQ0QsU0FBU0EsMEJBQTBCQyxRQUFRLENBQUMsQ0FBQztJQUN6QyxPQUFPO1FBQ0hDLFNBQVMsQ0FBQ0M7WUFDTixPQUFPRixLQUFLLENBQUNFLElBQUksSUFBSTtRQUN6QjtRQUNBQyxTQUFTLENBQUNELEtBQUtKO1lBQ1hFLEtBQUssQ0FBQ0UsSUFBSSxHQUFHSjtRQUNqQjtRQUNBTSxZQUFZLENBQUNGO1lBQ1QsT0FBT0YsS0FBSyxDQUFDRSxJQUFJO1FBQ3JCO0lBQ0o7QUFDSixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21haW4vbGliL2xvY2FsLXN0b3JhZ2UuanM/YTczMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlciA9IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXI7XG4vKipcbiAqIFJldHVybnMgYSBsb2NhbFN0b3JhZ2UtbGlrZSBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIGtleS12YWx1ZSBwYWlycyBpblxuICogbWVtb3J5LlxuICovXG5mdW5jdGlvbiBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHN0b3JlID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVba2V5XSB8fCBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXRJdGVtOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgc3RvcmVba2V5XTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWwtc3RvcmFnZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyIiwic3RvcmUiLCJnZXRJdGVtIiwia2V5Iiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/local-storage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/locks.js":
/*!***************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/lib/locks.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ProcessLockAcquireTimeoutError = exports.NavigatorLockAcquireTimeoutError = exports.LockAcquireTimeoutError = exports.internals = void 0;\nexports.navigatorLock = navigatorLock;\nexports.processLock = processLock;\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/helpers.js\");\n/**\n * @experimental\n */ exports.internals = {\n    /**\n     * @experimental\n     */ debug: !!(globalThis && (0, helpers_1.supportsLocalStorage)() && globalThis.localStorage && globalThis.localStorage.getItem(\"supabase.gotrue-js.locks.debug\") === \"true\")\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n *\n * @example\n * ```ts\n * import { LockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * class CustomLockError extends LockAcquireTimeoutError {\n *   constructor() {\n *     super('Lock timed out')\n *   }\n * }\n * ```\n */ class LockAcquireTimeoutError extends Error {\n    constructor(message){\n        super(message);\n        this.isAcquireTimeout = true;\n    }\n}\nexports.LockAcquireTimeoutError = LockAcquireTimeoutError;\n/**\n * Error thrown when the browser Navigator Lock API fails to acquire a lock.\n *\n * @example\n * ```ts\n * import { NavigatorLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new NavigatorLockAcquireTimeoutError('Lock timed out')\n * ```\n */ class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nexports.NavigatorLockAcquireTimeoutError = NavigatorLockAcquireTimeoutError;\n/**\n * Error thrown when the process-level lock helper cannot acquire a lock.\n *\n * @example\n * ```ts\n * import { ProcessLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new ProcessLockAcquireTimeoutError('Lock timed out')\n * ```\n */ class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nexports.ProcessLockAcquireTimeoutError = ProcessLockAcquireTimeoutError;\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await navigatorLock('sync-user', 1000, async () => {\n *   await refreshSession()\n * })\n * ```\n */ async function navigatorLock(name, acquireTimeout, fn) {\n    if (exports.internals.debug) {\n        console.log(\"@supabase/gotrue-js: navigatorLock: acquire lock\", name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n        setTimeout(()=>{\n            abortController.abort();\n            if (exports.internals.debug) {\n                console.log(\"@supabase/gotrue-js: navigatorLock acquire timed out\", name);\n            }\n        }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping navigator.locks.request() with a plain Promise is done as some\n    // libraries like zone.js patch the Promise object to track the execution\n    // context. However, it appears that most browsers use an internal promise\n    // implementation when using the navigator.locks.request() API causing them\n    // to lose context and emit confusing log messages or break certain features.\n    // This wrapping is believed to help zone.js track the execution context\n    // better.\n    return await Promise.resolve().then(()=>globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {\n            mode: \"exclusive\",\n            ifAvailable: true\n        } : {\n            mode: \"exclusive\",\n            signal: abortController.signal\n        }, async (lock)=>{\n            if (lock) {\n                if (exports.internals.debug) {\n                    console.log(\"@supabase/gotrue-js: navigatorLock: acquired\", name, lock.name);\n                }\n                try {\n                    return await fn();\n                } finally{\n                    if (exports.internals.debug) {\n                        console.log(\"@supabase/gotrue-js: navigatorLock: released\", name, lock.name);\n                    }\n                }\n            } else {\n                if (acquireTimeout === 0) {\n                    if (exports.internals.debug) {\n                        console.log(\"@supabase/gotrue-js: navigatorLock: not immediately available\", name);\n                    }\n                    throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n                } else {\n                    if (exports.internals.debug) {\n                        try {\n                            const result = await globalThis.navigator.locks.query();\n                            console.log(\"@supabase/gotrue-js: Navigator LockManager state\", JSON.stringify(result, null, \"  \"));\n                        } catch (e) {\n                            console.warn(\"@supabase/gotrue-js: Error when querying Navigator LockManager state\", e);\n                        }\n                    }\n                    // Browser is not following the Navigator LockManager spec, it\n                    // returned a null lock when we didn't use ifAvailable. So we can\n                    // pretend the lock is acquired in the name of backward compatibility\n                    // and user experience and just run the function.\n                    console.warn(\"@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\");\n                    return await fn();\n                }\n            }\n        }));\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await processLock('migrate', 5000, async () => {\n *   await runMigration()\n * })\n * ```\n */ async function processLock(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    const currentOperation = Promise.race([\n        previousOperation.catch(()=>{\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n        }),\n        acquireTimeout >= 0 ? new Promise((_, reject)=>{\n            setTimeout(()=>{\n                console.warn(`@supabase/gotrue-js: Lock \"${name}\" acquisition timed out after ${acquireTimeout}ms. ` + \"This may be caused by another operation holding the lock. \" + \"Consider increasing lockAcquireTimeout or checking for stuck operations.\");\n                reject(new ProcessLockAcquireTimeoutError(`Acquiring process lock with name \"${name}\" timed out`));\n            }, acquireTimeout);\n        }) : null\n    ].filter((x)=>x)).catch((e)=>{\n        if (e && e.isAcquireTimeout) {\n            throw e;\n        }\n        return null;\n    }).then(async ()=>{\n        // previous operations finished and we didn't get a race on the acquire\n        // timeout, so the current operation can finally start\n        return await fn();\n    });\n    PROCESS_LOCKS[name] = currentOperation.catch(async (e)=>{\n        if (e && e.isAcquireTimeout) {\n            // if the current operation timed out, it doesn't mean that the previous\n            // operation finished, so we need contnue waiting for it to finish\n            await previousOperation;\n            return null;\n        }\n        throw e;\n    });\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return await currentOperation;\n} //# sourceMappingURL=locks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi9sb2Nrcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0NBQXNDLEdBQUdBLHdDQUF3QyxHQUFHQSwrQkFBK0IsR0FBR0EsaUJBQWlCLEdBQUcsS0FBSztBQUMvSUEscUJBQXFCLEdBQUdNO0FBQ3hCTixtQkFBbUIsR0FBR087QUFDdEIsTUFBTUMsWUFBWUMsbUJBQU9BLENBQUMsa0ZBQVc7QUFDckM7O0NBRUMsR0FDRFQsaUJBQWlCLEdBQUc7SUFDaEI7O0tBRUMsR0FDRFUsT0FBTyxDQUFDLENBQUVDLENBQUFBLGNBQ04sQ0FBQyxHQUFHSCxVQUFVSSxvQkFBb0IsT0FDbENELFdBQVdFLFlBQVksSUFDdkJGLFdBQVdFLFlBQVksQ0FBQ0MsT0FBTyxDQUFDLHNDQUFzQyxNQUFLO0FBQ25GO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTVYsZ0NBQWdDVztJQUNsQ0MsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLGdCQUFnQixHQUFHO0lBQzVCO0FBQ0o7QUFDQWxCLCtCQUErQixHQUFHSTtBQUNsQzs7Ozs7Ozs7O0NBU0MsR0FDRCxNQUFNRCx5Q0FBeUNDO0FBQy9DO0FBQ0FKLHdDQUF3QyxHQUFHRztBQUMzQzs7Ozs7Ozs7O0NBU0MsR0FDRCxNQUFNRCx1Q0FBdUNFO0FBQzdDO0FBQ0FKLHNDQUFzQyxHQUFHRTtBQUN6Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBOEJDLEdBQ0QsZUFBZUksY0FBY2EsSUFBSSxFQUFFQyxjQUFjLEVBQUVDLEVBQUU7SUFDakQsSUFBSXJCLFFBQVFLLFNBQVMsQ0FBQ0ssS0FBSyxFQUFFO1FBQ3pCWSxRQUFRQyxHQUFHLENBQUMsb0RBQW9ESixNQUFNQztJQUMxRTtJQUNBLE1BQU1JLGtCQUFr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Q0FBQ2dDLE1BQU0sQ0FBQyxDQUFDQyxJQUFNQSxJQUNYSixLQUFLLENBQUMsQ0FBQ1A7UUFDUixJQUFJQSxLQUFLQSxFQUFFeEIsZ0JBQWdCLEVBQUU7WUFDekIsTUFBTXdCO1FBQ1Y7UUFDQSxPQUFPO0lBQ1gsR0FDS1osSUFBSSxDQUFDO1FBQ04sdUVBQXVFO1FBQ3ZFLHNEQUFzRDtRQUN0RCxPQUFPLE1BQU1UO0lBQ2pCO0lBQ0F1QixhQUFhLENBQUN6QixLQUFLLEdBQUc0QixpQkFBaUJFLEtBQUssQ0FBQyxPQUFPUDtRQUNoRCxJQUFJQSxLQUFLQSxFQUFFeEIsZ0JBQWdCLEVBQUU7WUFDekIsd0VBQXdFO1lBQ3hFLGtFQUFrRTtZQUNsRSxNQUFNNEI7WUFDTixPQUFPO1FBQ1g7UUFDQSxNQUFNSjtJQUNWO0lBQ0EseUVBQXlFO0lBQ3pFLHlDQUF5QztJQUN6QyxPQUFPLE1BQU1LO0FBQ2pCLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbWFpbi9saWIvbG9ja3MuanM/NmU2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yID0gZXhwb3J0cy5OYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciA9IGV4cG9ydHMuTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgPSBleHBvcnRzLmludGVybmFscyA9IHZvaWQgMDtcbmV4cG9ydHMubmF2aWdhdG9yTG9jayA9IG5hdmlnYXRvckxvY2s7XG5leHBvcnRzLnByb2Nlc3NMb2NrID0gcHJvY2Vzc0xvY2s7XG5jb25zdCBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydHMuaW50ZXJuYWxzID0ge1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBkZWJ1ZzogISEoZ2xvYmFsVGhpcyAmJlxuICAgICAgICAoMCwgaGVscGVyc18xLnN1cHBvcnRzTG9jYWxTdG9yYWdlKSgpICYmXG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlICYmXG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3N1cGFiYXNlLmdvdHJ1ZS1qcy5sb2Nrcy5kZWJ1ZycpID09PSAndHJ1ZScpLFxufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYSBsb2NrIGNhbm5vdCBiZSBhY3F1aXJlZCBhZnRlciBzb21lIGFtb3VudCBvZiB0aW1lLlxuICpcbiAqIFVzZSB0aGUge0BsaW5rICNpc0FjcXVpcmVUaW1lb3V0fSBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGNoZWNraW5nIHdpdGggYGluc3RhbmNlb2ZgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiBjbGFzcyBDdXN0b21Mb2NrRXJyb3IgZXh0ZW5kcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB7XG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgIHN1cGVyKCdMb2NrIHRpbWVkIG91dCcpXG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmlzQWNxdWlyZVRpbWVvdXQgPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgPSBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcjtcbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIGJyb3dzZXIgTmF2aWdhdG9yIExvY2sgQVBJIGZhaWxzIHRvIGFjcXVpcmUgYSBsb2NrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IoJ0xvY2sgdGltZWQgb3V0JylcbiAqIGBgYFxuICovXG5jbGFzcyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIHtcbn1cbmV4cG9ydHMuTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgPSBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcjtcbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIHByb2Nlc3MtbGV2ZWwgbG9jayBoZWxwZXIgY2Fubm90IGFjcXVpcmUgYSBsb2NrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcignTG9jayB0aW1lZCBvdXQnKVxuICogYGBgXG4gKi9cbmNsYXNzIFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIHtcbn1cbmV4cG9ydHMuUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yID0gUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yO1xuLyoqXG4gKiBJbXBsZW1lbnRzIGEgZ2xvYmFsIGV4Y2x1c2l2ZSBsb2NrIHVzaW5nIHRoZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgQVBJLiBJdFxuICogaXMgYXZhaWxhYmxlIG9uIGFsbCBicm93c2VycyByZWxlYXNlZCBhZnRlciAyMDIyLTAzLTE1IHdpdGggU2FmYXJpIGJlaW5nIHRoZVxuICogbGFzdCBvbmUgdG8gcmVsZWFzZSBzdXBwb3J0LiBJZiB0aGUgQVBJIGlzIG5vdCBhdmFpbGFibGUsIHRoaXMgZnVuY3Rpb24gd2lsbFxuICogdGhyb3cuIE1ha2Ugc3VyZSB5b3UgY2hlY2sgYXZhaWxhYmxpbGl0eSBiZWZvcmUgY29uZmlndXJpbmcge0BsaW5rXG4gKiBHb1RydWVDbGllbnR9LlxuICpcbiAqIFlvdSBjYW4gdHVybiBvbiBkZWJ1Z2dpbmcgYnkgc2V0dGluZyB0aGUgYHN1cGFiYXNlLmdvdHJ1ZS1qcy5sb2Nrcy5kZWJ1Z2BcbiAqIGxvY2FsIHN0b3JhZ2UgaXRlbSB0byBgdHJ1ZWAuXG4gKlxuICogSW50ZXJuYWxzOlxuICpcbiAqIFNpbmNlIHRoZSBMb2NrTWFuYWdlciBBUEkgZG9lcyBub3QgcHJlc2VydmUgc3RhY2sgdHJhY2VzIGZvciB0aGUgYXN5bmNcbiAqIGZ1bmN0aW9uIHBhc3NlZCBpbiB0aGUgYHJlcXVlc3RgIG1ldGhvZCwgYSB0cmljayBpcyB1c2VkIHdoZXJlIGFjcXVpcmluZyB0aGVcbiAqIGxvY2sgcmVsZWFzZXMgYSBwcmV2aW91c2x5IHN0YXJ0ZWQgcHJvbWlzZSB0byBydW4gdGhlIG9wZXJhdGlvbiBpbiB0aGUgYGZuYFxuICogZnVuY3Rpb24uIFRoZSBsb2NrIHdhaXRzIGZvciB0aGF0IHByb21pc2UgdG8gZmluaXNoICh3aXRoIG9yIHdpdGhvdXQgZXJyb3IpLFxuICogd2hpbGUgdGhlIGZ1bmN0aW9uIHdpbGwgZmluYWxseSB3YWl0IGZvciB0aGUgcmVzdWx0IGFueXdheS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBsb2NrIHRvIGJlIGFjcXVpcmVkLlxuICogQHBhcmFtIGFjcXVpcmVUaW1lb3V0IElmIG5lZ2F0aXZlLCBubyB0aW1lb3V0LiBJZiAwIGFuIGVycm9yIGlzIHRocm93biBpZlxuICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBsb2NrIGNhbid0IGJlIGFjcXVpcmVkIHdpdGhvdXQgd2FpdGluZy4gSWYgcG9zaXRpdmUsIHRoZSBsb2NrIGFjcXVpcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICB3aWxsIHRpbWUgb3V0IGFmdGVyIHNvIG1hbnkgbWlsbGlzZWNvbmRzLiBBbiBlcnJvciBpc1xuICogICAgICAgICAgICAgICAgICAgICAgIGEgdGltZW91dCBpZiBpdCBoYXMgYGlzQWNxdWlyZVRpbWVvdXRgIHNldCB0byB0cnVlLlxuICogQHBhcmFtIGZuIFRoZSBvcGVyYXRpb24gdG8gcnVuIG9uY2UgdGhlIGxvY2sgaXMgYWNxdWlyZWQuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGF3YWl0IG5hdmlnYXRvckxvY2soJ3N5bmMtdXNlcicsIDEwMDAsIGFzeW5jICgpID0+IHtcbiAqICAgYXdhaXQgcmVmcmVzaFNlc3Npb24oKVxuICogfSlcbiAqIGBgYFxuICovXG5hc3luYyBmdW5jdGlvbiBuYXZpZ2F0b3JMb2NrKG5hbWUsIGFjcXVpcmVUaW1lb3V0LCBmbikge1xuICAgIGlmIChleHBvcnRzLmludGVybmFscy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogYWNxdWlyZSBsb2NrJywgbmFtZSwgYWNxdWlyZVRpbWVvdXQpO1xuICAgIH1cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICBpZiAoYWNxdWlyZVRpbWVvdXQgPiAwKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBpZiAoZXhwb3J0cy5pbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jayBhY3F1aXJlIHRpbWVkIG91dCcsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBhY3F1aXJlVGltZW91dCk7XG4gICAgfVxuICAgIC8vIE1ETiBhcnRpY2xlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTG9ja01hbmFnZXIvcmVxdWVzdFxuICAgIC8vIFdyYXBwaW5nIG5hdmlnYXRvci5sb2Nrcy5yZXF1ZXN0KCkgd2l0aCBhIHBsYWluIFByb21pc2UgaXMgZG9uZSBhcyBzb21lXG4gICAgLy8gbGlicmFyaWVzIGxpa2Ugem9uZS5qcyBwYXRjaCB0aGUgUHJvbWlzZSBvYmplY3QgdG8gdHJhY2sgdGhlIGV4ZWN1dGlvblxuICAgIC8vIGNvbnRleHQuIEhvd2V2ZXIsIGl0IGFwcGVhcnMgdGhhdCBtb3N0IGJyb3dzZXJzIHVzZSBhbiBpbnRlcm5hbCBwcm9taXNlXG4gICAgLy8gaW1wbGVtZW50YXRpb24gd2hlbiB1c2luZyB0aGUgbmF2aWdhdG9yLmxvY2tzLnJlcXVlc3QoKSBBUEkgY2F1c2luZyB0aGVtXG4gICAgLy8gdG8gbG9zZSBjb250ZXh0IGFuZCBlbWl0IGNvbmZ1c2luZyBsb2cgbWVzc2FnZXMgb3IgYnJlYWsgY2VydGFpbiBmZWF0dXJlcy5cbiAgICAvLyBUaGlzIHdyYXBwaW5nIGlzIGJlbGlldmVkIHRvIGhlbHAgem9uZS5qcyB0cmFjayB0aGUgZXhlY3V0aW9uIGNvbnRleHRcbiAgICAvLyBiZXR0ZXIuXG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubG9ja3MucmVxdWVzdChuYW1lLCBhY3F1aXJlVGltZW91dCA9PT0gMFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIG1vZGU6ICdleGNsdXNpdmUnLFxuICAgICAgICAgICAgaWZBdmFpbGFibGU6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBtb2RlOiAnZXhjbHVzaXZlJyxcbiAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgfSwgYXN5bmMgKGxvY2spID0+IHtcbiAgICAgICAgaWYgKGxvY2spIHtcbiAgICAgICAgICAgIGlmIChleHBvcnRzLmludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBhY3F1aXJlZCcsIG5hbWUsIGxvY2submFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydHMuaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiByZWxlYXNlZCcsIG5hbWUsIGxvY2submFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFjcXVpcmVUaW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydHMuaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcihgQWNxdWlyaW5nIGFuIGV4Y2x1c2l2ZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgbG9jayBcIiR7bmFtZX1cIiBpbW1lZGlhdGVseSBmYWlsZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChleHBvcnRzLmludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubG9ja3MucXVlcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3RhdGUnLCBKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsICcgICcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBFcnJvciB3aGVuIHF1ZXJ5aW5nIE5hdmlnYXRvciBMb2NrTWFuYWdlciBzdGF0ZScsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJyb3dzZXIgaXMgbm90IGZvbGxvd2luZyB0aGUgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHNwZWMsIGl0XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuZWQgYSBudWxsIGxvY2sgd2hlbiB3ZSBkaWRuJ3QgdXNlIGlmQXZhaWxhYmxlLiBTbyB3ZSBjYW5cbiAgICAgICAgICAgICAgICAvLyBwcmV0ZW5kIHRoZSBsb2NrIGlzIGFjcXVpcmVkIGluIHRoZSBuYW1lIG9mIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAvLyBhbmQgdXNlciBleHBlcmllbmNlIGFuZCBqdXN0IHJ1biB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgcmV0dXJuZWQgYSBudWxsIGxvY2sgd2hlbiB1c2luZyAjcmVxdWVzdCB3aXRob3V0IGlmQXZhaWxhYmxlIHNldCB0byB0cnVlLCBpdCBhcHBlYXJzIHRoaXMgYnJvd3NlciBpcyBub3QgZm9sbG93aW5nIHRoZSBMb2NrTWFuYWdlciBzcGVjIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Mb2NrTWFuYWdlci9yZXF1ZXN0Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSk7XG59XG5jb25zdCBQUk9DRVNTX0xPQ0tTID0ge307XG4vKipcbiAqIEltcGxlbWVudHMgYSBnbG9iYWwgZXhjbHVzaXZlIGxvY2sgdGhhdCB3b3JrcyBvbmx5IGluIHRoZSBjdXJyZW50IHByb2Nlc3MuXG4gKiBVc2VmdWwgZm9yIGVudmlyb25tZW50cyBsaWtlIFJlYWN0IE5hdGl2ZSBvciBvdGhlciBub24tYnJvd3NlclxuICogc2luZ2xlLXByb2Nlc3MgKGkuZS4gbm8gY29uY2VwdCBvZiBcInRhYnNcIikgZW52aXJvbm1lbnRzLlxuICpcbiAqIFVzZSB7QGxpbmsgI25hdmlnYXRvckxvY2t9IGluIGJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGxvY2sgdG8gYmUgYWNxdWlyZWQuXG4gKiBAcGFyYW0gYWNxdWlyZVRpbWVvdXQgSWYgbmVnYXRpdmUsIG5vIHRpbWVvdXQuIElmIDAgYW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIGxvY2sgY2FuJ3QgYmUgYWNxdWlyZWQgd2l0aG91dCB3YWl0aW5nLiBJZiBwb3NpdGl2ZSwgdGhlIGxvY2sgYWNxdWlyZVxuICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgdGltZSBvdXQgYWZ0ZXIgc28gbWFueSBtaWxsaXNlY29uZHMuIEFuIGVycm9yIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYSB0aW1lb3V0IGlmIGl0IGhhcyBgaXNBY3F1aXJlVGltZW91dGAgc2V0IHRvIHRydWUuXG4gKiBAcGFyYW0gZm4gVGhlIG9wZXJhdGlvbiB0byBydW4gb25jZSB0aGUgbG9jayBpcyBhY3F1aXJlZC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogYXdhaXQgcHJvY2Vzc0xvY2soJ21pZ3JhdGUnLCA1MDAwLCBhc3luYyAoKSA9PiB7XG4gKiAgIGF3YWl0IHJ1bk1pZ3JhdGlvbigpXG4gKiB9KVxuICogYGBgXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NMb2NrKG5hbWUsIGFjcXVpcmVUaW1lb3V0LCBmbikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwcmV2aW91c09wZXJhdGlvbiA9IChfYSA9IFBST0NFU1NfTE9DS1NbbmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGNvbnN0IGN1cnJlbnRPcGVyYXRpb24gPSBQcm9taXNlLnJhY2UoW1xuICAgICAgICBwcmV2aW91c09wZXJhdGlvbi5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3Igb2YgcHJldmlvdXMgb3BlcmF0aW9uIHRoYXQgd2UncmUgd2FpdGluZyB0byBmaW5pc2hcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KSxcbiAgICAgICAgYWNxdWlyZVRpbWVvdXQgPj0gMFxuICAgICAgICAgICAgPyBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQHN1cGFiYXNlL2dvdHJ1ZS1qczogTG9jayBcIiR7bmFtZX1cIiBhY3F1aXNpdGlvbiB0aW1lZCBvdXQgYWZ0ZXIgJHthY3F1aXJlVGltZW91dH1tcy4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IGFub3RoZXIgb3BlcmF0aW9uIGhvbGRpbmcgdGhlIGxvY2suICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnNpZGVyIGluY3JlYXNpbmcgbG9ja0FjcXVpcmVUaW1lb3V0IG9yIGNoZWNraW5nIGZvciBzdHVjayBvcGVyYXRpb25zLicpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcihgQWNxdWlyaW5nIHByb2Nlc3MgbG9jayB3aXRoIG5hbWUgXCIke25hbWV9XCIgdGltZWQgb3V0YCkpO1xuICAgICAgICAgICAgICAgIH0sIGFjcXVpcmVUaW1lb3V0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgXS5maWx0ZXIoKHgpID0+IHgpKVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgaWYgKGUgJiYgZS5pc0FjcXVpcmVUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0pXG4gICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gcHJldmlvdXMgb3BlcmF0aW9ucyBmaW5pc2hlZCBhbmQgd2UgZGlkbid0IGdldCBhIHJhY2Ugb24gdGhlIGFjcXVpcmVcbiAgICAgICAgLy8gdGltZW91dCwgc28gdGhlIGN1cnJlbnQgb3BlcmF0aW9uIGNhbiBmaW5hbGx5IHN0YXJ0XG4gICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgIH0pO1xuICAgIFBST0NFU1NfTE9DS1NbbmFtZV0gPSBjdXJyZW50T3BlcmF0aW9uLmNhdGNoKGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGlmIChlICYmIGUuaXNBY3F1aXJlVGltZW91dCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIHRpbWVkIG91dCwgaXQgZG9lc24ndCBtZWFuIHRoYXQgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAvLyBvcGVyYXRpb24gZmluaXNoZWQsIHNvIHdlIG5lZWQgY29udG51ZSB3YWl0aW5nIGZvciBpdCB0byBmaW5pc2hcbiAgICAgICAgICAgIGF3YWl0IHByZXZpb3VzT3BlcmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgICAvLyBmaW5hbGx5IHdhaXQgZm9yIHRoZSBjdXJyZW50IG9wZXJhdGlvbiB0byBmaW5pc2ggc3VjY2Vzc2Z1bGx5LCB3aXRoIGFuXG4gICAgLy8gZXJyb3Igb3Igd2l0aCBhbiBhY3F1aXJlIHRpbWVvdXQgZXJyb3JcbiAgICByZXR1cm4gYXdhaXQgY3VycmVudE9wZXJhdGlvbjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2tzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciIsIk5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yIiwiTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IiLCJpbnRlcm5hbHMiLCJuYXZpZ2F0b3JMb2NrIiwicHJvY2Vzc0xvY2siLCJoZWxwZXJzXzEiLCJyZXF1aXJlIiwiZGVidWciLCJnbG9iYWxUaGlzIiwic3VwcG9ydHNMb2NhbFN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJpc0FjcXVpcmVUaW1lb3V0IiwibmFtZSIsImFjcXVpcmVUaW1lb3V0IiwiZm4iLCJjb25zb2xlIiwibG9nIiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwic2V0VGltZW91dCIsImFib3J0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwibmF2aWdhdG9yIiwibG9ja3MiLCJyZXF1ZXN0IiwibW9kZSIsImlmQXZhaWxhYmxlIiwic2lnbmFsIiwibG9jayIsInJlc3VsdCIsInF1ZXJ5IiwiSlNPTiIsInN0cmluZ2lmeSIsImUiLCJ3YXJuIiwiUFJPQ0VTU19MT0NLUyIsIl9hIiwicHJldmlvdXNPcGVyYXRpb24iLCJjdXJyZW50T3BlcmF0aW9uIiwicmFjZSIsImNhdGNoIiwiXyIsInJlamVjdCIsImZpbHRlciIsIngiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/locks.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/polyfills.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/lib/polyfills.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.polyfillGlobalThis = polyfillGlobalThis;\n/**\n * https://mathiasbynens.be/notes/globalthis\n */ function polyfillGlobalThis() {\n    if (typeof globalThis === \"object\") return;\n    try {\n        Object.defineProperty(Object.prototype, \"__magic__\", {\n            get: function() {\n                return this;\n            },\n            configurable: true\n        });\n        // @ts-expect-error 'Allow access to magic'\n        __magic__.globalThis = __magic__;\n        // @ts-expect-error 'Allow access to magic'\n        delete Object.prototype.__magic__;\n    } catch (e) {\n        if (typeof self !== \"undefined\") {\n            // @ts-expect-error 'Allow access to globals'\n            self.globalThis = self;\n        }\n    }\n} //# sourceMappingURL=polyfills.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi9wb2x5ZmlsbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDBCQUEwQixHQUFHRTtBQUM3Qjs7Q0FFQyxHQUNELFNBQVNBO0lBQ0wsSUFBSSxPQUFPQyxlQUFlLFVBQ3RCO0lBQ0osSUFBSTtRQUNBTCxPQUFPQyxjQUFjLENBQUNELE9BQU9NLFNBQVMsRUFBRSxhQUFhO1lBQ2pEQyxLQUFLO2dCQUNELE9BQU8sSUFBSTtZQUNmO1lBQ0FDLGNBQWM7UUFDbEI7UUFDQSwyQ0FBMkM7UUFDM0NDLFVBQVVKLFVBQVUsR0FBR0k7UUFDdkIsMkNBQTJDO1FBQzNDLE9BQU9ULE9BQU9NLFNBQVMsQ0FBQ0csU0FBUztJQUNyQyxFQUNBLE9BQU9DLEdBQUc7UUFDTixJQUFJLE9BQU9DLFNBQVMsYUFBYTtZQUM3Qiw2Q0FBNkM7WUFDN0NBLEtBQUtOLFVBQVUsR0FBR007UUFDdEI7SUFDSjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbWFpbi9saWIvcG9seWZpbGxzLmpzP2FmMGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBvbHlmaWxsR2xvYmFsVGhpcyA9IHBvbHlmaWxsR2xvYmFsVGhpcztcbi8qKlxuICogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2dsb2JhbHRoaXNcbiAqL1xuZnVuY3Rpb24gcG9seWZpbGxHbG9iYWxUaGlzKCkge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgJ19fbWFnaWNfXycsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICAgICAgX19tYWdpY19fLmdsb2JhbFRoaXMgPSBfX21hZ2ljX187XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICAgICAgZGVsZXRlIE9iamVjdC5wcm90b3R5cGUuX19tYWdpY19fO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gZ2xvYmFscydcbiAgICAgICAgICAgIHNlbGYuZ2xvYmFsVGhpcyA9IHNlbGY7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2x5ZmlsbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicG9seWZpbGxHbG9iYWxUaGlzIiwiZ2xvYmFsVGhpcyIsInByb3RvdHlwZSIsImdldCIsImNvbmZpZ3VyYWJsZSIsIl9fbWFnaWNfXyIsImUiLCJzZWxmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/polyfills.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/types.js":
/*!***************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/lib/types.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SIGN_OUT_SCOPES = void 0;\nconst WeakPasswordReasons = [\n    \"length\",\n    \"characters\",\n    \"pwned\"\n];\nconst AMRMethods = [\n    \"password\",\n    \"otp\",\n    \"oauth\",\n    \"totp\",\n    \"mfa/totp\",\n    \"mfa/phone\",\n    \"mfa/webauthn\",\n    \"anonymous\",\n    \"sso/saml\",\n    \"magiclink\",\n    \"web3\",\n    \"oauth_provider/authorization_code\"\n];\nconst FactorTypes = [\n    \"totp\",\n    \"phone\",\n    \"webauthn\"\n];\nconst FactorVerificationStatuses = [\n    \"verified\",\n    \"unverified\"\n];\nconst MFATOTPChannels = [\n    \"sms\",\n    \"whatsapp\"\n];\nexports.SIGN_OUT_SCOPES = [\n    \"global\",\n    \"local\",\n    \"others\"\n]; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUcsS0FBSztBQUMvQixNQUFNRyxzQkFBc0I7SUFBQztJQUFVO0lBQWM7Q0FBUTtBQUM3RCxNQUFNQyxhQUFhO0lBQ2Y7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxNQUFNQyxjQUFjO0lBQUM7SUFBUTtJQUFTO0NBQVc7QUFDakQsTUFBTUMsNkJBQTZCO0lBQUM7SUFBWTtDQUFhO0FBQzdELE1BQU1DLGtCQUFrQjtJQUFDO0lBQU87Q0FBVztBQUMzQ1AsdUJBQXVCLEdBQUc7SUFBQztJQUFVO0lBQVM7Q0FBUyxFQUN2RCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi90eXBlcy5qcz9mYjU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TSUdOX09VVF9TQ09QRVMgPSB2b2lkIDA7XG5jb25zdCBXZWFrUGFzc3dvcmRSZWFzb25zID0gWydsZW5ndGgnLCAnY2hhcmFjdGVycycsICdwd25lZCddO1xuY29uc3QgQU1STWV0aG9kcyA9IFtcbiAgICAncGFzc3dvcmQnLFxuICAgICdvdHAnLFxuICAgICdvYXV0aCcsXG4gICAgJ3RvdHAnLFxuICAgICdtZmEvdG90cCcsXG4gICAgJ21mYS9waG9uZScsXG4gICAgJ21mYS93ZWJhdXRobicsXG4gICAgJ2Fub255bW91cycsXG4gICAgJ3Nzby9zYW1sJyxcbiAgICAnbWFnaWNsaW5rJyxcbiAgICAnd2ViMycsXG4gICAgJ29hdXRoX3Byb3ZpZGVyL2F1dGhvcml6YXRpb25fY29kZScsXG5dO1xuY29uc3QgRmFjdG9yVHlwZXMgPSBbJ3RvdHAnLCAncGhvbmUnLCAnd2ViYXV0aG4nXTtcbmNvbnN0IEZhY3RvclZlcmlmaWNhdGlvblN0YXR1c2VzID0gWyd2ZXJpZmllZCcsICd1bnZlcmlmaWVkJ107XG5jb25zdCBNRkFUT1RQQ2hhbm5lbHMgPSBbJ3NtcycsICd3aGF0c2FwcCddO1xuZXhwb3J0cy5TSUdOX09VVF9TQ09QRVMgPSBbJ2dsb2JhbCcsICdsb2NhbCcsICdvdGhlcnMnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNJR05fT1VUX1NDT1BFUyIsIldlYWtQYXNzd29yZFJlYXNvbnMiLCJBTVJNZXRob2RzIiwiRmFjdG9yVHlwZXMiLCJGYWN0b3JWZXJpZmljYXRpb25TdGF0dXNlcyIsIk1GQVRPVFBDaGFubmVscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/version.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/lib/version.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.version = void 0;\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nexports.version = \"2.91.0\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUcsS0FBSztBQUN2Qiw2RUFBNkU7QUFDN0UsZ0VBQWdFO0FBQ2hFLHVFQUF1RTtBQUN2RSxpRUFBaUU7QUFDakUsa0VBQWtFO0FBQ2xFLGlFQUFpRTtBQUNqRUEsZUFBZSxHQUFHLFVBQ2xCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21haW4vbGliL3ZlcnNpb24uanM/OTY2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcbi8vIEdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IGR1cmluZyByZWxlYXNlcyBieSBzY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLWZpbGVzLnRzXG4vLyBUaGlzIGZpbGUgcHJvdmlkZXMgcnVudGltZSBhY2Nlc3MgdG8gdGhlIHBhY2thZ2UgdmVyc2lvbiBmb3I6XG4vLyAtIEhUVFAgcmVxdWVzdCBoZWFkZXJzIChlLmcuLCBYLUNsaWVudC1JbmZvIGhlYWRlciBmb3IgQVBJIHJlcXVlc3RzKVxuLy8gLSBEZWJ1Z2dpbmcgYW5kIHN1cHBvcnQgKGlkZW50aWZ5aW5nIHdoaWNoIHZlcnNpb24gaXMgcnVubmluZylcbi8vIC0gVGVsZW1ldHJ5IGFuZCBsb2dnaW5nICh2ZXJzaW9uIHJlcG9ydGluZyBpbiBlcnJvcnMvYW5hbHl0aWNzKVxuLy8gLSBFbnN1cmluZyBidWlsZCBhcnRpZmFjdHMgbWF0Y2ggdGhlIHB1Ymxpc2hlZCBwYWNrYWdlIHZlcnNpb25cbmV4cG9ydHMudmVyc2lvbiA9ICcyLjkxLjAnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/web3/ethereum.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/lib/web3/ethereum.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// types and functions copied over from viem so this library doesn't depend on it\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getAddress = getAddress;\nexports.fromHex = fromHex;\nexports.toHex = toHex;\nexports.createSiweMessage = createSiweMessage;\nfunction getAddress(address) {\n    if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {\n        throw new Error(`@supabase/auth-js: Address \"${address}\" is invalid.`);\n    }\n    return address.toLowerCase();\n}\nfunction fromHex(hex) {\n    return parseInt(hex, 16);\n}\nfunction toHex(value) {\n    const bytes = new TextEncoder().encode(value);\n    const hex = Array.from(bytes, (byte)=>byte.toString(16).padStart(2, \"0\")).join(\"\");\n    return \"0x\" + hex;\n}\n/**\n * Creates EIP-4361 formatted message.\n */ function createSiweMessage(parameters) {\n    var _a;\n    const { chainId, domain, expirationTime, issuedAt = new Date(), nonce, notBefore, requestId, resources, scheme, uri, version } = parameters;\n    // Validate fields\n    {\n        if (!Number.isInteger(chainId)) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"chainId\". Chain ID must be a EIP-155 chain ID. Provided value: ${chainId}`);\n        if (!domain) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"domain\". Domain must be provided.`);\n        if (nonce && nonce.length < 8) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"nonce\". Nonce must be at least 8 characters. Provided value: ${nonce}`);\n        if (!uri) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"uri\". URI must be provided.`);\n        if (version !== \"1\") throw new Error(`@supabase/auth-js: Invalid SIWE message field \"version\". Version must be '1'. Provided value: ${version}`);\n        if ((_a = parameters.statement) === null || _a === void 0 ? void 0 : _a.includes(\"\\n\")) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"statement\". Statement must not include '\\\\n'. Provided value: ${parameters.statement}`);\n    }\n    // Construct message\n    const address = getAddress(parameters.address);\n    const origin = scheme ? `${scheme}://${domain}` : domain;\n    const statement = parameters.statement ? `${parameters.statement}\\n` : \"\";\n    const prefix = `${origin} wants you to sign in with your Ethereum account:\\n${address}\\n\\n${statement}`;\n    let suffix = `URI: ${uri}\\nVersion: ${version}\\nChain ID: ${chainId}${nonce ? `\\nNonce: ${nonce}` : \"\"}\\nIssued At: ${issuedAt.toISOString()}`;\n    if (expirationTime) suffix += `\\nExpiration Time: ${expirationTime.toISOString()}`;\n    if (notBefore) suffix += `\\nNot Before: ${notBefore.toISOString()}`;\n    if (requestId) suffix += `\\nRequest ID: ${requestId}`;\n    if (resources) {\n        let content = \"\\nResources:\";\n        for (const resource of resources){\n            if (!resource || typeof resource !== \"string\") throw new Error(`@supabase/auth-js: Invalid SIWE message field \"resources\". Every resource must be a valid string. Provided value: ${resource}`);\n            content += `\\n- ${resource}`;\n        }\n        suffix += content;\n    }\n    return `${prefix}\\n${suffix}`;\n} //# sourceMappingURL=ethereum.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi93ZWIzL2V0aGVyZXVtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsaUZBQWlGO0FBQ2pGQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUdFO0FBQ3JCRixlQUFlLEdBQUdHO0FBQ2xCSCxhQUFhLEdBQUdJO0FBQ2hCSix5QkFBeUIsR0FBR0s7QUFDNUIsU0FBU0gsV0FBV0ksT0FBTztJQUN2QixJQUFJLENBQUMsc0JBQXNCQyxJQUFJLENBQUNELFVBQVU7UUFDdEMsTUFBTSxJQUFJRSxNQUFNLENBQUMsNEJBQTRCLEVBQUVGLFFBQVEsYUFBYSxDQUFDO0lBQ3pFO0lBQ0EsT0FBT0EsUUFBUUcsV0FBVztBQUM5QjtBQUNBLFNBQVNOLFFBQVFPLEdBQUc7SUFDaEIsT0FBT0MsU0FBU0QsS0FBSztBQUN6QjtBQUNBLFNBQVNOLE1BQU1ILEtBQUs7SUFDaEIsTUFBTVcsUUFBUSxJQUFJQyxjQUFjQyxNQUFNLENBQUNiO0lBQ3ZDLE1BQU1TLE1BQU1LLE1BQU1DLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxPQUFTQSxLQUFLQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDO0lBQ2pGLE9BQVEsT0FBT1Y7QUFDbkI7QUFDQTs7Q0FFQyxHQUNELFNBQVNMLGtCQUFrQmdCLFVBQVU7SUFDakMsSUFBSUM7SUFDSixNQUFNLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxjQUFjLEVBQUVDLFdBQVcsSUFBSUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxPQUFPLEVBQUcsR0FBR2I7SUFDbEksa0JBQWtCO0lBQ2xCO1FBQ0ksSUFBSSxDQUFDYyxPQUFPQyxTQUFTLENBQUNiLFVBQ2xCLE1BQU0sSUFBSWYsTUFBTSxDQUFDLDhHQUE4RyxFQUFFZSxRQUFRLENBQUM7UUFDOUksSUFBSSxDQUFDQyxRQUNELE1BQU0sSUFBSWhCLE1BQU0sQ0FBQyxnRkFBZ0YsQ0FBQztRQUN0RyxJQUFJb0IsU0FBU0EsTUFBTVMsTUFBTSxHQUFHLEdBQ3hCLE1BQU0sSUFBSTdCLE1BQU0sQ0FBQyw0R0FBNEcsRUFBRW9CLE1BQU0sQ0FBQztRQUMxSSxJQUFJLENBQUNLLEtBQ0QsTUFBTSxJQUFJekIsTUFBTSxDQUFDLDBFQUEwRSxDQUFDO1FBQ2hHLElBQUkwQixZQUFZLEtBQ1osTUFBTSxJQUFJMUIsTUFBTSxDQUFDLDhGQUE4RixFQUFFMEIsUUFBUSxDQUFDO1FBQzlILElBQUksQ0FBQ1osS0FBS0QsV0FBV2lCLFNBQVMsTUFBTSxRQUFRaEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaUIsUUFBUSxDQUFDLE9BQzdFLE1BQU0sSUFBSS9CLE1BQU0sQ0FBQyw2R0FBNkcsRUFBRWEsV0FBV2lCLFNBQVMsQ0FBQyxDQUFDO0lBQzlKO0lBQ0Esb0JBQW9CO0lBQ3BCLE1BQU1oQyxVQUFVSixXQUFXbUIsV0FBV2YsT0FBTztJQUM3QyxNQUFNa0MsU0FBU1IsU0FBUyxDQUFDLEVBQUVBLE9BQU8sR0FBRyxFQUFFUixPQUFPLENBQUMsR0FBR0E7SUFDbEQsTUFBTWMsWUFBWWpCLFdBQVdpQixTQUFTLEdBQUcsQ0FBQyxFQUFFakIsV0FBV2lCLFNBQVMsQ0FBQyxFQUFFLENBQUMsR0FBRztJQUN2RSxNQUFNRyxTQUFTLENBQUMsRUFBRUQsT0FBTyxtREFBbUQsRUFBRWxDLFFBQVEsSUFBSSxFQUFFZ0MsVUFBVSxDQUFDO0lBQ3ZHLElBQUlJLFNBQVMsQ0FBQyxLQUFLLEVBQUVULElBQUksV0FBVyxFQUFFQyxRQUFRLFlBQVksRUFBRVgsUUFBUSxFQUFFSyxRQUFRLENBQUMsU0FBUyxFQUFFQSxNQUFNLENBQUMsR0FBRyxHQUFHLGFBQWEsRUFBRUYsU0FBU2lCLFdBQVcsR0FBRyxDQUFDO0lBQzlJLElBQUlsQixnQkFDQWlCLFVBQVUsQ0FBQyxtQkFBbUIsRUFBRWpCLGVBQWVrQixXQUFXLEdBQUcsQ0FBQztJQUNsRSxJQUFJZCxXQUNBYSxVQUFVLENBQUMsY0FBYyxFQUFFYixVQUFVYyxXQUFXLEdBQUcsQ0FBQztJQUN4RCxJQUFJYixXQUNBWSxVQUFVLENBQUMsY0FBYyxFQUFFWixVQUFVLENBQUM7SUFDMUMsSUFBSUMsV0FBVztRQUNYLElBQUlhLFVBQVU7UUFDZCxLQUFLLE1BQU1DLFlBQVlkLFVBQVc7WUFDOUIsSUFBSSxDQUFDYyxZQUFZLE9BQU9BLGFBQWEsVUFDakMsTUFBTSxJQUFJckMsTUFBTSxDQUFDLGtIQUFrSCxFQUFFcUMsU0FBUyxDQUFDO1lBQ25KRCxXQUFXLENBQUMsSUFBSSxFQUFFQyxTQUFTLENBQUM7UUFDaEM7UUFDQUgsVUFBVUU7SUFDZDtJQUNBLE9BQU8sQ0FBQyxFQUFFSCxPQUFPLEVBQUUsRUFBRUMsT0FBTyxDQUFDO0FBQ2pDLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbWFpbi9saWIvd2ViMy9ldGhlcmV1bS5qcz8wY2QwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gdHlwZXMgYW5kIGZ1bmN0aW9ucyBjb3BpZWQgb3ZlciBmcm9tIHZpZW0gc28gdGhpcyBsaWJyYXJ5IGRvZXNuJ3QgZGVwZW5kIG9uIGl0XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEFkZHJlc3MgPSBnZXRBZGRyZXNzO1xuZXhwb3J0cy5mcm9tSGV4ID0gZnJvbUhleDtcbmV4cG9ydHMudG9IZXggPSB0b0hleDtcbmV4cG9ydHMuY3JlYXRlU2l3ZU1lc3NhZ2UgPSBjcmVhdGVTaXdlTWVzc2FnZTtcbmZ1bmN0aW9uIGdldEFkZHJlc3MoYWRkcmVzcykge1xuICAgIGlmICghL14weFthLWZBLUYwLTldezQwfSQvLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogQWRkcmVzcyBcIiR7YWRkcmVzc31cIiBpcyBpbnZhbGlkLmApO1xuICAgIH1cbiAgICByZXR1cm4gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoaGV4LCAxNik7XG59XG5mdW5jdGlvbiB0b0hleCh2YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKTtcbiAgICBjb25zdCBoZXggPSBBcnJheS5mcm9tKGJ5dGVzLCAoYnl0ZSkgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XG4gICAgcmV0dXJuICgnMHgnICsgaGV4KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBFSVAtNDM2MSBmb3JtYXR0ZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2l3ZU1lc3NhZ2UocGFyYW1ldGVycykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGNoYWluSWQsIGRvbWFpbiwgZXhwaXJhdGlvblRpbWUsIGlzc3VlZEF0ID0gbmV3IERhdGUoKSwgbm9uY2UsIG5vdEJlZm9yZSwgcmVxdWVzdElkLCByZXNvdXJjZXMsIHNjaGVtZSwgdXJpLCB2ZXJzaW9uLCB9ID0gcGFyYW1ldGVycztcbiAgICAvLyBWYWxpZGF0ZSBmaWVsZHNcbiAgICB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjaGFpbklkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwiY2hhaW5JZFwiLiBDaGFpbiBJRCBtdXN0IGJlIGEgRUlQLTE1NSBjaGFpbiBJRC4gUHJvdmlkZWQgdmFsdWU6ICR7Y2hhaW5JZH1gKTtcbiAgICAgICAgaWYgKCFkb21haW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcImRvbWFpblwiLiBEb21haW4gbXVzdCBiZSBwcm92aWRlZC5gKTtcbiAgICAgICAgaWYgKG5vbmNlICYmIG5vbmNlLmxlbmd0aCA8IDgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcIm5vbmNlXCIuIE5vbmNlIG11c3QgYmUgYXQgbGVhc3QgOCBjaGFyYWN0ZXJzLiBQcm92aWRlZCB2YWx1ZTogJHtub25jZX1gKTtcbiAgICAgICAgaWYgKCF1cmkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcInVyaVwiLiBVUkkgbXVzdCBiZSBwcm92aWRlZC5gKTtcbiAgICAgICAgaWYgKHZlcnNpb24gIT09ICcxJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwidmVyc2lvblwiLiBWZXJzaW9uIG11c3QgYmUgJzEnLiBQcm92aWRlZCB2YWx1ZTogJHt2ZXJzaW9ufWApO1xuICAgICAgICBpZiAoKF9hID0gcGFyYW1ldGVycy5zdGF0ZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcygnXFxuJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcInN0YXRlbWVudFwiLiBTdGF0ZW1lbnQgbXVzdCBub3QgaW5jbHVkZSAnXFxcXG4nLiBQcm92aWRlZCB2YWx1ZTogJHtwYXJhbWV0ZXJzLnN0YXRlbWVudH1gKTtcbiAgICB9XG4gICAgLy8gQ29uc3RydWN0IG1lc3NhZ2VcbiAgICBjb25zdCBhZGRyZXNzID0gZ2V0QWRkcmVzcyhwYXJhbWV0ZXJzLmFkZHJlc3MpO1xuICAgIGNvbnN0IG9yaWdpbiA9IHNjaGVtZSA/IGAke3NjaGVtZX06Ly8ke2RvbWFpbn1gIDogZG9tYWluO1xuICAgIGNvbnN0IHN0YXRlbWVudCA9IHBhcmFtZXRlcnMuc3RhdGVtZW50ID8gYCR7cGFyYW1ldGVycy5zdGF0ZW1lbnR9XFxuYCA6ICcnO1xuICAgIGNvbnN0IHByZWZpeCA9IGAke29yaWdpbn0gd2FudHMgeW91IHRvIHNpZ24gaW4gd2l0aCB5b3VyIEV0aGVyZXVtIGFjY291bnQ6XFxuJHthZGRyZXNzfVxcblxcbiR7c3RhdGVtZW50fWA7XG4gICAgbGV0IHN1ZmZpeCA9IGBVUkk6ICR7dXJpfVxcblZlcnNpb246ICR7dmVyc2lvbn1cXG5DaGFpbiBJRDogJHtjaGFpbklkfSR7bm9uY2UgPyBgXFxuTm9uY2U6ICR7bm9uY2V9YCA6ICcnfVxcbklzc3VlZCBBdDogJHtpc3N1ZWRBdC50b0lTT1N0cmluZygpfWA7XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lKVxuICAgICAgICBzdWZmaXggKz0gYFxcbkV4cGlyYXRpb24gVGltZTogJHtleHBpcmF0aW9uVGltZS50b0lTT1N0cmluZygpfWA7XG4gICAgaWYgKG5vdEJlZm9yZSlcbiAgICAgICAgc3VmZml4ICs9IGBcXG5Ob3QgQmVmb3JlOiAke25vdEJlZm9yZS50b0lTT1N0cmluZygpfWA7XG4gICAgaWYgKHJlcXVlc3RJZClcbiAgICAgICAgc3VmZml4ICs9IGBcXG5SZXF1ZXN0IElEOiAke3JlcXVlc3RJZH1gO1xuICAgIGlmIChyZXNvdXJjZXMpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSAnXFxuUmVzb3VyY2VzOic7XG4gICAgICAgIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgcmVzb3VyY2VzKSB7XG4gICAgICAgICAgICBpZiAoIXJlc291cmNlIHx8IHR5cGVvZiByZXNvdXJjZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogSW52YWxpZCBTSVdFIG1lc3NhZ2UgZmllbGQgXCJyZXNvdXJjZXNcIi4gRXZlcnkgcmVzb3VyY2UgbXVzdCBiZSBhIHZhbGlkIHN0cmluZy4gUHJvdmlkZWQgdmFsdWU6ICR7cmVzb3VyY2V9YCk7XG4gICAgICAgICAgICBjb250ZW50ICs9IGBcXG4tICR7cmVzb3VyY2V9YDtcbiAgICAgICAgfVxuICAgICAgICBzdWZmaXggKz0gY29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3ByZWZpeH1cXG4ke3N1ZmZpeH1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXRoZXJldW0uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0QWRkcmVzcyIsImZyb21IZXgiLCJ0b0hleCIsImNyZWF0ZVNpd2VNZXNzYWdlIiwiYWRkcmVzcyIsInRlc3QiLCJFcnJvciIsInRvTG93ZXJDYXNlIiwiaGV4IiwicGFyc2VJbnQiLCJieXRlcyIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiQXJyYXkiLCJmcm9tIiwiYnl0ZSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJqb2luIiwicGFyYW1ldGVycyIsIl9hIiwiY2hhaW5JZCIsImRvbWFpbiIsImV4cGlyYXRpb25UaW1lIiwiaXNzdWVkQXQiLCJEYXRlIiwibm9uY2UiLCJub3RCZWZvcmUiLCJyZXF1ZXN0SWQiLCJyZXNvdXJjZXMiLCJzY2hlbWUiLCJ1cmkiLCJ2ZXJzaW9uIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwibGVuZ3RoIiwic3RhdGVtZW50IiwiaW5jbHVkZXMiLCJvcmlnaW4iLCJwcmVmaXgiLCJzdWZmaXgiLCJ0b0lTT1N0cmluZyIsImNvbnRlbnQiLCJyZXNvdXJjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/web3/ethereum.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/webauthn.errors.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/lib/webauthn.errors.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/ban-ts-comment */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebAuthnUnknownError = exports.WebAuthnError = void 0;\nexports.isWebAuthnError = isWebAuthnError;\nexports.identifyRegistrationError = identifyRegistrationError;\nexports.identifyAuthenticationError = identifyAuthenticationError;\nconst webauthn_1 = __webpack_require__(/*! ./webauthn */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/webauthn.js\");\n/**\n * A custom Error used to return a more nuanced error detailing _why_ one of the eight documented\n * errors in the spec was raised after calling `navigator.credentials.create()` or\n * `navigator.credentials.get()`:\n *\n * - `AbortError`\n * - `ConstraintError`\n * - `InvalidStateError`\n * - `NotAllowedError`\n * - `NotSupportedError`\n * - `SecurityError`\n * - `TypeError`\n * - `UnknownError`\n *\n * Error messages were determined through investigation of the spec to determine under which\n * scenarios a given error would be raised.\n */ class WebAuthnError extends Error {\n    constructor({ message, code, cause, name }){\n        var _a;\n        // @ts-ignore: help Rollup understand that `cause` is okay to set\n        super(message, {\n            cause\n        });\n        this.__isWebAuthnError = true;\n        this.name = (_a = name !== null && name !== void 0 ? name : cause instanceof Error ? cause.name : undefined) !== null && _a !== void 0 ? _a : \"Unknown Error\";\n        this.code = code;\n    }\n}\nexports.WebAuthnError = WebAuthnError;\n/**\n * Error class for unknown WebAuthn errors.\n * Wraps unexpected errors that don't match known WebAuthn error conditions.\n */ class WebAuthnUnknownError extends WebAuthnError {\n    constructor(message, originalError){\n        super({\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: originalError,\n            message\n        });\n        this.name = \"WebAuthnUnknownError\";\n        this.originalError = originalError;\n    }\n}\nexports.WebAuthnUnknownError = WebAuthnUnknownError;\n/**\n * Type guard to check if an error is a WebAuthnError.\n * @param {unknown} error - The error to check\n * @returns {boolean} True if the error is a WebAuthnError\n */ function isWebAuthnError(error) {\n    return typeof error === \"object\" && error !== null && \"__isWebAuthnError\" in error;\n}\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.create()`.\n * Maps browser errors to specific WebAuthn error codes for better debugging.\n * @param {Object} params - Error identification parameters\n * @param {Error} params.error - The error thrown by the browser\n * @param {CredentialCreationOptions} params.options - The options passed to credentials.create()\n * @returns {WebAuthnError} A WebAuthnError with a specific error code\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n */ function identifyRegistrationError({ error, options }) {\n    var _a, _b, _c;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error(\"options was missing required publicKey property\");\n    }\n    if (error.name === \"AbortError\") {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: \"Registration ceremony was sent an abort signal\",\n                code: \"ERROR_CEREMONY_ABORTED\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"ConstraintError\") {\n        if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 4)\n            return new WebAuthnError({\n                message: \"Discoverable credentials were required but no available authenticator supported it\",\n                code: \"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT\",\n                cause: error\n            });\n        } else if (// @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024\n        options.mediation === \"conditional\" && ((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === \"required\") {\n            // https://w3c.github.io/webauthn/#sctn-createCredential (Step 22.4)\n            return new WebAuthnError({\n                message: \"User verification was required during automatic registration but it could not be performed\",\n                code: \"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE\",\n                cause: error\n            });\n        } else if (((_c = publicKey.authenticatorSelection) === null || _c === void 0 ? void 0 : _c.userVerification) === \"required\") {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 5)\n            return new WebAuthnError({\n                message: \"User verification was required but no available authenticator supported it\",\n                code: \"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"InvalidStateError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 20)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 3)\n        return new WebAuthnError({\n            message: \"The authenticator was previously registered\",\n            code: \"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED\",\n            cause: error\n        });\n    } else if (error.name === \"NotAllowedError\") {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */ return new WebAuthnError({\n            message: error.message,\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: error\n        });\n    } else if (error.name === \"NotSupportedError\") {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param)=>param.type === \"public-key\");\n        if (validPubKeyCredParams.length === 0) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 10)\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: \"ERROR_MALFORMED_PUBKEYCREDPARAMS\",\n                cause: error\n            });\n        }\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 2)\n        return new WebAuthnError({\n            message: \"No available authenticator supported any of the specified pubKeyCredParams algorithms\",\n            code: \"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG\",\n            cause: error\n        });\n    } else if (error.name === \"SecurityError\") {\n        const effectiveDomain = window.location.hostname;\n        if (!(0, webauthn_1.isValidDomain)(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 7)\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: \"ERROR_INVALID_DOMAIN\",\n                cause: error\n            });\n        } else if (publicKey.rp.id !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 8)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: \"ERROR_INVALID_RP_ID\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"TypeError\") {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 5)\n            return new WebAuthnError({\n                message: \"User ID was not between 1 and 64 characters\",\n                code: \"ERROR_INVALID_USER_ID_LENGTH\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"UnknownError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 8)\n        return new WebAuthnError({\n            message: \"The authenticator was unable to process the specified options, or could not create a new credential\",\n            code: \"ERROR_AUTHENTICATOR_GENERAL_ERROR\",\n            cause: error\n        });\n    }\n    return new WebAuthnError({\n        message: \"a Non-Webauthn related error has occurred\",\n        code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n        cause: error\n    });\n}\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.get()`.\n * Maps browser errors to specific WebAuthn error codes for better debugging.\n * @param {Object} params - Error identification parameters\n * @param {Error} params.error - The error thrown by the browser\n * @param {CredentialRequestOptions} params.options - The options passed to credentials.get()\n * @returns {WebAuthnError} A WebAuthnError with a specific error code\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n */ function identifyAuthenticationError({ error, options }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error(\"options was missing required publicKey property\");\n    }\n    if (error.name === \"AbortError\") {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: \"Authentication ceremony was sent an abort signal\",\n                code: \"ERROR_CEREMONY_ABORTED\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"NotAllowedError\") {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */ return new WebAuthnError({\n            message: error.message,\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: error\n        });\n    } else if (error.name === \"SecurityError\") {\n        const effectiveDomain = window.location.hostname;\n        if (!(0, webauthn_1.isValidDomain)(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 5)\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: \"ERROR_INVALID_DOMAIN\",\n                cause: error\n            });\n        } else if (publicKey.rpId !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 6)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: \"ERROR_INVALID_RP_ID\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"UnknownError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 12)\n        return new WebAuthnError({\n            message: \"The authenticator was unable to process the specified options, or could not create a new assertion signature\",\n            code: \"ERROR_AUTHENTICATOR_GENERAL_ERROR\",\n            cause: error\n        });\n    }\n    return new WebAuthnError({\n        message: \"a Non-Webauthn related error has occurred\",\n        code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n        cause: error\n    });\n} //# sourceMappingURL=webauthn.errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi93ZWJhdXRobi5lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixvREFBb0QsR0FDcERBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw0QkFBNEIsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUM1REEsdUJBQXVCLEdBQUdJO0FBQzFCSixpQ0FBaUMsR0FBR0s7QUFDcENMLG1DQUFtQyxHQUFHTTtBQUN0QyxNQUFNQyxhQUFhQyxtQkFBT0EsQ0FBQyxvRkFBWTtBQUN2Qzs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNELE1BQU1MLHNCQUFzQk07SUFDeEJDLFlBQVksRUFBRUMsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFHLENBQUU7UUFDekMsSUFBSUM7UUFDSixpRUFBaUU7UUFDakUsS0FBSyxDQUFDSixTQUFTO1lBQUVFO1FBQU07UUFDdkIsSUFBSSxDQUFDRyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNGLElBQUksR0FBRyxDQUFDQyxLQUFLRCxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJQSxPQUFRRCxpQkFBaUJKLFFBQVFJLE1BQU1DLElBQUksR0FBR0csU0FBUyxNQUFPLFFBQVFGLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ2hKLElBQUksQ0FBQ0gsSUFBSSxHQUFHQTtJQUNoQjtBQUNKO0FBQ0FaLHFCQUFxQixHQUFHRztBQUN4Qjs7O0NBR0MsR0FDRCxNQUFNRCw2QkFBNkJDO0lBQy9CTyxZQUFZQyxPQUFPLEVBQUVPLGFBQWEsQ0FBRTtRQUNoQyxLQUFLLENBQUM7WUFDRk4sTUFBTTtZQUNOQyxPQUFPSztZQUNQUDtRQUNKO1FBQ0EsSUFBSSxDQUFDRyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNJLGFBQWEsR0FBR0E7SUFDekI7QUFDSjtBQUNBbEIsNEJBQTRCLEdBQUdFO0FBQy9COzs7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c3QvbWFpbi9saWIvd2ViYXV0aG4uZXJyb3JzLmpzP2Q3M2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViQXV0aG5Vbmtub3duRXJyb3IgPSBleHBvcnRzLldlYkF1dGhuRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmlzV2ViQXV0aG5FcnJvciA9IGlzV2ViQXV0aG5FcnJvcjtcbmV4cG9ydHMuaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvciA9IGlkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3I7XG5leHBvcnRzLmlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvciA9IGlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvcjtcbmNvbnN0IHdlYmF1dGhuXzEgPSByZXF1aXJlKFwiLi93ZWJhdXRoblwiKTtcbi8qKlxuICogQSBjdXN0b20gRXJyb3IgdXNlZCB0byByZXR1cm4gYSBtb3JlIG51YW5jZWQgZXJyb3IgZGV0YWlsaW5nIF93aHlfIG9uZSBvZiB0aGUgZWlnaHQgZG9jdW1lbnRlZFxuICogZXJyb3JzIGluIHRoZSBzcGVjIHdhcyByYWlzZWQgYWZ0ZXIgY2FsbGluZyBgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpYCBvclxuICogYG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKWA6XG4gKlxuICogLSBgQWJvcnRFcnJvcmBcbiAqIC0gYENvbnN0cmFpbnRFcnJvcmBcbiAqIC0gYEludmFsaWRTdGF0ZUVycm9yYFxuICogLSBgTm90QWxsb3dlZEVycm9yYFxuICogLSBgTm90U3VwcG9ydGVkRXJyb3JgXG4gKiAtIGBTZWN1cml0eUVycm9yYFxuICogLSBgVHlwZUVycm9yYFxuICogLSBgVW5rbm93bkVycm9yYFxuICpcbiAqIEVycm9yIG1lc3NhZ2VzIHdlcmUgZGV0ZXJtaW5lZCB0aHJvdWdoIGludmVzdGlnYXRpb24gb2YgdGhlIHNwZWMgdG8gZGV0ZXJtaW5lIHVuZGVyIHdoaWNoXG4gKiBzY2VuYXJpb3MgYSBnaXZlbiBlcnJvciB3b3VsZCBiZSByYWlzZWQuXG4gKi9cbmNsYXNzIFdlYkF1dGhuRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlLCBjb2RlLCBjYXVzZSwgbmFtZSwgfSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIEB0cy1pZ25vcmU6IGhlbHAgUm9sbHVwIHVuZGVyc3RhbmQgdGhhdCBgY2F1c2VgIGlzIG9rYXkgdG8gc2V0XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIHsgY2F1c2UgfSk7XG4gICAgICAgIHRoaXMuX19pc1dlYkF1dGhuRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWUgPSAoX2EgPSBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiAoY2F1c2UgaW5zdGFuY2VvZiBFcnJvciA/IGNhdXNlLm5hbWUgOiB1bmRlZmluZWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnVW5rbm93biBFcnJvcic7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJBdXRobkVycm9yID0gV2ViQXV0aG5FcnJvcjtcbi8qKlxuICogRXJyb3IgY2xhc3MgZm9yIHVua25vd24gV2ViQXV0aG4gZXJyb3JzLlxuICogV3JhcHMgdW5leHBlY3RlZCBlcnJvcnMgdGhhdCBkb24ndCBtYXRjaCBrbm93biBXZWJBdXRobiBlcnJvciBjb25kaXRpb25zLlxuICovXG5jbGFzcyBXZWJBdXRoblVua25vd25FcnJvciBleHRlbmRzIFdlYkF1dGhuRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY29kZTogJ0VSUk9SX1BBU1NUSFJPVUdIX1NFRV9DQVVTRV9QUk9QRVJUWScsXG4gICAgICAgICAgICBjYXVzZTogb3JpZ2luYWxFcnJvcixcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2ViQXV0aG5Vbmtub3duRXJyb3InO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuV2ViQXV0aG5Vbmtub3duRXJyb3IgPSBXZWJBdXRoblVua25vd25FcnJvcjtcbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBhbiBlcnJvciBpcyBhIFdlYkF1dGhuRXJyb3IuXG4gKiBAcGFyYW0ge3Vua25vd259IGVycm9yIC0gVGhlIGVycm9yIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSBXZWJBdXRobkVycm9yXG4gKi9cbmZ1bmN0aW9uIGlzV2ViQXV0aG5FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdfX2lzV2ViQXV0aG5FcnJvcicgaW4gZXJyb3I7XG59XG4vKipcbiAqIEF0dGVtcHQgdG8gaW50dWl0IF93aHlfIGFuIGVycm9yIHdhcyByYWlzZWQgYWZ0ZXIgY2FsbGluZyBgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpYC5cbiAqIE1hcHMgYnJvd3NlciBlcnJvcnMgdG8gc3BlY2lmaWMgV2ViQXV0aG4gZXJyb3IgY29kZXMgZm9yIGJldHRlciBkZWJ1Z2dpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gRXJyb3IgaWRlbnRpZmljYXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtFcnJvcn0gcGFyYW1zLmVycm9yIC0gVGhlIGVycm9yIHRocm93biBieSB0aGUgYnJvd3NlclxuICogQHBhcmFtIHtDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zfSBwYXJhbXMub3B0aW9ucyAtIFRoZSBvcHRpb25zIHBhc3NlZCB0byBjcmVkZW50aWFscy5jcmVhdGUoKVxuICogQHJldHVybnMge1dlYkF1dGhuRXJyb3J9IEEgV2ViQXV0aG5FcnJvciB3aXRoIGEgc3BlY2lmaWMgZXJyb3IgY29kZVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgVzNDIFdlYkF1dGhuIFNwZWMgLSBDcmVhdGUgQ3JlZGVudGlhbH1cbiAqL1xuZnVuY3Rpb24gaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvcih7IGVycm9yLCBvcHRpb25zLCB9KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgeyBwdWJsaWNLZXkgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFwdWJsaWNLZXkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ29wdGlvbnMgd2FzIG1pc3NpbmcgcmVxdWlyZWQgcHVibGljS2V5IHByb3BlcnR5Jyk7XG4gICAgfVxuICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgMTYpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdSZWdpc3RyYXRpb24gY2VyZW1vbnkgd2FzIHNlbnQgYW4gYWJvcnQgc2lnbmFsJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQ0VSRU1PTllfQUJPUlRFRCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ0NvbnN0cmFpbnRFcnJvcicpIHtcbiAgICAgICAgaWYgKCgoX2EgPSBwdWJsaWNLZXkuYXV0aGVudGljYXRvclNlbGVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcXVpcmVSZXNpZGVudEtleSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCA0KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRGlzY292ZXJhYmxlIGNyZWRlbnRpYWxzIHdlcmUgcmVxdWlyZWQgYnV0IG5vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBpdCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfTUlTU0lOR19ESVNDT1ZFUkFCTEVfQ1JFREVOVElBTF9TVVBQT1JUJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgLy8gQHRzLWlnbm9yZTogYG1lZGlhdGlvbmAgZG9lc24ndCB5ZXQgZXhpc3Qgb24gQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyBidXQgaXQncyBwb3NzaWJsZSBhcyBvZiBTZXB0IDIwMjRcbiAgICAgICAgb3B0aW9ucy5tZWRpYXRpb24gPT09ICdjb25kaXRpb25hbCcgJiZcbiAgICAgICAgICAgICgoX2IgPSBwdWJsaWNLZXkuYXV0aGVudGljYXRvclNlbGVjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVzZXJWZXJpZmljYXRpb24pID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCAyMi40KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVXNlciB2ZXJpZmljYXRpb24gd2FzIHJlcXVpcmVkIGR1cmluZyBhdXRvbWF0aWMgcmVnaXN0cmF0aW9uIGJ1dCBpdCBjb3VsZCBub3QgYmUgcGVyZm9ybWVkJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUT19SRUdJU1RFUl9VU0VSX1ZFUklGSUNBVElPTl9GQUlMVVJFJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKF9jID0gcHVibGljS2V5LmF1dGhlbnRpY2F0b3JTZWxlY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51c2VyVmVyaWZpY2F0aW9uKSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtbWFrZS1jcmVkIChTdGVwIDUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdVc2VyIHZlcmlmaWNhdGlvbiB3YXMgcmVxdWlyZWQgYnV0IG5vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBpdCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfTUlTU0lOR19VU0VSX1ZFUklGSUNBVElPTl9TVVBQT1JUJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnSW52YWxpZFN0YXRlRXJyb3InKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgMjApXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCAzKVxuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSBhdXRoZW50aWNhdG9yIHdhcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQnLFxuICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfUFJFVklPVVNMWV9SRUdJU1RFUkVEJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXNzIHRoZSBlcnJvciBkaXJlY3RseSB0aHJvdWdoLiBQbGF0Zm9ybXMgYXJlIG92ZXJsb2FkaW5nIHRoaXMgZXJyb3IgYmV5b25kIHdoYXQgdGhlIHNwZWNcbiAgICAgICAgICogZGVmaW5lcyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgcG90ZW50aWFsbHkgdXNlZnVsIGVycm9yIG1lc3NhZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RTdXBwb3J0ZWRFcnJvcicpIHtcbiAgICAgICAgY29uc3QgdmFsaWRQdWJLZXlDcmVkUGFyYW1zID0gcHVibGljS2V5LnB1YktleUNyZWRQYXJhbXMuZmlsdGVyKChwYXJhbSkgPT4gcGFyYW0udHlwZSA9PT0gJ3B1YmxpYy1rZXknKTtcbiAgICAgICAgaWYgKHZhbGlkUHViS2V5Q3JlZFBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgMTApXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdObyBlbnRyeSBpbiBwdWJLZXlDcmVkUGFyYW1zIHdhcyBvZiB0eXBlIFwicHVibGljLWtleVwiJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfTUFMRk9STUVEX1BVQktFWUNSRURQQVJBTVMnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCAyKVxuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ05vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBhbnkgb2YgdGhlIHNwZWNpZmllZCBwdWJLZXlDcmVkUGFyYW1zIGFsZ29yaXRobXMnLFxuICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfTk9fU1VQUE9SVEVEX1BVQktFWUNSRURQQVJBTVNfQUxHJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdTZWN1cml0eUVycm9yJykge1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVEb21haW4gPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgICAgIGlmICghKDAsIHdlYmF1dGhuXzEuaXNWYWxpZERvbWFpbikoZWZmZWN0aXZlRG9tYWluKSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCA3KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgJHt3aW5kb3cubG9jYXRpb24uaG9zdG5hbWV9IGlzIGFuIGludmFsaWQgZG9tYWluYCxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfSU5WQUxJRF9ET01BSU4nLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHB1YmxpY0tleS5ycC5pZCAhPT0gZWZmZWN0aXZlRG9tYWluKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDgpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBUaGUgUlAgSUQgXCIke3B1YmxpY0tleS5ycC5pZH1cIiBpcyBpbnZhbGlkIGZvciB0aGlzIGRvbWFpbmAsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0lOVkFMSURfUlBfSUQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgIGlmIChwdWJsaWNLZXkudXNlci5pZC5ieXRlTGVuZ3RoIDwgMSB8fCBwdWJsaWNLZXkudXNlci5pZC5ieXRlTGVuZ3RoID4gNjQpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgNSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1VzZXIgSUQgd2FzIG5vdCBiZXR3ZWVuIDEgYW5kIDY0IGNoYXJhY3RlcnMnLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX1VTRVJfSURfTEVOR1RIJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnVW5rbm93bkVycm9yJykge1xuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1tYWtlLWNyZWQgKFN0ZXAgMSlcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtbWFrZS1jcmVkIChTdGVwIDgpXG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhlIGF1dGhlbnRpY2F0b3Igd2FzIHVuYWJsZSB0byBwcm9jZXNzIHRoZSBzcGVjaWZpZWQgb3B0aW9ucywgb3IgY291bGQgbm90IGNyZWF0ZSBhIG5ldyBjcmVkZW50aWFsJyxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX0dFTkVSQUxfRVJST1InLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ2EgTm9uLVdlYmF1dGhuIHJlbGF0ZWQgZXJyb3IgaGFzIG9jY3VycmVkJyxcbiAgICAgICAgY29kZTogJ0VSUk9SX1BBU1NUSFJPVUdIX1NFRV9DQVVTRV9QUk9QRVJUWScsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICB9KTtcbn1cbi8qKlxuICogQXR0ZW1wdCB0byBpbnR1aXQgX3doeV8gYW4gZXJyb3Igd2FzIHJhaXNlZCBhZnRlciBjYWxsaW5nIGBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KClgLlxuICogTWFwcyBicm93c2VyIGVycm9ycyB0byBzcGVjaWZpYyBXZWJBdXRobiBlcnJvciBjb2RlcyBmb3IgYmV0dGVyIGRlYnVnZ2luZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBFcnJvciBpZGVudGlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0Vycm9yfSBwYXJhbXMuZXJyb3IgLSBUaGUgZXJyb3IgdGhyb3duIGJ5IHRoZSBicm93c2VyXG4gKiBAcGFyYW0ge0NyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc30gcGFyYW1zLm9wdGlvbnMgLSBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gY3JlZGVudGlhbHMuZ2V0KClcbiAqIEByZXR1cm5zIHtXZWJBdXRobkVycm9yfSBBIFdlYkF1dGhuRXJyb3Igd2l0aCBhIHNwZWNpZmljIGVycm9yIGNvZGVcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1nZXRBc3NlcnRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBHZXQgQXNzZXJ0aW9ufVxuICovXG5mdW5jdGlvbiBpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IoeyBlcnJvciwgb3B0aW9ucywgfSkge1xuICAgIGNvbnN0IHsgcHVibGljS2V5IH0gPSBvcHRpb25zO1xuICAgIGlmICghcHVibGljS2V5KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdvcHRpb25zIHdhcyBtaXNzaW5nIHJlcXVpcmVkIHB1YmxpY0tleSBwcm9wZXJ0eScpO1xuICAgIH1cbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDE2KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQXV0aGVudGljYXRpb24gY2VyZW1vbnkgd2FzIHNlbnQgYW4gYWJvcnQgc2lnbmFsJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQ0VSRU1PTllfQUJPUlRFRCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhc3MgdGhlIGVycm9yIGRpcmVjdGx5IHRocm91Z2guIFBsYXRmb3JtcyBhcmUgb3ZlcmxvYWRpbmcgdGhpcyBlcnJvciBiZXlvbmQgd2hhdCB0aGUgc3BlY1xuICAgICAgICAgKiBkZWZpbmVzIGFuZCB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSBwb3RlbnRpYWxseSB1c2VmdWwgZXJyb3IgbWVzc2FnZXMuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9QQVNTVEhST1VHSF9TRUVfQ0FVU0VfUFJPUEVSVFknLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1NlY3VyaXR5RXJyb3InKSB7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZURvbWFpbiA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICAgICAgaWYgKCEoMCwgd2ViYXV0aG5fMS5pc1ZhbGlkRG9tYWluKShlZmZlY3RpdmVEb21haW4pKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1kaXNjb3Zlci1mcm9tLWV4dGVybmFsLXNvdXJjZSAoU3RlcCA1KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgJHt3aW5kb3cubG9jYXRpb24uaG9zdG5hbWV9IGlzIGFuIGludmFsaWQgZG9tYWluYCxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfSU5WQUxJRF9ET01BSU4nLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHB1YmxpY0tleS5ycElkICE9PSBlZmZlY3RpdmVEb21haW4pIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWRpc2NvdmVyLWZyb20tZXh0ZXJuYWwtc291cmNlIChTdGVwIDYpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBUaGUgUlAgSUQgXCIke3B1YmxpY0tleS5ycElkfVwiIGlzIGludmFsaWQgZm9yIHRoaXMgZG9tYWluYCxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfSU5WQUxJRF9SUF9JRCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1Vua25vd25FcnJvcicpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtZ2V0LWFzc2VydGlvbiAoU3RlcCAxKVxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1nZXQtYXNzZXJ0aW9uIChTdGVwIDEyKVxuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSBhdXRoZW50aWNhdG9yIHdhcyB1bmFibGUgdG8gcHJvY2VzcyB0aGUgc3BlY2lmaWVkIG9wdGlvbnMsIG9yIGNvdWxkIG5vdCBjcmVhdGUgYSBuZXcgYXNzZXJ0aW9uIHNpZ25hdHVyZScsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9HRU5FUkFMX0VSUk9SJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdhIE5vbi1XZWJhdXRobiByZWxhdGVkIGVycm9yIGhhcyBvY2N1cnJlZCcsXG4gICAgICAgIGNvZGU6ICdFUlJPUl9QQVNTVEhST1VHSF9TRUVfQ0FVU0VfUFJPUEVSVFknLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJhdXRobi5lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiV2ViQXV0aG5Vbmtub3duRXJyb3IiLCJXZWJBdXRobkVycm9yIiwiaXNXZWJBdXRobkVycm9yIiwiaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvciIsImlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvciIsIndlYmF1dGhuXzEiLCJyZXF1aXJlIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJjb2RlIiwiY2F1c2UiLCJuYW1lIiwiX2EiLCJfX2lzV2ViQXV0aG5FcnJvciIsInVuZGVmaW5lZCIsIm9yaWdpbmFsRXJyb3IiLCJlcnJvciIsIm9wdGlvbnMiLCJfYiIsIl9jIiwicHVibGljS2V5Iiwic2lnbmFsIiwiQWJvcnRTaWduYWwiLCJhdXRoZW50aWNhdG9yU2VsZWN0aW9uIiwicmVxdWlyZVJlc2lkZW50S2V5IiwibWVkaWF0aW9uIiwidXNlclZlcmlmaWNhdGlvbiIsInZhbGlkUHViS2V5Q3JlZFBhcmFtcyIsInB1YktleUNyZWRQYXJhbXMiLCJmaWx0ZXIiLCJwYXJhbSIsInR5cGUiLCJsZW5ndGgiLCJlZmZlY3RpdmVEb21haW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhvc3RuYW1lIiwiaXNWYWxpZERvbWFpbiIsInJwIiwiaWQiLCJ1c2VyIiwiYnl0ZUxlbmd0aCIsInJwSWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/webauthn.errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/webauthn.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/main/lib/webauthn.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebAuthnApi = exports.DEFAULT_REQUEST_OPTIONS = exports.DEFAULT_CREATION_OPTIONS = exports.webAuthnAbortService = exports.WebAuthnAbortService = exports.identifyAuthenticationError = exports.identifyRegistrationError = exports.isWebAuthnError = exports.WebAuthnError = void 0;\nexports.deserializeCredentialCreationOptions = deserializeCredentialCreationOptions;\nexports.deserializeCredentialRequestOptions = deserializeCredentialRequestOptions;\nexports.serializeCredentialCreationResponse = serializeCredentialCreationResponse;\nexports.serializeCredentialRequestResponse = serializeCredentialRequestResponse;\nexports.isValidDomain = isValidDomain;\nexports.createCredential = createCredential;\nexports.getCredential = getCredential;\nexports.mergeCredentialCreationOptions = mergeCredentialCreationOptions;\nexports.mergeCredentialRequestOptions = mergeCredentialRequestOptions;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst base64url_1 = __webpack_require__(/*! ./base64url */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/base64url.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/errors.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/helpers.js\");\nconst webauthn_errors_1 = __webpack_require__(/*! ./webauthn.errors */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/webauthn.errors.js\");\nObject.defineProperty(exports, \"identifyAuthenticationError\", ({\n    enumerable: true,\n    get: function() {\n        return webauthn_errors_1.identifyAuthenticationError;\n    }\n}));\nObject.defineProperty(exports, \"identifyRegistrationError\", ({\n    enumerable: true,\n    get: function() {\n        return webauthn_errors_1.identifyRegistrationError;\n    }\n}));\nObject.defineProperty(exports, \"isWebAuthnError\", ({\n    enumerable: true,\n    get: function() {\n        return webauthn_errors_1.isWebAuthnError;\n    }\n}));\nObject.defineProperty(exports, \"WebAuthnError\", ({\n    enumerable: true,\n    get: function() {\n        return webauthn_errors_1.WebAuthnError;\n    }\n}));\n/**\n * WebAuthn abort service to manage ceremony cancellation.\n * Ensures only one WebAuthn ceremony is active at a time to prevent \"operation already in progress\" errors.\n *\n * @experimental This class is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\n */ class WebAuthnAbortService {\n    /**\n     * Create an abort signal for a new WebAuthn operation.\n     * Automatically cancels any existing operation.\n     *\n     * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\n     */ createNewAbortSignal() {\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n        if (this.controller) {\n            const abortError = new Error(\"Cancelling existing WebAuthn API call for new one\");\n            abortError.name = \"AbortError\";\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    /**\n     * Manually cancel the current WebAuthn operation.\n     * Useful for cleaning up when user cancels or navigates away.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\n     */ cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error(\"Manually cancelling existing WebAuthn API call\");\n            abortError.name = \"AbortError\";\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\nexports.WebAuthnAbortService = WebAuthnAbortService;\n/**\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\n * This prevents \"operation already in progress\" errors when retrying WebAuthn operations.\n *\n * @experimental This instance is experimental and may change in future releases\n */ exports.webAuthnAbortService = new WebAuthnAbortService();\n/**\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\n */ function deserializeCredentialCreationOptions(options) {\n    if (!options) {\n        throw new Error(\"Credential creation options are required\");\n    }\n    // Check if the native parseCreationOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== \"undefined\" && \"parseCreationOptionsFromJSON\" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseCreationOptionsFromJSON(/** we assert the options here as typescript still doesn't know about future webauthn types */ options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = tslib_1.__rest(options, [\n        \"challenge\",\n        \"user\",\n        \"excludeCredentials\"\n    ]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\n    // Convert user.id from base64url to ArrayBuffer\n    const user = Object.assign(Object.assign({}, userOpts), {\n        id: (0, base64url_1.base64UrlToUint8Array)(userOpts.id).buffer\n    });\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), {\n        challenge,\n        user\n    });\n    // Only add excludeCredentials if it exists\n    if (excludeCredentials && excludeCredentials.length > 0) {\n        result.excludeCredentials = new Array(excludeCredentials.length);\n        for(let i = 0; i < excludeCredentials.length; i++){\n            const cred = excludeCredentials[i];\n            result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), {\n                id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer,\n                type: cred.type || \"public-key\",\n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports\n            });\n        }\n    }\n    return result;\n}\n/**\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\n */ function deserializeCredentialRequestOptions(options) {\n    if (!options) {\n        throw new Error(\"Credential request options are required\");\n    }\n    // Check if the native parseRequestOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== \"undefined\" && \"parseRequestOptionsFromJSON\" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseRequestOptionsFromJSON(options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, allowCredentials } = options, restOptions = tslib_1.__rest(options, [\n        \"challenge\",\n        \"allowCredentials\"\n    ]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), {\n        challenge\n    });\n    // Only add allowCredentials if it exists\n    if (allowCredentials && allowCredentials.length > 0) {\n        result.allowCredentials = new Array(allowCredentials.length);\n        for(let i = 0; i < allowCredentials.length; i++){\n            const cred = allowCredentials[i];\n            result.allowCredentials[i] = Object.assign(Object.assign({}, cred), {\n                id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer,\n                type: cred.type || \"public-key\",\n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports\n            });\n        }\n    }\n    return result;\n}\n/**\n * Convert a registration/enrollment credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */ function serializeCredentialCreationResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if (\"toJSON\" in credential && typeof credential.toJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    const credentialWithAttachment = credential;\n    return {\n        id: credential.id,\n        rawId: credential.id,\n        response: {\n            attestationObject: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)),\n            clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON))\n        },\n        type: \"public-key\",\n        clientExtensionResults: credential.getClientExtensionResults(),\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n    };\n}\n/**\n * Convert an authentication/verification credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */ function serializeCredentialRequestResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if (\"toJSON\" in credential && typeof credential.toJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    // Fallback to manual conversion for browsers that don't support toJSON\n    // Access authenticatorAttachment via type assertion to handle TypeScript version differences\n    // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\n    const credentialWithAttachment = credential;\n    const clientExtensionResults = credential.getClientExtensionResults();\n    const assertionResponse = credential.response;\n    return {\n        id: credential.id,\n        rawId: credential.id,\n        response: {\n            authenticatorData: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)),\n            clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)),\n            signature: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)),\n            userHandle: assertionResponse.userHandle ? (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle)) : undefined\n        },\n        type: \"public-key\",\n        clientExtensionResults,\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n    };\n}\n/**\n * A simple test to determine if a hostname is a properly-formatted domain name.\n * Considers localhost valid for development environments.\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n *\n * @param {string} hostname - The hostname to validate\n * @returns {boolean} True if valid domain or localhost\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\n */ function isValidDomain(hostname) {\n    return(// Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === \"localhost\" || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n/**\n * Determine if the browser is capable of WebAuthn.\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\n *\n * @returns {boolean} True if browser supports WebAuthn\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\n */ function browserSupportsWebAuthn() {\n    var _a, _b;\n    return !!((0, helpers_1.isBrowser)() && \"PublicKeyCredential\" in window && window.PublicKeyCredential && \"credentials\" in navigator && typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === \"function\" && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === \"function\");\n}\n/**\n * Create a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.create() with error handling.\n *\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\n */ async function createCredential(options) {\n    try {\n        const response = await navigator.credentials.create(/** we assert the type here until typescript types are updated */ options);\n        if (!response) {\n            return {\n                data: null,\n                error: new webauthn_errors_1.WebAuthnUnknownError(\"Empty credential response\", response)\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new webauthn_errors_1.WebAuthnUnknownError(\"Browser returned unexpected credential type\", response)\n            };\n        }\n        return {\n            data: response,\n            error: null\n        };\n    } catch (err) {\n        return {\n            data: null,\n            error: (0, webauthn_errors_1.identifyRegistrationError)({\n                error: err,\n                options\n            })\n        };\n    }\n}\n/**\n * Get a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.get() with error handling.\n *\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\n */ async function getCredential(options) {\n    try {\n        const response = await navigator.credentials.get(/** we assert the type here until typescript types are updated */ options);\n        if (!response) {\n            return {\n                data: null,\n                error: new webauthn_errors_1.WebAuthnUnknownError(\"Empty credential response\", response)\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new webauthn_errors_1.WebAuthnUnknownError(\"Browser returned unexpected credential type\", response)\n            };\n        }\n        return {\n            data: response,\n            error: null\n        };\n    } catch (err) {\n        return {\n            data: null,\n            error: (0, webauthn_errors_1.identifyAuthenticationError)({\n                error: err,\n                options\n            })\n        };\n    }\n}\nexports.DEFAULT_CREATION_OPTIONS = {\n    hints: [\n        \"security-key\"\n    ],\n    authenticatorSelection: {\n        authenticatorAttachment: \"cross-platform\",\n        requireResidentKey: false,\n        /** set to preferred because older yubikeys don't have PIN/Biometric */ userVerification: \"preferred\",\n        residentKey: \"discouraged\"\n    },\n    attestation: \"direct\"\n};\nexports.DEFAULT_REQUEST_OPTIONS = {\n    /** set to preferred because older yubikeys don't have PIN/Biometric */ userVerification: \"preferred\",\n    hints: [\n        \"security-key\"\n    ],\n    attestation: \"direct\"\n};\nfunction deepMerge(...sources) {\n    const isObject = (val)=>val !== null && typeof val === \"object\" && !Array.isArray(val);\n    const isArrayBufferLike = (val)=>val instanceof ArrayBuffer || ArrayBuffer.isView(val);\n    const result = {};\n    for (const source of sources){\n        if (!source) continue;\n        for(const key in source){\n            const value = source[key];\n            if (value === undefined) continue;\n            if (Array.isArray(value)) {\n                // preserve array reference, including unions like AuthenticatorTransport[]\n                result[key] = value;\n            } else if (isArrayBufferLike(value)) {\n                result[key] = value;\n            } else if (isObject(value)) {\n                const existing = result[key];\n                if (isObject(existing)) {\n                    result[key] = deepMerge(existing, value);\n                } else {\n                    result[key] = deepMerge(value);\n                }\n            } else {\n                result[key] = value;\n            }\n        }\n    }\n    return result;\n}\n/**\n * Merges WebAuthn credential creation options with overrides.\n * Sets sensible defaults for authenticator selection and extensions.\n *\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\n * @param {string} friendlyName - Optional friendly name for the credential\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\n */ function mergeCredentialCreationOptions(baseOptions, overrides) {\n    return deepMerge(exports.DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * Merges WebAuthn credential request options with overrides.\n * Sets sensible defaults for user verification and hints.\n *\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\n */ function mergeCredentialRequestOptions(baseOptions, overrides) {\n    return deepMerge(exports.DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * WebAuthn API wrapper for Supabase Auth.\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\n *\n * @experimental This API is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\n */ class WebAuthnApi {\n    constructor(client){\n        this.client = client;\n        // Bind all methods so they can be destructured\n        this.enroll = this._enroll.bind(this);\n        this.challenge = this._challenge.bind(this);\n        this.verify = this._verify.bind(this);\n        this.authenticate = this._authenticate.bind(this);\n        this.register = this._register.bind(this);\n    }\n    /**\n     * Enroll a new WebAuthn factor.\n     * Creates an unverified WebAuthn factor that must be verified with a credential.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\n     * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\n     */ async _enroll(params) {\n        return this.client.mfa.enroll(Object.assign(Object.assign({}, params), {\n            factorType: \"webauthn\"\n        }));\n    }\n    /**\n     * Challenge for WebAuthn credential creation or authentication.\n     * Combines server challenge with browser credential operations.\n     * Handles both registration (create) and authentication (request) flows.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\n     * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\n     * @returns {Promise<RequestResult>} Challenge response with credential or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\n     */ async _challenge({ factorId, webauthn, friendlyName, signal }, overrides) {\n        try {\n            // Get challenge from server using the client's MFA methods\n            const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({\n                factorId,\n                webauthn\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            const abortSignal = signal !== null && signal !== void 0 ? signal : exports.webAuthnAbortService.createNewAbortSignal();\n            /** webauthn will fail if either of the name/displayname are blank */ if (challengeResponse.webauthn.type === \"create\") {\n                const { user } = challengeResponse.webauthn.credential_options.publicKey;\n                if (!user.name) {\n                    user.name = `${user.id}:${friendlyName}`;\n                }\n                if (!user.displayName) {\n                    user.displayName = user.name;\n                }\n            }\n            switch(challengeResponse.webauthn.type){\n                case \"create\":\n                    {\n                        const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\n                        const { data, error } = await createCredential({\n                            publicKey: options,\n                            signal: abortSignal\n                        });\n                        if (data) {\n                            return {\n                                data: {\n                                    factorId,\n                                    challengeId: challengeResponse.id,\n                                    webauthn: {\n                                        type: challengeResponse.webauthn.type,\n                                        credential_response: data\n                                    }\n                                },\n                                error: null\n                            };\n                        }\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                case \"request\":\n                    {\n                        const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\n                        const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), {\n                            publicKey: options,\n                            signal: abortSignal\n                        }));\n                        if (data) {\n                            return {\n                                data: {\n                                    factorId,\n                                    challengeId: challengeResponse.id,\n                                    webauthn: {\n                                        type: challengeResponse.webauthn.type,\n                                        credential_response: data\n                                    }\n                                },\n                                error: null\n                            };\n                        }\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n            }\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new errors_1.AuthUnknownError(\"Unexpected error in challenge\", error)\n            };\n        }\n    }\n    /**\n     * Verify a WebAuthn credential with the server.\n     * Completes the WebAuthn ceremony by sending the credential to the server for verification.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Verification parameters\n     * @param {string} params.challengeId - ID of the challenge being verified\n     * @param {string} params.factorId - ID of the WebAuthn factor\n     * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\n     * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\n     * */ async _verify({ challengeId, factorId, webauthn }) {\n        return this.client.mfa.verify({\n            factorId,\n            challengeId,\n            webauthn: webauthn\n        });\n    }\n    /**\n     * Complete WebAuthn authentication flow.\n     * Performs challenge and verification in a single operation for existing credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Authentication parameters\n     * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\n     * @param {Object} params.webauthn - WebAuthn configuration\n     * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.webauthn.signal - Optional abort signal\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\n     */ async _authenticate({ factorId, webauthn: { rpId =  false ? 0 : undefined, rpOrigins =  false ? 0 : undefined, signal } = {} }, overrides) {\n        if (!rpId) {\n            return {\n                data: null,\n                error: new errors_1.AuthError(\"rpId is required for WebAuthn authentication\")\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new errors_1.AuthUnknownError(\"Browser does not support WebAuthn\", null)\n                };\n            }\n            // Get challenge and credential\n            const { data: challengeResponse, error: challengeError } = await this.challenge({\n                factorId,\n                webauthn: {\n                    rpId,\n                    rpOrigins\n                },\n                signal\n            }, {\n                request: overrides\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            const { webauthn } = challengeResponse;\n            // Verify credential\n            return this._verify({\n                factorId,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    type: webauthn.type,\n                    rpId,\n                    rpOrigins,\n                    credential_response: webauthn.credential_response\n                }\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new errors_1.AuthUnknownError(\"Unexpected error in authenticate\", error)\n            };\n        }\n    }\n    /**\n     * Complete WebAuthn registration flow.\n     * Performs enrollment, challenge, and verification in a single operation for new credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Registration parameters\n     * @param {string} params.friendlyName - User-friendly name for the credential\n     * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.signal - Optional abort signal\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\n     */ async _register({ friendlyName, webauthn: { rpId =  false ? 0 : undefined, rpOrigins =  false ? 0 : undefined, signal } = {} }, overrides) {\n        if (!rpId) {\n            return {\n                data: null,\n                error: new errors_1.AuthError(\"rpId is required for WebAuthn registration\")\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new errors_1.AuthUnknownError(\"Browser does not support WebAuthn\", null)\n                };\n            }\n            // Enroll factor\n            const { data: factor, error: enrollError } = await this._enroll({\n                friendlyName\n            });\n            if (!factor) {\n                await this.client.mfa.listFactors().then((factors)=>{\n                    var _a;\n                    return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find((v)=>v.factor_type === \"webauthn\" && v.friendly_name === friendlyName && v.status !== \"unverified\");\n                }).then((factor)=>factor ? this.client.mfa.unenroll({\n                        factorId: factor === null || factor === void 0 ? void 0 : factor.id\n                    }) : void 0);\n                return {\n                    data: null,\n                    error: enrollError\n                };\n            }\n            // Get challenge and create credential\n            const { data: challengeResponse, error: challengeError } = await this._challenge({\n                factorId: factor.id,\n                friendlyName: factor.friendly_name,\n                webauthn: {\n                    rpId,\n                    rpOrigins\n                },\n                signal\n            }, {\n                create: overrides\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            return this._verify({\n                factorId: factor.id,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    rpId,\n                    rpOrigins,\n                    type: challengeResponse.webauthn.type,\n                    credential_response: challengeResponse.webauthn.credential_response\n                }\n            });\n        } catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new errors_1.AuthUnknownError(\"Unexpected error in register\", error)\n            };\n        }\n    }\n}\nexports.WebAuthnApi = WebAuthnApi; //# sourceMappingURL=webauthn.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tYWluL2xpYi93ZWJhdXRobi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLCtCQUErQixHQUFHQSxnQ0FBZ0MsR0FBR0EsNEJBQTRCLEdBQUdBLDRCQUE0QixHQUFHQSxtQ0FBbUMsR0FBR0EsaUNBQWlDLEdBQUdBLHVCQUF1QixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQzFSQSw0Q0FBNEMsR0FBR1c7QUFDL0NYLDJDQUEyQyxHQUFHWTtBQUM5Q1osMkNBQTJDLEdBQUdhO0FBQzlDYiwwQ0FBMEMsR0FBR2M7QUFDN0NkLHFCQUFxQixHQUFHZTtBQUN4QmYsd0JBQXdCLEdBQUdnQjtBQUMzQmhCLHFCQUFxQixHQUFHaUI7QUFDeEJqQixzQ0FBc0MsR0FBR2tCO0FBQ3pDbEIscUNBQXFDLEdBQUdtQjtBQUN4QyxNQUFNQyxVQUFVQyxtQkFBT0EsQ0FBQyx1REFBTztBQUMvQixNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyxzRkFBYTtBQUN6QyxNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQyxnRkFBVTtBQUNuQyxNQUFNRyxZQUFZSCxtQkFBT0EsQ0FBQyxrRkFBVztBQUNyQyxNQUFNSSxvQkFBb0JKLG1CQUFPQSxDQUFDLGtHQUFtQjtBQUNyRHZCLCtEQUE4RDtJQUFFNEIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0Ysa0JBQWtCbEIsMkJBQTJCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDL0pULDZEQUE0RDtJQUFFNEIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0Ysa0JBQWtCakIseUJBQXlCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDM0pWLG1EQUFrRDtJQUFFNEIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0Ysa0JBQWtCaEIsZUFBZTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3ZJWCxp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WUFDQSxzQ0FBc0M7WUFDdEMsTUFBTSxFQUFFMUQsTUFBTXlDLGlCQUFpQixFQUFFeEMsT0FBT3lDLGNBQWMsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDZCxVQUFVLENBQUM7Z0JBQzdFVSxVQUFVbUIsT0FBTzdGLEVBQUU7Z0JBQ25CNEUsY0FBY2lCLE9BQU9TLGFBQWE7Z0JBQ2xDM0IsVUFBVTtvQkFBRWE7b0JBQU1FO2dCQUFVO2dCQUM1QjFHO1lBQ0osR0FBRztnQkFDQ21ELFFBQVF1QjtZQUNaO1lBQ0EsSUFBSSxDQUFDbUIsbUJBQW1CO2dCQUNwQixPQUFPO29CQUFFekMsTUFBTTtvQkFBTUMsT0FBT3lDO2dCQUFlO1lBQy9DO1lBQ0EsT0FBTyxJQUFJLENBQUNaLE9BQU8sQ0FBQztnQkFDaEJRLFVBQVVtQixPQUFPN0YsRUFBRTtnQkFDbkJtRixhQUFhTixrQkFBa0JNLFdBQVc7Z0JBQzFDUixVQUFVO29CQUNOYTtvQkFDQUU7b0JBQ0FwRixNQUFNdUUsa0JBQWtCRixRQUFRLENBQUNyRSxJQUFJO29CQUNyQzhFLHFCQUFxQlAsa0JBQWtCRixRQUFRLENBQUNTLG1CQUFtQjtnQkFDdkU7WUFDSjtRQUNKLEVBQ0EsT0FBTy9DLE9BQU87WUFDVixJQUFJLENBQUMsR0FBR2xFLFNBQVNtSCxXQUFXLEVBQUVqRCxRQUFRO2dCQUNsQyxPQUFPO29CQUFFRCxNQUFNO29CQUFNQztnQkFBTTtZQUMvQjtZQUNBLE9BQU87Z0JBQ0hELE1BQU07Z0JBQ05DLE9BQU8sSUFBSWxFLFNBQVNvSCxnQkFBZ0IsQ0FBQyxnQ0FBZ0NsRDtZQUN6RTtRQUNKO0lBQ0o7QUFDSjtBQUNBekYsbUJBQW1CLEdBQUdFLGFBQ3RCLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21haW4vbGliL3dlYmF1dGhuLmpzP2UyMTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYkF1dGhuQXBpID0gZXhwb3J0cy5ERUZBVUxUX1JFUVVFU1RfT1BUSU9OUyA9IGV4cG9ydHMuREVGQVVMVF9DUkVBVElPTl9PUFRJT05TID0gZXhwb3J0cy53ZWJBdXRobkFib3J0U2VydmljZSA9IGV4cG9ydHMuV2ViQXV0aG5BYm9ydFNlcnZpY2UgPSBleHBvcnRzLmlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvciA9IGV4cG9ydHMuaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvciA9IGV4cG9ydHMuaXNXZWJBdXRobkVycm9yID0gZXhwb3J0cy5XZWJBdXRobkVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5kZXNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMgPSBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnM7XG5leHBvcnRzLmRlc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zID0gZGVzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnM7XG5leHBvcnRzLnNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvblJlc3BvbnNlID0gc2VyaWFsaXplQ3JlZGVudGlhbENyZWF0aW9uUmVzcG9uc2U7XG5leHBvcnRzLnNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0UmVzcG9uc2UgPSBzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdFJlc3BvbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRG9tYWluID0gaXNWYWxpZERvbWFpbjtcbmV4cG9ydHMuY3JlYXRlQ3JlZGVudGlhbCA9IGNyZWF0ZUNyZWRlbnRpYWw7XG5leHBvcnRzLmdldENyZWRlbnRpYWwgPSBnZXRDcmVkZW50aWFsO1xuZXhwb3J0cy5tZXJnZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMgPSBtZXJnZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnM7XG5leHBvcnRzLm1lcmdlQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zID0gbWVyZ2VDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnM7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuY29uc3QgYmFzZTY0dXJsXzEgPSByZXF1aXJlKFwiLi9iYXNlNjR1cmxcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG5jb25zdCB3ZWJhdXRobl9lcnJvcnNfMSA9IHJlcXVpcmUoXCIuL3dlYmF1dGhuLmVycm9yc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2ViYXV0aG5fZXJyb3JzXzEuaWRlbnRpZnlBdXRoZW50aWNhdGlvbkVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2ViYXV0aG5fZXJyb3JzXzEuaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzV2ViQXV0aG5FcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2ViYXV0aG5fZXJyb3JzXzEuaXNXZWJBdXRobkVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2ViQXV0aG5FcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2ViYXV0aG5fZXJyb3JzXzEuV2ViQXV0aG5FcnJvcjsgfSB9KTtcbi8qKlxuICogV2ViQXV0aG4gYWJvcnQgc2VydmljZSB0byBtYW5hZ2UgY2VyZW1vbnkgY2FuY2VsbGF0aW9uLlxuICogRW5zdXJlcyBvbmx5IG9uZSBXZWJBdXRobiBjZXJlbW9ueSBpcyBhY3RpdmUgYXQgYSB0aW1lIHRvIHByZXZlbnQgXCJvcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzc1wiIGVycm9ycy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgY2xhc3MgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWF1dG9tYXRpb24td2ViZHJpdmVyLWNhcGFiaWxpdHkgVzNDIFdlYkF1dGhuIFNwZWMgLSBBYm9ydGluZyBDZXJlbW9uaWVzfVxuICovXG5jbGFzcyBXZWJBdXRobkFib3J0U2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGFib3J0IHNpZ25hbCBmb3IgYSBuZXcgV2ViQXV0aG4gb3BlcmF0aW9uLlxuICAgICAqIEF1dG9tYXRpY2FsbHkgY2FuY2VscyBhbnkgZXhpc3Rpbmcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Fib3J0U2lnbmFsfSBTaWduYWwgdG8gcGFzcyB0byBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKCkgb3IgLmdldCgpXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0U2lnbmFsIE1ETiAtIEFib3J0U2lnbmFsfVxuICAgICAqL1xuICAgIGNyZWF0ZU5ld0Fib3J0U2lnbmFsKCkge1xuICAgICAgICAvLyBBYm9ydCBhbnkgZXhpc3RpbmcgY2FsbHMgdG8gbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpIG9yIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKVxuICAgICAgICBpZiAodGhpcy5jb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBhYm9ydEVycm9yID0gbmV3IEVycm9yKCdDYW5jZWxsaW5nIGV4aXN0aW5nIFdlYkF1dGhuIEFQSSBjYWxsIGZvciBuZXcgb25lJyk7XG4gICAgICAgICAgICBhYm9ydEVycm9yLm5hbWUgPSAnQWJvcnRFcnJvcic7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoYWJvcnRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gbmV3Q29udHJvbGxlcjtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRyb2xsZXIuc2lnbmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYW51YWxseSBjYW5jZWwgdGhlIGN1cnJlbnQgV2ViQXV0aG4gb3BlcmF0aW9uLlxuICAgICAqIFVzZWZ1bCBmb3IgY2xlYW5pbmcgdXAgd2hlbiB1c2VyIGNhbmNlbHMgb3IgbmF2aWdhdGVzIGF3YXkuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQWJvcnRDb250cm9sbGVyL2Fib3J0IE1ETiAtIEFib3J0Q29udHJvbGxlci5hYm9ydH1cbiAgICAgKi9cbiAgICBjYW5jZWxDZXJlbW9ueSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3QgYWJvcnRFcnJvciA9IG5ldyBFcnJvcignTWFudWFsbHkgY2FuY2VsbGluZyBleGlzdGluZyBXZWJBdXRobiBBUEkgY2FsbCcpO1xuICAgICAgICAgICAgYWJvcnRFcnJvci5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KGFib3J0RXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5XZWJBdXRobkFib3J0U2VydmljZSA9IFdlYkF1dGhuQWJvcnRTZXJ2aWNlO1xuLyoqXG4gKiBTaW5nbGV0b24gaW5zdGFuY2UgdG8gZW5zdXJlIG9ubHkgb25lIFdlYkF1dGhuIGNlcmVtb255IGlzIGFjdGl2ZSBhdCBhIHRpbWUuXG4gKiBUaGlzIHByZXZlbnRzIFwib3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiBlcnJvcnMgd2hlbiByZXRyeWluZyBXZWJBdXRobiBvcGVyYXRpb25zLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBpbnN0YW5jZSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gKi9cbmV4cG9ydHMud2ViQXV0aG5BYm9ydFNlcnZpY2UgPSBuZXcgV2ViQXV0aG5BYm9ydFNlcnZpY2UoKTtcbi8qKlxuICogQ29udmVydCBiYXNlNjR1cmwgZW5jb2RlZCBzdHJpbmdzIGluIFdlYkF1dGhuIGNyZWRlbnRpYWwgY3JlYXRpb24gb3B0aW9ucyB0byBBcnJheUJ1ZmZlcnNcbiAqIGFzIHJlcXVpcmVkIGJ5IHRoZSBXZWJBdXRobiBicm93c2VyIEFQSS5cbiAqIFN1cHBvcnRzIGJvdGggbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgcGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTiBhbmQgbWFudWFsIGZhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7U2VydmVyQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc30gb3B0aW9ucyAtIEpTT04gb3B0aW9ucyBmcm9tIHNlcnZlciB3aXRoIGJhc2U2NHVybCBlbmNvZGVkIGZpZWxkc1xuICogQHJldHVybnMge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IE9wdGlvbnMgcmVhZHkgZm9yIG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoKVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXBhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT04gVzNDIFdlYkF1dGhuIFNwZWMgLSBwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OfVxuICovXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NyZWRlbnRpYWwgY3JlYXRpb24gb3B0aW9ucyBhcmUgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIG5hdGl2ZSBwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OIG1ldGhvZCBpcyBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIFB1YmxpY0tleUNyZWRlbnRpYWwgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICdwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OJyBpbiBQdWJsaWNLZXlDcmVkZW50aWFsICYmXG4gICAgICAgIHR5cGVvZiBQdWJsaWNLZXlDcmVkZW50aWFsXG4gICAgICAgICAgICAucGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBVc2UgdGhlIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIG1ldGhvZFxuICAgICAgICByZXR1cm4gUHVibGljS2V5Q3JlZGVudGlhbC5wYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OKFxuICAgICAgICAvKiogd2UgYXNzZXJ0IHRoZSBvcHRpb25zIGhlcmUgYXMgdHlwZXNjcmlwdCBzdGlsbCBkb2Vzbid0IGtub3cgYWJvdXQgZnV0dXJlIHdlYmF1dGhuIHR5cGVzICovXG4gICAgICAgIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBtYW51YWwgcGFyc2luZyBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBuYXRpdmUgbWV0aG9kXG4gICAgLy8gRGVzdHJ1Y3R1cmUgdG8gc2VwYXJhdGUgZmllbGRzIHRoYXQgbmVlZCB0cmFuc2Zvcm1hdGlvblxuICAgIGNvbnN0IHsgY2hhbGxlbmdlOiBjaGFsbGVuZ2VTdHIsIHVzZXI6IHVzZXJPcHRzLCBleGNsdWRlQ3JlZGVudGlhbHMgfSA9IG9wdGlvbnMsIHJlc3RPcHRpb25zID0gdHNsaWJfMS5fX3Jlc3Qob3B0aW9uc1xuICAgIC8vIENvbnZlcnQgY2hhbGxlbmdlIGZyb20gYmFzZTY0dXJsIHRvIEFycmF5QnVmZmVyXG4gICAgLCBbXCJjaGFsbGVuZ2VcIiwgXCJ1c2VyXCIsIFwiZXhjbHVkZUNyZWRlbnRpYWxzXCJdKTtcbiAgICAvLyBDb252ZXJ0IGNoYWxsZW5nZSBmcm9tIGJhc2U2NHVybCB0byBBcnJheUJ1ZmZlclxuICAgIGNvbnN0IGNoYWxsZW5nZSA9ICgwLCBiYXNlNjR1cmxfMS5iYXNlNjRVcmxUb1VpbnQ4QXJyYXkpKGNoYWxsZW5nZVN0cikuYnVmZmVyO1xuICAgIC8vIENvbnZlcnQgdXNlci5pZCBmcm9tIGJhc2U2NHVybCB0byBBcnJheUJ1ZmZlclxuICAgIGNvbnN0IHVzZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHVzZXJPcHRzKSwgeyBpZDogKDAsIGJhc2U2NHVybF8xLmJhc2U2NFVybFRvVWludDhBcnJheSkodXNlck9wdHMuaWQpLmJ1ZmZlciB9KTtcbiAgICAvLyBCdWlsZCB0aGUgcmVzdWx0IG9iamVjdFxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdE9wdGlvbnMpLCB7IGNoYWxsZW5nZSxcbiAgICAgICAgdXNlciB9KTtcbiAgICAvLyBPbmx5IGFkZCBleGNsdWRlQ3JlZGVudGlhbHMgaWYgaXQgZXhpc3RzXG4gICAgaWYgKGV4Y2x1ZGVDcmVkZW50aWFscyAmJiBleGNsdWRlQ3JlZGVudGlhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQuZXhjbHVkZUNyZWRlbnRpYWxzID0gbmV3IEFycmF5KGV4Y2x1ZGVDcmVkZW50aWFscy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4Y2x1ZGVDcmVkZW50aWFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3JlZCA9IGV4Y2x1ZGVDcmVkZW50aWFsc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5leGNsdWRlQ3JlZGVudGlhbHNbaV0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNyZWQpLCB7IGlkOiAoMCwgYmFzZTY0dXJsXzEuYmFzZTY0VXJsVG9VaW50OEFycmF5KShjcmVkLmlkKS5idWZmZXIsIHR5cGU6IGNyZWQudHlwZSB8fCAncHVibGljLWtleScsIFxuICAgICAgICAgICAgICAgIC8vIENhc3QgdHJhbnNwb3J0cyB0byBoYW5kbGUgZnV0dXJlIHRyYW5zcG9ydCB0eXBlcyBsaWtlIFwiY2FibGVcIlxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydHM6IGNyZWQudHJhbnNwb3J0cyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb252ZXJ0IGJhc2U2NHVybCBlbmNvZGVkIHN0cmluZ3MgaW4gV2ViQXV0aG4gY3JlZGVudGlhbCByZXF1ZXN0IG9wdGlvbnMgdG8gQXJyYXlCdWZmZXJzXG4gKiBhcyByZXF1aXJlZCBieSB0aGUgV2ViQXV0aG4gYnJvd3NlciBBUEkuXG4gKiBTdXBwb3J0cyBib3RoIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIHBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTiBhbmQgbWFudWFsIGZhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7U2VydmVyQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zfSBvcHRpb25zIC0gSlNPTiBvcHRpb25zIGZyb20gc2VydmVyIHdpdGggYmFzZTY0dXJsIGVuY29kZWQgZmllbGRzXG4gKiBAcmV0dXJucyB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBPcHRpb25zIHJlYWR5IGZvciBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KClcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1wYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04gVzNDIFdlYkF1dGhuIFNwZWMgLSBwYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT059XG4gKi9cbmZ1bmN0aW9uIGRlc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDcmVkZW50aWFsIHJlcXVlc3Qgb3B0aW9ucyBhcmUgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIG5hdGl2ZSBwYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04gbWV0aG9kIGlzIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2YgUHVibGljS2V5Q3JlZGVudGlhbCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgJ3BhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTicgaW4gUHVibGljS2V5Q3JlZGVudGlhbCAmJlxuICAgICAgICB0eXBlb2YgUHVibGljS2V5Q3JlZGVudGlhbFxuICAgICAgICAgICAgLnBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBVc2UgdGhlIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIG1ldGhvZFxuICAgICAgICByZXR1cm4gUHVibGljS2V5Q3JlZGVudGlhbC5wYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04ob3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG1hbnVhbCBwYXJzaW5nIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIG5hdGl2ZSBtZXRob2RcbiAgICAvLyBEZXN0cnVjdHVyZSB0byBzZXBhcmF0ZSBmaWVsZHMgdGhhdCBuZWVkIHRyYW5zZm9ybWF0aW9uXG4gICAgY29uc3QgeyBjaGFsbGVuZ2U6IGNoYWxsZW5nZVN0ciwgYWxsb3dDcmVkZW50aWFscyB9ID0gb3B0aW9ucywgcmVzdE9wdGlvbnMgPSB0c2xpYl8xLl9fcmVzdChvcHRpb25zXG4gICAgLy8gQ29udmVydCBjaGFsbGVuZ2UgZnJvbSBiYXNlNjR1cmwgdG8gQXJyYXlCdWZmZXJcbiAgICAsIFtcImNoYWxsZW5nZVwiLCBcImFsbG93Q3JlZGVudGlhbHNcIl0pO1xuICAgIC8vIENvbnZlcnQgY2hhbGxlbmdlIGZyb20gYmFzZTY0dXJsIHRvIEFycmF5QnVmZmVyXG4gICAgY29uc3QgY2hhbGxlbmdlID0gKDAsIGJhc2U2NHVybF8xLmJhc2U2NFVybFRvVWludDhBcnJheSkoY2hhbGxlbmdlU3RyKS5idWZmZXI7XG4gICAgLy8gQnVpbGQgdGhlIHJlc3VsdCBvYmplY3RcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3RPcHRpb25zKSwgeyBjaGFsbGVuZ2UgfSk7XG4gICAgLy8gT25seSBhZGQgYWxsb3dDcmVkZW50aWFscyBpZiBpdCBleGlzdHNcbiAgICBpZiAoYWxsb3dDcmVkZW50aWFscyAmJiBhbGxvd0NyZWRlbnRpYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0LmFsbG93Q3JlZGVudGlhbHMgPSBuZXcgQXJyYXkoYWxsb3dDcmVkZW50aWFscy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbG93Q3JlZGVudGlhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWQgPSBhbGxvd0NyZWRlbnRpYWxzW2ldO1xuICAgICAgICAgICAgcmVzdWx0LmFsbG93Q3JlZGVudGlhbHNbaV0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNyZWQpLCB7IGlkOiAoMCwgYmFzZTY0dXJsXzEuYmFzZTY0VXJsVG9VaW50OEFycmF5KShjcmVkLmlkKS5idWZmZXIsIHR5cGU6IGNyZWQudHlwZSB8fCAncHVibGljLWtleScsIFxuICAgICAgICAgICAgICAgIC8vIENhc3QgdHJhbnNwb3J0cyB0byBoYW5kbGUgZnV0dXJlIHRyYW5zcG9ydCB0eXBlcyBsaWtlIFwiY2FibGVcIlxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydHM6IGNyZWQudHJhbnNwb3J0cyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgcmVnaXN0cmF0aW9uL2Vucm9sbG1lbnQgY3JlZGVudGlhbCByZXNwb25zZSB0byBzZXJ2ZXIgZm9ybWF0LlxuICogU2VyaWFsaXplcyBiaW5hcnkgZmllbGRzIHRvIGJhc2U2NHVybCBmb3IgSlNPTiB0cmFuc21pc3Npb24uXG4gKiBTdXBwb3J0cyBib3RoIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIHRvSlNPTiBhbmQgbWFudWFsIGZhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7UmVnaXN0cmF0aW9uQ3JlZGVudGlhbH0gY3JlZGVudGlhbCAtIENyZWRlbnRpYWwgZnJvbSBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKClcbiAqIEByZXR1cm5zIHtSZWdpc3RyYXRpb25SZXNwb25zZUpTT059IEpTT04tc2VyaWFsaXphYmxlIGNyZWRlbnRpYWwgZm9yIHNlcnZlclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNkb20tcHVibGlja2V5Y3JlZGVudGlhbC10b2pzb24gVzNDIFdlYkF1dGhuIFNwZWMgLSB0b0pTT059XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvblJlc3BvbnNlKGNyZWRlbnRpYWwpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNyZWRlbnRpYWwgaW5zdGFuY2UgaGFzIHRoZSB0b0pTT04gbWV0aG9kXG4gICAgaWYgKCd0b0pTT04nIGluIGNyZWRlbnRpYWwgJiYgdHlwZW9mIGNyZWRlbnRpYWwudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgbWV0aG9kXG4gICAgICAgIHJldHVybiBjcmVkZW50aWFsLnRvSlNPTigpO1xuICAgIH1cbiAgICBjb25zdCBjcmVkZW50aWFsV2l0aEF0dGFjaG1lbnQgPSBjcmVkZW50aWFsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBjcmVkZW50aWFsLmlkLFxuICAgICAgICByYXdJZDogY3JlZGVudGlhbC5pZCxcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgIGF0dGVzdGF0aW9uT2JqZWN0OiAoMCwgYmFzZTY0dXJsXzEuYnl0ZXNUb0Jhc2U2NFVSTCkobmV3IFVpbnQ4QXJyYXkoY3JlZGVudGlhbC5yZXNwb25zZS5hdHRlc3RhdGlvbk9iamVjdCkpLFxuICAgICAgICAgICAgY2xpZW50RGF0YUpTT046ICgwLCBiYXNlNjR1cmxfMS5ieXRlc1RvQmFzZTY0VVJMKShuZXcgVWludDhBcnJheShjcmVkZW50aWFsLnJlc3BvbnNlLmNsaWVudERhdGFKU09OKSksXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6ICdwdWJsaWMta2V5JyxcbiAgICAgICAgY2xpZW50RXh0ZW5zaW9uUmVzdWx0czogY3JlZGVudGlhbC5nZXRDbGllbnRFeHRlbnNpb25SZXN1bHRzKCksXG4gICAgICAgIC8vIENvbnZlcnQgbnVsbCB0byB1bmRlZmluZWQgYW5kIGNhc3QgdG8gQXV0aGVudGljYXRvckF0dGFjaG1lbnQgdHlwZVxuICAgICAgICBhdXRoZW50aWNhdG9yQXR0YWNobWVudDogKChfYSA9IGNyZWRlbnRpYWxXaXRoQXR0YWNobWVudC5hdXRoZW50aWNhdG9yQXR0YWNobWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IGFuIGF1dGhlbnRpY2F0aW9uL3ZlcmlmaWNhdGlvbiBjcmVkZW50aWFsIHJlc3BvbnNlIHRvIHNlcnZlciBmb3JtYXQuXG4gKiBTZXJpYWxpemVzIGJpbmFyeSBmaWVsZHMgdG8gYmFzZTY0dXJsIGZvciBKU09OIHRyYW5zbWlzc2lvbi5cbiAqIFN1cHBvcnRzIGJvdGggbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgdG9KU09OIGFuZCBtYW51YWwgZmFsbGJhY2suXG4gKlxuICogQHBhcmFtIHtBdXRoZW50aWNhdGlvbkNyZWRlbnRpYWx9IGNyZWRlbnRpYWwgLSBDcmVkZW50aWFsIGZyb20gbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldCgpXG4gKiBAcmV0dXJucyB7QXV0aGVudGljYXRpb25SZXNwb25zZUpTT059IEpTT04tc2VyaWFsaXphYmxlIGNyZWRlbnRpYWwgZm9yIHNlcnZlclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNkb20tcHVibGlja2V5Y3JlZGVudGlhbC10b2pzb24gVzNDIFdlYkF1dGhuIFNwZWMgLSB0b0pTT059XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0UmVzcG9uc2UoY3JlZGVudGlhbCkge1xuICAgIHZhciBfYTtcbiAgICAvLyBDaGVjayBpZiB0aGUgY3JlZGVudGlhbCBpbnN0YW5jZSBoYXMgdGhlIHRvSlNPTiBtZXRob2RcbiAgICBpZiAoJ3RvSlNPTicgaW4gY3JlZGVudGlhbCAmJiB0eXBlb2YgY3JlZGVudGlhbC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyBtZXRob2RcbiAgICAgICAgcmV0dXJuIGNyZWRlbnRpYWwudG9KU09OKCk7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG1hbnVhbCBjb252ZXJzaW9uIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdG9KU09OXG4gICAgLy8gQWNjZXNzIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50IHZpYSB0eXBlIGFzc2VydGlvbiB0byBoYW5kbGUgVHlwZVNjcmlwdCB2ZXJzaW9uIGRpZmZlcmVuY2VzXG4gICAgLy8gQHNpbXBsZXdlYmF1dGhuL3R5cGVzIGluY2x1ZGVzIHRoaXMgcHJvcGVydHkgYnV0IGJhc2UgVHlwZVNjcmlwdCA0LjcuNCBkb2Vzbid0XG4gICAgY29uc3QgY3JlZGVudGlhbFdpdGhBdHRhY2htZW50ID0gY3JlZGVudGlhbDtcbiAgICBjb25zdCBjbGllbnRFeHRlbnNpb25SZXN1bHRzID0gY3JlZGVudGlhbC5nZXRDbGllbnRFeHRlbnNpb25SZXN1bHRzKCk7XG4gICAgY29uc3QgYXNzZXJ0aW9uUmVzcG9uc2UgPSBjcmVkZW50aWFsLnJlc3BvbnNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBjcmVkZW50aWFsLmlkLFxuICAgICAgICByYXdJZDogY3JlZGVudGlhbC5pZCwgLy8gVzNDIHNwZWMgZXhwZWN0cyByYXdJZCB0byBtYXRjaCBpZCBmb3IgSlNPTiBmb3JtYXRcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0b3JEYXRhOiAoMCwgYmFzZTY0dXJsXzEuYnl0ZXNUb0Jhc2U2NFVSTCkobmV3IFVpbnQ4QXJyYXkoYXNzZXJ0aW9uUmVzcG9uc2UuYXV0aGVudGljYXRvckRhdGEpKSxcbiAgICAgICAgICAgIGNsaWVudERhdGFKU09OOiAoMCwgYmFzZTY0dXJsXzEuYnl0ZXNUb0Jhc2U2NFVSTCkobmV3IFVpbnQ4QXJyYXkoYXNzZXJ0aW9uUmVzcG9uc2UuY2xpZW50RGF0YUpTT04pKSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogKDAsIGJhc2U2NHVybF8xLmJ5dGVzVG9CYXNlNjRVUkwpKG5ldyBVaW50OEFycmF5KGFzc2VydGlvblJlc3BvbnNlLnNpZ25hdHVyZSkpLFxuICAgICAgICAgICAgdXNlckhhbmRsZTogYXNzZXJ0aW9uUmVzcG9uc2UudXNlckhhbmRsZVxuICAgICAgICAgICAgICAgID8gKDAsIGJhc2U2NHVybF8xLmJ5dGVzVG9CYXNlNjRVUkwpKG5ldyBVaW50OEFycmF5KGFzc2VydGlvblJlc3BvbnNlLnVzZXJIYW5kbGUpKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiAncHVibGljLWtleScsXG4gICAgICAgIGNsaWVudEV4dGVuc2lvblJlc3VsdHMsXG4gICAgICAgIC8vIENvbnZlcnQgbnVsbCB0byB1bmRlZmluZWQgYW5kIGNhc3QgdG8gQXV0aGVudGljYXRvckF0dGFjaG1lbnQgdHlwZVxuICAgICAgICBhdXRoZW50aWNhdG9yQXR0YWNobWVudDogKChfYSA9IGNyZWRlbnRpYWxXaXRoQXR0YWNobWVudC5hdXRoZW50aWNhdG9yQXR0YWNobWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkKSxcbiAgICB9O1xufVxuLyoqXG4gKiBBIHNpbXBsZSB0ZXN0IHRvIGRldGVybWluZSBpZiBhIGhvc3RuYW1lIGlzIGEgcHJvcGVybHktZm9ybWF0dGVkIGRvbWFpbiBuYW1lLlxuICogQ29uc2lkZXJzIGxvY2FsaG9zdCB2YWxpZCBmb3IgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICpcbiAqIEEgXCJ2YWxpZCBkb21haW5cIiBpcyBkZWZpbmVkIGhlcmU6IGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdmFsaWQtZG9tYWluXG4gKlxuICogUmVnZXggc291cmNlZCBmcm9tIGhlcmU6XG4gKiBodHRwczovL3d3dy5vcmVpbGx5LmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgxNDQ5MzI3NDUzL2NoMDhzMTUuaHRtbFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBob3N0bmFtZSAtIFRoZSBob3N0bmFtZSB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsaWQgZG9tYWluIG9yIGxvY2FsaG9zdFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN2YWxpZC1kb21haW4gV0hBVFdHIFVSTCBTcGVjIC0gVmFsaWQgRG9tYWlufVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRG9tYWluKGhvc3RuYW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAvLyBDb25zaWRlciBsb2NhbGhvc3QgdmFsaWQgYXMgd2VsbCBzaW5jZSBpdCdzIG9rYXkgd3J0IFNlY3VyZSBDb250ZXh0c1xuICAgIGhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fCAvXihbYS16MC05XSsoLVthLXowLTldKykqXFwuKStbYS16XXsyLH0kL2kudGVzdChob3N0bmFtZSkpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGJyb3dzZXIgaXMgY2FwYWJsZSBvZiBXZWJBdXRobi5cbiAqIENoZWNrcyBmb3IgbmVjZXNzYXJ5IFdlYiBBUElzOiBQdWJsaWNLZXlDcmVkZW50aWFsIGFuZCBDcmVkZW50aWFsIE1hbmFnZW1lbnQuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYnJvd3NlciBzdXBwb3J0cyBXZWJBdXRoblxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1B1YmxpY0tleUNyZWRlbnRpYWwjYnJvd3Nlcl9jb21wYXRpYmlsaXR5IE1ETiAtIFB1YmxpY0tleUNyZWRlbnRpYWwgQnJvd3NlciBDb21wYXRpYmlsaXR5fVxuICovXG5mdW5jdGlvbiBicm93c2VyU3VwcG9ydHNXZWJBdXRobigpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAhISgoMCwgaGVscGVyc18xLmlzQnJvd3NlcikoKSAmJlxuICAgICAgICAnUHVibGljS2V5Q3JlZGVudGlhbCcgaW4gd2luZG93ICYmXG4gICAgICAgIHdpbmRvdy5QdWJsaWNLZXlDcmVkZW50aWFsICYmXG4gICAgICAgICdjcmVkZW50aWFscycgaW4gbmF2aWdhdG9yICYmXG4gICAgICAgIHR5cGVvZiAoKF9hID0gbmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmNyZWRlbnRpYWxzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3JlYXRlKSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgKChfYiA9IG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5jcmVkZW50aWFscykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldCkgPT09ICdmdW5jdGlvbicpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBXZWJBdXRobiBjcmVkZW50aWFsIHVzaW5nIHRoZSBicm93c2VyJ3MgY3JlZGVudGlhbHMgQVBJLlxuICogV3JhcHMgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpIHdpdGggZXJyb3IgaGFuZGxpbmcuXG4gKlxuICogQHBhcmFtIHtDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zfSBvcHRpb25zIC0gT3B0aW9ucyBpbmNsdWRpbmcgcHVibGljS2V5IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVlc3RSZXN1bHQ8UmVnaXN0cmF0aW9uQ3JlZGVudGlhbCwgV2ViQXV0aG5FcnJvcj4+fSBDcmVhdGVkIGNyZWRlbnRpYWwgb3IgZXJyb3JcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIFczQyBXZWJBdXRobiBTcGVjIC0gQ3JlYXRlIENyZWRlbnRpYWx9XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3JlZGVudGlhbHNDb250YWluZXIvY3JlYXRlIE1ETiAtIGNyZWRlbnRpYWxzLmNyZWF0ZX1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ3JlZGVudGlhbChvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKFxuICAgICAgICAvKiogd2UgYXNzZXJ0IHRoZSB0eXBlIGhlcmUgdW50aWwgdHlwZXNjcmlwdCB0eXBlcyBhcmUgdXBkYXRlZCAqL1xuICAgICAgICBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgd2ViYXV0aG5fZXJyb3JzXzEuV2ViQXV0aG5Vbmtub3duRXJyb3IoJ0VtcHR5IGNyZWRlbnRpYWwgcmVzcG9uc2UnLCByZXNwb25zZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUHVibGljS2V5Q3JlZGVudGlhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IHdlYmF1dGhuX2Vycm9yc18xLldlYkF1dGhuVW5rbm93bkVycm9yKCdCcm93c2VyIHJldHVybmVkIHVuZXhwZWN0ZWQgY3JlZGVudGlhbCB0eXBlJywgcmVzcG9uc2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhOiByZXNwb25zZSwgZXJyb3I6IG51bGwgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiAoMCwgd2ViYXV0aG5fZXJyb3JzXzEuaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvcikoe1xuICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogR2V0IGEgV2ViQXV0aG4gY3JlZGVudGlhbCB1c2luZyB0aGUgYnJvd3NlcidzIGNyZWRlbnRpYWxzIEFQSS5cbiAqIFdyYXBzIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKSB3aXRoIGVycm9yIGhhbmRsaW5nLlxuICpcbiAqIEBwYXJhbSB7Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zfSBvcHRpb25zIC0gT3B0aW9ucyBpbmNsdWRpbmcgcHVibGljS2V5IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVlc3RSZXN1bHQ8QXV0aGVudGljYXRpb25DcmVkZW50aWFsLCBXZWJBdXRobkVycm9yPj59IFJldHJpZXZlZCBjcmVkZW50aWFsIG9yIGVycm9yXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tZ2V0QXNzZXJ0aW9uIFczQyBXZWJBdXRobiBTcGVjIC0gR2V0IEFzc2VydGlvbn1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DcmVkZW50aWFsc0NvbnRhaW5lci9nZXQgTUROIC0gY3JlZGVudGlhbHMuZ2V0fVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRDcmVkZW50aWFsKG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoXG4gICAgICAgIC8qKiB3ZSBhc3NlcnQgdGhlIHR5cGUgaGVyZSB1bnRpbCB0eXBlc2NyaXB0IHR5cGVzIGFyZSB1cGRhdGVkICovXG4gICAgICAgIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyB3ZWJhdXRobl9lcnJvcnNfMS5XZWJBdXRoblVua25vd25FcnJvcignRW1wdHkgY3JlZGVudGlhbCByZXNwb25zZScsIHJlc3BvbnNlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBQdWJsaWNLZXlDcmVkZW50aWFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgd2ViYXV0aG5fZXJyb3JzXzEuV2ViQXV0aG5Vbmtub3duRXJyb3IoJ0Jyb3dzZXIgcmV0dXJuZWQgdW5leHBlY3RlZCBjcmVkZW50aWFsIHR5cGUnLCByZXNwb25zZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHJlc3BvbnNlLCBlcnJvcjogbnVsbCB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgZXJyb3I6ICgwLCB3ZWJhdXRobl9lcnJvcnNfMS5pZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IpKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkRFRkFVTFRfQ1JFQVRJT05fT1BUSU9OUyA9IHtcbiAgICBoaW50czogWydzZWN1cml0eS1rZXknXSxcbiAgICBhdXRoZW50aWNhdG9yU2VsZWN0aW9uOiB7XG4gICAgICAgIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50OiAnY3Jvc3MtcGxhdGZvcm0nLFxuICAgICAgICByZXF1aXJlUmVzaWRlbnRLZXk6IGZhbHNlLFxuICAgICAgICAvKiogc2V0IHRvIHByZWZlcnJlZCBiZWNhdXNlIG9sZGVyIHl1YmlrZXlzIGRvbid0IGhhdmUgUElOL0Jpb21ldHJpYyAqL1xuICAgICAgICB1c2VyVmVyaWZpY2F0aW9uOiAncHJlZmVycmVkJyxcbiAgICAgICAgcmVzaWRlbnRLZXk6ICdkaXNjb3VyYWdlZCcsXG4gICAgfSxcbiAgICBhdHRlc3RhdGlvbjogJ2RpcmVjdCcsXG59O1xuZXhwb3J0cy5ERUZBVUxUX1JFUVVFU1RfT1BUSU9OUyA9IHtcbiAgICAvKiogc2V0IHRvIHByZWZlcnJlZCBiZWNhdXNlIG9sZGVyIHl1YmlrZXlzIGRvbid0IGhhdmUgUElOL0Jpb21ldHJpYyAqL1xuICAgIHVzZXJWZXJpZmljYXRpb246ICdwcmVmZXJyZWQnLFxuICAgIGhpbnRzOiBbJ3NlY3VyaXR5LWtleSddLFxuICAgIGF0dGVzdGF0aW9uOiAnZGlyZWN0Jyxcbn07XG5mdW5jdGlvbiBkZWVwTWVyZ2UoLi4uc291cmNlcykge1xuICAgIGNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCk7XG4gICAgY29uc3QgaXNBcnJheUJ1ZmZlckxpa2UgPSAodmFsKSA9PiB2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgIGlmICghc291cmNlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJlc2VydmUgYXJyYXkgcmVmZXJlbmNlLCBpbmNsdWRpbmcgdW5pb25zIGxpa2UgQXV0aGVudGljYXRvclRyYW5zcG9ydFtdXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlCdWZmZXJMaWtlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChleGlzdGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWVwTWVyZ2UoZXhpc3RpbmcsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZGVlcE1lcmdlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIE1lcmdlcyBXZWJBdXRobiBjcmVkZW50aWFsIGNyZWF0aW9uIG9wdGlvbnMgd2l0aCBvdmVycmlkZXMuXG4gKiBTZXRzIHNlbnNpYmxlIGRlZmF1bHRzIGZvciBhdXRoZW50aWNhdG9yIHNlbGVjdGlvbiBhbmQgZXh0ZW5zaW9ucy5cbiAqXG4gKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IGJhc2VPcHRpb25zIC0gVGhlIGJhc2Ugb3B0aW9ucyBmcm9tIHRoZSBzZXJ2ZXJcbiAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gb3ZlcnJpZGVzIC0gT3B0aW9uYWwgb3ZlcnJpZGVzIHRvIGFwcGx5XG4gKiBAcGFyYW0ge3N0cmluZ30gZnJpZW5kbHlOYW1lIC0gT3B0aW9uYWwgZnJpZW5kbHkgbmFtZSBmb3IgdGhlIGNyZWRlbnRpYWxcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlfSBNZXJnZWQgY3JlZGVudGlhbCBjcmVhdGlvbiBvcHRpb25zXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI2RpY3RkZWYtYXV0aGVudGljYXRvcnNlbGVjdGlvbmNyaXRlcmlhIFczQyBXZWJBdXRobiBTcGVjIC0gQXV0aGVudGljYXRvclNlbGVjdGlvbkNyaXRlcmlhfVxuICovXG5mdW5jdGlvbiBtZXJnZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMoYmFzZU9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBkZWVwTWVyZ2UoZXhwb3J0cy5ERUZBVUxUX0NSRUFUSU9OX09QVElPTlMsIGJhc2VPcHRpb25zLCBvdmVycmlkZXMgfHwge30pO1xufVxuLyoqXG4gKiBNZXJnZXMgV2ViQXV0aG4gY3JlZGVudGlhbCByZXF1ZXN0IG9wdGlvbnMgd2l0aCBvdmVycmlkZXMuXG4gKiBTZXRzIHNlbnNpYmxlIGRlZmF1bHRzIGZvciB1c2VyIHZlcmlmaWNhdGlvbiBhbmQgaGludHMuXG4gKlxuICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IGJhc2VPcHRpb25zIC0gVGhlIGJhc2Ugb3B0aW9ucyBmcm9tIHRoZSBzZXJ2ZXJcbiAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBvdmVycmlkZXMgLSBPcHRpb25hbCBvdmVycmlkZXMgdG8gYXBwbHlcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IE1lcmdlZCBjcmVkZW50aWFsIHJlcXVlc3Qgb3B0aW9uc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNkaWN0ZGVmLXB1YmxpY2tleWNyZWRlbnRpYWxyZXF1ZXN0b3B0aW9ucyBXM0MgV2ViQXV0aG4gU3BlYyAtIFB1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc31cbiAqL1xuZnVuY3Rpb24gbWVyZ2VDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMoYmFzZU9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBkZWVwTWVyZ2UoZXhwb3J0cy5ERUZBVUxUX1JFUVVFU1RfT1BUSU9OUywgYmFzZU9wdGlvbnMsIG92ZXJyaWRlcyB8fCB7fSk7XG59XG4vKipcbiAqIFdlYkF1dGhuIEFQSSB3cmFwcGVyIGZvciBTdXBhYmFzZSBBdXRoLlxuICogUHJvdmlkZXMgbWV0aG9kcyBmb3IgZW5yb2xsaW5nLCBjaGFsbGVuZ2luZywgdmVyaWZ5aW5nLCBhdXRoZW50aWNhdGluZywgYW5kIHJlZ2lzdGVyaW5nIFdlYkF1dGhuIGNyZWRlbnRpYWxzLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyBXM0MgV2ViQXV0aG4gU3BlY2lmaWNhdGlvbn1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfQXV0aGVudGljYXRpb25fQVBJIE1ETiAtIFdlYiBBdXRoZW50aWNhdGlvbiBBUEl9XG4gKi9cbmNsYXNzIFdlYkF1dGhuQXBpIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIC8vIEJpbmQgYWxsIG1ldGhvZHMgc28gdGhleSBjYW4gYmUgZGVzdHJ1Y3R1cmVkXG4gICAgICAgIHRoaXMuZW5yb2xsID0gdGhpcy5fZW5yb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2hhbGxlbmdlID0gdGhpcy5fY2hhbGxlbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudmVyaWZ5ID0gdGhpcy5fdmVyaWZ5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRlID0gdGhpcy5fYXV0aGVudGljYXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIgPSB0aGlzLl9yZWdpc3Rlci5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnJvbGwgYSBuZXcgV2ViQXV0aG4gZmFjdG9yLlxuICAgICAqIENyZWF0ZXMgYW4gdW52ZXJpZmllZCBXZWJBdXRobiBmYWN0b3IgdGhhdCBtdXN0IGJlIHZlcmlmaWVkIHdpdGggYSBjcmVkZW50aWFsLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldGhvZCBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gICAgICogQHBhcmFtIHtPbWl0PE1GQUVucm9sbFdlYmF1dGhuUGFyYW1zLCAnZmFjdG9yVHlwZSc+fSBwYXJhbXMgLSBFbnJvbGxtZW50IHBhcmFtZXRlcnMgKGZyaWVuZGx5TmFtZSByZXF1aXJlZClcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBdXRoTUZBRW5yb2xsV2ViYXV0aG5SZXNwb25zZT59IEVucm9sbGVkIGZhY3RvciBkZXRhaWxzIG9yIGVycm9yXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXJlZ2lzdGVyaW5nLWEtbmV3LWNyZWRlbnRpYWwgVzNDIFdlYkF1dGhuIFNwZWMgLSBSZWdpc3RlcmluZyBhIE5ldyBDcmVkZW50aWFsfVxuICAgICAqL1xuICAgIGFzeW5jIF9lbnJvbGwocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5tZmEuZW5yb2xsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgeyBmYWN0b3JUeXBlOiAnd2ViYXV0aG4nIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbGxlbmdlIGZvciBXZWJBdXRobiBjcmVkZW50aWFsIGNyZWF0aW9uIG9yIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqIENvbWJpbmVzIHNlcnZlciBjaGFsbGVuZ2Ugd2l0aCBicm93c2VyIGNyZWRlbnRpYWwgb3BlcmF0aW9ucy5cbiAgICAgKiBIYW5kbGVzIGJvdGggcmVnaXN0cmF0aW9uIChjcmVhdGUpIGFuZCBhdXRoZW50aWNhdGlvbiAocmVxdWVzdCkgZmxvd3MuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICAgKiBAcGFyYW0ge01GQUNoYWxsZW5nZVdlYmF1dGhuUGFyYW1zICYgeyBmcmllbmRseU5hbWU/OiBzdHJpbmc7IHNpZ25hbD86IEFib3J0U2lnbmFsIH19IHBhcmFtcyAtIENoYWxsZW5nZSBwYXJhbWV0ZXJzIGluY2x1ZGluZyBmYWN0b3JJZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgLSBBbGxvd3MgeW91IHRvIG92ZXJyaWRlIHRoZSBwYXJhbWV0ZXJzIHBhc3NlZCB0byBuYXZpZ2F0b3IuY3JlZGVudGlhbHNcbiAgICAgKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IG92ZXJyaWRlcy5jcmVhdGUgLSBPdmVycmlkZSBvcHRpb25zIGZvciBjcmVkZW50aWFsIGNyZWF0aW9uXG4gICAgICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IG92ZXJyaWRlcy5yZXF1ZXN0IC0gT3ZlcnJpZGUgb3B0aW9ucyBmb3IgY3JlZGVudGlhbCByZXF1ZXN0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVxdWVzdFJlc3VsdD59IENoYWxsZW5nZSByZXNwb25zZSB3aXRoIGNyZWRlbnRpYWwgb3IgZXJyb3JcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tY3JlZGVudGlhbC1jcmVhdGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIENyZWRlbnRpYWwgQ3JlYXRpb259XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXZlcmlmeWluZy1hc3NlcnRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBWZXJpZnlpbmcgQXNzZXJ0aW9ufVxuICAgICAqL1xuICAgIGFzeW5jIF9jaGFsbGVuZ2UoeyBmYWN0b3JJZCwgd2ViYXV0aG4sIGZyaWVuZGx5TmFtZSwgc2lnbmFsLCB9LCBvdmVycmlkZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCBjaGFsbGVuZ2UgZnJvbSBzZXJ2ZXIgdXNpbmcgdGhlIGNsaWVudCdzIE1GQSBtZXRob2RzXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZVJlc3BvbnNlLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50Lm1mYS5jaGFsbGVuZ2Uoe1xuICAgICAgICAgICAgICAgIGZhY3RvcklkLFxuICAgICAgICAgICAgICAgIHdlYmF1dGhuLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWNoYWxsZW5nZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhYm9ydFNpZ25hbCA9IHNpZ25hbCAhPT0gbnVsbCAmJiBzaWduYWwgIT09IHZvaWQgMCA/IHNpZ25hbCA6IGV4cG9ydHMud2ViQXV0aG5BYm9ydFNlcnZpY2UuY3JlYXRlTmV3QWJvcnRTaWduYWwoKTtcbiAgICAgICAgICAgIC8qKiB3ZWJhdXRobiB3aWxsIGZhaWwgaWYgZWl0aGVyIG9mIHRoZSBuYW1lL2Rpc3BsYXluYW1lIGFyZSBibGFuayAqL1xuICAgICAgICAgICAgaWYgKGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLnR5cGUgPT09ICdjcmVhdGUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1c2VyIH0gPSBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMucHVibGljS2V5O1xuICAgICAgICAgICAgICAgIGlmICghdXNlci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXIubmFtZSA9IGAke3VzZXIuaWR9OiR7ZnJpZW5kbHlOYW1lfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdXNlci5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB1c2VyLmRpc3BsYXlOYW1lID0gdXNlci5uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NyZWF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyhjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMucHVibGljS2V5LCBvdmVycmlkZXMgPT09IG51bGwgfHwgb3ZlcnJpZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdmVycmlkZXMuY3JlYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgY3JlYXRlQ3JlZGVudGlhbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZVJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJhdXRobjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxfcmVzcG9uc2U6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAncmVxdWVzdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zKGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucy5wdWJsaWNLZXksIG92ZXJyaWRlcyA9PT0gbnVsbCB8fCBvdmVycmlkZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG92ZXJyaWRlcy5yZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgZ2V0Q3JlZGVudGlhbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucyksIHsgcHVibGljS2V5OiBvcHRpb25zLCBzaWduYWw6IGFib3J0U2lnbmFsIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZVJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJhdXRobjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxfcmVzcG9uc2U6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgZXJyb3JzXzEuQXV0aFVua25vd25FcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiBjaGFsbGVuZ2UnLCBlcnJvciksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmeSBhIFdlYkF1dGhuIGNyZWRlbnRpYWwgd2l0aCB0aGUgc2VydmVyLlxuICAgICAqIENvbXBsZXRlcyB0aGUgV2ViQXV0aG4gY2VyZW1vbnkgYnkgc2VuZGluZyB0aGUgY3JlZGVudGlhbCB0byB0aGUgc2VydmVyIGZvciB2ZXJpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVmVyaWZpY2F0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYWxsZW5nZUlkIC0gSUQgb2YgdGhlIGNoYWxsZW5nZSBiZWluZyB2ZXJpZmllZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZmFjdG9ySWQgLSBJRCBvZiB0aGUgV2ViQXV0aG4gZmFjdG9yXG4gICAgICogQHBhcmFtIHtNRkFWZXJpZnlXZWJhdXRoblBhcmFtczxUPlsnd2ViYXV0aG4nXX0gcGFyYW1zLndlYmF1dGhuIC0gV2ViQXV0aG4gY3JlZGVudGlhbCByZXNwb25zZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEF1dGhNRkFWZXJpZnlSZXNwb25zZT59IFZlcmlmaWNhdGlvbiByZXN1bHQgd2l0aCBzZXNzaW9uIG9yIGVycm9yXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXZlcmlmeWluZy1hc3NlcnRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBWZXJpZnlpbmcgYW4gQXV0aGVudGljYXRpb24gQXNzZXJ0aW9ufVxuICAgICAqICovXG4gICAgYXN5bmMgX3ZlcmlmeSh7IGNoYWxsZW5nZUlkLCBmYWN0b3JJZCwgd2ViYXV0aG4sIH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50Lm1mYS52ZXJpZnkoe1xuICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICBjaGFsbGVuZ2VJZCxcbiAgICAgICAgICAgIHdlYmF1dGhuOiB3ZWJhdXRobixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIFdlYkF1dGhuIGF1dGhlbnRpY2F0aW9uIGZsb3cuXG4gICAgICogUGVyZm9ybXMgY2hhbGxlbmdlIGFuZCB2ZXJpZmljYXRpb24gaW4gYSBzaW5nbGUgb3BlcmF0aW9uIGZvciBleGlzdGluZyBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2QgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBBdXRoZW50aWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mYWN0b3JJZCAtIElEIG9mIHRoZSBXZWJBdXRobiBmYWN0b3IgdG8gYXV0aGVudGljYXRlIHdpdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLndlYmF1dGhuIC0gV2ViQXV0aG4gY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMud2ViYXV0aG4ucnBJZCAtIFJlbHlpbmcgUGFydHkgSUQgKGRlZmF1bHRzIHRvIGN1cnJlbnQgaG9zdG5hbWUpXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLndlYmF1dGhuLnJwT3JpZ2lucyAtIEFsbG93ZWQgb3JpZ2lucyAoZGVmYXVsdHMgdG8gY3VycmVudCBvcmlnaW4pXG4gICAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gcGFyYW1zLndlYmF1dGhuLnNpZ25hbCAtIE9wdGlvbmFsIGFib3J0IHNpZ25hbFxuICAgICAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBvdmVycmlkZXMgLSBPdmVycmlkZSBvcHRpb25zIGZvciBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVxdWVzdFJlc3VsdDxBdXRoTUZBVmVyaWZ5UmVzcG9uc2VEYXRhLCBXZWJBdXRobkVycm9yIHwgQXV0aEVycm9yPj59IEF1dGhlbnRpY2F0aW9uIHJlc3VsdFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1hdXRoZW50aWNhdGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIEF1dGhlbnRpY2F0aW9uIENlcmVtb255fVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMgTUROIC0gUHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zfVxuICAgICAqL1xuICAgIGFzeW5jIF9hdXRoZW50aWNhdGUoeyBmYWN0b3JJZCwgd2ViYXV0aG46IHsgcnBJZCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lIDogdW5kZWZpbmVkLCBycE9yaWdpbnMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFt3aW5kb3cubG9jYXRpb24ub3JpZ2luXSA6IHVuZGVmaW5lZCwgc2lnbmFsLCB9ID0ge30sIH0sIG92ZXJyaWRlcykge1xuICAgICAgICBpZiAoIXJwSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IGVycm9yc18xLkF1dGhFcnJvcigncnBJZCBpcyByZXF1aXJlZCBmb3IgV2ViQXV0aG4gYXV0aGVudGljYXRpb24nKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgZXJyb3JzXzEuQXV0aFVua25vd25FcnJvcignQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkF1dGhuJywgbnVsbCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBjaGFsbGVuZ2UgYW5kIGNyZWRlbnRpYWxcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogY2hhbGxlbmdlUmVzcG9uc2UsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9ID0gYXdhaXQgdGhpcy5jaGFsbGVuZ2Uoe1xuICAgICAgICAgICAgICAgIGZhY3RvcklkLFxuICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7IHJwSWQsIHJwT3JpZ2lucyB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgIH0sIHsgcmVxdWVzdDogb3ZlcnJpZGVzIH0pO1xuICAgICAgICAgICAgaWYgKCFjaGFsbGVuZ2VSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB3ZWJhdXRobiB9ID0gY2hhbGxlbmdlUmVzcG9uc2U7XG4gICAgICAgICAgICAvLyBWZXJpZnkgY3JlZGVudGlhbFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZVJlc3BvbnNlLmNoYWxsZW5nZUlkLFxuICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHdlYmF1dGhuLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJwSWQsXG4gICAgICAgICAgICAgICAgICAgIHJwT3JpZ2lucyxcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbF9yZXNwb25zZTogd2ViYXV0aG4uY3JlZGVudGlhbF9yZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGVycm9yc18xLmlzQXV0aEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgZXJyb3JzXzEuQXV0aFVua25vd25FcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiBhdXRoZW50aWNhdGUnLCBlcnJvciksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIFdlYkF1dGhuIHJlZ2lzdHJhdGlvbiBmbG93LlxuICAgICAqIFBlcmZvcm1zIGVucm9sbG1lbnQsIGNoYWxsZW5nZSwgYW5kIHZlcmlmaWNhdGlvbiBpbiBhIHNpbmdsZSBvcGVyYXRpb24gZm9yIG5ldyBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2QgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBSZWdpc3RyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZnJpZW5kbHlOYW1lIC0gVXNlci1mcmllbmRseSBuYW1lIGZvciB0aGUgY3JlZGVudGlhbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucnBJZCAtIFJlbHlpbmcgUGFydHkgSUQgKGRlZmF1bHRzIHRvIGN1cnJlbnQgaG9zdG5hbWUpXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLnJwT3JpZ2lucyAtIEFsbG93ZWQgb3JpZ2lucyAoZGVmYXVsdHMgdG8gY3VycmVudCBvcmlnaW4pXG4gICAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gcGFyYW1zLnNpZ25hbCAtIE9wdGlvbmFsIGFib3J0IHNpZ25hbFxuICAgICAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gb3ZlcnJpZGVzIC0gT3ZlcnJpZGUgb3B0aW9ucyBmb3IgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVlc3RSZXN1bHQ8QXV0aE1GQVZlcmlmeVJlc3BvbnNlRGF0YSwgV2ViQXV0aG5FcnJvciB8IEF1dGhFcnJvcj4+fSBSZWdpc3RyYXRpb24gcmVzdWx0XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXJlZ2lzdGVyaW5nLWEtbmV3LWNyZWRlbnRpYWwgVzNDIFdlYkF1dGhuIFNwZWMgLSBSZWdpc3RyYXRpb24gQ2VyZW1vbnl9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMgTUROIC0gUHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc31cbiAgICAgKi9cbiAgICBhc3luYyBfcmVnaXN0ZXIoeyBmcmllbmRseU5hbWUsIHdlYmF1dGhuOiB7IHJwSWQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA6IHVuZGVmaW5lZCwgcnBPcmlnaW5zID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBbd2luZG93LmxvY2F0aW9uLm9yaWdpbl0gOiB1bmRlZmluZWQsIHNpZ25hbCwgfSA9IHt9LCB9LCBvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKCFycElkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBlcnJvcnNfMS5BdXRoRXJyb3IoJ3JwSWQgaXMgcmVxdWlyZWQgZm9yIFdlYkF1dGhuIHJlZ2lzdHJhdGlvbicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFicm93c2VyU3VwcG9ydHNXZWJBdXRobigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBlcnJvcnNfMS5BdXRoVW5rbm93bkVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViQXV0aG4nLCBudWxsKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRW5yb2xsIGZhY3RvclxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBmYWN0b3IsIGVycm9yOiBlbnJvbGxFcnJvciB9ID0gYXdhaXQgdGhpcy5fZW5yb2xsKHtcbiAgICAgICAgICAgICAgICBmcmllbmRseU5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghZmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQubWZhXG4gICAgICAgICAgICAgICAgICAgIC5saXN0RmFjdG9ycygpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChmYWN0b3JzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IGZhY3RvcnMuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFsbC5maW5kKCh2KSA9PiB2LmZhY3Rvcl90eXBlID09PSAnd2ViYXV0aG4nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2LmZyaWVuZGx5X25hbWUgPT09IGZyaWVuZGx5TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdi5zdGF0dXMgIT09ICd1bnZlcmlmaWVkJyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGZhY3RvcikgPT4gKGZhY3RvciA/IHRoaXMuY2xpZW50Lm1mYS51bmVucm9sbCh7IGZhY3RvcklkOiBmYWN0b3IgPT09IG51bGwgfHwgZmFjdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWN0b3IuaWQgfSkgOiB2b2lkIDApKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogZW5yb2xsRXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBjaGFsbGVuZ2UgYW5kIGNyZWF0ZSBjcmVkZW50aWFsXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZVJlc3BvbnNlLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NoYWxsZW5nZSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQ6IGZhY3Rvci5pZCxcbiAgICAgICAgICAgICAgICBmcmllbmRseU5hbWU6IGZhY3Rvci5mcmllbmRseV9uYW1lLFxuICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7IHJwSWQsIHJwT3JpZ2lucyB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBjcmVhdGU6IG92ZXJyaWRlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFjaGFsbGVuZ2VSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQ6IGZhY3Rvci5pZCxcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlUmVzcG9uc2UuY2hhbGxlbmdlSWQsXG4gICAgICAgICAgICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgICAgICAgICAgICAgcnBJZCxcbiAgICAgICAgICAgICAgICAgICAgcnBPcmlnaW5zLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi50eXBlLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsX3Jlc3BvbnNlOiBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX3Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgZXJyb3JzXzEuaXNBdXRoRXJyb3IpKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBlcnJvcnNfMS5BdXRoVW5rbm93bkVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGluIHJlZ2lzdGVyJywgZXJyb3IpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuV2ViQXV0aG5BcGkgPSBXZWJBdXRobkFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYmF1dGhuLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIldlYkF1dGhuQXBpIiwiREVGQVVMVF9SRVFVRVNUX09QVElPTlMiLCJERUZBVUxUX0NSRUFUSU9OX09QVElPTlMiLCJ3ZWJBdXRobkFib3J0U2VydmljZSIsIldlYkF1dGhuQWJvcnRTZXJ2aWNlIiwiaWRlbnRpZnlBdXRoZW50aWNhdGlvbkVycm9yIiwiaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvciIsImlzV2ViQXV0aG5FcnJvciIsIldlYkF1dGhuRXJyb3IiLCJkZXNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMiLCJkZXNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyIsInNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvblJlc3BvbnNlIiwic2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RSZXNwb25zZSIsImlzVmFsaWREb21haW4iLCJjcmVhdGVDcmVkZW50aWFsIiwiZ2V0Q3JlZGVudGlhbCIsIm1lcmdlQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyIsIm1lcmdlQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zIiwidHNsaWJfMSIsInJlcXVpcmUiLCJiYXNlNjR1cmxfMSIsImVycm9yc18xIiwiaGVscGVyc18xIiwid2ViYXV0aG5fZXJyb3JzXzEiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiY3JlYXRlTmV3QWJvcnRTaWduYWwiLCJjb250cm9sbGVyIiwiYWJvcnRFcnJvciIsIkVycm9yIiwibmFtZSIsImFib3J0IiwibmV3Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInNpZ25hbCIsImNhbmNlbENlcmVtb255IiwidW5kZWZpbmVkIiwib3B0aW9ucyIsIlB1YmxpY0tleUNyZWRlbnRpYWwiLCJwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OIiwiY2hhbGxlbmdlIiwiY2hhbGxlbmdlU3RyIiwidXNlciIsInVzZXJPcHRzIiwiZXhjbHVkZUNyZWRlbnRpYWxzIiwicmVzdE9wdGlvbnMiLCJfX3Jlc3QiLCJiYXNlNjRVcmxUb1VpbnQ4QXJyYXkiLCJidWZmZXIiLCJhc3NpZ24iLCJpZCIsInJlc3VsdCIsImxlbmd0aCIsIkFycmF5IiwiaSIsImNyZWQiLCJ0eXBlIiwidHJhbnNwb3J0cyIsInBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTiIsImFsbG93Q3JlZGVudGlhbHMiLCJjcmVkZW50aWFsIiwiX2EiLCJ0b0pTT04iLCJjcmVkZW50aWFsV2l0aEF0dGFjaG1lbnQiLCJyYXdJZCIsInJlc3BvbnNlIiwiYXR0ZXN0YXRpb25PYmplY3QiLCJieXRlc1RvQmFzZTY0VVJMIiwiVWludDhBcnJheSIsImNsaWVudERhdGFKU09OIiwiY2xpZW50RXh0ZW5zaW9uUmVzdWx0cyIsImdldENsaWVudEV4dGVuc2lvblJlc3VsdHMiLCJhdXRoZW50aWNhdG9yQXR0YWNobWVudCIsImFzc2VydGlvblJlc3BvbnNlIiwiYXV0aGVudGljYXRvckRhdGEiLCJzaWduYXR1cmUiLCJ1c2VySGFuZGxlIiwiaG9zdG5hbWUiLCJ0ZXN0IiwiYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4iLCJfYiIsImlzQnJvd3NlciIsIndpbmRvdyIsIm5hdmlnYXRvciIsImNyZWRlbnRpYWxzIiwiY3JlYXRlIiwiZGF0YSIsImVycm9yIiwiV2ViQXV0aG5Vbmtub3duRXJyb3IiLCJlcnIiLCJoaW50cyIsImF1dGhlbnRpY2F0b3JTZWxlY3Rpb24iLCJyZXF1aXJlUmVzaWRlbnRLZXkiLCJ1c2VyVmVyaWZpY2F0aW9uIiwicmVzaWRlbnRLZXkiLCJhdHRlc3RhdGlvbiIsImRlZXBNZXJnZSIsInNvdXJjZXMiLCJpc09iamVjdCIsInZhbCIsImlzQXJyYXkiLCJpc0FycmF5QnVmZmVyTGlrZSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3Iiwic291cmNlIiwia2V5IiwiZXhpc3RpbmciLCJiYXNlT3B0aW9ucyIsIm92ZXJyaWRlcyIsImNvbnN0cnVjdG9yIiwiY2xpZW50IiwiZW5yb2xsIiwiX2Vucm9sbCIsImJpbmQiLCJfY2hhbGxlbmdlIiwidmVyaWZ5IiwiX3ZlcmlmeSIsImF1dGhlbnRpY2F0ZSIsIl9hdXRoZW50aWNhdGUiLCJyZWdpc3RlciIsIl9yZWdpc3RlciIsInBhcmFtcyIsIm1mYSIsImZhY3RvclR5cGUiLCJmYWN0b3JJZCIsIndlYmF1dGhuIiwiZnJpZW5kbHlOYW1lIiwiY2hhbGxlbmdlUmVzcG9uc2UiLCJjaGFsbGVuZ2VFcnJvciIsImFib3J0U2lnbmFsIiwiY3JlZGVudGlhbF9vcHRpb25zIiwicHVibGljS2V5IiwiZGlzcGxheU5hbWUiLCJjaGFsbGVuZ2VJZCIsImNyZWRlbnRpYWxfcmVzcG9uc2UiLCJyZXF1ZXN0IiwiaXNBdXRoRXJyb3IiLCJBdXRoVW5rbm93bkVycm9yIiwicnBJZCIsImxvY2F0aW9uIiwicnBPcmlnaW5zIiwib3JpZ2luIiwiQXV0aEVycm9yIiwiZmFjdG9yIiwiZW5yb2xsRXJyb3IiLCJsaXN0RmFjdG9ycyIsInRoZW4iLCJmYWN0b3JzIiwiYWxsIiwiZmluZCIsInYiLCJmYWN0b3JfdHlwZSIsImZyaWVuZGx5X25hbWUiLCJzdGF0dXMiLCJ1bmVucm9sbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-js/dist/main/lib/webauthn.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/functions-js/dist/main/FunctionsClient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/main/FunctionsClient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FunctionsClient = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(rsc)/./node_modules/@supabase/functions-js/dist/main/helper.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@supabase/functions-js/dist/main/types.js\");\n/**\n * Client for invoking Supabase Edge Functions.\n */ class FunctionsClient {\n    /**\n     * Creates a new Functions client bound to an Edge Functions URL.\n     *\n     * @example\n     * ```ts\n     * import { FunctionsClient, FunctionRegion } from '@supabase/functions-js'\n     *\n     * const functions = new FunctionsClient('https://xyzcompany.supabase.co/functions/v1', {\n     *   headers: { apikey: 'public-anon-key' },\n     *   region: FunctionRegion.UsEast1,\n     * })\n     * ```\n     */ constructor(url, { headers = {}, customFetch, region = types_1.FunctionRegion.Any } = {}){\n        this.url = url;\n        this.headers = headers;\n        this.region = region;\n        this.fetch = (0, helper_1.resolveFetch)(customFetch);\n    }\n    /**\n     * Updates the authorization header\n     * @param token - the new jwt token sent in the authorisation header\n     * @example\n     * ```ts\n     * functions.setAuth(session.access_token)\n     * ```\n     */ setAuth(token) {\n        this.headers.Authorization = `Bearer ${token}`;\n    }\n    /**\n     * Invokes a function\n     * @param functionName - The name of the Function to invoke.\n     * @param options - Options for invoking the Function.\n     * @example\n     * ```ts\n     * const { data, error } = await functions.invoke('hello-world', {\n     *   body: { name: 'Ada' },\n     * })\n     * ```\n     */ invoke(functionName_1) {\n        return tslib_1.__awaiter(this, arguments, void 0, function*(functionName, options = {}) {\n            var _a;\n            let timeoutId;\n            let timeoutController;\n            try {\n                const { headers, method, body: functionArgs, signal, timeout } = options;\n                let _headers = {};\n                let { region } = options;\n                if (!region) {\n                    region = this.region;\n                }\n                // Add region as query parameter using URL API\n                const url = new URL(`${this.url}/${functionName}`);\n                if (region && region !== \"any\") {\n                    _headers[\"x-region\"] = region;\n                    url.searchParams.set(\"forceFunctionRegion\", region);\n                }\n                let body;\n                if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, \"Content-Type\") || !headers)) {\n                    if (typeof Blob !== \"undefined\" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {\n                        // will work for File as File inherits Blob\n                        // also works for ArrayBuffer as it is the same underlying structure as a Blob\n                        _headers[\"Content-Type\"] = \"application/octet-stream\";\n                        body = functionArgs;\n                    } else if (typeof functionArgs === \"string\") {\n                        // plain string\n                        _headers[\"Content-Type\"] = \"text/plain\";\n                        body = functionArgs;\n                    } else if (typeof FormData !== \"undefined\" && functionArgs instanceof FormData) {\n                        // don't set content-type headers\n                        // Request will automatically add the right boundary value\n                        body = functionArgs;\n                    } else {\n                        // default, assume this is JSON\n                        _headers[\"Content-Type\"] = \"application/json\";\n                        body = JSON.stringify(functionArgs);\n                    }\n                } else {\n                    if (functionArgs && typeof functionArgs !== \"string\" && !(typeof Blob !== \"undefined\" && functionArgs instanceof Blob) && !(functionArgs instanceof ArrayBuffer) && !(typeof FormData !== \"undefined\" && functionArgs instanceof FormData)) {\n                        body = JSON.stringify(functionArgs);\n                    } else {\n                        body = functionArgs;\n                    }\n                }\n                // Handle timeout by creating an AbortController\n                let effectiveSignal = signal;\n                if (timeout) {\n                    timeoutController = new AbortController();\n                    timeoutId = setTimeout(()=>timeoutController.abort(), timeout);\n                    // If user provided their own signal, we need to respect both\n                    if (signal) {\n                        effectiveSignal = timeoutController.signal;\n                        // If the user's signal is aborted, abort our timeout controller too\n                        signal.addEventListener(\"abort\", ()=>timeoutController.abort());\n                    } else {\n                        effectiveSignal = timeoutController.signal;\n                    }\n                }\n                const response = yield this.fetch(url.toString(), {\n                    method: method || \"POST\",\n                    // headers priority is (high to low):\n                    // 1. invoke-level headers\n                    // 2. client-level headers\n                    // 3. default Content-Type header\n                    headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n                    body,\n                    signal: effectiveSignal\n                }).catch((fetchError)=>{\n                    throw new types_1.FunctionsFetchError(fetchError);\n                });\n                const isRelayError = response.headers.get(\"x-relay-error\");\n                if (isRelayError && isRelayError === \"true\") {\n                    throw new types_1.FunctionsRelayError(response);\n                }\n                if (!response.ok) {\n                    throw new types_1.FunctionsHttpError(response);\n                }\n                let responseType = ((_a = response.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"text/plain\").split(\";\")[0].trim();\n                let data;\n                if (responseType === \"application/json\") {\n                    data = yield response.json();\n                } else if (responseType === \"application/octet-stream\" || responseType === \"application/pdf\") {\n                    data = yield response.blob();\n                } else if (responseType === \"text/event-stream\") {\n                    data = response;\n                } else if (responseType === \"multipart/form-data\") {\n                    data = yield response.formData();\n                } else {\n                    // default to text\n                    data = yield response.text();\n                }\n                return {\n                    data,\n                    error: null,\n                    response\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error,\n                    response: error instanceof types_1.FunctionsHttpError || error instanceof types_1.FunctionsRelayError ? error.context : undefined\n                };\n            } finally{\n                // Clear the timeout if it was set\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n            }\n        });\n    }\n}\nexports.FunctionsClient = FunctionsClient; //# sourceMappingURL=FunctionsClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21haW4vRnVuY3Rpb25zQ2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1QkFBdUIsR0FBRyxLQUFLO0FBQy9CLE1BQU1HLFVBQVVDLG1CQUFPQSxDQUFDLHVEQUFPO0FBQy9CLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLGlGQUFVO0FBQ25DLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLCtFQUFTO0FBQ2pDOztDQUVDLEdBQ0QsTUFBTUY7SUFDRjs7Ozs7Ozs7Ozs7O0tBWUMsR0FDREssWUFBWUMsR0FBRyxFQUFFLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUVDLFdBQVcsRUFBRUMsU0FBU0wsUUFBUU0sY0FBYyxDQUFDQyxHQUFHLEVBQUcsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUN2RixJQUFJLENBQUNMLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNFLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNHLEtBQUssR0FBRyxDQUFDLEdBQUdULFNBQVNVLFlBQVksRUFBRUw7SUFDNUM7SUFDQTs7Ozs7OztLQU9DLEdBQ0RNLFFBQVFDLEtBQUssRUFBRTtRQUNYLElBQUksQ0FBQ1IsT0FBTyxDQUFDUyxhQUFhLEdBQUcsQ0FBQyxPQUFPLEVBQUVELE1BQU0sQ0FBQztJQUNsRDtJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDREUsT0FBT0MsY0FBYyxFQUFFO1FBQ25CLE9BQU9qQixRQUFRa0IsU0FBUyxDQUFDLElBQUksRUFBRUMsV0FBVyxLQUFLLEdBQUcsVUFBV0MsWUFBWSxFQUFFQyxVQUFVLENBQUMsQ0FBQztZQUNuRixJQUFJQztZQUNKLElBQUlDO1lBQ0osSUFBSUM7WUFDSixJQUFJO2dCQUNBLE1BQU0sRUFBRWxCLE9BQU8sRUFBRW1CLE1BQU0sRUFB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Q0o7QUFDQTFCLHVCQUF1QixHQUFHRSxpQkFDMUIsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvZGlzdC9tYWluL0Z1bmN0aW9uc0NsaWVudC5qcz83YWVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GdW5jdGlvbnNDbGllbnQgPSB2b2lkIDA7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuY29uc3QgaGVscGVyXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG4vKipcbiAqIENsaWVudCBmb3IgaW52b2tpbmcgU3VwYWJhc2UgRWRnZSBGdW5jdGlvbnMuXG4gKi9cbmNsYXNzIEZ1bmN0aW9uc0NsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGdW5jdGlvbnMgY2xpZW50IGJvdW5kIHRvIGFuIEVkZ2UgRnVuY3Rpb25zIFVSTC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBGdW5jdGlvbnNDbGllbnQsIEZ1bmN0aW9uUmVnaW9uIH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcydcbiAgICAgKlxuICAgICAqIGNvbnN0IGZ1bmN0aW9ucyA9IG5ldyBGdW5jdGlvbnNDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9mdW5jdGlvbnMvdjEnLCB7XG4gICAgICogICBoZWFkZXJzOiB7IGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScgfSxcbiAgICAgKiAgIHJlZ2lvbjogRnVuY3Rpb25SZWdpb24uVXNFYXN0MSxcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgeyBoZWFkZXJzID0ge30sIGN1c3RvbUZldGNoLCByZWdpb24gPSB0eXBlc18xLkZ1bmN0aW9uUmVnaW9uLkFueSwgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLnJlZ2lvbiA9IHJlZ2lvbjtcbiAgICAgICAgdGhpcy5mZXRjaCA9ICgwLCBoZWxwZXJfMS5yZXNvbHZlRmV0Y2gpKGN1c3RvbUZldGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSB0aGUgbmV3IGp3dCB0b2tlbiBzZW50IGluIHRoZSBhdXRob3Jpc2F0aW9uIGhlYWRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBmdW5jdGlvbnMuc2V0QXV0aChzZXNzaW9uLmFjY2Vzc190b2tlbilcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXRBdXRoKHRva2VuKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBmdW5jdGlvbk5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgRnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgaW52b2tpbmcgdGhlIEZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBmdW5jdGlvbnMuaW52b2tlKCdoZWxsby13b3JsZCcsIHtcbiAgICAgKiAgIGJvZHk6IHsgbmFtZTogJ0FkYScgfSxcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGludm9rZShmdW5jdGlvbk5hbWVfMSkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKiAoZnVuY3Rpb25OYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgICAgICAgICBsZXQgdGltZW91dENvbnRyb2xsZXI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGVhZGVycywgbWV0aG9kLCBib2R5OiBmdW5jdGlvbkFyZ3MsIHNpZ25hbCwgdGltZW91dCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBsZXQgX2hlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICBsZXQgeyByZWdpb24gfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uID0gdGhpcy5yZWdpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCByZWdpb24gYXMgcXVlcnkgcGFyYW1ldGVyIHVzaW5nIFVSTCBBUElcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke3RoaXMudXJsfS8ke2Z1bmN0aW9uTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBpZiAocmVnaW9uICYmIHJlZ2lvbiAhPT0gJ2FueScpIHtcbiAgICAgICAgICAgICAgICAgICAgX2hlYWRlcnNbJ3gtcmVnaW9uJ10gPSByZWdpb247XG4gICAgICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdmb3JjZUZ1bmN0aW9uUmVnaW9uJywgcmVnaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQXJncyAmJlxuICAgICAgICAgICAgICAgICAgICAoKGhlYWRlcnMgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWFkZXJzLCAnQ29udGVudC1UeXBlJykpIHx8ICFoZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgd29yayBmb3IgRmlsZSBhcyBGaWxlIGluaGVyaXRzIEJsb2JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gd29ya3MgZm9yIEFycmF5QnVmZmVyIGFzIGl0IGlzIHRoZSBzYW1lIHVuZGVybHlpbmcgc3RydWN0dXJlIGFzIGEgQmxvYlxuICAgICAgICAgICAgICAgICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gZnVuY3Rpb25BcmdzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvbkFyZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFpbiBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICd0ZXh0L3BsYWluJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc2V0IGNvbnRlbnQtdHlwZSBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXF1ZXN0IHdpbGwgYXV0b21hdGljYWxseSBhZGQgdGhlIHJpZ2h0IGJvdW5kYXJ5IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gZnVuY3Rpb25BcmdzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCwgYXNzdW1lIHRoaXMgaXMgSlNPTlxuICAgICAgICAgICAgICAgICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KGZ1bmN0aW9uQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbkFyZ3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBmdW5jdGlvbkFyZ3MgIT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBCbG9iKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIShmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBGb3JtRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShmdW5jdGlvbkFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJncztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGltZW91dCBieSBjcmVhdGluZyBhbiBBYm9ydENvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICBsZXQgZWZmZWN0aXZlU2lnbmFsID0gc2lnbmFsO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHRpbWVvdXRDb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB1c2VyIHByb3ZpZGVkIHRoZWlyIG93biBzaWduYWwsIHdlIG5lZWQgdG8gcmVzcGVjdCBib3RoXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdGl2ZVNpZ25hbCA9IHRpbWVvdXRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyJ3Mgc2lnbmFsIGlzIGFib3J0ZWQsIGFib3J0IG91ciB0aW1lb3V0IGNvbnRyb2xsZXIgdG9vXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aW1lb3V0Q29udHJvbGxlci5hYm9ydCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdGl2ZVNpZ25hbCA9IHRpbWVvdXRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QgfHwgJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAvLyBoZWFkZXJzIHByaW9yaXR5IGlzIChoaWdoIHRvIGxvdyk6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIGludm9rZS1sZXZlbCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIGNsaWVudC1sZXZlbCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIDMuIGRlZmF1bHQgQ29udGVudC1UeXBlIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX2hlYWRlcnMpLCB0aGlzLmhlYWRlcnMpLCBoZWFkZXJzKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBlZmZlY3RpdmVTaWduYWwsXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGZldGNoRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuRnVuY3Rpb25zRmV0Y2hFcnJvcihmZXRjaEVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlbGF5RXJyb3IgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1yZWxheS1lcnJvcicpO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlbGF5RXJyb3IgJiYgaXNSZWxheUVycm9yID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuRnVuY3Rpb25zUmVsYXlFcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuRnVuY3Rpb25zSHR0cEVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlVHlwZSA9ICgoX2EgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd0ZXh0L3BsYWluJykuc3BsaXQoJzsnKVswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgfHxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vcGRmJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICd0ZXh0L2V2ZW50LXN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuZm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gdGV4dFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCwgcmVzcG9uc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogZXJyb3IgaW5zdGFuY2VvZiB0eXBlc18xLkZ1bmN0aW9uc0h0dHBFcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIHR5cGVzXzEuRnVuY3Rpb25zUmVsYXlFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBlcnJvci5jb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVvdXQgaWYgaXQgd2FzIHNldFxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkZ1bmN0aW9uc0NsaWVudCA9IEZ1bmN0aW9uc0NsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bmN0aW9uc0NsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJGdW5jdGlvbnNDbGllbnQiLCJ0c2xpYl8xIiwicmVxdWlyZSIsImhlbHBlcl8xIiwidHlwZXNfMSIsImNvbnN0cnVjdG9yIiwidXJsIiwiaGVhZGVycyIsImN1c3RvbUZldGNoIiwicmVnaW9uIiwiRnVuY3Rpb25SZWdpb24iLCJBbnkiLCJmZXRjaCIsInJlc29sdmVGZXRjaCIsInNldEF1dGgiLCJ0b2tlbiIsIkF1dGhvcml6YXRpb24iLCJpbnZva2UiLCJmdW5jdGlvbk5hbWVfMSIsIl9fYXdhaXRlciIsImFyZ3VtZW50cyIsImZ1bmN0aW9uTmFtZSIsIm9wdGlvbnMiLCJfYSIsInRpbWVvdXRJZCIsInRpbWVvdXRDb250cm9sbGVyIiwibWV0aG9kIiwiYm9keSIsImZ1bmN0aW9uQXJncyIsInNpZ25hbCIsInRpbWVvdXQiLCJfaGVhZGVycyIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInNldCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIkJsb2IiLCJBcnJheUJ1ZmZlciIsIkZvcm1EYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsImVmZmVjdGl2ZVNpZ25hbCIsIkFib3J0Q29udHJvbGxlciIsInNldFRpbWVvdXQiLCJhYm9ydCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZXNwb25zZSIsInRvU3RyaW5nIiwiYXNzaWduIiwiY2F0Y2giLCJmZXRjaEVycm9yIiwiRnVuY3Rpb25zRmV0Y2hFcnJvciIsImlzUmVsYXlFcnJvciIsImdldCIsIkZ1bmN0aW9uc1JlbGF5RXJyb3IiLCJvayIsIkZ1bmN0aW9uc0h0dHBFcnJvciIsInJlc3BvbnNlVHlwZSIsInNwbGl0IiwidHJpbSIsImRhdGEiLCJqc29uIiwiYmxvYiIsImZvcm1EYXRhIiwidGV4dCIsImVycm9yIiwiY29udGV4dCIsInVuZGVmaW5lZCIsImNsZWFyVGltZW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/functions-js/dist/main/FunctionsClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/functions-js/dist/main/helper.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/main/helper.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.resolveFetch = void 0;\nconst resolveFetch = (customFetch)=>{\n    if (customFetch) {\n        return (...args)=>customFetch(...args);\n    }\n    return (...args)=>fetch(...args);\n};\nexports.resolveFetch = resolveFetch; //# sourceMappingURL=helper.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21haW4vaGVscGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBRyxLQUFLO0FBQzVCLE1BQU1FLGVBQWUsQ0FBQ0M7SUFDbEIsSUFBSUEsYUFBYTtRQUNiLE9BQU8sQ0FBQyxHQUFHQyxPQUFTRCxlQUFlQztJQUN2QztJQUNBLE9BQU8sQ0FBQyxHQUFHQSxPQUFTQyxTQUFTRDtBQUNqQztBQUNBSixvQkFBb0IsR0FBR0UsY0FDdkIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvZGlzdC9tYWluL2hlbHBlci5qcz8xZWYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvbHZlRmV0Y2ggPSB2b2lkIDA7XG5jb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiBjdXN0b21GZXRjaCguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbn07XG5leHBvcnRzLnJlc29sdmVGZXRjaCA9IHJlc29sdmVGZXRjaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZXNvbHZlRmV0Y2giLCJjdXN0b21GZXRjaCIsImFyZ3MiLCJmZXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/functions-js/dist/main/helper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/functions-js/dist/main/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/main/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FunctionRegion = exports.FunctionsRelayError = exports.FunctionsHttpError = exports.FunctionsFetchError = exports.FunctionsError = exports.FunctionsClient = void 0;\nvar FunctionsClient_1 = __webpack_require__(/*! ./FunctionsClient */ \"(rsc)/./node_modules/@supabase/functions-js/dist/main/FunctionsClient.js\");\nObject.defineProperty(exports, \"FunctionsClient\", ({\n    enumerable: true,\n    get: function() {\n        return FunctionsClient_1.FunctionsClient;\n    }\n}));\nvar types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@supabase/functions-js/dist/main/types.js\");\nObject.defineProperty(exports, \"FunctionsError\", ({\n    enumerable: true,\n    get: function() {\n        return types_1.FunctionsError;\n    }\n}));\nObject.defineProperty(exports, \"FunctionsFetchError\", ({\n    enumerable: true,\n    get: function() {\n        return types_1.FunctionsFetchError;\n    }\n}));\nObject.defineProperty(exports, \"FunctionsHttpError\", ({\n    enumerable: true,\n    get: function() {\n        return types_1.FunctionsHttpError;\n    }\n}));\nObject.defineProperty(exports, \"FunctionsRelayError\", ({\n    enumerable: true,\n    get: function() {\n        return types_1.FunctionsRelayError;\n    }\n}));\nObject.defineProperty(exports, \"FunctionRegion\", ({\n    enumerable: true,\n    get: function() {\n        return types_1.FunctionRegion;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21haW4vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNCQUFzQixHQUFHQSwyQkFBMkIsR0FBR0EsMEJBQTBCLEdBQUdBLDJCQUEyQixHQUFHQSxzQkFBc0IsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUMxSyxJQUFJUSxvQkFBb0JDLG1CQUFPQSxDQUFDLG1HQUFtQjtBQUNuRFgsbURBQWtEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILGtCQUFrQkQsZUFBZTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3ZJLElBQUlLLFVBQVVILG1CQUFPQSxDQUFDLCtFQUFTO0FBQy9CWCxrREFBaUQ7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsUUFBUU4sY0FBYztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzNIUix1REFBc0Q7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsUUFBUVAsbUJBQW1CO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDcklQLHNEQUFxRDtJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxRQUFRUixrQkFBa0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuSU4sdURBQXNEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLFFBQVFULG1CQUFtQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3JJTCxrREFBaUQ7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsUUFBUVYsY0FBYztJQUFFO0FBQUUsQ0FBQyxFQUFDLEVBQzNILGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbWFpbi9pbmRleC5qcz9kZmE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GdW5jdGlvblJlZ2lvbiA9IGV4cG9ydHMuRnVuY3Rpb25zUmVsYXlFcnJvciA9IGV4cG9ydHMuRnVuY3Rpb25zSHR0cEVycm9yID0gZXhwb3J0cy5GdW5jdGlvbnNGZXRjaEVycm9yID0gZXhwb3J0cy5GdW5jdGlvbnNFcnJvciA9IGV4cG9ydHMuRnVuY3Rpb25zQ2xpZW50ID0gdm9pZCAwO1xudmFyIEZ1bmN0aW9uc0NsaWVudF8xID0gcmVxdWlyZShcIi4vRnVuY3Rpb25zQ2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnVuY3Rpb25zQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBGdW5jdGlvbnNDbGllbnRfMS5GdW5jdGlvbnNDbGllbnQ7IH0gfSk7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnVuY3Rpb25zRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzEuRnVuY3Rpb25zRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGdW5jdGlvbnNGZXRjaEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18xLkZ1bmN0aW9uc0ZldGNoRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGdW5jdGlvbnNIdHRwRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzEuRnVuY3Rpb25zSHR0cEVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnVuY3Rpb25zUmVsYXlFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMS5GdW5jdGlvbnNSZWxheUVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnVuY3Rpb25SZWdpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzEuRnVuY3Rpb25SZWdpb247IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJGdW5jdGlvblJlZ2lvbiIsIkZ1bmN0aW9uc1JlbGF5RXJyb3IiLCJGdW5jdGlvbnNIdHRwRXJyb3IiLCJGdW5jdGlvbnNGZXRjaEVycm9yIiwiRnVuY3Rpb25zRXJyb3IiLCJGdW5jdGlvbnNDbGllbnQiLCJGdW5jdGlvbnNDbGllbnRfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwidHlwZXNfMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/functions-js/dist/main/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/functions-js/dist/main/types.js":
/*!****************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/main/types.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FunctionRegion = exports.FunctionsHttpError = exports.FunctionsRelayError = exports.FunctionsFetchError = exports.FunctionsError = void 0;\n/**\n * Base error for Supabase Edge Function invocations.\n *\n * @example\n * ```ts\n * import { FunctionsError } from '@supabase/functions-js'\n *\n * throw new FunctionsError('Unexpected error invoking function', 'FunctionsError', {\n *   requestId: 'abc123',\n * })\n * ```\n */ class FunctionsError extends Error {\n    constructor(message, name = \"FunctionsError\", context){\n        super(message);\n        this.name = name;\n        this.context = context;\n    }\n}\nexports.FunctionsError = FunctionsError;\n/**\n * Error thrown when the network request to an Edge Function fails.\n *\n * @example\n * ```ts\n * import { FunctionsFetchError } from '@supabase/functions-js'\n *\n * throw new FunctionsFetchError({ requestId: 'abc123' })\n * ```\n */ class FunctionsFetchError extends FunctionsError {\n    constructor(context){\n        super(\"Failed to send a request to the Edge Function\", \"FunctionsFetchError\", context);\n    }\n}\nexports.FunctionsFetchError = FunctionsFetchError;\n/**\n * Error thrown when the Supabase relay cannot reach the Edge Function.\n *\n * @example\n * ```ts\n * import { FunctionsRelayError } from '@supabase/functions-js'\n *\n * throw new FunctionsRelayError({ region: 'us-east-1' })\n * ```\n */ class FunctionsRelayError extends FunctionsError {\n    constructor(context){\n        super(\"Relay Error invoking the Edge Function\", \"FunctionsRelayError\", context);\n    }\n}\nexports.FunctionsRelayError = FunctionsRelayError;\n/**\n * Error thrown when the Edge Function returns a non-2xx status code.\n *\n * @example\n * ```ts\n * import { FunctionsHttpError } from '@supabase/functions-js'\n *\n * throw new FunctionsHttpError({ status: 500 })\n * ```\n */ class FunctionsHttpError extends FunctionsError {\n    constructor(context){\n        super(\"Edge Function returned a non-2xx status code\", \"FunctionsHttpError\", context);\n    }\n}\nexports.FunctionsHttpError = FunctionsHttpError;\n// Define the enum for the 'region' property\nvar FunctionRegion;\n(function(FunctionRegion) {\n    FunctionRegion[\"Any\"] = \"any\";\n    FunctionRegion[\"ApNortheast1\"] = \"ap-northeast-1\";\n    FunctionRegion[\"ApNortheast2\"] = \"ap-northeast-2\";\n    FunctionRegion[\"ApSouth1\"] = \"ap-south-1\";\n    FunctionRegion[\"ApSoutheast1\"] = \"ap-southeast-1\";\n    FunctionRegion[\"ApSoutheast2\"] = \"ap-southeast-2\";\n    FunctionRegion[\"CaCentral1\"] = \"ca-central-1\";\n    FunctionRegion[\"EuCentral1\"] = \"eu-central-1\";\n    FunctionRegion[\"EuWest1\"] = \"eu-west-1\";\n    FunctionRegion[\"EuWest2\"] = \"eu-west-2\";\n    FunctionRegion[\"EuWest3\"] = \"eu-west-3\";\n    FunctionRegion[\"SaEast1\"] = \"sa-east-1\";\n    FunctionRegion[\"UsEast1\"] = \"us-east-1\";\n    FunctionRegion[\"UsWest1\"] = \"us-west-1\";\n    FunctionRegion[\"UsWest2\"] = \"us-west-2\";\n})(FunctionRegion || (exports.FunctionRegion = FunctionRegion = {})); //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21haW4vdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNCQUFzQixHQUFHQSwwQkFBMEIsR0FBR0EsMkJBQTJCLEdBQUdBLDJCQUEyQixHQUFHQSxzQkFBc0IsR0FBRyxLQUFLO0FBQ2hKOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsTUFBTU0sdUJBQXVCQztJQUN6QkMsWUFBWUMsT0FBTyxFQUFFQyxPQUFPLGdCQUFnQixFQUFFQyxPQUFPLENBQUU7UUFDbkQsS0FBSyxDQUFDRjtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtJQUNuQjtBQUNKO0FBQ0FYLHNCQUFzQixHQUFHTTtBQUN6Qjs7Ozs7Ozs7O0NBU0MsR0FDRCxNQUFNRCw0QkFBNEJDO0lBQzlCRSxZQUFZRyxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDLGlEQUFpRCx1QkFBdUJBO0lBQ2xGO0FBQ0o7QUFDQVgsMkJBQTJCLEdBQUdLO0FBQzlCOzs7Ozs7Ozs7Q0FTQyxHQUNELE1BQU1ELDRCQUE0QkU7SUFDOUJFLFlBQVlHLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUMsMENBQTBDLHVCQUF1QkE7SUFDM0U7QUFDSjtBQUNBWCwyQkFBMkIsR0FBR0k7QUFDOUI7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTUQsMkJBQTJCRztJQUM3QkUsWUFBWUcsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQyxnREFBZ0Qsc0JBQXNCQTtJQUNoRjtBQUNKO0FBQ0FYLDBCQUEwQixHQUFHRztBQUM3Qiw0Q0FBNEM7QUFDNUMsSUFBSUQ7QUFDSCxVQUFVQSxjQUFjO0lBQ3JCQSxjQUFjLENBQUMsTUFBTSxHQUFHO0lBQ3hCQSxjQUFjLENBQUMsZUFBZSxHQUFHO0lBQ2pDQSxjQUFjLENBQUMsZUFBZSxHQUFHO0lBQ2pDQSxjQUFjLENBQUMsV0FBVyxHQUFHO0lBQzdCQSxjQUFjLENBQUMsZUFBZSxHQUFHO0lBQ2pDQSxjQUFjLENBQUMsZUFBZSxHQUFHO0lBQ2pDQSxjQUFjLENBQUMsYUFBYSxHQUFHO0lBQy9CQSxjQUFjLENBQUMsYUFBYSxHQUFHO0lBQy9CQSxjQUFjLENBQUMsVUFBVSxHQUFHO0lBQzVCQSxjQUFjLENBQUMsVUFBVSxHQUFHO0lBQzVCQSxjQUFjLENBQUMsVUFBVSxHQUFHO0lBQzVCQSxjQUFjLENBQUMsVUFBVSxHQUFHO0lBQzVCQSxjQUFjLENBQUMsVUFBVSxHQUFHO0lBQzVCQSxjQUFjLENBQUMsVUFBVSxHQUFHO0lBQzVCQSxjQUFjLENBQUMsVUFBVSxHQUFHO0FBQ2hDLEdBQUdBLGtCQUFtQkYsQ0FBQUEsc0JBQXNCLEdBQUdFLGlCQUFpQixDQUFDLEtBQ2pFLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbWFpbi90eXBlcy5qcz9jYzg5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GdW5jdGlvblJlZ2lvbiA9IGV4cG9ydHMuRnVuY3Rpb25zSHR0cEVycm9yID0gZXhwb3J0cy5GdW5jdGlvbnNSZWxheUVycm9yID0gZXhwb3J0cy5GdW5jdGlvbnNGZXRjaEVycm9yID0gZXhwb3J0cy5GdW5jdGlvbnNFcnJvciA9IHZvaWQgMDtcbi8qKlxuICogQmFzZSBlcnJvciBmb3IgU3VwYWJhc2UgRWRnZSBGdW5jdGlvbiBpbnZvY2F0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEZ1bmN0aW9uc0Vycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcydcbiAqXG4gKiB0aHJvdyBuZXcgRnVuY3Rpb25zRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgaW52b2tpbmcgZnVuY3Rpb24nLCAnRnVuY3Rpb25zRXJyb3InLCB7XG4gKiAgIHJlcXVlc3RJZDogJ2FiYzEyMycsXG4gKiB9KVxuICogYGBgXG4gKi9cbmNsYXNzIEZ1bmN0aW9uc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG5hbWUgPSAnRnVuY3Rpb25zRXJyb3InLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbn1cbmV4cG9ydHMuRnVuY3Rpb25zRXJyb3IgPSBGdW5jdGlvbnNFcnJvcjtcbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIG5ldHdvcmsgcmVxdWVzdCB0byBhbiBFZGdlIEZ1bmN0aW9uIGZhaWxzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRnVuY3Rpb25zRmV0Y2hFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnXG4gKlxuICogdGhyb3cgbmV3IEZ1bmN0aW9uc0ZldGNoRXJyb3IoeyByZXF1ZXN0SWQ6ICdhYmMxMjMnIH0pXG4gKiBgYGBcbiAqL1xuY2xhc3MgRnVuY3Rpb25zRmV0Y2hFcnJvciBleHRlbmRzIEZ1bmN0aW9uc0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCdGYWlsZWQgdG8gc2VuZCBhIHJlcXVlc3QgdG8gdGhlIEVkZ2UgRnVuY3Rpb24nLCAnRnVuY3Rpb25zRmV0Y2hFcnJvcicsIGNvbnRleHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuRnVuY3Rpb25zRmV0Y2hFcnJvciA9IEZ1bmN0aW9uc0ZldGNoRXJyb3I7XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSBTdXBhYmFzZSByZWxheSBjYW5ub3QgcmVhY2ggdGhlIEVkZ2UgRnVuY3Rpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBGdW5jdGlvbnNSZWxheUVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcydcbiAqXG4gKiB0aHJvdyBuZXcgRnVuY3Rpb25zUmVsYXlFcnJvcih7IHJlZ2lvbjogJ3VzLWVhc3QtMScgfSlcbiAqIGBgYFxuICovXG5jbGFzcyBGdW5jdGlvbnNSZWxheUVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoJ1JlbGF5IEVycm9yIGludm9raW5nIHRoZSBFZGdlIEZ1bmN0aW9uJywgJ0Z1bmN0aW9uc1JlbGF5RXJyb3InLCBjb250ZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLkZ1bmN0aW9uc1JlbGF5RXJyb3IgPSBGdW5jdGlvbnNSZWxheUVycm9yO1xuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgRWRnZSBGdW5jdGlvbiByZXR1cm5zIGEgbm9uLTJ4eCBzdGF0dXMgY29kZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEZ1bmN0aW9uc0h0dHBFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnXG4gKlxuICogdGhyb3cgbmV3IEZ1bmN0aW9uc0h0dHBFcnJvcih7IHN0YXR1czogNTAwIH0pXG4gKiBgYGBcbiAqL1xuY2xhc3MgRnVuY3Rpb25zSHR0cEVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoJ0VkZ2UgRnVuY3Rpb24gcmV0dXJuZWQgYSBub24tMnh4IHN0YXR1cyBjb2RlJywgJ0Z1bmN0aW9uc0h0dHBFcnJvcicsIGNvbnRleHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuRnVuY3Rpb25zSHR0cEVycm9yID0gRnVuY3Rpb25zSHR0cEVycm9yO1xuLy8gRGVmaW5lIHRoZSBlbnVtIGZvciB0aGUgJ3JlZ2lvbicgcHJvcGVydHlcbnZhciBGdW5jdGlvblJlZ2lvbjtcbihmdW5jdGlvbiAoRnVuY3Rpb25SZWdpb24pIHtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFueVwiXSA9IFwiYW55XCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcE5vcnRoZWFzdDFcIl0gPSBcImFwLW5vcnRoZWFzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcE5vcnRoZWFzdDJcIl0gPSBcImFwLW5vcnRoZWFzdC0yXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcFNvdXRoMVwiXSA9IFwiYXAtc291dGgtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQXBTb3V0aGVhc3QxXCJdID0gXCJhcC1zb3V0aGVhc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQXBTb3V0aGVhc3QyXCJdID0gXCJhcC1zb3V0aGVhc3QtMlwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQ2FDZW50cmFsMVwiXSA9IFwiY2EtY2VudHJhbC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJFdUNlbnRyYWwxXCJdID0gXCJldS1jZW50cmFsLTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkV1V2VzdDFcIl0gPSBcImV1LXdlc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiRXVXZXN0MlwiXSA9IFwiZXUtd2VzdC0yXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJFdVdlc3QzXCJdID0gXCJldS13ZXN0LTNcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIlNhRWFzdDFcIl0gPSBcInNhLWVhc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiVXNFYXN0MVwiXSA9IFwidXMtZWFzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJVc1dlc3QxXCJdID0gXCJ1cy13ZXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIlVzV2VzdDJcIl0gPSBcInVzLXdlc3QtMlwiO1xufSkoRnVuY3Rpb25SZWdpb24gfHwgKGV4cG9ydHMuRnVuY3Rpb25SZWdpb24gPSBGdW5jdGlvblJlZ2lvbiA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJGdW5jdGlvblJlZ2lvbiIsIkZ1bmN0aW9uc0h0dHBFcnJvciIsIkZ1bmN0aW9uc1JlbGF5RXJyb3IiLCJGdW5jdGlvbnNGZXRjaEVycm9yIiwiRnVuY3Rpb25zRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm5hbWUiLCJjb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/functions-js/dist/main/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/realtime-js/dist/main/RealtimeChannel.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/main/RealtimeChannel.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.REALTIME_CHANNEL_STATES = exports.REALTIME_SUBSCRIBE_STATES = exports.REALTIME_LISTEN_TYPES = exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst constants_1 = __webpack_require__(/*! ./lib/constants */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/constants.js\");\nconst push_1 = tslib_1.__importDefault(__webpack_require__(/*! ./lib/push */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/push.js\"));\nconst timer_1 = tslib_1.__importDefault(__webpack_require__(/*! ./lib/timer */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/timer.js\"));\nconst RealtimePresence_1 = tslib_1.__importDefault(__webpack_require__(/*! ./RealtimePresence */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/RealtimePresence.js\"));\nconst Transformers = tslib_1.__importStar(__webpack_require__(/*! ./lib/transformers */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/transformers.js\"));\nconst transformers_1 = __webpack_require__(/*! ./lib/transformers */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/transformers.js\");\nvar REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nvar REALTIME_LISTEN_TYPES;\n(function(REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n    REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (exports.REALTIME_LISTEN_TYPES = REALTIME_LISTEN_TYPES = {}));\nvar REALTIME_SUBSCRIBE_STATES;\n(function(REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (exports.REALTIME_SUBSCRIBE_STATES = REALTIME_SUBSCRIBE_STATES = {}));\nexports.REALTIME_CHANNEL_STATES = constants_1.CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */ class RealtimeChannel {\n    /**\n     * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.\n     *\n     * The topic determines which realtime stream you are subscribing to. Config options let you\n     * enable acknowledgement for broadcasts, presence tracking, or private channels.\n     *\n     * @example\n     * ```ts\n     * import RealtimeClient from '@supabase/realtime-js'\n     *\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\n     *   params: { apikey: 'public-anon-key' },\n     * })\n     * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)\n     * ```\n     */ constructor(/** Topic name can be any string. */ topic, params = {\n        config: {}\n    }, socket){\n        var _a, _b;\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = constants_1.CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.subTopic = topic.replace(/^realtime:/i, \"\");\n        this.params.config = Object.assign({\n            broadcast: {\n                ack: false,\n                self: false\n            },\n            presence: {\n                key: \"\",\n                enabled: false\n            },\n            private: false\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new push_1.default(this, constants_1.CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new timer_1.default(()=>this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive(\"ok\", ()=>{\n            this.state = constants_1.CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent)=>pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(()=>{\n            this.rejoinTimer.reset();\n            this.socket.log(\"channel\", `close ${this.topic} ${this._joinRef()}`);\n            this.state = constants_1.CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason)=>{\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log(\"channel\", `error ${this.topic}`, reason);\n            this.state = constants_1.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive(\"timeout\", ()=>{\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log(\"channel\", `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = constants_1.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive(\"error\", (reason)=>{\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log(\"channel\", `error ${this.topic}`, reason);\n            this.state = constants_1.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(constants_1.CHANNEL_EVENTS.reply, {}, (payload, ref)=>{\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new RealtimePresence_1.default(this);\n        this.broadcastEndpointURL = (0, transformers_1.httpEndpointURL)(this.socket.endPoint);\n        this.private = this.params.config.private || false;\n        if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {\n            throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;\n        }\n    }\n    /** Subscribe registers your client with the server */ subscribe(callback, timeout = this.timeout) {\n        var _a, _b, _c;\n        if (!this.socket.isConnected()) {\n            this.socket.connect();\n        }\n        if (this.state == constants_1.CHANNEL_STATES.closed) {\n            const { config: { broadcast, presence, private: isPrivate } } = this.params;\n            const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r)=>r.filter)) !== null && _b !== void 0 ? _b : [];\n            const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence: Object.assign(Object.assign({}, presence), {\n                    enabled: presence_enabled\n                }),\n                postgres_changes,\n                private: isPrivate\n            };\n            if (this.socket.accessTokenValue) {\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\n            }\n            this._onError((e)=>callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n            this._onClose(()=>callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n            this.updateJoinPayload(Object.assign({\n                config\n            }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush.receive(\"ok\", async ({ postgres_changes })=>{\n                var _a;\n                // Only refresh auth if using callback-based tokens\n                if (!this.socket._isManualToken()) {\n                    this.socket.setAuth();\n                }\n                if (postgres_changes === undefined) {\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                } else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for(let i = 0; i < bindingsLen; i++){\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter } } = clientPostgresBinding;\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\n                        if (serverPostgresFilter && serverPostgresFilter.event === event && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                                id: serverPostgresFilter.id\n                            }));\n                        } else {\n                            this.unsubscribe();\n                            this.state = constants_1.CHANNEL_STATES.errored;\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(\"mismatch between server and client bindings for postgres changes\"));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n            }).receive(\"error\", (error)=>{\n                this.state = constants_1.CHANNEL_STATES.errored;\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(\", \") || \"error\")));\n                return;\n            }).receive(\"timeout\", ()=>{\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n                return;\n            });\n        }\n        return this;\n    }\n    /**\n     * Returns the current presence state for this channel.\n     *\n     * The shape is a map keyed by presence key (for example a user id) where each entry contains the\n     * tracked metadata for that user.\n     */ presenceState() {\n        return this.presence.state;\n    }\n    /**\n     * Sends the supplied payload to the presence tracker so other subscribers can see that this\n     * client is online. Use `untrack` to stop broadcasting presence for the same key.\n     */ async track(payload, opts = {}) {\n        return await this.send({\n            type: \"presence\",\n            event: \"track\",\n            payload\n        }, opts.timeout || this.timeout);\n    }\n    /**\n     * Removes the current presence state for this client.\n     */ async untrack(opts = {}) {\n        return await this.send({\n            type: \"presence\",\n            event: \"untrack\"\n        }, opts);\n    }\n    on(type, filter, callback) {\n        if (this.state === constants_1.CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {\n            this.socket.log(\"channel\", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);\n            this.unsubscribe().then(async ()=>await this.subscribe());\n        }\n        return this._on(type, filter, callback);\n    }\n    /**\n     * Sends a broadcast message explicitly via REST API.\n     *\n     * This method always uses the REST API endpoint regardless of WebSocket connection state.\n     * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.\n     *\n     * @param event The name of the broadcast event\n     * @param payload Payload to be sent (required)\n     * @param opts Options including timeout\n     * @returns Promise resolving to object with success status, and error details if failed\n     */ async httpSend(event, payload, opts = {}) {\n        var _a;\n        if (payload === undefined || payload === null) {\n            return Promise.reject(\"Payload is required for httpSend()\");\n        }\n        const headers = {\n            apikey: this.socket.apiKey ? this.socket.apiKey : \"\",\n            \"Content-Type\": \"application/json\"\n        };\n        if (this.socket.accessTokenValue) {\n            headers[\"Authorization\"] = `Bearer ${this.socket.accessTokenValue}`;\n        }\n        const options = {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({\n                messages: [\n                    {\n                        topic: this.subTopic,\n                        event,\n                        payload: payload,\n                        private: this.private\n                    }\n                ]\n            })\n        };\n        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n        if (response.status === 202) {\n            return {\n                success: true\n            };\n        }\n        let errorMessage = response.statusText;\n        try {\n            const errorBody = await response.json();\n            errorMessage = errorBody.error || errorBody.message || errorMessage;\n        } catch (_b) {}\n        return Promise.reject(new Error(errorMessage));\n    }\n    /**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */ async send(args, opts = {}) {\n        var _a, _b;\n        if (!this._canPush() && args.type === \"broadcast\") {\n            console.warn(\"Realtime send() is automatically falling back to REST API. \" + \"This behavior will be deprecated in the future. \" + \"Please use httpSend() explicitly for REST delivery.\");\n            const { event, payload: endpoint_payload } = args;\n            const headers = {\n                apikey: this.socket.apiKey ? this.socket.apiKey : \"\",\n                \"Content-Type\": \"application/json\"\n            };\n            if (this.socket.accessTokenValue) {\n                headers[\"Authorization\"] = `Bearer ${this.socket.accessTokenValue}`;\n            }\n            const options = {\n                method: \"POST\",\n                headers,\n                body: JSON.stringify({\n                    messages: [\n                        {\n                            topic: this.subTopic,\n                            event,\n                            payload: endpoint_payload,\n                            private: this.private\n                        }\n                    ]\n                })\n            };\n            try {\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n                return response.ok ? \"ok\" : \"error\";\n            } catch (error) {\n                if (error.name === \"AbortError\") {\n                    return \"timed out\";\n                } else {\n                    return \"error\";\n                }\n            }\n        } else {\n            return new Promise((resolve)=>{\n                var _a, _b, _c;\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\n                if (args.type === \"broadcast\" && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                    resolve(\"ok\");\n                }\n                push.receive(\"ok\", ()=>resolve(\"ok\"));\n                push.receive(\"error\", ()=>resolve(\"error\"));\n                push.receive(\"timeout\", ()=>resolve(\"timed out\"));\n            });\n        }\n    }\n    /**\n     * Updates the payload that will be sent the next time the channel joins (reconnects).\n     * Useful for rotating access tokens or updating config without re-creating the channel.\n     */ updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */ unsubscribe(timeout = this.timeout) {\n        this.state = constants_1.CHANNEL_STATES.leaving;\n        const onClose = ()=>{\n            this.socket.log(\"channel\", `leave ${this.topic}`);\n            this._trigger(constants_1.CHANNEL_EVENTS.close, \"leave\", this._joinRef());\n        };\n        this.joinPush.destroy();\n        let leavePush = null;\n        return new Promise((resolve)=>{\n            leavePush = new push_1.default(this, constants_1.CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush.receive(\"ok\", ()=>{\n                onClose();\n                resolve(\"ok\");\n            }).receive(\"timeout\", ()=>{\n                onClose();\n                resolve(\"timed out\");\n            }).receive(\"error\", ()=>{\n                resolve(\"error\");\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger(\"ok\", {});\n            }\n        }).finally(()=>{\n            leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\n        });\n    }\n    /**\n     * Teardown the channel.\n     *\n     * Destroys and stops related timers.\n     */ teardown() {\n        this.pushBuffer.forEach((push)=>push.destroy());\n        this.pushBuffer = [];\n        this.rejoinTimer.reset();\n        this.joinPush.destroy();\n        this.state = constants_1.CHANNEL_STATES.closed;\n        this.bindings = {};\n    }\n    /** @internal */ async _fetchWithTimeout(url, options, timeout) {\n        const controller = new AbortController();\n        const id = setTimeout(()=>controller.abort(), timeout);\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {\n            signal: controller.signal\n        }));\n        clearTimeout(id);\n        return response;\n    }\n    /** @internal */ _push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new push_1.default(this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        } else {\n            this._addToPushBuffer(pushEvent);\n        }\n        return pushEvent;\n    }\n    /** @internal */ _addToPushBuffer(pushEvent) {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n        // Enforce buffer size limit\n        if (this.pushBuffer.length > constants_1.MAX_PUSH_BUFFER_SIZE) {\n            const removedPush = this.pushBuffer.shift();\n            if (removedPush) {\n                removedPush.destroy();\n                this.socket.log(\"channel\", `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);\n            }\n        }\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */ _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */ _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */ _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */ _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = constants_1.CHANNEL_EVENTS;\n        const events = [\n            close,\n            error,\n            leave,\n            join\n        ];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw \"channel onMessage callbacks must return the payload, modified or unmodified\";\n        }\n        if ([\n            \"insert\",\n            \"update\",\n            \"delete\"\n        ].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind)=>{\n                var _a, _b, _c;\n                return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === \"*\" || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n            }).map((bind)=>bind.callback(handledPayload, ref));\n        } else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind)=>{\n                var _a, _b, _c, _d, _e, _f, _g, _h;\n                if ([\n                    \"broadcast\",\n                    \"presence\",\n                    \"postgres_changes\"\n                ].includes(typeLower)) {\n                    if (\"id\" in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === \"*\" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())) && (!((_d = bind.filter) === null || _d === void 0 ? void 0 : _d.table) || bind.filter.table === ((_e = payload.data) === null || _e === void 0 ? void 0 : _e.table));\n                    } else {\n                        const bindEvent = (_g = (_f = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _f === void 0 ? void 0 : _f.event) === null || _g === void 0 ? void 0 : _g.toLocaleLowerCase();\n                        return bindEvent === \"*\" || bindEvent === ((_h = payload === null || payload === void 0 ? void 0 : payload.event) === null || _h === void 0 ? void 0 : _h.toLocaleLowerCase());\n                    }\n                } else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind)=>{\n                if (typeof handledPayload === \"object\" && \"ids\" in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */ _isClosed() {\n        return this.state === constants_1.CHANNEL_STATES.closed;\n    }\n    /** @internal */ _isJoined() {\n        return this.state === constants_1.CHANNEL_STATES.joined;\n    }\n    /** @internal */ _isJoining() {\n        return this.state === constants_1.CHANNEL_STATES.joining;\n    }\n    /** @internal */ _isLeaving() {\n        return this.state === constants_1.CHANNEL_STATES.leaving;\n    }\n    /** @internal */ _replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    /** @internal */ _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        } else {\n            this.bindings[typeLower] = [\n                binding\n            ];\n        }\n        return this;\n    }\n    /** @internal */ _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower] = this.bindings[typeLower].filter((bind)=>{\n                var _a;\n                return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n            });\n        }\n        return this;\n    }\n    /** @internal */ static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for(const k in obj1){\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Compares two optional filter values for equality.\n     * Treats undefined, null, and empty string as equivalent empty values.\n     * @internal\n     */ static isFilterValueEqual(serverValue, clientValue) {\n        const normalizedServer = serverValue !== null && serverValue !== void 0 ? serverValue : undefined;\n        const normalizedClient = clientValue !== null && clientValue !== void 0 ? clientValue : undefined;\n        return normalizedServer === normalizedClient;\n    }\n    /** @internal */ _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */ _onClose(callback) {\n        this._on(constants_1.CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */ _onError(callback) {\n        this._on(constants_1.CHANNEL_EVENTS.error, {}, (reason)=>callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */ _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */ _rejoin(timeout = this.timeout) {\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = constants_1.CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */ _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {}\n        };\n        if (payload.type === \"INSERT\" || payload.type === \"UPDATE\") {\n            records.new = Transformers.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === \"UPDATE\" || payload.type === \"DELETE\") {\n            records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n}\nexports[\"default\"] = RealtimeChannel; //# sourceMappingURL=RealtimeChannel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9SZWFsdGltZUNoYW5uZWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELCtCQUErQixHQUFHQSxpQ0FBaUMsR0FBR0EsNkJBQTZCLEdBQUdBLDhDQUE4QyxHQUFHLEtBQUs7QUFDNUosTUFBTU0sVUFBVUMsbUJBQU9BLENBQUMsdURBQU87QUFDL0IsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEZBQWlCO0FBQzdDLE1BQU1FLFNBQVNILFFBQVFJLGVBQWUsQ0FBQ0gsbUJBQU9BLENBQUMsb0ZBQVk7QUFDM0QsTUFBTUksVUFBVUwsUUFBUUksZUFBZSxDQUFDSCxtQkFBT0EsQ0FBQyxzRkFBYTtBQUM3RCxNQUFNSyxxQkFBcUJOLFFBQVFJLGVBQWUsQ0FBQ0gsbUJBQU9BLENBQUMsb0dBQW9CO0FBQy9FLE1BQU1NLGVBQWVQLFFBQVFRLFlBQVksQ0FBQ1AsbUJBQU9BLENBQUMsb0dBQW9CO0FBQ3RFLE1BQU1RLGlCQUFpQlIsbUJBQU9BLENBQUMsb0dBQW9CO0FBQ25ELElBQUlGO0FBQ0gsVUFBVUEsc0NBQXNDO0lBQzdDQSxzQ0FBc0MsQ0FBQyxNQUFNLEdBQUc7SUFDaERBLHNDQUFzQyxDQUFDLFNBQVMsR0FBRztJQUNuREEsc0NBQXNDLENBQUMsU0FBUyxHQUFHO0lBQ25EQSxzQ0FBc0MsQ0FBQyxTQUFTLEdBQUc7QUFDdkQsR0FBR0EsMENBQTJDTCxDQUFBQSw4Q0FBOEMsR0FBR0sseUNBQXlDLENBQUM7QUFDekksSUFBSUQ7QUFDSCxVQUFVQSxxQkFBcUI7SUFDNUJBLHFCQUFxQixDQUFDLFlBQVksR0FBRztJQUNyQ0EscUJBQXFCLENBQUMsV0FBVyxHQUFHO0lBQ3BDQSxxQkFBcUIsQ0FBQyxtQkFBbUIsR0FBRztJQUM1Q0EscUJBQXFCLENBQUMsU0FBUyxHQUFHO0FBQ3RDLEdBQUdBLHlC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QUFDK0wsT0FBTztRQUMvQyxJQUFJLENBQUN0SyxRQUFRLENBQUNtTCxNQUFNLENBQUNwTDtJQUN6QjtJQUNBLGNBQWMsR0FDZHFLLG1CQUFtQjFJLE9BQU8sRUFBRTtRQUN4QixNQUFNMEosVUFBVTtZQUNabEIsS0FBSyxDQUFDO1lBQ05DLEtBQUssQ0FBQztRQUNWO1FBQ0EsSUFBSXpJLFFBQVF1RCxJQUFJLEtBQUssWUFBWXZELFFBQVF1RCxJQUFJLEtBQUssVUFBVTtZQUN4RG1HLFFBQVFsQixHQUFHLEdBQUc5TCxhQUFhaU4saUJBQWlCLENBQUMzSixRQUFRNEosT0FBTyxFQUFFNUosUUFBUTZKLE1BQU07UUFDaEY7UUFDQSxJQUFJN0osUUFBUXVELElBQUksS0FBSyxZQUFZdkQsUUFBUXVELElBQUksS0FBSyxVQUFVO1lBQ3hEbUcsUUFBUWpCLEdBQUcsR0FBRy9MLGFBQWFpTixpQkFBaUIsQ0FBQzNKLFFBQVE0SixPQUFPLEVBQUU1SixRQUFROEosVUFBVTtRQUNwRjtRQUNBLE9BQU9KO0lBQ1g7QUFDSjtBQUNBN04sa0JBQWUsR0FBR2lCLGlCQUNsQiwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9SZWFsdGltZUNoYW5uZWwuanM/ZDJhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUkVBTFRJTUVfQ0hBTk5FTF9TVEFURVMgPSBleHBvcnRzLlJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMgPSBleHBvcnRzLlJFQUxUSU1FX0xJU1RFTl9UWVBFUyA9IGV4cG9ydHMuUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQgPSB2b2lkIDA7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9saWIvY29uc3RhbnRzXCIpO1xuY29uc3QgcHVzaF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbGliL3B1c2hcIikpO1xuY29uc3QgdGltZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi90aW1lclwiKSk7XG5jb25zdCBSZWFsdGltZVByZXNlbmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9SZWFsdGltZVByZXNlbmNlXCIpKTtcbmNvbnN0IFRyYW5zZm9ybWVycyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi90cmFuc2Zvcm1lcnNcIikpO1xuY29uc3QgdHJhbnNmb3JtZXJzXzEgPSByZXF1aXJlKFwiLi9saWIvdHJhbnNmb3JtZXJzXCIpO1xudmFyIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCkge1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiQUxMXCJdID0gXCIqXCI7XG4gICAgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlRbXCJJTlNFUlRcIl0gPSBcIklOU0VSVFwiO1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiVVBEQVRFXCJdID0gXCJVUERBVEVcIjtcbiAgICBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVFtcIkRFTEVURVwiXSA9IFwiREVMRVRFXCI7XG59KShSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCB8fCAoZXhwb3J0cy5SRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCA9IFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UID0ge30pKTtcbnZhciBSRUFMVElNRV9MSVNURU5fVFlQRVM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX0xJU1RFTl9UWVBFUykge1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIkJST0FEQ0FTVFwiXSA9IFwiYnJvYWRjYXN0XCI7XG4gICAgUkVBTFRJTUVfTElTVEVOX1RZUEVTW1wiUFJFU0VOQ0VcIl0gPSBcInByZXNlbmNlXCI7XG4gICAgUkVBTFRJTUVfTElTVEVOX1RZUEVTW1wiUE9TVEdSRVNfQ0hBTkdFU1wiXSA9IFwicG9zdGdyZXNfY2hhbmdlc1wiO1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIlNZU1RFTVwiXSA9IFwic3lzdGVtXCI7XG59KShSRUFMVElNRV9MSVNURU5fVFlQRVMgfHwgKGV4cG9ydHMuUkVBTFRJTUVfTElTVEVOX1RZUEVTID0gUkVBTFRJTUVfTElTVEVOX1RZUEVTID0ge30pKTtcbnZhciBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTKSB7XG4gICAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFU1tcIlNVQlNDUklCRURcIl0gPSBcIlNVQlNDUklCRURcIjtcbiAgICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTW1wiVElNRURfT1VUXCJdID0gXCJUSU1FRF9PVVRcIjtcbiAgICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTW1wiQ0xPU0VEXCJdID0gXCJDTE9TRURcIjtcbiAgICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTW1wiQ0hBTk5FTF9FUlJPUlwiXSA9IFwiQ0hBTk5FTF9FUlJPUlwiO1xufSkoUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyB8fCAoZXhwb3J0cy5SRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTID0gUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyA9IHt9KSk7XG5leHBvcnRzLlJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTID0gY29uc3RhbnRzXzEuQ0hBTk5FTF9TVEFURVM7XG4vKiogQSBjaGFubmVsIGlzIHRoZSBiYXNpYyBidWlsZGluZyBibG9jayBvZiBSZWFsdGltZVxuICogYW5kIG5hcnJvd3MgdGhlIHNjb3BlIG9mIGRhdGEgZmxvdyB0byBzdWJzY3JpYmVkIGNsaWVudHMuXG4gKiBZb3UgY2FuIHRoaW5rIG9mIGEgY2hhbm5lbCBhcyBhIGNoYXRyb29tIHdoZXJlIHBhcnRpY2lwYW50cyBhcmUgYWJsZSB0byBzZWUgd2hvJ3Mgb25saW5lXG4gKiBhbmQgc2VuZCBhbmQgcmVjZWl2ZSBtZXNzYWdlcy5cbiAqL1xuY2xhc3MgUmVhbHRpbWVDaGFubmVsIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hhbm5lbCB0aGF0IGNhbiBicm9hZGNhc3QgbWVzc2FnZXMsIHN5bmMgcHJlc2VuY2UsIGFuZCBsaXN0ZW4gdG8gUG9zdGdyZXMgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIFRoZSB0b3BpYyBkZXRlcm1pbmVzIHdoaWNoIHJlYWx0aW1lIHN0cmVhbSB5b3UgYXJlIHN1YnNjcmliaW5nIHRvLiBDb25maWcgb3B0aW9ucyBsZXQgeW91XG4gICAgICogZW5hYmxlIGFja25vd2xlZGdlbWVudCBmb3IgYnJvYWRjYXN0cywgcHJlc2VuY2UgdHJhY2tpbmcsIG9yIHByaXZhdGUgY2hhbm5lbHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IFJlYWx0aW1lQ2xpZW50IGZyb20gJ0BzdXBhYmFzZS9yZWFsdGltZS1qcydcbiAgICAgKlxuICAgICAqIGNvbnN0IGNsaWVudCA9IG5ldyBSZWFsdGltZUNsaWVudCgnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvL3JlYWx0aW1lL3YxJywge1xuICAgICAqICAgcGFyYW1zOiB7IGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScgfSxcbiAgICAgKiB9KVxuICAgICAqIGNvbnN0IGNoYW5uZWwgPSBuZXcgUmVhbHRpbWVDaGFubmVsKCdyZWFsdGltZTpwdWJsaWM6bWVzc2FnZXMnLCB7IGNvbmZpZzoge30gfSwgY2xpZW50KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUb3BpYyBuYW1lIGNhbiBiZSBhbnkgc3RyaW5nLiAqL1xuICAgIHRvcGljLCBwYXJhbXMgPSB7IGNvbmZpZzoge30gfSwgc29ja2V0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMudG9waWMgPSB0b3BpYztcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICB0aGlzLmJpbmRpbmdzID0ge307XG4gICAgICAgIHRoaXMuc3RhdGUgPSBjb25zdGFudHNfMS5DSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgICAgIHRoaXMuam9pbmVkT25jZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5zdWJUb3BpYyA9IHRvcGljLnJlcGxhY2UoL15yZWFsdGltZTovaSwgJycpO1xuICAgICAgICB0aGlzLnBhcmFtcy5jb25maWcgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGJyb2FkY2FzdDogeyBhY2s6IGZhbHNlLCBzZWxmOiBmYWxzZSB9LFxuICAgICAgICAgICAgcHJlc2VuY2U6IHsga2V5OiAnJywgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHByaXZhdGU6IGZhbHNlLFxuICAgICAgICB9LCBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGhpcy5zb2NrZXQudGltZW91dDtcbiAgICAgICAgdGhpcy5qb2luUHVzaCA9IG5ldyBwdXNoXzEuZGVmYXVsdCh0aGlzLCBjb25zdGFudHNfMS5DSEFOTkVMX0VWRU5UUy5qb2luLCB0aGlzLnBhcmFtcywgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lciA9IG5ldyB0aW1lcl8xLmRlZmF1bHQoKCkgPT4gdGhpcy5fcmVqb2luVW50aWxDb25uZWN0ZWQoKSwgdGhpcy5zb2NrZXQucmVjb25uZWN0QWZ0ZXJNcyk7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgnb2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gY29uc3RhbnRzXzEuQ0hBTk5FTF9TVEFURVMuam9pbmVkO1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2goKHB1c2hFdmVudCkgPT4gcHVzaEV2ZW50LnNlbmQoKSk7XG4gICAgICAgICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29uQ2xvc2UoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGNsb3NlICR7dGhpcy50b3BpY30gJHt0aGlzLl9qb2luUmVmKCl9YCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gY29uc3RhbnRzXzEuQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29uRXJyb3IoKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTGVhdmluZygpIHx8IHRoaXMuX2lzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gY29uc3RhbnRzXzEuQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzSm9pbmluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYHRpbWVvdXQgJHt0aGlzLnRvcGljfWAsIHRoaXMuam9pblB1c2gudGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gY29uc3RhbnRzXzEuQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoJ2Vycm9yJywgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTGVhdmluZygpIHx8IHRoaXMuX2lzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gY29uc3RhbnRzXzEuQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vbihjb25zdGFudHNfMS5DSEFOTkVMX0VWRU5UUy5yZXBseSwge30sIChwYXlsb2FkLCByZWYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIodGhpcy5fcmVwbHlFdmVudE5hbWUocmVmKSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByZXNlbmNlID0gbmV3IFJlYWx0aW1lUHJlc2VuY2VfMS5kZWZhdWx0KHRoaXMpO1xuICAgICAgICB0aGlzLmJyb2FkY2FzdEVuZHBvaW50VVJMID0gKDAsIHRyYW5zZm9ybWVyc18xLmh0dHBFbmRwb2ludFVSTCkodGhpcy5zb2NrZXQuZW5kUG9pbnQpO1xuICAgICAgICB0aGlzLnByaXZhdGUgPSB0aGlzLnBhcmFtcy5jb25maWcucHJpdmF0ZSB8fCBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLnByaXZhdGUgJiYgKChfYiA9IChfYSA9IHRoaXMucGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJyb2FkY2FzdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlcGxheSkpIHtcbiAgICAgICAgICAgIHRocm93IGB0cmllZCB0byB1c2UgcmVwbGF5IG9uIHB1YmxpYyBjaGFubmVsICcke3RoaXMudG9waWN9Jy4gSXQgbXVzdCBiZSBhIHByaXZhdGUgY2hhbm5lbC5gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBTdWJzY3JpYmUgcmVnaXN0ZXJzIHlvdXIgY2xpZW50IHdpdGggdGhlIHNlcnZlciAqL1xuICAgIHN1YnNjcmliZShjYWxsYmFjaywgdGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKCF0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gY29uc3RhbnRzXzEuQ0hBTk5FTF9TVEFURVMuY2xvc2VkKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbmZpZzogeyBicm9hZGNhc3QsIHByZXNlbmNlLCBwcml2YXRlOiBpc1ByaXZhdGUgfSwgfSA9IHRoaXMucGFyYW1zO1xuICAgICAgICAgICAgY29uc3QgcG9zdGdyZXNfY2hhbmdlcyA9IChfYiA9IChfYSA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgocikgPT4gci5maWx0ZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXNlbmNlX2VuYWJsZWQgPSAoISF0aGlzLmJpbmRpbmdzW1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRV0gJiZcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzW1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRV0ubGVuZ3RoID4gMCkgfHxcbiAgICAgICAgICAgICAgICAoKF9jID0gdGhpcy5wYXJhbXMuY29uZmlnLnByZXNlbmNlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZW5hYmxlZCkgPT09IHRydWU7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlblBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBicm9hZGNhc3QsXG4gICAgICAgICAgICAgICAgcHJlc2VuY2U6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJlc2VuY2UpLCB7IGVuYWJsZWQ6IHByZXNlbmNlX2VuYWJsZWQgfSksXG4gICAgICAgICAgICAgICAgcG9zdGdyZXNfY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBwcml2YXRlOiBpc1ByaXZhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlblBheWxvYWQuYWNjZXNzX3Rva2VuID0gdGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoKGUpID0+IGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsIGUpKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ2xvc2UoKCkgPT4gY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0xPU0VEKSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUpvaW5QYXlsb2FkKE9iamVjdC5hc3NpZ24oeyBjb25maWcgfSwgYWNjZXNzVG9rZW5QYXlsb2FkKSk7XG4gICAgICAgICAgICB0aGlzLmpvaW5lZE9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVqb2luKHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5qb2luUHVzaFxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdvaycsIGFzeW5jICh7IHBvc3RncmVzX2NoYW5nZXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlZnJlc2ggYXV0aCBpZiB1c2luZyBjYWxsYmFjay1iYXNlZCB0b2tlbnNcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc29ja2V0Ll9pc01hbnVhbFRva2VuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2V0QXV0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zdGdyZXNfY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlNVQlNDUklCRUQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5kaW5nc0xlbiA9IChfYSA9IGNsaWVudFBvc3RncmVzQmluZGluZ3MgPT09IG51bGwgfHwgY2xpZW50UG9zdGdyZXNCaW5kaW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xpZW50UG9zdGdyZXNCaW5kaW5ncy5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Bvc3RncmVzQmluZGluZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5kaW5nc0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRQb3N0Z3Jlc0JpbmRpbmcgPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmaWx0ZXI6IHsgZXZlbnQsIHNjaGVtYSwgdGFibGUsIGZpbHRlciB9LCB9ID0gY2xpZW50UG9zdGdyZXNCaW5kaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyUG9zdGdyZXNGaWx0ZXIgPSBwb3N0Z3Jlc19jaGFuZ2VzICYmIHBvc3RncmVzX2NoYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VydmVyUG9zdGdyZXNGaWx0ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5ldmVudCA9PT0gZXZlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFsdGltZUNoYW5uZWwuaXNGaWx0ZXJWYWx1ZUVxdWFsKHNlcnZlclBvc3RncmVzRmlsdGVyLnNjaGVtYSwgc2NoZW1hKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWx0aW1lQ2hhbm5lbC5pc0ZpbHRlclZhbHVlRXF1YWwoc2VydmVyUG9zdGdyZXNGaWx0ZXIudGFibGUsIHRhYmxlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWx0aW1lQ2hhbm5lbC5pc0ZpbHRlclZhbHVlRXF1YWwoc2VydmVyUG9zdGdyZXNGaWx0ZXIuZmlsdGVyLCBmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9zdGdyZXNCaW5kaW5ncy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2xpZW50UG9zdGdyZXNCaW5kaW5nKSwgeyBpZDogc2VydmVyUG9zdGdyZXNGaWx0ZXIuaWQgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBjb25zdGFudHNfMS5DSEFOTkVMX1NUQVRFUy5lcnJvcmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsIG5ldyBFcnJvcignbWlzbWF0Y2ggYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCBiaW5kaW5ncyBmb3IgcG9zdGdyZXMgY2hhbmdlcycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzID0gbmV3UG9zdGdyZXNCaW5kaW5ncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5TVUJTQ1JJQkVEKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGNvbnN0YW50c18xLkNIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0hBTk5FTF9FUlJPUiwgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KE9iamVjdC52YWx1ZXMoZXJyb3IpLmpvaW4oJywgJykgfHwgJ2Vycm9yJykpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlRJTUVEX09VVCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcHJlc2VuY2Ugc3RhdGUgZm9yIHRoaXMgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIFRoZSBzaGFwZSBpcyBhIG1hcCBrZXllZCBieSBwcmVzZW5jZSBrZXkgKGZvciBleGFtcGxlIGEgdXNlciBpZCkgd2hlcmUgZWFjaCBlbnRyeSBjb250YWlucyB0aGVcbiAgICAgKiB0cmFja2VkIG1ldGFkYXRhIGZvciB0aGF0IHVzZXIuXG4gICAgICovXG4gICAgcHJlc2VuY2VTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlc2VuY2Uuc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIHRoZSBzdXBwbGllZCBwYXlsb2FkIHRvIHRoZSBwcmVzZW5jZSB0cmFja2VyIHNvIG90aGVyIHN1YnNjcmliZXJzIGNhbiBzZWUgdGhhdCB0aGlzXG4gICAgICogY2xpZW50IGlzIG9ubGluZS4gVXNlIGB1bnRyYWNrYCB0byBzdG9wIGJyb2FkY2FzdGluZyBwcmVzZW5jZSBmb3IgdGhlIHNhbWUga2V5LlxuICAgICAqL1xuICAgIGFzeW5jIHRyYWNrKHBheWxvYWQsIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6ICdwcmVzZW5jZScsXG4gICAgICAgICAgICBldmVudDogJ3RyYWNrJyxcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgIH0sIG9wdHMudGltZW91dCB8fCB0aGlzLnRpbWVvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBjdXJyZW50IHByZXNlbmNlIHN0YXRlIGZvciB0aGlzIGNsaWVudC5cbiAgICAgKi9cbiAgICBhc3luYyB1bnRyYWNrKG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6ICdwcmVzZW5jZScsXG4gICAgICAgICAgICBldmVudDogJ3VudHJhY2snLFxuICAgICAgICB9LCBvcHRzKTtcbiAgICB9XG4gICAgb24odHlwZSwgZmlsdGVyLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gY29uc3RhbnRzXzEuQ0hBTk5FTF9TVEFURVMuam9pbmVkICYmIHR5cGUgPT09IFJFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRSkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYHJlc3Vic2NyaWJlIHRvICR7dGhpcy50b3BpY30gZHVlIHRvIGNoYW5nZSBpbiBwcmVzZW5jZSBjYWxsYmFja3Mgb24gam9pbmVkIGNoYW5uZWxgKTtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKS50aGVuKGFzeW5jICgpID0+IGF3YWl0IHRoaXMuc3Vic2NyaWJlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9vbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBicm9hZGNhc3QgbWVzc2FnZSBleHBsaWNpdGx5IHZpYSBSRVNUIEFQSS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsd2F5cyB1c2VzIHRoZSBSRVNUIEFQSSBlbmRwb2ludCByZWdhcmRsZXNzIG9mIFdlYlNvY2tldCBjb25uZWN0aW9uIHN0YXRlLlxuICAgICAqIFVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGd1YXJhbnRlZSBSRVNUIGRlbGl2ZXJ5IG9yIHdoZW4gZ3JhZHVhbGx5IG1pZ3JhdGluZyBmcm9tIGltcGxpY2l0IFJFU1QgZmFsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGJyb2FkY2FzdCBldmVudFxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgdG8gYmUgc2VudCAocmVxdWlyZWQpXG4gICAgICogQHBhcmFtIG9wdHMgT3B0aW9ucyBpbmNsdWRpbmcgdGltZW91dFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIG9iamVjdCB3aXRoIHN1Y2Nlc3Mgc3RhdHVzLCBhbmQgZXJyb3IgZGV0YWlscyBpZiBmYWlsZWRcbiAgICAgKi9cbiAgICBhc3luYyBodHRwU2VuZChldmVudCwgcGF5bG9hZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHBheWxvYWQgPT09IHVuZGVmaW5lZCB8fCBwYXlsb2FkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1BheWxvYWQgaXMgcmVxdWlyZWQgZm9yIGh0dHBTZW5kKCknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgYXBpa2V5OiB0aGlzLnNvY2tldC5hcGlLZXkgPyB0aGlzLnNvY2tldC5hcGlLZXkgOiAnJyxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9waWM6IHRoaXMuc3ViVG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcml2YXRlOiB0aGlzLnByaXZhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoV2l0aFRpbWVvdXQodGhpcy5icm9hZGNhc3RFbmRwb2ludFVSTCwgb3B0aW9ucywgKF9hID0gb3B0cy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnRpbWVvdXQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gcmVzcG9uc2Uuc3RhdHVzVGV4dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yQm9keS5lcnJvciB8fCBlcnJvckJvZHkubWVzc2FnZSB8fCBlcnJvck1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9iKSB7IH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIGludG8gdGhlIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyBBcmd1bWVudHMgdG8gc2VuZCB0byBjaGFubmVsXG4gICAgICogQHBhcmFtIGFyZ3MudHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byBzZW5kXG4gICAgICogQHBhcmFtIGFyZ3MuZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IGJlaW5nIHNlbnRcbiAgICAgKiBAcGFyYW0gYXJncy5wYXlsb2FkIFBheWxvYWQgdG8gYmUgc2VudFxuICAgICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMgdG8gYmUgdXNlZCBkdXJpbmcgdGhlIHNlbmQgcHJvY2Vzc1xuICAgICAqL1xuICAgIGFzeW5jIHNlbmQoYXJncywgb3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5fY2FuUHVzaCgpICYmIGFyZ3MudHlwZSA9PT0gJ2Jyb2FkY2FzdCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUmVhbHRpbWUgc2VuZCgpIGlzIGF1dG9tYXRpY2FsbHkgZmFsbGluZyBiYWNrIHRvIFJFU1QgQVBJLiAnICtcbiAgICAgICAgICAgICAgICAnVGhpcyBiZWhhdmlvciB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZS4gJyArXG4gICAgICAgICAgICAgICAgJ1BsZWFzZSB1c2UgaHR0cFNlbmQoKSBleHBsaWNpdGx5IGZvciBSRVNUIGRlbGl2ZXJ5LicpO1xuICAgICAgICAgICAgY29uc3QgeyBldmVudCwgcGF5bG9hZDogZW5kcG9pbnRfcGF5bG9hZCB9ID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgYXBpa2V5OiB0aGlzLnNvY2tldC5hcGlLZXkgPyB0aGlzLnNvY2tldC5hcGlLZXkgOiAnJyxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3RoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9waWM6IHRoaXMuc3ViVG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogZW5kcG9pbnRfcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcml2YXRlOiB0aGlzLnByaXZhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9mZXRjaFdpdGhUaW1lb3V0KHRoaXMuYnJvYWRjYXN0RW5kcG9pbnRVUkwsIG9wdGlvbnMsIChfYSA9IG9wdHMudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBhd2FpdCAoKF9iID0gcmVzcG9uc2UuYm9keSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbmNlbCgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2sgPyAnb2snIDogJ2Vycm9yJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0aW1lZCBvdXQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlcnJvcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVzaCA9IHRoaXMuX3B1c2goYXJncy50eXBlLCBhcmdzLCBvcHRzLnRpbWVvdXQgfHwgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy50eXBlID09PSAnYnJvYWRjYXN0JyAmJiAhKChfYyA9IChfYiA9IChfYSA9IHRoaXMucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYnJvYWRjYXN0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCdvaycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwdXNoLnJlY2VpdmUoJ29rJywgKCkgPT4gcmVzb2x2ZSgnb2snKSk7XG4gICAgICAgICAgICAgICAgcHVzaC5yZWNlaXZlKCdlcnJvcicsICgpID0+IHJlc29sdmUoJ2Vycm9yJykpO1xuICAgICAgICAgICAgICAgIHB1c2gucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHJlc29sdmUoJ3RpbWVkIG91dCcpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHBheWxvYWQgdGhhdCB3aWxsIGJlIHNlbnQgdGhlIG5leHQgdGltZSB0aGUgY2hhbm5lbCBqb2lucyAocmVjb25uZWN0cykuXG4gICAgICogVXNlZnVsIGZvciByb3RhdGluZyBhY2Nlc3MgdG9rZW5zIG9yIHVwZGF0aW5nIGNvbmZpZyB3aXRob3V0IHJlLWNyZWF0aW5nIHRoZSBjaGFubmVsLlxuICAgICAqL1xuICAgIHVwZGF0ZUpvaW5QYXlsb2FkKHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5qb2luUHVzaC51cGRhdGVQYXlsb2FkKHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWF2ZXMgdGhlIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSBzZXJ2ZXIgZXZlbnRzLCBhbmQgaW5zdHJ1Y3RzIGNoYW5uZWwgdG8gdGVybWluYXRlIG9uIHNlcnZlci5cbiAgICAgKiBUcmlnZ2VycyBvbkNsb3NlKCkgaG9va3MuXG4gICAgICpcbiAgICAgKiBUbyByZWNlaXZlIGxlYXZlIGFja25vd2xlZGdlbWVudHMsIHVzZSB0aGUgYSBgcmVjZWl2ZWAgaG9vayB0byBiaW5kIHRvIHRoZSBzZXJ2ZXIgYWNrLCBpZTpcbiAgICAgKiBjaGFubmVsLnVuc3Vic2NyaWJlKCkucmVjZWl2ZShcIm9rXCIsICgpID0+IGFsZXJ0KFwibGVmdCFcIikgKVxuICAgICAqL1xuICAgIHVuc3Vic2NyaWJlKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGNvbnN0YW50c18xLkNIQU5ORUxfU1RBVEVTLmxlYXZpbmc7XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgbGVhdmUgJHt0aGlzLnRvcGljfWApO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihjb25zdGFudHNfMS5DSEFOTkVMX0VWRU5UUy5jbG9zZSwgJ2xlYXZlJywgdGhpcy5fam9pblJlZigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5qb2luUHVzaC5kZXN0cm95KCk7XG4gICAgICAgIGxldCBsZWF2ZVB1c2ggPSBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGxlYXZlUHVzaCA9IG5ldyBwdXNoXzEuZGVmYXVsdCh0aGlzLCBjb25zdGFudHNfMS5DSEFOTkVMX0VWRU5UUy5sZWF2ZSwge30sIHRpbWVvdXQpO1xuICAgICAgICAgICAgbGVhdmVQdXNoXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ29rJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCdvaycpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgndGltZWQgb3V0Jyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCdlcnJvcicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZWF2ZVB1c2guc2VuZCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYW5QdXNoKCkpIHtcbiAgICAgICAgICAgICAgICBsZWF2ZVB1c2gudHJpZ2dlcignb2snLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgbGVhdmVQdXNoID09PSBudWxsIHx8IGxlYXZlUHVzaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhdmVQdXNoLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlYXJkb3duIHRoZSBjaGFubmVsLlxuICAgICAqXG4gICAgICogRGVzdHJveXMgYW5kIHN0b3BzIHJlbGF0ZWQgdGltZXJzLlxuICAgICAqL1xuICAgIHRlYXJkb3duKCkge1xuICAgICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaCgocHVzaCkgPT4gcHVzaC5kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICB0aGlzLmpvaW5QdXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGNvbnN0YW50c18xLkNIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYXN5bmMgX2ZldGNoV2l0aFRpbWVvdXQodXJsLCBvcHRpb25zLCB0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IGlkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc29ja2V0LmZldGNoKHVybCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3B1c2goZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmpvaW5lZE9uY2UpIHtcbiAgICAgICAgICAgIHRocm93IGB0cmllZCB0byBwdXNoICcke2V2ZW50fScgdG8gJyR7dGhpcy50b3BpY30nIGJlZm9yZSBqb2luaW5nLiBVc2UgY2hhbm5lbC5zdWJzY3JpYmUoKSBiZWZvcmUgcHVzaGluZyBldmVudHNgO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdXNoRXZlbnQgPSBuZXcgcHVzaF8xLmRlZmF1bHQodGhpcywgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpO1xuICAgICAgICBpZiAodGhpcy5fY2FuUHVzaCgpKSB7XG4gICAgICAgICAgICBwdXNoRXZlbnQuc2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9QdXNoQnVmZmVyKHB1c2hFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB1c2hFdmVudDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hZGRUb1B1c2hCdWZmZXIocHVzaEV2ZW50KSB7XG4gICAgICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KTtcbiAgICAgICAgLy8gRW5mb3JjZSBidWZmZXIgc2l6ZSBsaW1pdFxuICAgICAgICBpZiAodGhpcy5wdXNoQnVmZmVyLmxlbmd0aCA+IGNvbnN0YW50c18xLk1BWF9QVVNIX0JVRkZFUl9TSVpFKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkUHVzaCA9IHRoaXMucHVzaEJ1ZmZlci5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHJlbW92ZWRQdXNoKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZFB1c2guZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBkaXNjYXJkZWQgcHVzaCBkdWUgdG8gYnVmZmVyIG92ZXJmbG93OiAke3JlbW92ZWRQdXNoLmV2ZW50fWAsIHJlbW92ZWRQdXNoLnBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRhYmxlIG1lc3NhZ2UgaG9va1xuICAgICAqXG4gICAgICogUmVjZWl2ZXMgYWxsIGV2ZW50cyBmb3Igc3BlY2lhbGl6ZWQgbWVzc2FnZSBoYW5kbGluZyBiZWZvcmUgZGlzcGF0Y2hpbmcgdG8gdGhlIGNoYW5uZWwgY2FsbGJhY2tzLlxuICAgICAqIE11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uTWVzc2FnZShfZXZlbnQsIHBheWxvYWQsIF9yZWYpIHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNNZW1iZXIodG9waWMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9waWMgPT09IHRvcGljO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2pvaW5SZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpvaW5QdXNoLnJlZjtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90cmlnZ2VyKHR5cGUsIHBheWxvYWQsIHJlZikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHsgY2xvc2UsIGVycm9yLCBsZWF2ZSwgam9pbiB9ID0gY29uc3RhbnRzXzEuQ0hBTk5FTF9FVkVOVFM7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IFtjbG9zZSwgZXJyb3IsIGxlYXZlLCBqb2luXTtcbiAgICAgICAgaWYgKHJlZiAmJiBldmVudHMuaW5kZXhPZih0eXBlTG93ZXIpID49IDAgJiYgcmVmICE9PSB0aGlzLl9qb2luUmVmKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGFuZGxlZFBheWxvYWQgPSB0aGlzLl9vbk1lc3NhZ2UodHlwZUxvd2VyLCBwYXlsb2FkLCByZWYpO1xuICAgICAgICBpZiAocGF5bG9hZCAmJiAhaGFuZGxlZFBheWxvYWQpIHtcbiAgICAgICAgICAgIHRocm93ICdjaGFubmVsIG9uTWVzc2FnZSBjYWxsYmFja3MgbXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChbJ2luc2VydCcsICd1cGRhdGUnLCAnZGVsZXRlJ10uaW5jbHVkZXModHlwZUxvd2VyKSkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoX2EgPSBiaW5kLmZpbHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV2ZW50KSA9PT0gJyonIHx8ICgoX2MgPSAoX2IgPSBiaW5kLmZpbHRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV2ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9Mb2NhbGVMb3dlckNhc2UoKSkgPT09IHR5cGVMb3dlcjtcbiAgICAgICAgICAgIH0pLm1hcCgoYmluZCkgPT4gYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICAgICAgICAgIGlmIChbJ2Jyb2FkY2FzdCcsICdwcmVzZW5jZScsICdwb3N0Z3Jlc19jaGFuZ2VzJ10uaW5jbHVkZXModHlwZUxvd2VyKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ2lkJyBpbiBiaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5kSWQgPSBiaW5kLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZEV2ZW50ID0gKF9hID0gYmluZC5maWx0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYmluZElkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYiA9IHBheWxvYWQuaWRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoYmluZElkKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmluZEV2ZW50ID09PSAnKicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJpbmRFdmVudCA9PT0gbnVsbCB8fCBiaW5kRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJpbmRFdmVudC50b0xvY2FsZUxvd2VyQ2FzZSgpKSA9PT0gKChfYyA9IHBheWxvYWQuZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCEoKF9kID0gYmluZC5maWx0ZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50YWJsZSkgfHwgYmluZC5maWx0ZXIudGFibGUgPT09ICgoX2UgPSBwYXlsb2FkLmRhdGEpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS50YWJsZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRFdmVudCA9IChfZyA9IChfZiA9IGJpbmQgPT09IG51bGwgfHwgYmluZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmluZC5maWx0ZXIpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5ldmVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmluZEV2ZW50ID09PSAnKicgfHwgYmluZEV2ZW50ID09PSAoKF9oID0gcGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLmV2ZW50KSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2gudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gdHlwZUxvd2VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLm1hcCgoYmluZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlZFBheWxvYWQgPT09ICdvYmplY3QnICYmICdpZHMnIGluIGhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RncmVzQ2hhbmdlcyA9IGhhbmRsZWRQYXlsb2FkLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hLCB0YWJsZSwgY29tbWl0X3RpbWVzdGFtcCwgdHlwZSwgZXJyb3JzIH0gPSBwb3N0Z3Jlc0NoYW5nZXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVucmljaGVkUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0X3RpbWVzdGFtcDogY29tbWl0X3RpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldzoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGQ6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZWRQYXlsb2FkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnJpY2hlZFBheWxvYWQpLCB0aGlzLl9nZXRQYXlsb2FkUmVjb3Jkcyhwb3N0Z3Jlc0NoYW5nZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBjb25zdGFudHNfMS5DSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNKb2luZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBjb25zdGFudHNfMS5DSEFOTkVMX1NUQVRFUy5qb2luZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNKb2luaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gY29uc3RhbnRzXzEuQ0hBTk5FTF9TVEFURVMuam9pbmluZztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pc0xlYXZpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBjb25zdGFudHNfMS5DSEFOTkVMX1NUQVRFUy5sZWF2aW5nO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3JlcGx5RXZlbnROYW1lKHJlZikge1xuICAgICAgICByZXR1cm4gYGNoYW5fcmVwbHlfJHtyZWZ9YDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVMb3dlcixcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0ucHVzaChiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSA9IFtiaW5kaW5nXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vZmYodHlwZSwgZmlsdGVyKSB7XG4gICAgICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdID0gdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gISgoKF9hID0gYmluZC50eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb2NhbGVMb3dlckNhc2UoKSkgPT09IHR5cGVMb3dlciAmJlxuICAgICAgICAgICAgICAgICAgICBSZWFsdGltZUNoYW5uZWwuaXNFcXVhbChiaW5kLmZpbHRlciwgZmlsdGVyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBpc0VxdWFsKG9iajEsIG9iajIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrIGluIG9iajEpIHtcbiAgICAgICAgICAgIGlmIChvYmoxW2tdICE9PSBvYmoyW2tdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0d28gb3B0aW9uYWwgZmlsdGVyIHZhbHVlcyBmb3IgZXF1YWxpdHkuXG4gICAgICogVHJlYXRzIHVuZGVmaW5lZCwgbnVsbCwgYW5kIGVtcHR5IHN0cmluZyBhcyBlcXVpdmFsZW50IGVtcHR5IHZhbHVlcy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGaWx0ZXJWYWx1ZUVxdWFsKHNlcnZlclZhbHVlLCBjbGllbnRWYWx1ZSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkU2VydmVyID0gc2VydmVyVmFsdWUgIT09IG51bGwgJiYgc2VydmVyVmFsdWUgIT09IHZvaWQgMCA/IHNlcnZlclZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQ2xpZW50ID0gY2xpZW50VmFsdWUgIT09IG51bGwgJiYgY2xpZW50VmFsdWUgIT09IHZvaWQgMCA/IGNsaWVudFZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplZFNlcnZlciA9PT0gbm9ybWFsaXplZENsaWVudDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9yZWpvaW5VbnRpbENvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlam9pbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjaGFubmVsIGNsb3Nlcy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9vbkNsb3NlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uKGNvbnN0YW50c18xLkNIQU5ORUxfRVZFTlRTLmNsb3NlLCB7fSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2hhbm5lbCBlbmNvdW50ZXJlcyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9vbkVycm9yKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uKGNvbnN0YW50c18xLkNIQU5ORUxfRVZFTlRTLmVycm9yLCB7fSwgKHJlYXNvbikgPT4gY2FsbGJhY2socmVhc29uKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkIGFuZCB0aGUgY2hhbm5lbCBoYXMgYmVlbiBqb2luZWQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfY2FuUHVzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5faXNKb2luZWQoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9yZWpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgICBpZiAodGhpcy5faXNMZWF2aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvY2tldC5fbGVhdmVPcGVuVG9waWModGhpcy50b3BpYyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBjb25zdGFudHNfMS5DSEFOTkVMX1NUQVRFUy5qb2luaW5nO1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnJlc2VuZCh0aW1lb3V0KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRQYXlsb2FkUmVjb3JkcyhwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHJlY29yZHMgPSB7XG4gICAgICAgICAgICBuZXc6IHt9LFxuICAgICAgICAgICAgb2xkOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBheWxvYWQudHlwZSA9PT0gJ0lOU0VSVCcgfHwgcGF5bG9hZC50eXBlID09PSAnVVBEQVRFJykge1xuICAgICAgICAgICAgcmVjb3Jkcy5uZXcgPSBUcmFuc2Zvcm1lcnMuY29udmVydENoYW5nZURhdGEocGF5bG9hZC5jb2x1bW5zLCBwYXlsb2FkLnJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBheWxvYWQudHlwZSA9PT0gJ1VQREFURScgfHwgcGF5bG9hZC50eXBlID09PSAnREVMRVRFJykge1xuICAgICAgICAgICAgcmVjb3Jkcy5vbGQgPSBUcmFuc2Zvcm1lcnMuY29udmVydENoYW5nZURhdGEocGF5bG9hZC5jb2x1bW5zLCBwYXlsb2FkLm9sZF9yZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmRzO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJlYWx0aW1lQ2hhbm5lbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlYWx0aW1lQ2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSRUFMVElNRV9DSEFOTkVMX1NUQVRFUyIsIlJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMiLCJSRUFMVElNRV9MSVNURU5fVFlQRVMiLCJSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCIsInRzbGliXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJwdXNoXzEiLCJfX2ltcG9ydERlZmF1bHQiLCJ0aW1lcl8xIiwiUmVhbHRpbWVQcmVzZW5jZV8xIiwiVHJhbnNmb3JtZXJzIiwiX19pbXBvcnRTdGFyIiwidHJhbnNmb3JtZXJzXzEiLCJDSEFOTkVMX1NUQVRFUyIsIlJlYWx0aW1lQ2hhbm5lbCIsImNvbnN0cnVjdG9yIiwidG9waWMiLCJwYXJhbXMiLCJjb25maWciLCJzb2NrZXQiLCJfYSIsIl9iIiwiYmluZGluZ3MiLCJzdGF0ZSIsImNsb3NlZCIsImpvaW5lZE9uY2UiLCJwdXNoQnVmZmVyIiwic3ViVG9waWMiLCJyZXBsYWNlIiwiYXNzaWduIiwiYnJvYWRjYXN0IiwiYWNrIiwic2VsZiIsInByZXNlbmNlIiwia2V5IiwiZW5hYmxlZCIsInByaXZhdGUiLCJ0aW1lb3V0Iiwiam9pblB1c2giLCJkZWZhdWx0IiwiQ0hBTk5FTF9FVkVOVFMiLCJqb2luIiwicmVqb2luVGltZXIiLCJfcmVqb2luVW50aWxDb25uZWN0ZWQiLCJyZWNvbm5lY3RBZnRlck1zIiwicmVjZWl2ZSIsImpvaW5lZCIsInJlc2V0IiwiZm9yRWFjaCIsInB1c2hFdmVudCIsInNlbmQiLCJfb25DbG9zZSIsImxvZyIsIl9qb2luUmVmIiwiX3JlbW92ZSIsIl9vbkVycm9yIiwicmVhc29uIiwiX2lzTGVhdmluZyIsIl9pc0Nsb3NlZCIsImVycm9yZWQiLCJzY2hlZHVsZVRpbWVvdXQiLCJfaXNKb2luaW5nIiwiX29uIiwicmVwbHkiLCJwYXlsb2FkIiwicmVmIiwiX3RyaWdnZXIiLCJfcmVwbHlFdmVudE5hbWUiLCJicm9hZGNhc3RFbmRwb2ludFVSTCIsImh0dHBFbmRwb2ludFVSTCIsImVuZFBvaW50IiwicmVwbGF5Iiwic3Vic2NyaWJlIiwiY2FsbGJhY2siLCJfYyIsImlzQ29ubmVjdGVkIiwiY29ubmVjdCIsImlzUHJpdmF0ZSIsInBvc3RncmVzX2NoYW5nZXMiLCJtYXAiLCJyIiwiZmlsdGVyIiwicHJlc2VuY2VfZW5hYmxlZCIsIlBSRVNFTkNFIiwibGVuZ3RoIiwiYWNjZXNzVG9rZW5QYXlsb2FkIiwiYWNjZXNzVG9rZW5WYWx1ZSIsImFjY2Vzc190b2tlbiIsImUiLCJDSEFOTkVMX0VSUk9SIiwiQ0xPU0VEIiwidXBkYXRlSm9pblBheWxvYWQiLCJfcmVqb2luIiwiX2lzTWFudWFsVG9rZW4iLCJzZXRBdXRoIiwidW5kZWZpbmVkIiwiU1VCU0NSSUJFRCIsImNsaWVudFBvc3RncmVzQmluZGluZ3MiLCJiaW5kaW5nc0xlbiIsIm5ld1Bvc3RncmVzQmluZGluZ3MiLCJpIiwiY2xpZW50UG9zdGdyZXNCaW5kaW5nIiwiZXZlbnQiLCJzY2hlbWEiLCJ0YWJsZSIsInNlcnZlclBvc3RncmVzRmlsdGVyIiwiaXNGaWx0ZXJWYWx1ZUVxdWFsIiwicHVzaCIsImlkIiwidW5zdWJzY3JpYmUiLCJFcnJvciIsImVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInZhbHVlcyIsIlRJTUVEX09VVCIsInByZXNlbmNlU3RhdGUiLCJ0cmFjayIsIm9wdHMiLCJ0eXBlIiwidW50cmFjayIsIm9uIiwidGhlbiIsImh0dHBTZW5kIiwiUHJvbWlzZSIsInJlamVjdCIsImhlYWRlcnMiLCJhcGlrZXkiLCJhcGlLZXkiLCJvcHRpb25zIiwibWV0aG9kIiwiYm9keSIsIm1lc3NhZ2VzIiwicmVzcG9uc2UiLCJfZmV0Y2hXaXRoVGltZW91dCIsInN0YXR1cyIsInN1Y2Nlc3MiLCJlcnJvck1lc3NhZ2UiLCJzdGF0dXNUZXh0IiwiZXJyb3JCb2R5IiwianNvbiIsIm1lc3NhZ2UiLCJhcmdzIiwiX2NhblB1c2giLCJjb25zb2xlIiwid2FybiIsImVuZHBvaW50X3BheWxvYWQiLCJjYW5jZWwiLCJvayIsIm5hbWUiLCJyZXNvbHZlIiwiX3B1c2giLCJ1cGRhdGVQYXlsb2FkIiwibGVhdmluZyIsIm9uQ2xvc2UiLCJjbG9zZSIsImRlc3Ryb3kiLCJsZWF2ZVB1c2giLCJsZWF2ZSIsInRyaWdnZXIiLCJmaW5hbGx5IiwidGVhcmRvd24iLCJ1cmwiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwic2V0VGltZW91dCIsImFib3J0IiwiZmV0Y2giLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJfYWRkVG9QdXNoQnVmZmVyIiwic3RhcnRUaW1lb3V0IiwiTUFYX1BVU0hfQlVGRkVSX1NJWkUiLCJyZW1vdmVkUHVzaCIsInNoaWZ0IiwiX29uTWVzc2FnZSIsIl9ldmVudCIsIl9yZWYiLCJfaXNNZW1iZXIiLCJ0eXBlTG93ZXIiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsImV2ZW50cyIsImluZGV4T2YiLCJoYW5kbGVkUGF5bG9hZCIsImluY2x1ZGVzIiwiYmluZCIsIl9kIiwiX2UiLCJfZiIsIl9nIiwiX2giLCJiaW5kSWQiLCJiaW5kRXZlbnQiLCJpZHMiLCJkYXRhIiwicG9zdGdyZXNDaGFuZ2VzIiwiY29tbWl0X3RpbWVzdGFtcCIsImVycm9ycyIsImVucmljaGVkUGF5bG9hZCIsImV2ZW50VHlwZSIsIm5ldyIsIm9sZCIsIl9nZXRQYXlsb2FkUmVjb3JkcyIsIl9pc0pvaW5lZCIsImpvaW5pbmciLCJiaW5kaW5nIiwiX29mZiIsImlzRXF1YWwiLCJvYmoxIiwib2JqMiIsImtleXMiLCJrIiwic2VydmVyVmFsdWUiLCJjbGllbnRWYWx1ZSIsIm5vcm1hbGl6ZWRTZXJ2ZXIiLCJub3JtYWxpemVkQ2xpZW50IiwiX2xlYXZlT3BlblRvcGljIiwicmVzZW5kIiwicmVjb3JkcyIsImNvbnZlcnRDaGFuZ2VEYXRhIiwiY29sdW1ucyIsInJlY29yZCIsIm9sZF9yZWNvcmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/realtime-js/dist/main/RealtimeChannel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/realtime-js/dist/main/RealtimeClient.js":
/*!************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/main/RealtimeClient.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst websocket_factory_1 = tslib_1.__importDefault(__webpack_require__(/*! ./lib/websocket-factory */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/websocket-factory.js\"));\nconst constants_1 = __webpack_require__(/*! ./lib/constants */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/constants.js\");\nconst serializer_1 = tslib_1.__importDefault(__webpack_require__(/*! ./lib/serializer */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/serializer.js\"));\nconst timer_1 = tslib_1.__importDefault(__webpack_require__(/*! ./lib/timer */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/timer.js\"));\nconst transformers_1 = __webpack_require__(/*! ./lib/transformers */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/transformers.js\");\nconst RealtimeChannel_1 = tslib_1.__importDefault(__webpack_require__(/*! ./RealtimeChannel */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/RealtimeChannel.js\"));\nconst noop = ()=>{};\n// Connection-related constants\nconst CONNECTION_TIMEOUTS = {\n    HEARTBEAT_INTERVAL: 25000,\n    RECONNECT_DELAY: 10,\n    HEARTBEAT_TIMEOUT_FALLBACK: 100\n};\nconst RECONNECT_INTERVALS = [\n    1000,\n    2000,\n    5000,\n    10000\n];\nconst DEFAULT_RECONNECT_FALLBACK = 10000;\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nclass RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.heartbeatCallback The optional function to handle heartbeat status and latency.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.logLevel Sets the log level for Realtime\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n     * @param options.vsn The protocol version to use when connecting. Supported versions are \"1.0.0\" and \"2.0.0\". Defaults to \"2.0.0\".\n     * @example\n     * ```ts\n     * import RealtimeClient from '@supabase/realtime-js'\n     *\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\n     *   params: { apikey: 'public-anon-key' },\n     * })\n     * client.connect()\n     * ```\n     */ constructor(endPoint, options){\n        var _a;\n        this.accessTokenValue = null;\n        this.apiKey = null;\n        this._manuallySetToken = false;\n        this.channels = new Array();\n        this.endPoint = \"\";\n        this.httpEndpoint = \"\";\n        /** @deprecated headers cannot be set on websocket connections */ this.headers = {};\n        this.params = {};\n        this.timeout = constants_1.DEFAULT_TIMEOUT;\n        this.transport = null;\n        this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.heartbeatCallback = noop;\n        this.ref = 0;\n        this.reconnectTimer = null;\n        this.vsn = constants_1.DEFAULT_VSN;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new serializer_1.default();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: []\n        };\n        this.accessToken = null;\n        this._connectionState = \"disconnected\";\n        this._wasManualDisconnect = false;\n        this._authPromise = null;\n        this._heartbeatSentAt = null;\n        /**\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\n         *\n         * @internal\n         */ this._resolveFetch = (customFetch)=>{\n            if (customFetch) {\n                return (...args)=>customFetch(...args);\n            }\n            return (...args)=>fetch(...args);\n        };\n        // Validate required parameters\n        if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {\n            throw new Error(\"API key is required to connect to Realtime\");\n        }\n        this.apiKey = options.params.apikey;\n        // Initialize endpoint URLs\n        this.endPoint = `${endPoint}/${constants_1.TRANSPORTS.websocket}`;\n        this.httpEndpoint = (0, transformers_1.httpEndpointURL)(endPoint);\n        this._initializeOptions(options);\n        this._setupReconnectionTimer();\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */ connect() {\n        // Skip if already connecting, disconnecting, or connected\n        if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {\n            return;\n        }\n        this._setConnectionState(\"connecting\");\n        // Trigger auth if needed and not already in progress\n        // This ensures auth is called for standalone RealtimeClient usage\n        // while avoiding race conditions with SupabaseClient's immediate setAuth call\n        if (this.accessToken && !this._authPromise) {\n            this._setAuthSafely(\"connect\");\n        }\n        // Establish WebSocket connection\n        if (this.transport) {\n            // Use custom transport if provided\n            this.conn = new this.transport(this.endpointURL());\n        } else {\n            // Try to use native WebSocket\n            try {\n                this.conn = websocket_factory_1.default.createWebSocket(this.endpointURL());\n            } catch (error) {\n                this._setConnectionState(\"disconnected\");\n                const errorMessage = error.message;\n                // Provide helpful error message based on environment\n                if (errorMessage.includes(\"Node.js\")) {\n                    throw new Error(`${errorMessage}\\n\\n` + \"To use Realtime in Node.js, you need to provide a WebSocket implementation:\\n\\n\" + \"Option 1: Use Node.js 22+ which has native WebSocket support\\n\" + 'Option 2: Install and provide the \"ws\" package:\\n\\n' + \"  npm install ws\\n\\n\" + '  import ws from \"ws\"\\n' + \"  const client = new RealtimeClient(url, {\\n\" + \"    ...options,\\n\" + \"    transport: ws\\n\" + \"  })\");\n                }\n                throw new Error(`WebSocket not available: ${errorMessage}`);\n            }\n        }\n        this._setupConnectionHandlers();\n    }\n    /**\n     * Returns the URL of the websocket.\n     * @returns string The URL of the websocket.\n     */ endpointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n            vsn: this.vsn\n        }));\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */ disconnect(code, reason) {\n        if (this.isDisconnecting()) {\n            return;\n        }\n        this._setConnectionState(\"disconnecting\", true);\n        if (this.conn) {\n            // Setup fallback timer to prevent hanging in disconnecting state\n            const fallbackTimer = setTimeout(()=>{\n                this._setConnectionState(\"disconnected\");\n            }, 100);\n            this.conn.onclose = ()=>{\n                clearTimeout(fallbackTimer);\n                this._setConnectionState(\"disconnected\");\n            };\n            // Close the WebSocket connection if close method exists\n            if (typeof this.conn.close === \"function\") {\n                if (code) {\n                    this.conn.close(code, reason !== null && reason !== void 0 ? reason : \"\");\n                } else {\n                    this.conn.close();\n                }\n            }\n            this._teardownConnection();\n        } else {\n            this._setConnectionState(\"disconnected\");\n        }\n    }\n    /**\n     * Returns all created channels\n     */ getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */ async removeChannel(channel) {\n        const status = await channel.unsubscribe();\n        if (this.channels.length === 0) {\n            this.disconnect();\n        }\n        return status;\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */ async removeAllChannels() {\n        const values_1 = await Promise.all(this.channels.map((channel)=>channel.unsubscribe()));\n        this.channels = [];\n        this.disconnect();\n        return values_1;\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */ log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */ connectionState() {\n        switch(this.conn && this.conn.readyState){\n            case constants_1.SOCKET_STATES.connecting:\n                return constants_1.CONNECTION_STATE.Connecting;\n            case constants_1.SOCKET_STATES.open:\n                return constants_1.CONNECTION_STATE.Open;\n            case constants_1.SOCKET_STATES.closing:\n                return constants_1.CONNECTION_STATE.Closing;\n            default:\n                return constants_1.CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */ isConnected() {\n        return this.connectionState() === constants_1.CONNECTION_STATE.Open;\n    }\n    /**\n     * Returns `true` if the connection is currently connecting.\n     */ isConnecting() {\n        return this._connectionState === \"connecting\";\n    }\n    /**\n     * Returns `true` if the connection is currently disconnecting.\n     */ isDisconnecting() {\n        return this._connectionState === \"disconnecting\";\n    }\n    /**\n     * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.\n     *\n     * Topics are automatically prefixed with `realtime:` to match the Realtime service.\n     * If a channel with the same topic already exists it will be returned instead of creating\n     * a duplicate connection.\n     */ channel(topic, params = {\n        config: {}\n    }) {\n        const realtimeTopic = `realtime:${topic}`;\n        const exists = this.getChannels().find((c)=>c.topic === realtimeTopic);\n        if (!exists) {\n            const chan = new RealtimeChannel_1.default(`realtime:${topic}`, params, this);\n            this.channels.push(chan);\n            return chan;\n        } else {\n            return exists;\n        }\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */ push(data) {\n        const { topic, event, payload, ref } = data;\n        const callback = ()=>{\n            this.encode(data, (result)=>{\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log(\"push\", `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            callback();\n        } else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\n     *\n     * On callback used, it will set the value of the token internal to the client.\n     *\n     * When a token is explicitly provided, it will be preserved across channel operations\n     * (including removeChannel and resubscribe). The `accessToken` callback will not be\n     * invoked until `setAuth()` is called without arguments.\n     *\n     * @param token A JWT string to override the token set on the client.\n     *\n     * @example\n     * // Use a manual token (preserved across resubscribes, ignores accessToken callback)\n     * client.realtime.setAuth('my-custom-jwt')\n     *\n     * // Switch back to using the accessToken callback\n     * client.realtime.setAuth()\n     */ async setAuth(token = null) {\n        this._authPromise = this._performAuth(token);\n        try {\n            await this._authPromise;\n        } finally{\n            this._authPromise = null;\n        }\n    }\n    /**\n     * Returns true if the current access token was explicitly set via setAuth(token),\n     * false if it was obtained via the accessToken callback.\n     * @internal\n     */ _isManualToken() {\n        return this._manuallySetToken;\n    }\n    /**\n     * Sends a heartbeat message if the socket is connected.\n     */ async sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            try {\n                this.heartbeatCallback(\"disconnected\");\n            } catch (e) {\n                this.log(\"error\", \"error in heartbeat callback\", e);\n            }\n            return;\n        }\n        // Handle heartbeat timeout and force reconnection if needed\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this._heartbeatSentAt = null;\n            this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n            try {\n                this.heartbeatCallback(\"timeout\");\n            } catch (e) {\n                this.log(\"error\", \"error in heartbeat callback\", e);\n            }\n            // Force reconnection after heartbeat timeout\n            this._wasManualDisconnect = false;\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(constants_1.WS_CLOSE_NORMAL, \"heartbeat timeout\");\n            setTimeout(()=>{\n                var _a;\n                if (!this.isConnected()) {\n                    (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n                }\n            }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);\n            return;\n        }\n        // Send heartbeat message to server\n        this._heartbeatSentAt = Date.now();\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: \"phoenix\",\n            event: \"heartbeat\",\n            payload: {},\n            ref: this.pendingHeartbeatRef\n        });\n        try {\n            this.heartbeatCallback(\"sent\");\n        } catch (e) {\n            this.log(\"error\", \"error in heartbeat callback\", e);\n        }\n        this._setAuthSafely(\"heartbeat\");\n    }\n    /**\n     * Sets a callback that receives lifecycle events for internal heartbeat messages.\n     * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).\n     */ onHeartbeat(callback) {\n        this.heartbeatCallback = callback;\n    }\n    /**\n     * Flushes send buffer\n     */ flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback)=>callback());\n            this.sendBuffer = [];\n        }\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */ _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        } else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */ _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c)=>c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */ _remove(channel) {\n        this.channels = this.channels.filter((c)=>c.topic !== channel.topic);\n    }\n    /** @internal */ _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg)=>{\n            // Handle heartbeat responses\n            if (msg.topic === \"phoenix\" && msg.event === \"phx_reply\" && msg.ref && msg.ref === this.pendingHeartbeatRef) {\n                const latency = this._heartbeatSentAt ? Date.now() - this._heartbeatSentAt : undefined;\n                try {\n                    this.heartbeatCallback(msg.payload.status === \"ok\" ? \"ok\" : \"error\", latency);\n                } catch (e) {\n                    this.log(\"error\", \"error in heartbeat callback\", e);\n                }\n                this._heartbeatSentAt = null;\n                this.pendingHeartbeatRef = null;\n            }\n            // Log incoming message\n            const { topic, event, payload, ref } = msg;\n            const refString = ref ? `(${ref})` : \"\";\n            const status = payload.status || \"\";\n            this.log(\"receive\", `${status} ${topic} ${event} ${refString}`.trim(), payload);\n            // Route message to appropriate channels\n            this.channels.filter((channel)=>channel._isMember(topic)).forEach((channel)=>channel._trigger(event, payload, ref));\n            this._triggerStateCallbacks(\"message\", msg);\n        });\n    }\n    /**\n     * Clear specific timer\n     * @internal\n     */ _clearTimer(timer) {\n        var _a;\n        if (timer === \"heartbeat\" && this.heartbeatTimer) {\n            clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = undefined;\n        } else if (timer === \"reconnect\") {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();\n        }\n    }\n    /**\n     * Clear all timers\n     * @internal\n     */ _clearAllTimers() {\n        this._clearTimer(\"heartbeat\");\n        this._clearTimer(\"reconnect\");\n    }\n    /**\n     * Setup connection handlers for WebSocket events\n     * @internal\n     */ _setupConnectionHandlers() {\n        if (!this.conn) return;\n        // Set binary type if supported (browsers and most WebSocket implementations)\n        if (\"binaryType\" in this.conn) {\n            ;\n            this.conn.binaryType = \"arraybuffer\";\n        }\n        this.conn.onopen = ()=>this._onConnOpen();\n        this.conn.onerror = (error)=>this._onConnError(error);\n        this.conn.onmessage = (event)=>this._onConnMessage(event);\n        this.conn.onclose = (event)=>this._onConnClose(event);\n        if (this.conn.readyState === constants_1.SOCKET_STATES.open) {\n            this._onConnOpen();\n        }\n    }\n    /**\n     * Teardown connection and cleanup resources\n     * @internal\n     */ _teardownConnection() {\n        if (this.conn) {\n            if (this.conn.readyState === constants_1.SOCKET_STATES.open || this.conn.readyState === constants_1.SOCKET_STATES.connecting) {\n                try {\n                    this.conn.close();\n                } catch (e) {\n                    this.log(\"error\", \"Error closing connection\", e);\n                }\n            }\n            this.conn.onopen = null;\n            this.conn.onerror = null;\n            this.conn.onmessage = null;\n            this.conn.onclose = null;\n            this.conn = null;\n        }\n        this._clearAllTimers();\n        this._terminateWorker();\n        this.channels.forEach((channel)=>channel.teardown());\n    }\n    /** @internal */ _onConnOpen() {\n        this._setConnectionState(\"connected\");\n        this.log(\"transport\", `connected to ${this.endpointURL()}`);\n        // Wait for any pending auth operations before flushing send buffer\n        // This ensures channel join messages include the correct access token\n        const authPromise = this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());\n        authPromise.then(()=>{\n            this.flushSendBuffer();\n        }).catch((e)=>{\n            this.log(\"error\", \"error waiting for auth on connect\", e);\n            // Proceed anyway to avoid hanging connections\n            this.flushSendBuffer();\n        });\n        this._clearTimer(\"reconnect\");\n        if (!this.worker) {\n            this._startHeartbeat();\n        } else {\n            if (!this.workerRef) {\n                this._startWorkerHeartbeat();\n            }\n        }\n        this._triggerStateCallbacks(\"open\");\n    }\n    /** @internal */ _startHeartbeat() {\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(()=>this.sendHeartbeat(), this.heartbeatIntervalMs);\n    }\n    /** @internal */ _startWorkerHeartbeat() {\n        if (this.workerUrl) {\n            this.log(\"worker\", `starting worker for from ${this.workerUrl}`);\n        } else {\n            this.log(\"worker\", `starting default worker`);\n        }\n        const objectUrl = this._workerObjectUrl(this.workerUrl);\n        this.workerRef = new Worker(objectUrl);\n        this.workerRef.onerror = (error)=>{\n            this.log(\"worker\", \"worker error\", error.message);\n            this._terminateWorker();\n        };\n        this.workerRef.onmessage = (event)=>{\n            if (event.data.event === \"keepAlive\") {\n                this.sendHeartbeat();\n            }\n        };\n        this.workerRef.postMessage({\n            event: \"start\",\n            interval: this.heartbeatIntervalMs\n        });\n    }\n    /**\n     * Terminate the Web Worker and clear the reference\n     * @internal\n     */ _terminateWorker() {\n        if (this.workerRef) {\n            this.log(\"worker\", \"terminating worker\");\n            this.workerRef.terminate();\n            this.workerRef = undefined;\n        }\n    }\n    /** @internal */ _onConnClose(event) {\n        var _a;\n        this._setConnectionState(\"disconnected\");\n        this.log(\"transport\", \"close\", event);\n        this._triggerChanError();\n        this._clearTimer(\"heartbeat\");\n        // Only schedule reconnection if it wasn't a manual disconnect\n        if (!this._wasManualDisconnect) {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n        }\n        this._triggerStateCallbacks(\"close\", event);\n    }\n    /** @internal */ _onConnError(error) {\n        this._setConnectionState(\"disconnected\");\n        this.log(\"transport\", `${error}`);\n        this._triggerChanError();\n        this._triggerStateCallbacks(\"error\", error);\n    }\n    /** @internal */ _triggerChanError() {\n        this.channels.forEach((channel)=>channel._trigger(constants_1.CHANNEL_EVENTS.error));\n    }\n    /** @internal */ _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? \"&\" : \"?\";\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    _workerObjectUrl(url) {\n        let result_url;\n        if (url) {\n            result_url = url;\n        } else {\n            const blob = new Blob([\n                WORKER_SCRIPT\n            ], {\n                type: \"application/javascript\"\n            });\n            result_url = URL.createObjectURL(blob);\n        }\n        return result_url;\n    }\n    /**\n     * Set connection state with proper state management\n     * @internal\n     */ _setConnectionState(state, manual = false) {\n        this._connectionState = state;\n        if (state === \"connecting\") {\n            this._wasManualDisconnect = false;\n        } else if (state === \"disconnecting\") {\n            this._wasManualDisconnect = manual;\n        }\n    }\n    /**\n     * Perform the actual auth operation\n     * @internal\n     */ async _performAuth(token = null) {\n        let tokenToSend;\n        let isManualToken = false;\n        if (token) {\n            tokenToSend = token;\n            // Track if this is a manually-provided token\n            isManualToken = true;\n        } else if (this.accessToken) {\n            // Call the accessToken callback to get fresh token\n            try {\n                tokenToSend = await this.accessToken();\n            } catch (e) {\n                this.log(\"error\", \"Error fetching access token from callback\", e);\n                // Fall back to cached value if callback fails\n                tokenToSend = this.accessTokenValue;\n            }\n        } else {\n            tokenToSend = this.accessTokenValue;\n        }\n        // Track whether this token was manually set or fetched via callback\n        if (isManualToken) {\n            this._manuallySetToken = true;\n        } else if (this.accessToken) {\n            // If we used the callback, clear the manual flag\n            this._manuallySetToken = false;\n        }\n        if (this.accessTokenValue != tokenToSend) {\n            this.accessTokenValue = tokenToSend;\n            this.channels.forEach((channel)=>{\n                const payload = {\n                    access_token: tokenToSend,\n                    version: constants_1.DEFAULT_VERSION\n                };\n                tokenToSend && channel.updateJoinPayload(payload);\n                if (channel.joinedOnce && channel._isJoined()) {\n                    channel._push(constants_1.CHANNEL_EVENTS.access_token, {\n                        access_token: tokenToSend\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Wait for any in-flight auth operations to complete\n     * @internal\n     */ async _waitForAuthIfNeeded() {\n        if (this._authPromise) {\n            await this._authPromise;\n        }\n    }\n    /**\n     * Safely call setAuth with standardized error handling\n     * @internal\n     */ _setAuthSafely(context = \"general\") {\n        // Only refresh auth if using callback-based tokens\n        if (!this._isManualToken()) {\n            this.setAuth().catch((e)=>{\n                this.log(\"error\", `Error setting auth in ${context}`, e);\n            });\n        }\n    }\n    /**\n     * Trigger state change callbacks with proper error handling\n     * @internal\n     */ _triggerStateCallbacks(event, data) {\n        try {\n            this.stateChangeCallbacks[event].forEach((callback)=>{\n                try {\n                    callback(data);\n                } catch (e) {\n                    this.log(\"error\", `error in ${event} callback`, e);\n                }\n            });\n        } catch (e) {\n            this.log(\"error\", `error triggering ${event} callbacks`, e);\n        }\n    }\n    /**\n     * Setup reconnection timer with proper configuration\n     * @internal\n     */ _setupReconnectionTimer() {\n        this.reconnectTimer = new timer_1.default(async ()=>{\n            setTimeout(async ()=>{\n                await this._waitForAuthIfNeeded();\n                if (!this.isConnected()) {\n                    this.connect();\n                }\n            }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);\n        }, this.reconnectAfterMs);\n    }\n    /**\n     * Initialize client options with defaults\n     * @internal\n     */ _initializeOptions(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        // Set defaults\n        this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;\n        this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_TIMEOUT;\n        this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;\n        this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;\n        this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;\n        this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : constants_1.DEFAULT_VSN;\n        // Handle special cases\n        if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n        if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\n            this.logLevel = options.logLevel || options.log_level;\n            this.params = Object.assign(Object.assign({}, this.params), {\n                log_level: this.logLevel\n            });\n        }\n        // Set up functions with defaults\n        this.reconnectAfterMs = (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : (tries)=>{\n            return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;\n        };\n        switch(this.vsn){\n            case constants_1.VSN_1_0_0:\n                this.encode = (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : (payload, callback)=>{\n                    return callback(JSON.stringify(payload));\n                };\n                this.decode = (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : (payload, callback)=>{\n                    return callback(JSON.parse(payload));\n                };\n                break;\n            case constants_1.VSN_2_0_0:\n                this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);\n                this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);\n                break;\n            default:\n                throw new Error(`Unsupported serializer version: ${this.vsn}`);\n        }\n        // Handle worker setup\n        if (this.worker) {\n            if (false) {}\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n        }\n    }\n}\nexports[\"default\"] = RealtimeClient; //# sourceMappingURL=RealtimeClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9SZWFsdGltZUNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxVQUFVQyxtQkFBT0EsQ0FBQyx1REFBTztBQUMvQixNQUFNQyxzQkFBc0JGLFFBQVFHLGVBQWUsQ0FBQ0YsbUJBQU9BLENBQUMsOEdBQXlCO0FBQ3JGLE1BQU1HLGNBQWNILG1CQUFPQSxDQUFDLDhGQUFpQjtBQUM3QyxNQUFNSSxlQUFlTCxRQUFRRyxlQUFlLENBQUNGLG1CQUFPQSxDQUFDLGdHQUFrQjtBQUN2RSxNQUFNSyxVQUFVTixRQUFRRyxlQUFlLENBQUNGLG1CQUFPQSxDQUFDLHNGQUFhO0FBQzdELE1BQU1NLGlCQUFpQk4sbUJBQU9BLENBQUMsb0dBQW9CO0FBQ25ELE1BQU1PLG9CQUFvQlIsUUFBUUcsZUFBZSxDQUFDRixtQkFBT0EsQ0FBQyxrR0FBbUI7QUFDN0UsTUFBTVEsT0FBTyxLQUFRO0FBQ3JCLCtCQUErQjtBQUMvQixNQUFNQyxzQkFBc0I7SUFDeEJDLG9CQUFvQjtJQUNwQkMsaUJBQWlCO0lBQ2pCQyw0QkFBNEI7QUFDaEM7QUFDQSxNQUFNQyxzQkFBc0I7SUFBQztJQUFNO0lBQU07SUFBTTtDQUFNO0FBQ3JELE1BQU1DLDZCQUE2QjtBQUNuQyxNQUFNQyxnQkFBZ0IsQ0FBQzs7Ozs7S0FLbEIsQ0FBQztBQUNOLE1BQU1DO0lBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0E0QkMsR0FDREMsWUFBWUMsUUFBUSxFQUFFQyxPQUFPLENBQUU7UUFDM0IsSUFBSUM7UUFDSixJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJQztRQUNwQixJ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QUlBLFFBQVF5RyxNQUFNLE1BQU0sUUFBUW9HLE9BQU8sS0FBSyxJQUFJQSxLQUFLLElBQUksQ0FBQ3BMLFVBQVUsQ0FBQ2dGLE1BQU0sQ0FBQzhHLElBQUksQ0FBQyxJQUFJLENBQUM5TCxVQUFVO2dCQUNsSyxJQUFJLENBQUMyRyxNQUFNLEdBQUcsQ0FBQzBFLEtBQUs5TSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUW9JLE1BQU0sTUFBTSxRQUFRMEUsT0FBTyxLQUFLLElBQUlBLEtBQUssSUFBSSxDQUFDckwsVUFBVSxDQUFDMkcsTUFBTSxDQUFDbUYsSUFBSSxDQUFDLElBQUksQ0FBQzlMLFVBQVU7Z0JBQ2xLO1lBQ0o7Z0JBQ0ksTUFBTSxJQUFJaUIsTUFBTSxDQUFDLGdDQUFnQyxFQUFFLElBQUksQ0FBQ3RCLEdBQUcsQ0FBQyxDQUFDO1FBQ3JFO1FBQ0Esc0JBQXNCO1FBQ3RCLElBQUksSUFBSSxDQUFDeUksTUFBTSxFQUFFO1lBQ2IsSUFBSSxLQUErQyxFQUFFLEVBRXBEO1lBQ0QsSUFBSSxDQUFDSyxTQUFTLEdBQUdsSyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUWtLLFNBQVM7UUFDeEY7SUFDSjtBQUNKO0FBQ0F4TCxrQkFBZSxHQUFHbUIsZ0JBQ2xCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tYWluL1JlYWx0aW1lQ2xpZW50LmpzPzQ4NjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuY29uc3Qgd2Vic29ja2V0X2ZhY3RvcnlfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi93ZWJzb2NrZXQtZmFjdG9yeVwiKSk7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2xpYi9jb25zdGFudHNcIik7XG5jb25zdCBzZXJpYWxpemVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9saWIvc2VyaWFsaXplclwiKSk7XG5jb25zdCB0aW1lcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbGliL3RpbWVyXCIpKTtcbmNvbnN0IHRyYW5zZm9ybWVyc18xID0gcmVxdWlyZShcIi4vbGliL3RyYW5zZm9ybWVyc1wiKTtcbmNvbnN0IFJlYWx0aW1lQ2hhbm5lbF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUmVhbHRpbWVDaGFubmVsXCIpKTtcbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG4vLyBDb25uZWN0aW9uLXJlbGF0ZWQgY29uc3RhbnRzXG5jb25zdCBDT05ORUNUSU9OX1RJTUVPVVRTID0ge1xuICAgIEhFQVJUQkVBVF9JTlRFUlZBTDogMjUwMDAsXG4gICAgUkVDT05ORUNUX0RFTEFZOiAxMCxcbiAgICBIRUFSVEJFQVRfVElNRU9VVF9GQUxMQkFDSzogMTAwLFxufTtcbmNvbnN0IFJFQ09OTkVDVF9JTlRFUlZBTFMgPSBbMTAwMCwgMjAwMCwgNTAwMCwgMTAwMDBdO1xuY29uc3QgREVGQVVMVF9SRUNPTk5FQ1RfRkFMTEJBQ0sgPSAxMDAwMDtcbmNvbnN0IFdPUktFUl9TQ1JJUFQgPSBgXG4gIGFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKSA9PiB7XG4gICAgaWYgKGUuZGF0YS5ldmVudCA9PT0gXCJzdGFydFwiKSB7XG4gICAgICBzZXRJbnRlcnZhbCgoKSA9PiBwb3N0TWVzc2FnZSh7IGV2ZW50OiBcImtlZXBBbGl2ZVwiIH0pLCBlLmRhdGEuaW50ZXJ2YWwpO1xuICAgIH1cbiAgfSk7YDtcbmNsYXNzIFJlYWx0aW1lQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgU29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuZFBvaW50IFRoZSBzdHJpbmcgV2ViU29ja2V0IGVuZHBvaW50LCBpZSwgXCJ3czovL2V4YW1wbGUuY29tL3NvY2tldFwiLCBcIndzczovL2V4YW1wbGUuY29tXCIsIFwiL3NvY2tldFwiIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICAgICAqIEBwYXJhbSBodHRwRW5kcG9pbnQgVGhlIHN0cmluZyBIVFRQIGVuZHBvaW50LCBpZSwgXCJodHRwczovL2V4YW1wbGUuY29tXCIsIFwiL1wiIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zcG9ydCBUaGUgV2Vic29ja2V0IFRyYW5zcG9ydCwgZm9yIGV4YW1wbGUgV2ViU29ja2V0LiBUaGlzIGNhbiBiZSBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXQgVGhlIGRlZmF1bHQgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gdHJpZ2dlciBwdXNoIHRpbWVvdXRzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhcmFtcyBUaGUgb3B0aW9uYWwgcGFyYW1zIHRvIHBhc3Mgd2hlbiBjb25uZWN0aW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgRGVwcmVjYXRlZDogaGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIHdlYnNvY2tldCBjb25uZWN0aW9ucyBhbmQgdGhpcyBvcHRpb24gd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhcnRiZWF0SW50ZXJ2YWxNcyBUaGUgbWlsbGlzZWMgaW50ZXJ2YWwgdG8gc2VuZCBhIGhlYXJ0YmVhdCBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYXJ0YmVhdENhbGxiYWNrIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0byBoYW5kbGUgaGVhcnRiZWF0IHN0YXR1cyBhbmQgbGF0ZW5jeS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5sb2dnZXIgVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLCBpZTogbG9nZ2VyOiAoa2luZCwgbXNnLCBkYXRhKSA9PiB7IGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKSB9XG4gICAgICogQHBhcmFtIG9wdGlvbnMubG9nTGV2ZWwgU2V0cyB0aGUgbG9nIGxldmVsIGZvciBSZWFsdGltZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmVuY29kZSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBKU09OOiAocGF5bG9hZCwgY2FsbGJhY2spID0+IGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlY29kZSBUaGUgZnVuY3Rpb24gdG8gZGVjb2RlIGluY29taW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBTZXJpYWxpemVyJ3MgZGVjb2RlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlY29ubmVjdEFmdGVyTXMgaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsc2VjIHJlY29ubmVjdCBpbnRlcnZhbC4gRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mZi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy53b3JrZXIgVXNlIFdlYiBXb3JrZXIgdG8gc2V0IGEgc2lkZSBmbG93LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy53b3JrZXJVcmwgVGhlIFVSTCBvZiB0aGUgd29ya2VyIHNjcmlwdC4gRGVmYXVsdHMgdG8gaHR0cHM6Ly9yZWFsdGltZS5zdXBhYmFzZS5jb20vd29ya2VyLmpzIHRoYXQgaW5jbHVkZXMgYSBoZWFydGJlYXQgZXZlbnQgY2FsbCB0byBrZWVwIHRoZSBjb25uZWN0aW9uIGFsaXZlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnZzbiBUaGUgcHJvdG9jb2wgdmVyc2lvbiB0byB1c2Ugd2hlbiBjb25uZWN0aW5nLiBTdXBwb3J0ZWQgdmVyc2lvbnMgYXJlIFwiMS4wLjBcIiBhbmQgXCIyLjAuMFwiLiBEZWZhdWx0cyB0byBcIjIuMC4wXCIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCBSZWFsdGltZUNsaWVudCBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnXG4gICAgICpcbiAgICAgKiBjb25zdCBjbGllbnQgPSBuZXcgUmVhbHRpbWVDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9yZWFsdGltZS92MScsIHtcbiAgICAgKiAgIHBhcmFtczogeyBhcGlrZXk6ICdwdWJsaWMtYW5vbi1rZXknIH0sXG4gICAgICogfSlcbiAgICAgKiBjbGllbnQuY29ubmVjdCgpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW5kUG9pbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmFwaUtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hbnVhbGx5U2V0VG9rZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmVuZFBvaW50ID0gJyc7XG4gICAgICAgIHRoaXMuaHR0cEVuZHBvaW50ID0gJyc7XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCBoZWFkZXJzIGNhbm5vdCBiZSBzZXQgb24gd2Vic29ja2V0IGNvbm5lY3Rpb25zICovXG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHt9O1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBjb25zdGFudHNfMS5ERUZBVUxUX1RJTUVPVVQ7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zID0gQ09OTkVDVElPTl9USU1FT1VUUy5IRUFSVEJFQVRfSU5URVJWQUw7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2sgPSBub29wO1xuICAgICAgICB0aGlzLnJlZiA9IDA7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnZzbiA9IGNvbnN0YW50c18xLkRFRkFVTFRfVlNOO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IG5vb3A7XG4gICAgICAgIHRoaXMuY29ubiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBuZXcgc2VyaWFsaXplcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9wZW46IFtdLFxuICAgICAgICAgICAgY2xvc2U6IFtdLFxuICAgICAgICAgICAgZXJyb3I6IFtdLFxuICAgICAgICAgICAgbWVzc2FnZTogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPSAnZGlzY29ubmVjdGVkJztcbiAgICAgICAgdGhpcy5fd2FzTWFudWFsRGlzY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hdXRoUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdFNlbnRBdCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgZWl0aGVyIGN1c3RvbSBmZXRjaCwgaWYgcHJvdmlkZWQsIG9yIGRlZmF1bHQgZmV0Y2ggdG8gbWFrZSBIVFRQIHJlcXVlc3RzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVmFsaWRhdGUgcmVxdWlyZWQgcGFyYW1ldGVyc1xuICAgICAgICBpZiAoISgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBpa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBUEkga2V5IGlzIHJlcXVpcmVkIHRvIGNvbm5lY3QgdG8gUmVhbHRpbWUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaUtleSA9IG9wdGlvbnMucGFyYW1zLmFwaWtleTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBlbmRwb2ludCBVUkxzXG4gICAgICAgIHRoaXMuZW5kUG9pbnQgPSBgJHtlbmRQb2ludH0vJHtjb25zdGFudHNfMS5UUkFOU1BPUlRTLndlYnNvY2tldH1gO1xuICAgICAgICB0aGlzLmh0dHBFbmRwb2ludCA9ICgwLCB0cmFuc2Zvcm1lcnNfMS5odHRwRW5kcG9pbnRVUkwpKGVuZFBvaW50KTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3NldHVwUmVjb25uZWN0aW9uVGltZXIoKTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IHRoaXMuX3Jlc29sdmVGZXRjaChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyB0aGUgc29ja2V0LCB1bmxlc3MgYWxyZWFkeSBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgLy8gU2tpcCBpZiBhbHJlYWR5IGNvbm5lY3RpbmcsIGRpc2Nvbm5lY3RpbmcsIG9yIGNvbm5lY3RlZFxuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RpbmcoKSB8fFxuICAgICAgICAgICAgdGhpcy5pc0Rpc2Nvbm5lY3RpbmcoKSB8fFxuICAgICAgICAgICAgKHRoaXMuY29ubiAhPT0gbnVsbCAmJiB0aGlzLmlzQ29ubmVjdGVkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0aW5nJyk7XG4gICAgICAgIC8vIFRyaWdnZXIgYXV0aCBpZiBuZWVkZWQgYW5kIG5vdCBhbHJlYWR5IGluIHByb2dyZXNzXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyBhdXRoIGlzIGNhbGxlZCBmb3Igc3RhbmRhbG9uZSBSZWFsdGltZUNsaWVudCB1c2FnZVxuICAgICAgICAvLyB3aGlsZSBhdm9pZGluZyByYWNlIGNvbmRpdGlvbnMgd2l0aCBTdXBhYmFzZUNsaWVudCdzIGltbWVkaWF0ZSBzZXRBdXRoIGNhbGxcbiAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4gJiYgIXRoaXMuX2F1dGhQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRBdXRoU2FmZWx5KCdjb25uZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXN0YWJsaXNoIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgLy8gVXNlIGN1c3RvbSB0cmFuc3BvcnQgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIHRoaXMuY29ubiA9IG5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLmVuZHBvaW50VVJMKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHVzZSBuYXRpdmUgV2ViU29ja2V0XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubiA9IHdlYnNvY2tldF9mYWN0b3J5XzEuZGVmYXVsdC5jcmVhdGVXZWJTb2NrZXQodGhpcy5lbmRwb2ludFVSTCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAvLyBQcm92aWRlIGhlbHBmdWwgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiBlbnZpcm9ubWVudFxuICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ05vZGUuanMnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JNZXNzYWdlfVxcblxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1RvIHVzZSBSZWFsdGltZSBpbiBOb2RlLmpzLCB5b3UgbmVlZCB0byBwcm92aWRlIGEgV2ViU29ja2V0IGltcGxlbWVudGF0aW9uOlxcblxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ09wdGlvbiAxOiBVc2UgTm9kZS5qcyAyMisgd2hpY2ggaGFzIG5hdGl2ZSBXZWJTb2NrZXQgc3VwcG9ydFxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ09wdGlvbiAyOiBJbnN0YWxsIGFuZCBwcm92aWRlIHRoZSBcIndzXCIgcGFja2FnZTpcXG5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgIG5wbSBpbnN0YWxsIHdzXFxuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICBpbXBvcnQgd3MgZnJvbSBcIndzXCJcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgIGNvbnN0IGNsaWVudCA9IG5ldyBSZWFsdGltZUNsaWVudCh1cmwsIHtcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgICAgLi4ub3B0aW9ucyxcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgICAgdHJhbnNwb3J0OiB3c1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAgfSknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXZWJTb2NrZXQgbm90IGF2YWlsYWJsZTogJHtlcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0dXBDb25uZWN0aW9uSGFuZGxlcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVVJMIG9mIHRoZSB3ZWJzb2NrZXQuXG4gICAgICogQHJldHVybnMgc3RyaW5nIFRoZSBVUkwgb2YgdGhlIHdlYnNvY2tldC5cbiAgICAgKi9cbiAgICBlbmRwb2ludFVSTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZFBhcmFtcyh0aGlzLmVuZFBvaW50LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcmFtcywgeyB2c246IHRoaXMudnNuIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgdGhlIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2RlIEEgbnVtZXJpYyBzdGF0dXMgY29kZSB0byBzZW5kIG9uIGRpc2Nvbm5lY3QuXG4gICAgICogQHBhcmFtIHJlYXNvbiBBIGN1c3RvbSByZWFzb24gZm9yIHRoZSBkaXNjb25uZWN0LlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoY29kZSwgcmVhc29uKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzY29ubmVjdGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0aW5nJywgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgICAgIC8vIFNldHVwIGZhbGxiYWNrIHRpbWVyIHRvIHByZXZlbnQgaGFuZ2luZyBpbiBkaXNjb25uZWN0aW5nIHN0YXRlXG4gICAgICAgICAgICBjb25zdCBmYWxsYmFja1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZmFsbGJhY2tUaW1lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBDbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaWYgY2xvc2UgbWV0aG9kIGV4aXN0c1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbm4uY2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uICE9PSBudWxsICYmIHJlYXNvbiAhPT0gdm9pZCAwID8gcmVhc29uIDogJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdGVhcmRvd25Db25uZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGNyZWF0ZWQgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBnZXRDaGFubmVscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhIHNpbmdsZSBjaGFubmVsXG4gICAgICogQHBhcmFtIGNoYW5uZWwgQSBSZWFsdGltZUNoYW5uZWwgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVDaGFubmVsKGNoYW5uZWwpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgY2hhbm5lbC51bnN1YnNjcmliZSgpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhbGwgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVBbGxDaGFubmVscygpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzXzEgPSBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmNoYW5uZWxzLm1hcCgoY2hhbm5lbCkgPT4gY2hhbm5lbC51bnN1YnNjcmliZSgpKSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIHJldHVybiB2YWx1ZXNfMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyB0aGUgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEZvciBjdXN0b21pemVkIGxvZ2dpbmcsIGB0aGlzLmxvZ2dlcmAgY2FuIGJlIG92ZXJyaWRkZW4uXG4gICAgICovXG4gICAgbG9nKGtpbmQsIG1zZywgZGF0YSkge1xuICAgICAgICB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzb2NrZXQuXG4gICAgICovXG4gICAgY29ubmVjdGlvblN0YXRlKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4ucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5TT0NLRVRfU1RBVEVTLmNvbm5lY3Rpbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLkNPTk5FQ1RJT05fU1RBVEUuQ29ubmVjdGluZztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuU09DS0VUX1NUQVRFUy5vcGVuOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5DT05ORUNUSU9OX1NUQVRFLk9wZW47XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLlNPQ0tFVF9TVEFURVMuY2xvc2luZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuQ09OTkVDVElPTl9TVEFURS5DbG9zaW5nO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuQ09OTkVDVElPTl9TVEFURS5DbG9zZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaXMgdGhlIGNvbm5lY3Rpb24gaXMgb3Blbi5cbiAgICAgKi9cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblN0YXRlKCkgPT09IGNvbnN0YW50c18xLkNPTk5FQ1RJT05fU1RBVEUuT3BlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbm5lY3Rpb24gaXMgY3VycmVudGx5IGNvbm5lY3RpbmcuXG4gICAgICovXG4gICAgaXNDb25uZWN0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGluZyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBjb25uZWN0aW9uIGlzIGN1cnJlbnRseSBkaXNjb25uZWN0aW5nLlxuICAgICAqL1xuICAgIGlzRGlzY29ubmVjdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RpbmcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIChvciByZXVzZXMpIGEge0BsaW5rIFJlYWx0aW1lQ2hhbm5lbH0gZm9yIHRoZSBwcm92aWRlZCB0b3BpYy5cbiAgICAgKlxuICAgICAqIFRvcGljcyBhcmUgYXV0b21hdGljYWxseSBwcmVmaXhlZCB3aXRoIGByZWFsdGltZTpgIHRvIG1hdGNoIHRoZSBSZWFsdGltZSBzZXJ2aWNlLlxuICAgICAqIElmIGEgY2hhbm5lbCB3aXRoIHRoZSBzYW1lIHRvcGljIGFscmVhZHkgZXhpc3RzIGl0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBjcmVhdGluZ1xuICAgICAqIGEgZHVwbGljYXRlIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgY2hhbm5lbCh0b3BpYywgcGFyYW1zID0geyBjb25maWc6IHt9IH0pIHtcbiAgICAgICAgY29uc3QgcmVhbHRpbWVUb3BpYyA9IGByZWFsdGltZToke3RvcGljfWA7XG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IHRoaXMuZ2V0Q2hhbm5lbHMoKS5maW5kKChjKSA9PiBjLnRvcGljID09PSByZWFsdGltZVRvcGljKTtcbiAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW4gPSBuZXcgUmVhbHRpbWVDaGFubmVsXzEuZGVmYXVsdChgcmVhbHRpbWU6JHt0b3BpY31gLCBwYXJhbXMsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscy5wdXNoKGNoYW4pO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2ggb3V0IGEgbWVzc2FnZSBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBzb2NrZXQgaXMgbm90IGNvbm5lY3RlZCwgdGhlIG1lc3NhZ2UgZ2V0cyBlbnF1ZXVlZCB3aXRoaW4gYSBsb2NhbCBidWZmZXIsIGFuZCBzZW50IG91dCB3aGVuIGEgY29ubmVjdGlvbiBpcyBuZXh0IGVzdGFibGlzaGVkLlxuICAgICAqL1xuICAgIHB1c2goZGF0YSkge1xuICAgICAgICBjb25zdCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmIH0gPSBkYXRhO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlKGRhdGEsIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5jb25uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZChyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nKCdwdXNoJywgYCR7dG9waWN9ICR7ZXZlbnR9ICgke3JlZn0pYCwgcGF5bG9hZCk7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgSldUIGFjY2VzcyB0b2tlbiB1c2VkIGZvciBjaGFubmVsIHN1YnNjcmlwdGlvbiBhdXRob3JpemF0aW9uIGFuZCBSZWFsdGltZSBSTFMuXG4gICAgICpcbiAgICAgKiBJZiBwYXJhbSBpcyBudWxsIGl0IHdpbGwgdXNlIHRoZSBgYWNjZXNzVG9rZW5gIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIHRoZSB0b2tlbiBzZXQgb24gdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIE9uIGNhbGxiYWNrIHVzZWQsIGl0IHdpbGwgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gaW50ZXJuYWwgdG8gdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIFdoZW4gYSB0b2tlbiBpcyBleHBsaWNpdGx5IHByb3ZpZGVkLCBpdCB3aWxsIGJlIHByZXNlcnZlZCBhY3Jvc3MgY2hhbm5lbCBvcGVyYXRpb25zXG4gICAgICogKGluY2x1ZGluZyByZW1vdmVDaGFubmVsIGFuZCByZXN1YnNjcmliZSkuIFRoZSBgYWNjZXNzVG9rZW5gIGNhbGxiYWNrIHdpbGwgbm90IGJlXG4gICAgICogaW52b2tlZCB1bnRpbCBgc2V0QXV0aCgpYCBpcyBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW4gQSBKV1Qgc3RyaW5nIHRvIG92ZXJyaWRlIHRoZSB0b2tlbiBzZXQgb24gdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gVXNlIGEgbWFudWFsIHRva2VuIChwcmVzZXJ2ZWQgYWNyb3NzIHJlc3Vic2NyaWJlcywgaWdub3JlcyBhY2Nlc3NUb2tlbiBjYWxsYmFjaylcbiAgICAgKiBjbGllbnQucmVhbHRpbWUuc2V0QXV0aCgnbXktY3VzdG9tLWp3dCcpXG4gICAgICpcbiAgICAgKiAvLyBTd2l0Y2ggYmFjayB0byB1c2luZyB0aGUgYWNjZXNzVG9rZW4gY2FsbGJhY2tcbiAgICAgKiBjbGllbnQucmVhbHRpbWUuc2V0QXV0aCgpXG4gICAgICovXG4gICAgYXN5bmMgc2V0QXV0aCh0b2tlbiA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fYXV0aFByb21pc2UgPSB0aGlzLl9wZXJmb3JtQXV0aCh0b2tlbik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hdXRoUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2F1dGhQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgYWNjZXNzIHRva2VuIHdhcyBleHBsaWNpdGx5IHNldCB2aWEgc2V0QXV0aCh0b2tlbiksXG4gICAgICogZmFsc2UgaWYgaXQgd2FzIG9idGFpbmVkIHZpYSB0aGUgYWNjZXNzVG9rZW4gY2FsbGJhY2suXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2lzTWFudWFsVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYW51YWxseVNldFRva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGhlYXJ0YmVhdCBtZXNzYWdlIGlmIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRIZWFydGJlYXQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjaygnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsICdlcnJvciBpbiBoZWFydGJlYXQgY2FsbGJhY2snLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgaGVhcnRiZWF0IHRpbWVvdXQgYW5kIGZvcmNlIHJlY29ubmVjdGlvbiBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdFNlbnRBdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgJ2hlYXJ0YmVhdCB0aW1lb3V0LiBBdHRlbXB0aW5nIHRvIHJlLWVzdGFibGlzaCBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2soJ3RpbWVvdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ2Vycm9yIGluIGhlYXJ0YmVhdCBjYWxsYmFjaycsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yY2UgcmVjb25uZWN0aW9uIGFmdGVyIGhlYXJ0YmVhdCB0aW1lb3V0XG4gICAgICAgICAgICB0aGlzLl93YXNNYW51YWxEaXNjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmNvbm4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZShjb25zdGFudHNfMS5XU19DTE9TRV9OT1JNQUwsICdoZWFydGJlYXQgdGltZW91dCcpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucmVjb25uZWN0VGltZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBDT05ORUNUSU9OX1RJTUVPVVRTLkhFQVJUQkVBVF9USU1FT1VUX0ZBTExCQUNLKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZW5kIGhlYXJ0YmVhdCBtZXNzYWdlIHRvIHNlcnZlclxuICAgICAgICB0aGlzLl9oZWFydGJlYXRTZW50QXQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSB0aGlzLl9tYWtlUmVmKCk7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICB0b3BpYzogJ3Bob2VuaXgnLFxuICAgICAgICAgICAgZXZlbnQ6ICdoZWFydGJlYXQnLFxuICAgICAgICAgICAgcGF5bG9hZDoge30sXG4gICAgICAgICAgICByZWY6IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZixcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrKCdzZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsICdlcnJvciBpbiBoZWFydGJlYXQgY2FsbGJhY2snLCBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRBdXRoU2FmZWx5KCdoZWFydGJlYXQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgbGlmZWN5Y2xlIGV2ZW50cyBmb3IgaW50ZXJuYWwgaGVhcnRiZWF0IG1lc3NhZ2VzLlxuICAgICAqIFVzZWZ1bCBmb3IgaW5zdHJ1bWVudGluZyBjb25uZWN0aW9uIGhlYWx0aCAoZS5nLiBzZW50L29rL3RpbWVvdXQvZGlzY29ubmVjdGVkKS5cbiAgICAgKi9cbiAgICBvbkhlYXJ0YmVhdChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoZXMgc2VuZCBidWZmZXJcbiAgICAgKi9cbiAgICBmbHVzaFNlbmRCdWZmZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZEJ1ZmZlci5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSk7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG5leHQgbWVzc2FnZSByZWYsIGFjY291bnRpbmcgZm9yIG92ZXJmbG93c1xuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX21ha2VSZWYoKSB7XG4gICAgICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZiArIDE7XG4gICAgICAgIGlmIChuZXdSZWYgPT09IHRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLnJlZiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZiA9IG5ld1JlZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWYudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgZnJvbSBjaGFubmVscyB3aXRoIHRoZSBzcGVjaWZpZWQgdG9waWMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfbGVhdmVPcGVuVG9waWModG9waWMpIHtcbiAgICAgICAgbGV0IGR1cENoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmZpbmQoKGMpID0+IGMudG9waWMgPT09IHRvcGljICYmIChjLl9pc0pvaW5lZCgpIHx8IGMuX2lzSm9pbmluZygpKSk7XG4gICAgICAgIGlmIChkdXBDaGFubmVsKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgYGxlYXZpbmcgZHVwbGljYXRlIHRvcGljIFwiJHt0b3BpY31cImApO1xuICAgICAgICAgICAgZHVwQ2hhbm5lbC51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzdWJzY3JpcHRpb24gZnJvbSB0aGUgc29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgQW4gb3BlbiBzdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfcmVtb3ZlKGNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZmlsdGVyKChjKSA9PiBjLnRvcGljICE9PSBjaGFubmVsLnRvcGljKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbkNvbm5NZXNzYWdlKHJhd01lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5kZWNvZGUocmF3TWVzc2FnZS5kYXRhLCAobXNnKSA9PiB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgaGVhcnRiZWF0IHJlc3BvbnNlc1xuICAgICAgICAgICAgaWYgKG1zZy50b3BpYyA9PT0gJ3Bob2VuaXgnICYmXG4gICAgICAgICAgICAgICAgbXNnLmV2ZW50ID09PSAncGh4X3JlcGx5JyAmJlxuICAgICAgICAgICAgICAgIG1zZy5yZWYgJiZcbiAgICAgICAgICAgICAgICBtc2cucmVmID09PSB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXRlbmN5ID0gdGhpcy5faGVhcnRiZWF0U2VudEF0ID8gRGF0ZS5ub3coKSAtIHRoaXMuX2hlYXJ0YmVhdFNlbnRBdCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrKG1zZy5wYXlsb2FkLnN0YXR1cyA9PT0gJ29rJyA/ICdvaycgOiAnZXJyb3InLCBsYXRlbmN5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ2Vycm9yIGluIGhlYXJ0YmVhdCBjYWxsYmFjaycsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRTZW50QXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb2cgaW5jb21pbmcgbWVzc2FnZVxuICAgICAgICAgICAgY29uc3QgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiB9ID0gbXNnO1xuICAgICAgICAgICAgY29uc3QgcmVmU3RyaW5nID0gcmVmID8gYCgke3JlZn0pYCA6ICcnO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gcGF5bG9hZC5zdGF0dXMgfHwgJyc7XG4gICAgICAgICAgICB0aGlzLmxvZygncmVjZWl2ZScsIGAke3N0YXR1c30gJHt0b3BpY30gJHtldmVudH0gJHtyZWZTdHJpbmd9YC50cmltKCksIHBheWxvYWQpO1xuICAgICAgICAgICAgLy8gUm91dGUgbWVzc2FnZSB0byBhcHByb3ByaWF0ZSBjaGFubmVsc1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGNoYW5uZWwpID0+IGNoYW5uZWwuX2lzTWVtYmVyKHRvcGljKSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoY2hhbm5lbCkgPT4gY2hhbm5lbC5fdHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmKSk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyU3RhdGVDYWxsYmFja3MoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgc3BlY2lmaWMgdGltZXJcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfY2xlYXJUaW1lcih0aW1lcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aW1lciA9PT0gJ2hlYXJ0YmVhdCcgJiYgdGhpcy5oZWFydGJlYXRUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGltZXIgPT09ICdyZWNvbm5lY3QnKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnJlY29ubmVjdFRpbWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgdGltZXJzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2NsZWFyQWxsVGltZXJzKCkge1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVyKCdoZWFydGJlYXQnKTtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lcigncmVjb25uZWN0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHVwIGNvbm5lY3Rpb24gaGFuZGxlcnMgZm9yIFdlYlNvY2tldCBldmVudHNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfc2V0dXBDb25uZWN0aW9uSGFuZGxlcnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBTZXQgYmluYXJ5IHR5cGUgaWYgc3VwcG9ydGVkIChicm93c2VycyBhbmQgbW9zdCBXZWJTb2NrZXQgaW1wbGVtZW50YXRpb25zKVxuICAgICAgICBpZiAoJ2JpbmFyeVR5cGUnIGluIHRoaXMuY29ubikge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdGhpcy5jb25uLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLl9vbkNvbm5PcGVuKCk7XG4gICAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gKGVycm9yKSA9PiB0aGlzLl9vbkNvbm5FcnJvcihlcnJvcik7XG4gICAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHRoaXMuX29uQ29ubk1lc3NhZ2UoZXZlbnQpO1xuICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IChldmVudCkgPT4gdGhpcy5fb25Db25uQ2xvc2UoZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5jb25uLnJlYWR5U3RhdGUgPT09IGNvbnN0YW50c18xLlNPQ0tFVF9TVEFURVMub3Blbikge1xuICAgICAgICAgICAgdGhpcy5fb25Db25uT3BlbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlYXJkb3duIGNvbm5lY3Rpb24gYW5kIGNsZWFudXAgcmVzb3VyY2VzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3RlYXJkb3duQ29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubi5yZWFkeVN0YXRlID09PSBjb25zdGFudHNfMS5TT0NLRVRfU1RBVEVTLm9wZW4gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm4ucmVhZHlTdGF0ZSA9PT0gY29uc3RhbnRzXzEuU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsICdFcnJvciBjbG9zaW5nIGNvbm5lY3Rpb24nLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25vcGVuID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb25uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGVhckFsbFRpbWVycygpO1xuICAgICAgICB0aGlzLl90ZXJtaW5hdGVXb3JrZXIoKTtcbiAgICAgICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiBjaGFubmVsLnRlYXJkb3duKCkpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29uQ29ubk9wZW4oKSB7XG4gICAgICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnY29ubmVjdGVkJyk7XG4gICAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCBgY29ubmVjdGVkIHRvICR7dGhpcy5lbmRwb2ludFVSTCgpfWApO1xuICAgICAgICAvLyBXYWl0IGZvciBhbnkgcGVuZGluZyBhdXRoIG9wZXJhdGlvbnMgYmVmb3JlIGZsdXNoaW5nIHNlbmQgYnVmZmVyXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyBjaGFubmVsIGpvaW4gbWVzc2FnZXMgaW5jbHVkZSB0aGUgY29ycmVjdCBhY2Nlc3MgdG9rZW5cbiAgICAgICAgY29uc3QgYXV0aFByb21pc2UgPSB0aGlzLl9hdXRoUHJvbWlzZSB8fFxuICAgICAgICAgICAgKHRoaXMuYWNjZXNzVG9rZW4gJiYgIXRoaXMuYWNjZXNzVG9rZW5WYWx1ZSA/IHRoaXMuc2V0QXV0aCgpIDogUHJvbWlzZS5yZXNvbHZlKCkpO1xuICAgICAgICBhdXRoUHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mbHVzaFNlbmRCdWZmZXIoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ2Vycm9yIHdhaXRpbmcgZm9yIGF1dGggb24gY29ubmVjdCcsIGUpO1xuICAgICAgICAgICAgLy8gUHJvY2VlZCBhbnl3YXkgdG8gYXZvaWQgaGFuZ2luZyBjb25uZWN0aW9uc1xuICAgICAgICAgICAgdGhpcy5mbHVzaFNlbmRCdWZmZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2NsZWFyVGltZXIoJ3JlY29ubmVjdCcpO1xuICAgICAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydEhlYXJ0YmVhdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLndvcmtlclJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0V29ya2VySGVhcnRiZWF0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKCdvcGVuJyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc3RhcnRIZWFydGJlYXQoKSB7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3N0YXJ0V29ya2VySGVhcnRiZWF0KCkge1xuICAgICAgICBpZiAodGhpcy53b3JrZXJVcmwpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCd3b3JrZXInLCBgc3RhcnRpbmcgd29ya2VyIGZvciBmcm9tICR7dGhpcy53b3JrZXJVcmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnd29ya2VyJywgYHN0YXJ0aW5nIGRlZmF1bHQgd29ya2VyYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JqZWN0VXJsID0gdGhpcy5fd29ya2VyT2JqZWN0VXJsKHRoaXMud29ya2VyVXJsKTtcbiAgICAgICAgdGhpcy53b3JrZXJSZWYgPSBuZXcgV29ya2VyKG9iamVjdFVybCk7XG4gICAgICAgIHRoaXMud29ya2VyUmVmLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nKCd3b3JrZXInLCAnd29ya2VyIGVycm9yJywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hdGVXb3JrZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53b3JrZXJSZWYub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5ldmVudCA9PT0gJ2tlZXBBbGl2ZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRIZWFydGJlYXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53b3JrZXJSZWYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgZXZlbnQ6ICdzdGFydCcsXG4gICAgICAgICAgICBpbnRlcnZhbDogdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVybWluYXRlIHRoZSBXZWIgV29ya2VyIGFuZCBjbGVhciB0aGUgcmVmZXJlbmNlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3Rlcm1pbmF0ZVdvcmtlcigpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2VyUmVmKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnd29ya2VyJywgJ3Rlcm1pbmF0aW5nIHdvcmtlcicpO1xuICAgICAgICAgICAgdGhpcy53b3JrZXJSZWYudGVybWluYXRlKCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlclJlZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29uQ29ubkNsb3NlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsICdjbG9zZScsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5FcnJvcigpO1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVyKCdoZWFydGJlYXQnKTtcbiAgICAgICAgLy8gT25seSBzY2hlZHVsZSByZWNvbm5lY3Rpb24gaWYgaXQgd2Fzbid0IGEgbWFudWFsIGRpc2Nvbm5lY3RcbiAgICAgICAgaWYgKCF0aGlzLl93YXNNYW51YWxEaXNjb25uZWN0KSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnJlY29ubmVjdFRpbWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKCdjbG9zZScsIGV2ZW50KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbkNvbm5FcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgYCR7ZXJyb3J9YCk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuRXJyb3IoKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKCdlcnJvcicsIGVycm9yKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90cmlnZ2VyQ2hhbkVycm9yKCkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IGNoYW5uZWwuX3RyaWdnZXIoY29uc3RhbnRzXzEuQ0hBTk5FTF9FVkVOVFMuZXJyb3IpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hcHBlbmRQYXJhbXModXJsLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHVybC5tYXRjaCgvXFw/LykgPyAnJicgOiAnPyc7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xuICAgICAgICByZXR1cm4gYCR7dXJsfSR7cHJlZml4fSR7cXVlcnl9YDtcbiAgICB9XG4gICAgX3dvcmtlck9iamVjdFVybCh1cmwpIHtcbiAgICAgICAgbGV0IHJlc3VsdF91cmw7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIHJlc3VsdF91cmwgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW1dPUktFUl9TQ1JJUFRdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KTtcbiAgICAgICAgICAgIHJlc3VsdF91cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRfdXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgY29ubmVjdGlvbiBzdGF0ZSB3aXRoIHByb3BlciBzdGF0ZSBtYW5hZ2VtZW50XG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldENvbm5lY3Rpb25TdGF0ZShzdGF0ZSwgbWFudWFsID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRlID0gc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl93YXNNYW51YWxEaXNjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgdGhpcy5fd2FzTWFudWFsRGlzY29ubmVjdCA9IG1hbnVhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIHRoZSBhY3R1YWwgYXV0aCBvcGVyYXRpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybUF1dGgodG9rZW4gPSBudWxsKSB7XG4gICAgICAgIGxldCB0b2tlblRvU2VuZDtcbiAgICAgICAgbGV0IGlzTWFudWFsVG9rZW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICB0b2tlblRvU2VuZCA9IHRva2VuO1xuICAgICAgICAgICAgLy8gVHJhY2sgaWYgdGhpcyBpcyBhIG1hbnVhbGx5LXByb3ZpZGVkIHRva2VuXG4gICAgICAgICAgICBpc01hbnVhbFRva2VuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBhY2Nlc3NUb2tlbiBjYWxsYmFjayB0byBnZXQgZnJlc2ggdG9rZW5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdG9rZW5Ub1NlbmQgPSBhd2FpdCB0aGlzLmFjY2Vzc1Rva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsICdFcnJvciBmZXRjaGluZyBhY2Nlc3MgdG9rZW4gZnJvbSBjYWxsYmFjaycsIGUpO1xuICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBjYWNoZWQgdmFsdWUgaWYgY2FsbGJhY2sgZmFpbHNcbiAgICAgICAgICAgICAgICB0b2tlblRvU2VuZCA9IHRoaXMuYWNjZXNzVG9rZW5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuVG9TZW5kID0gdGhpcy5hY2Nlc3NUb2tlblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyYWNrIHdoZXRoZXIgdGhpcyB0b2tlbiB3YXMgbWFudWFsbHkgc2V0IG9yIGZldGNoZWQgdmlhIGNhbGxiYWNrXG4gICAgICAgIGlmIChpc01hbnVhbFRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW51YWxseVNldFRva2VuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSB1c2VkIHRoZSBjYWxsYmFjaywgY2xlYXIgdGhlIG1hbnVhbCBmbGFnXG4gICAgICAgICAgICB0aGlzLl9tYW51YWxseVNldFRva2VuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW5WYWx1ZSAhPSB0b2tlblRvU2VuZCkge1xuICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlblZhbHVlID0gdG9rZW5Ub1NlbmQ7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRva2VuVG9TZW5kLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBjb25zdGFudHNfMS5ERUZBVUxUX1ZFUlNJT04sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0b2tlblRvU2VuZCAmJiBjaGFubmVsLnVwZGF0ZUpvaW5QYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsLmpvaW5lZE9uY2UgJiYgY2hhbm5lbC5faXNKb2luZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLl9wdXNoKGNvbnN0YW50c18xLkNIQU5ORUxfRVZFTlRTLmFjY2Vzc190b2tlbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlblRvU2VuZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdCBmb3IgYW55IGluLWZsaWdodCBhdXRoIG9wZXJhdGlvbnMgdG8gY29tcGxldGVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBfd2FpdEZvckF1dGhJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F1dGhQcm9taXNlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hdXRoUHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYWZlbHkgY2FsbCBzZXRBdXRoIHdpdGggc3RhbmRhcmRpemVkIGVycm9yIGhhbmRsaW5nXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldEF1dGhTYWZlbHkoY29udGV4dCA9ICdnZW5lcmFsJykge1xuICAgICAgICAvLyBPbmx5IHJlZnJlc2ggYXV0aCBpZiB1c2luZyBjYWxsYmFjay1iYXNlZCB0b2tlbnNcbiAgICAgICAgaWYgKCF0aGlzLl9pc01hbnVhbFRva2VuKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXV0aCgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgYEVycm9yIHNldHRpbmcgYXV0aCBpbiAke2NvbnRleHR9YCwgZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHN0YXRlIGNoYW5nZSBjYWxsYmFja3Mgd2l0aCBwcm9wZXIgZXJyb3IgaGFuZGxpbmdcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzW2V2ZW50XS5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCBgZXJyb3IgaW4gJHtldmVudH0gY2FsbGJhY2tgLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgYGVycm9yIHRyaWdnZXJpbmcgJHtldmVudH0gY2FsbGJhY2tzYCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0dXAgcmVjb25uZWN0aW9uIHRpbWVyIHdpdGggcHJvcGVyIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfc2V0dXBSZWNvbm5lY3Rpb25UaW1lcigpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyB0aW1lcl8xLmRlZmF1bHQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fd2FpdEZvckF1dGhJZk5lZWRlZCgpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIENPTk5FQ1RJT05fVElNRU9VVFMuUkVDT05ORUNUX0RFTEFZKTtcbiAgICAgICAgfSwgdGhpcy5yZWNvbm5lY3RBZnRlck1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBjbGllbnQgb3B0aW9ucyB3aXRoIGRlZmF1bHRzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2luaXRpYWxpemVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX207XG4gICAgICAgIC8vIFNldCBkZWZhdWx0c1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc3BvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgIHRoaXMudGltZW91dCA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb25zdGFudHNfMS5ERUZBVUxUX1RJTUVPVVQ7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9XG4gICAgICAgICAgICAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhcnRiZWF0SW50ZXJ2YWxNcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogQ09OTkVDVElPTl9USU1FT1VUUy5IRUFSVEJFQVRfSU5URVJWQUw7XG4gICAgICAgIHRoaXMud29ya2VyID0gKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndvcmtlcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZmFsc2U7XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSAoX2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWNjZXNzVG9rZW4pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IG51bGw7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2sgPSAoX2YgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhcnRiZWF0Q2FsbGJhY2spICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IG5vb3A7XG4gICAgICAgIHRoaXMudnNuID0gKF9nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZzbikgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogY29uc3RhbnRzXzEuREVGQVVMVF9WU047XG4gICAgICAgIC8vIEhhbmRsZSBzcGVjaWFsIGNhc2VzXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKVxuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBvcHRpb25zLnBhcmFtcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2dnZXIpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyO1xuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2dMZXZlbCkgfHwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2dfbGV2ZWwpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ0xldmVsID0gb3B0aW9ucy5sb2dMZXZlbCB8fCBvcHRpb25zLmxvZ19sZXZlbDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcmFtcyksIHsgbG9nX2xldmVsOiB0aGlzLmxvZ0xldmVsIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB1cCBmdW5jdGlvbnMgd2l0aCBkZWZhdWx0c1xuICAgICAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPVxuICAgICAgICAgICAgKF9oID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlY29ubmVjdEFmdGVyTXMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6ICgodHJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUkVDT05ORUNUX0lOVEVSVkFMU1t0cmllcyAtIDFdIHx8IERFRkFVTFRfUkVDT05ORUNUX0ZBTExCQUNLO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy52c24pIHtcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuVlNOXzFfMF8wOlxuICAgICAgICAgICAgICAgIHRoaXMuZW5jb2RlID1cbiAgICAgICAgICAgICAgICAgICAgKF9qID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVuY29kZSkgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogKChwYXlsb2FkLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGUgPVxuICAgICAgICAgICAgICAgICAgICAoX2sgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVjb2RlKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiAoKHBheWxvYWQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5wYXJzZShwYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5WU05fMl8wXzA6XG4gICAgICAgICAgICAgICAgdGhpcy5lbmNvZGUgPSAoX2wgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW5jb2RlKSAhPT0gbnVsbCAmJiBfbCAhPT0gdm9pZCAwID8gX2wgOiB0aGlzLnNlcmlhbGl6ZXIuZW5jb2RlLmJpbmQodGhpcy5zZXJpYWxpemVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IChfbSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZWNvZGUpICE9PSBudWxsICYmIF9tICE9PSB2b2lkIDAgPyBfbSA6IHRoaXMuc2VyaWFsaXplci5kZWNvZGUuYmluZCh0aGlzLnNlcmlhbGl6ZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNlcmlhbGl6ZXIgdmVyc2lvbjogJHt0aGlzLnZzbn1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgd29ya2VyIHNldHVwXG4gICAgICAgIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuV29ya2VyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWIgV29ya2VyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMud29ya2VyVXJsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndvcmtlclVybDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJlYWx0aW1lQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhbHRpbWVDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidHNsaWJfMSIsInJlcXVpcmUiLCJ3ZWJzb2NrZXRfZmFjdG9yeV8xIiwiX19pbXBvcnREZWZhdWx0IiwiY29uc3RhbnRzXzEiLCJzZXJpYWxpemVyXzEiLCJ0aW1lcl8xIiwidHJhbnNmb3JtZXJzXzEiLCJSZWFsdGltZUNoYW5uZWxfMSIsIm5vb3AiLCJDT05ORUNUSU9OX1RJTUVPVVRTIiwiSEVBUlRCRUFUX0lOVEVSVkFMIiwiUkVDT05ORUNUX0RFTEFZIiwiSEVBUlRCRUFUX1RJTUVPVVRfRkFMTEJBQ0siLCJSRUNPTk5FQ1RfSU5URVJWQUxTIiwiREVGQVVMVF9SRUNPTk5FQ1RfRkFMTEJBQ0siLCJXT1JLRVJfU0NSSVBUIiwiUmVhbHRpbWVDbGllbnQiLCJjb25zdHJ1Y3RvciIsImVuZFBvaW50Iiwib3B0aW9ucyIsIl9hIiwiYWNjZXNzVG9rZW5WYWx1ZSIsImFwaUtleSIsIl9tYW51YWxseVNldFRva2VuIiwiY2hhbm5lbHMiLCJBcnJheSIsImh0dHBFbmRwb2ludCIsImhlYWRlcnMiLCJwYXJhbXMiLCJ0aW1lb3V0IiwiREVGQVVMVF9USU1FT1VUIiwidHJhbnNwb3J0IiwiaGVhcnRiZWF0SW50ZXJ2YWxNcyIsImhlYXJ0YmVhdFRpbWVyIiwidW5kZWZpbmVkIiwicGVuZGluZ0hlYXJ0YmVhdFJlZiIsImhlYXJ0YmVhdENhbGxiYWNrIiwicmVmIiwicmVjb25uZWN0VGltZXIiLCJ2c24iLCJERUZBVUxUX1ZTTiIsImxvZ2dlciIsImNvbm4iLCJzZW5kQnVmZmVyIiwic2VyaWFsaXplciIsImRlZmF1bHQiLCJzdGF0ZUNoYW5nZUNhbGxiYWNrcyIsIm9wZW4iLCJjbG9zZSIsImVycm9yIiwibWVzc2FnZSIsImFjY2Vzc1Rva2VuIiwiX2Nvbm5lY3Rpb25TdGF0ZSIsIl93YXNNYW51YWxEaXNjb25uZWN0IiwiX2F1dGhQcm9taXNlIiwiX2hlYXJ0YmVhdFNlbnRBdCIsIl9yZXNvbHZlRmV0Y2giLCJjdXN0b21GZXRjaCIsImFyZ3MiLCJmZXRjaCIsImFwaWtleSIsIkVycm9yIiwiVFJBTlNQT1JUUyIsIndlYnNvY2tldCIsImh0dHBFbmRwb2ludFVSTCIsIl9pbml0aWFsaXplT3B0aW9ucyIsIl9zZXR1cFJlY29ubmVjdGlvblRpbWVyIiwiY29ubmVjdCIsImlzQ29ubmVjdGluZyIsImlzRGlzY29ubmVjdGluZyIsImlzQ29ubmVjdGVkIiwiX3NldENvbm5lY3Rpb25TdGF0ZSIsIl9zZXRBdXRoU2FmZWx5IiwiZW5kcG9pbnRVUkwiLCJjcmVhdGVXZWJTb2NrZXQiLCJlcnJvck1lc3NhZ2UiLCJpbmNsdWRlcyIsIl9zZXR1cENvbm5lY3Rpb25IYW5kbGVycyIsIl9hcHBlbmRQYXJhbXMiLCJhc3NpZ24iLCJkaXNjb25uZWN0IiwiY29kZSIsInJlYXNvbiIsImZhbGxiYWNrVGltZXIiLCJzZXRUaW1lb3V0Iiwib25jbG9zZSIsImNsZWFyVGltZW91dCIsIl90ZWFyZG93bkNvbm5lY3Rpb24iLCJnZXRDaGFubmVscyIsInJlbW92ZUNoYW5uZWwiLCJjaGFubmVsIiwic3RhdHVzIiwidW5zdWJzY3JpYmUiLCJsZW5ndGgiLCJyZW1vdmVBbGxDaGFubmVscyIsInZhbHVlc18xIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImxvZyIsImtpbmQiLCJtc2ciLCJkYXRhIiwiY29ubmVjdGlvblN0YXRlIiwicmVhZHlTdGF0ZSIsIlNPQ0tFVF9TVEFURVMiLCJjb25uZWN0aW5nIiwiQ09OTkVDVElPTl9TVEFURSIsIkNvbm5lY3RpbmciLCJPcGVuIiwiY2xvc2luZyIsIkNsb3NpbmciLCJDbG9zZWQiLCJ0b3BpYyIsImNvbmZpZyIsInJlYWx0aW1lVG9waWMiLCJleGlzdHMiLCJmaW5kIiwiYyIsImNoYW4iLCJwdXNoIiwiZXZlbnQiLCJwYXlsb2FkIiwiY2FsbGJhY2siLCJlbmNvZGUiLCJyZXN1bHQiLCJzZW5kIiwic2V0QXV0aCIsInRva2VuIiwiX3BlcmZvcm1BdXRoIiwiX2lzTWFudWFsVG9rZW4iLCJzZW5kSGVhcnRiZWF0IiwiZSIsIldTX0NMT1NFX05PUk1BTCIsInNjaGVkdWxlVGltZW91dCIsIkRhdGUiLCJub3ciLCJfbWFrZVJlZiIsIm9uSGVhcnRiZWF0IiwiZmx1c2hTZW5kQnVmZmVyIiwiZm9yRWFjaCIsIm5ld1JlZiIsInRvU3RyaW5nIiwiX2xlYXZlT3BlblRvcGljIiwiZHVwQ2hhbm5lbCIsIl9pc0pvaW5lZCIsIl9pc0pvaW5pbmciLCJfcmVtb3ZlIiwiZmlsdGVyIiwiX29uQ29ubk1lc3NhZ2UiLCJyYXdNZXNzYWdlIiwiZGVjb2RlIiwibGF0ZW5jeSIsInJlZlN0cmluZyIsInRyaW0iLCJfaXNNZW1iZXIiLCJfdHJpZ2dlciIsIl90cmlnZ2VyU3RhdGVDYWxsYmFja3MiLCJfY2xlYXJUaW1lciIsInRpbWVyIiwiY2xlYXJJbnRlcnZhbCIsInJlc2V0IiwiX2NsZWFyQWxsVGltZXJzIiwiYmluYXJ5VHlwZSIsIm9ub3BlbiIsIl9vbkNvbm5PcGVuIiwib25lcnJvciIsIl9vbkNvbm5FcnJvciIsIm9ubWVzc2FnZSIsIl9vbkNvbm5DbG9zZSIsIl90ZXJtaW5hdGVXb3JrZXIiLCJ0ZWFyZG93biIsImF1dGhQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJjYXRjaCIsIndvcmtlciIsIl9zdGFydEhlYXJ0YmVhdCIsIndvcmtlclJlZiIsIl9zdGFydFdvcmtlckhlYXJ0YmVhdCIsInNldEludGVydmFsIiwid29ya2VyVXJsIiwib2JqZWN0VXJsIiwiX3dvcmtlck9iamVjdFVybCIsIldvcmtlciIsInBvc3RNZXNzYWdlIiwiaW50ZXJ2YWwiLCJ0ZXJtaW5hdGUiLCJfdHJpZ2dlckNoYW5FcnJvciIsIkNIQU5ORUxfRVZFTlRTIiwidXJsIiwia2V5cyIsInByZWZpeCIsIm1hdGNoIiwicXVlcnkiLCJVUkxTZWFyY2hQYXJhbXMiLCJyZXN1bHRfdXJsIiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwic3RhdGUiLCJtYW51YWwiLCJ0b2tlblRvU2VuZCIsImlzTWFudWFsVG9rZW4iLCJhY2Nlc3NfdG9rZW4iLCJ2ZXJzaW9uIiwiREVGQVVMVF9WRVJTSU9OIiwidXBkYXRlSm9pblBheWxvYWQiLCJqb2luZWRPbmNlIiwiX3B1c2giLCJfd2FpdEZvckF1dGhJZk5lZWRlZCIsImNvbnRleHQiLCJyZWNvbm5lY3RBZnRlck1zIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIl9nIiwiX2giLCJfaiIsIl9rIiwiX2wiLCJfbSIsImxvZ0xldmVsIiwibG9nX2xldmVsIiwidHJpZXMiLCJWU05fMV8wXzAiLCJKU09OIiwic3RyaW5naWZ5IiwicGFyc2UiLCJWU05fMl8wXzAiLCJiaW5kIiwid2luZG93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/realtime-js/dist/main/RealtimeClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/realtime-js/dist/main/RealtimePresence.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/main/RealtimePresence.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.REALTIME_PRESENCE_LISTEN_EVENTS = void 0;\nvar REALTIME_PRESENCE_LISTEN_EVENTS;\n(function(REALTIME_PRESENCE_LISTEN_EVENTS) {\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"SYNC\"] = \"sync\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"JOIN\"] = \"join\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"LEAVE\"] = \"leave\";\n})(REALTIME_PRESENCE_LISTEN_EVENTS || (exports.REALTIME_PRESENCE_LISTEN_EVENTS = REALTIME_PRESENCE_LISTEN_EVENTS = {}));\nclass RealtimePresence {\n    /**\n     * Creates a Presence helper that keeps the local presence state in sync with the server.\n     *\n     * @param channel - The realtime channel to bind to.\n     * @param opts - Optional custom event names, e.g. `{ events: { state: 'state', diff: 'diff' } }`.\n     *\n     * @example\n     * ```ts\n     * const presence = new RealtimePresence(channel)\n     *\n     * channel.on('presence', ({ event, key }) => {\n     *   console.log(`Presence ${event} on ${key}`)\n     * })\n     * ```\n     */ constructor(channel, opts){\n        this.channel = channel;\n        this.state = {};\n        this.pendingDiffs = [];\n        this.joinRef = null;\n        this.enabled = false;\n        this.caller = {\n            onJoin: ()=>{},\n            onLeave: ()=>{},\n            onSync: ()=>{}\n        };\n        const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {\n            state: \"presence_state\",\n            diff: \"presence_diff\"\n        };\n        this.channel._on(events.state, {}, (newState)=>{\n            const { onJoin, onLeave, onSync } = this.caller;\n            this.joinRef = this.channel._joinRef();\n            this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);\n            this.pendingDiffs.forEach((diff)=>{\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n            });\n            this.pendingDiffs = [];\n            onSync();\n        });\n        this.channel._on(events.diff, {}, (diff)=>{\n            const { onJoin, onLeave, onSync } = this.caller;\n            if (this.inPendingSyncState()) {\n                this.pendingDiffs.push(diff);\n            } else {\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n                onSync();\n            }\n        });\n        this.onJoin((key, currentPresences, newPresences)=>{\n            this.channel._trigger(\"presence\", {\n                event: \"join\",\n                key,\n                currentPresences,\n                newPresences\n            });\n        });\n        this.onLeave((key, currentPresences, leftPresences)=>{\n            this.channel._trigger(\"presence\", {\n                event: \"leave\",\n                key,\n                currentPresences,\n                leftPresences\n            });\n        });\n        this.onSync(()=>{\n            this.channel._trigger(\"presence\", {\n                event: \"sync\"\n            });\n        });\n    }\n    /**\n     * Used to sync the list of presences on the server with the\n     * client's state.\n     *\n     * An optional `onJoin` and `onLeave` callback can be provided to\n     * react to changes in the client's local presences across\n     * disconnects and reconnects with the server.\n     *\n     * @internal\n     */ static syncState(currentState, newState, onJoin, onLeave) {\n        const state = this.cloneDeep(currentState);\n        const transformedState = this.transformState(newState);\n        const joins = {};\n        const leaves = {};\n        this.map(state, (key, presences)=>{\n            if (!transformedState[key]) {\n                leaves[key] = presences;\n            }\n        });\n        this.map(transformedState, (key, newPresences)=>{\n            const currentPresences = state[key];\n            if (currentPresences) {\n                const newPresenceRefs = newPresences.map((m)=>m.presence_ref);\n                const curPresenceRefs = currentPresences.map((m)=>m.presence_ref);\n                const joinedPresences = newPresences.filter((m)=>curPresenceRefs.indexOf(m.presence_ref) < 0);\n                const leftPresences = currentPresences.filter((m)=>newPresenceRefs.indexOf(m.presence_ref) < 0);\n                if (joinedPresences.length > 0) {\n                    joins[key] = joinedPresences;\n                }\n                if (leftPresences.length > 0) {\n                    leaves[key] = leftPresences;\n                }\n            } else {\n                joins[key] = newPresences;\n            }\n        });\n        return this.syncDiff(state, {\n            joins,\n            leaves\n        }, onJoin, onLeave);\n    }\n    /**\n     * Used to sync a diff of presence join and leave events from the\n     * server, as they happen.\n     *\n     * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n     * `onLeave` callbacks to react to a user joining or leaving from a\n     * device.\n     *\n     * @internal\n     */ static syncDiff(state, diff, onJoin, onLeave) {\n        const { joins, leaves } = {\n            joins: this.transformState(diff.joins),\n            leaves: this.transformState(diff.leaves)\n        };\n        if (!onJoin) {\n            onJoin = ()=>{};\n        }\n        if (!onLeave) {\n            onLeave = ()=>{};\n        }\n        this.map(joins, (key, newPresences)=>{\n            var _a;\n            const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];\n            state[key] = this.cloneDeep(newPresences);\n            if (currentPresences.length > 0) {\n                const joinedPresenceRefs = state[key].map((m)=>m.presence_ref);\n                const curPresences = currentPresences.filter((m)=>joinedPresenceRefs.indexOf(m.presence_ref) < 0);\n                state[key].unshift(...curPresences);\n            }\n            onJoin(key, currentPresences, newPresences);\n        });\n        this.map(leaves, (key, leftPresences)=>{\n            let currentPresences = state[key];\n            if (!currentPresences) return;\n            const presenceRefsToRemove = leftPresences.map((m)=>m.presence_ref);\n            currentPresences = currentPresences.filter((m)=>presenceRefsToRemove.indexOf(m.presence_ref) < 0);\n            state[key] = currentPresences;\n            onLeave(key, currentPresences, leftPresences);\n            if (currentPresences.length === 0) delete state[key];\n        });\n        return state;\n    }\n    /** @internal */ static map(obj, func) {\n        return Object.getOwnPropertyNames(obj).map((key)=>func(key, obj[key]));\n    }\n    /**\n     * Remove 'metas' key\n     * Change 'phx_ref' to 'presence_ref'\n     * Remove 'phx_ref' and 'phx_ref_prev'\n     *\n     * @example\n     * // returns {\n     *  abc123: [\n     *    { presence_ref: '2', user_id: 1 },\n     *    { presence_ref: '3', user_id: 2 }\n     *  ]\n     * }\n     * RealtimePresence.transformState({\n     *  abc123: {\n     *    metas: [\n     *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n     *      { phx_ref: '3', user_id: 2 }\n     *    ]\n     *  }\n     * })\n     *\n     * @internal\n     */ static transformState(state) {\n        state = this.cloneDeep(state);\n        return Object.getOwnPropertyNames(state).reduce((newState, key)=>{\n            const presences = state[key];\n            if (\"metas\" in presences) {\n                newState[key] = presences.metas.map((presence)=>{\n                    presence[\"presence_ref\"] = presence[\"phx_ref\"];\n                    delete presence[\"phx_ref\"];\n                    delete presence[\"phx_ref_prev\"];\n                    return presence;\n                });\n            } else {\n                newState[key] = presences;\n            }\n            return newState;\n        }, {});\n    }\n    /** @internal */ static cloneDeep(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    /** @internal */ onJoin(callback) {\n        this.caller.onJoin = callback;\n    }\n    /** @internal */ onLeave(callback) {\n        this.caller.onLeave = callback;\n    }\n    /** @internal */ onSync(callback) {\n        this.caller.onSync = callback;\n    }\n    /** @internal */ inPendingSyncState() {\n        return !this.joinRef || this.joinRef !== this.channel._joinRef();\n    }\n}\nexports[\"default\"] = RealtimePresence; //# sourceMappingURL=RealtimePresence.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9SZWFsdGltZVByZXNlbmNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7OztBQUdBLEdBQ0FBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1Q0FBdUMsR0FBRyxLQUFLO0FBQy9DLElBQUlFO0FBQ0gsVUFBVUEsK0JBQStCO0lBQ3RDQSwrQkFBK0IsQ0FBQyxPQUFPLEdBQUc7SUFDMUNBLCtCQUErQixDQUFDLE9BQU8sR0FBRztJQUMxQ0EsK0JBQStCLENBQUMsUUFBUSxHQUFHO0FBQy9DLEdBQUdBLG1DQUFvQ0YsQ0FBQUEsdUNBQXVDLEdBQUdFLGtDQUFrQyxDQUFDO0FBQ3BILE1BQU1DO0lBQ0Y7Ozs7Ozs7Ozs7Ozs7O0tBY0MsR0FDREMsWUFBWUMsT0FBTyxFQUFFQyxJQUFJLENBQUU7UUFDdkIsSUFBSSxDQUFDRCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDRSxLQUFLLEdBQUcsQ0FBQztRQUNkLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEVBQUU7UUFDdEIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1lBQ1ZDLFFBQVEsS0FBUTtZQUNoQkMsU0FBUyxLQUFRO1lBQ2pCQyxRQUFRLEtBQVE7UUFDcEI7UUFDQSxNQUFNQyxTQUFTLENBQUNULFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLUyxNQUFNLEtBQUs7WUFDeEVSLE9BQU87WUFDUFMsTUFBTTtRQUNWO1FBQ0EsSUFBSSxDQUFDWCxPQUFPLENBQUNZLEdBQUcsQ0FBQ0YsT0FBT1IsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDVztZQUNoQyxNQUFNLEVBQUVOLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUNILE1BQU07WUFDL0MsSUFB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b0I7b0JBQ2pDQSxRQUFRLENBQUMsZUFBZSxHQUFHQSxRQUFRLENBQUMsVUFBVTtvQkFDOUMsT0FBT0EsUUFBUSxDQUFDLFVBQVU7b0JBQzFCLE9BQU9BLFFBQVEsQ0FBQyxlQUFlO29CQUMvQixPQUFPQTtnQkFDWDtZQUNKLE9BQ0s7Z0JBQ0R2QyxRQUFRLENBQUNPLElBQUksR0FBR2E7WUFDcEI7WUFDQSxPQUFPcEI7UUFDWCxHQUFHLENBQUM7SUFDUjtJQUNBLGNBQWMsR0FDZCxPQUFPYyxVQUFVb0IsR0FBRyxFQUFFO1FBQ2xCLE9BQU9NLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDUjtJQUNyQztJQUNBLGNBQWMsR0FDZHhDLE9BQU9pRCxRQUFRLEVBQUU7UUFDYixJQUFJLENBQUNsRCxNQUFNLENBQUNDLE1BQU0sR0FBR2lEO0lBQ3pCO0lBQ0EsY0FBYyxHQUNkaEQsUUFBUWdELFFBQVEsRUFBRTtRQUNkLElBQUksQ0FBQ2xELE1BQU0sQ0FBQ0UsT0FBTyxHQUFHZ0Q7SUFDMUI7SUFDQSxjQUFjLEdBQ2QvQyxPQUFPK0MsUUFBUSxFQUFFO1FBQ2IsSUFBSSxDQUFDbEQsTUFBTSxDQUFDRyxNQUFNLEdBQUcrQztJQUN6QjtJQUNBLGNBQWMsR0FDZHRDLHFCQUFxQjtRQUNqQixPQUFPLENBQUMsSUFBSSxDQUFDZCxPQUFPLElBQUksSUFBSSxDQUFDQSxPQUFPLEtBQUssSUFBSSxDQUFDSixPQUFPLENBQUNjLFFBQVE7SUFDbEU7QUFDSjtBQUNBbkIsa0JBQWUsR0FBR0csa0JBQ2xCLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tYWluL1JlYWx0aW1lUHJlc2VuY2UuanM/YjdiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gIFRoaXMgZmlsZSBkcmF3cyBoZWF2aWx5IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peC9ibG9iL2QzNDRlYzBhNzMyYWI0ZWUyMDQyMTViMzFkZTY5Y2Y0YmU3MmUzYmYvYXNzZXRzL2pzL3Bob2VuaXgvcHJlc2VuY2UuanNcbiAgTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peC9ibG9iL2QzNDRlYzBhNzMyYWI0ZWUyMDQyMTViMzFkZTY5Y2Y0YmU3MmUzYmYvTElDRU5TRS5tZFxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyA9IHZvaWQgMDtcbnZhciBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTKSB7XG4gICAgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UU1tcIlNZTkNcIl0gPSBcInN5bmNcIjtcbiAgICBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTW1wiSk9JTlwiXSA9IFwiam9pblwiO1xuICAgIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFNbXCJMRUFWRVwiXSA9IFwibGVhdmVcIjtcbn0pKFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMgfHwgKGV4cG9ydHMuUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyA9IFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMgPSB7fSkpO1xuY2xhc3MgUmVhbHRpbWVQcmVzZW5jZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFByZXNlbmNlIGhlbHBlciB0aGF0IGtlZXBzIHRoZSBsb2NhbCBwcmVzZW5jZSBzdGF0ZSBpbiBzeW5jIHdpdGggdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIC0gVGhlIHJlYWx0aW1lIGNoYW5uZWwgdG8gYmluZCB0by5cbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIGN1c3RvbSBldmVudCBuYW1lcywgZS5nLiBgeyBldmVudHM6IHsgc3RhdGU6ICdzdGF0ZScsIGRpZmY6ICdkaWZmJyB9IH1gLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHByZXNlbmNlID0gbmV3IFJlYWx0aW1lUHJlc2VuY2UoY2hhbm5lbClcbiAgICAgKlxuICAgICAqIGNoYW5uZWwub24oJ3ByZXNlbmNlJywgKHsgZXZlbnQsIGtleSB9KSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgUHJlc2VuY2UgJHtldmVudH0gb24gJHtrZXl9YClcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgICB0aGlzLmpvaW5SZWYgPSBudWxsO1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWxsZXIgPSB7XG4gICAgICAgICAgICBvbkpvaW46ICgpID0+IHsgfSxcbiAgICAgICAgICAgIG9uTGVhdmU6ICgpID0+IHsgfSxcbiAgICAgICAgICAgIG9uU3luYzogKCkgPT4geyB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBldmVudHMgPSAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmV2ZW50cykgfHwge1xuICAgICAgICAgICAgc3RhdGU6ICdwcmVzZW5jZV9zdGF0ZScsXG4gICAgICAgICAgICBkaWZmOiAncHJlc2VuY2VfZGlmZicsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb24oZXZlbnRzLnN0YXRlLCB7fSwgKG5ld1N0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9uSm9pbiwgb25MZWF2ZSwgb25TeW5jIH0gPSB0aGlzLmNhbGxlcjtcbiAgICAgICAgICAgIHRoaXMuam9pblJlZiA9IHRoaXMuY2hhbm5lbC5fam9pblJlZigpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY1N0YXRlKHRoaXMuc3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaCgoZGlmZikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBSZWFsdGltZVByZXNlbmNlLnN5bmNEaWZmKHRoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW107XG4gICAgICAgICAgICBvblN5bmMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb24oZXZlbnRzLmRpZmYsIHt9LCAoZGlmZikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5pblBlbmRpbmdTeW5jU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goZGlmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICAgICAgICAgIG9uU3luYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbkpvaW4oKGtleSwgY3VycmVudFByZXNlbmNlcywgbmV3UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywge1xuICAgICAgICAgICAgICAgIGV2ZW50OiAnam9pbicsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcmVzZW5jZXMsXG4gICAgICAgICAgICAgICAgbmV3UHJlc2VuY2VzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uTGVhdmUoKGtleSwgY3VycmVudFByZXNlbmNlcywgbGVmdFByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHtcbiAgICAgICAgICAgICAgICBldmVudDogJ2xlYXZlJyxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgY3VycmVudFByZXNlbmNlcyxcbiAgICAgICAgICAgICAgICBsZWZ0UHJlc2VuY2VzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uU3luYygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywgeyBldmVudDogJ3N5bmMnIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzeW5jIHRoZSBsaXN0IG9mIHByZXNlbmNlcyBvbiB0aGUgc2VydmVyIHdpdGggdGhlXG4gICAgICogY2xpZW50J3Mgc3RhdGUuXG4gICAgICpcbiAgICAgKiBBbiBvcHRpb25hbCBgb25Kb2luYCBhbmQgYG9uTGVhdmVgIGNhbGxiYWNrIGNhbiBiZSBwcm92aWRlZCB0b1xuICAgICAqIHJlYWN0IHRvIGNoYW5nZXMgaW4gdGhlIGNsaWVudCdzIGxvY2FsIHByZXNlbmNlcyBhY3Jvc3NcbiAgICAgKiBkaXNjb25uZWN0cyBhbmQgcmVjb25uZWN0cyB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgc3luY1N0YXRlKGN1cnJlbnRTdGF0ZSwgbmV3U3RhdGUsIG9uSm9pbiwgb25MZWF2ZSkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuY2xvbmVEZWVwKGN1cnJlbnRTdGF0ZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkU3RhdGUgPSB0aGlzLnRyYW5zZm9ybVN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgY29uc3Qgam9pbnMgPSB7fTtcbiAgICAgICAgY29uc3QgbGVhdmVzID0ge307XG4gICAgICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5LCBwcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghdHJhbnNmb3JtZWRTdGF0ZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgbGVhdmVzW2tleV0gPSBwcmVzZW5jZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcCh0cmFuc2Zvcm1lZFN0YXRlLCAoa2V5LCBuZXdQcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQcmVzZW5jZXMgPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQcmVzZW5jZVJlZnMgPSBuZXdQcmVzZW5jZXMubWFwKChtKSA9PiBtLnByZXNlbmNlX3JlZik7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyUHJlc2VuY2VSZWZzID0gY3VycmVudFByZXNlbmNlcy5tYXAoKG0pID0+IG0ucHJlc2VuY2VfcmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2luZWRQcmVzZW5jZXMgPSBuZXdQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBjdXJQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0UHJlc2VuY2VzID0gY3VycmVudFByZXNlbmNlcy5maWx0ZXIoKG0pID0+IG5ld1ByZXNlbmNlUmVmcy5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDApO1xuICAgICAgICAgICAgICAgIGlmIChqb2luZWRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBqb2luc1trZXldID0gam9pbmVkUHJlc2VuY2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVmdFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZlc1trZXldID0gbGVmdFByZXNlbmNlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHsgam9pbnMsIGxlYXZlcyB9LCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHN5bmMgYSBkaWZmIG9mIHByZXNlbmNlIGpvaW4gYW5kIGxlYXZlIGV2ZW50cyBmcm9tIHRoZVxuICAgICAqIHNlcnZlciwgYXMgdGhleSBoYXBwZW4uXG4gICAgICpcbiAgICAgKiBMaWtlIGBzeW5jU3RhdGVgLCBgc3luY0RpZmZgIGFjY2VwdHMgb3B0aW9uYWwgYG9uSm9pbmAgYW5kXG4gICAgICogYG9uTGVhdmVgIGNhbGxiYWNrcyB0byByZWFjdCB0byBhIHVzZXIgam9pbmluZyBvciBsZWF2aW5nIGZyb20gYVxuICAgICAqIGRldmljZS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBzeW5jRGlmZihzdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKSB7XG4gICAgICAgIGNvbnN0IHsgam9pbnMsIGxlYXZlcyB9ID0ge1xuICAgICAgICAgICAgam9pbnM6IHRoaXMudHJhbnNmb3JtU3RhdGUoZGlmZi5qb2lucyksXG4gICAgICAgICAgICBsZWF2ZXM6IHRoaXMudHJhbnNmb3JtU3RhdGUoZGlmZi5sZWF2ZXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIW9uSm9pbikge1xuICAgICAgICAgICAgb25Kb2luID0gKCkgPT4geyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghb25MZWF2ZSkge1xuICAgICAgICAgICAgb25MZWF2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcChqb2lucywgKGtleSwgbmV3UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UHJlc2VuY2VzID0gKF9hID0gc3RhdGVba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICBzdGF0ZVtrZXldID0gdGhpcy5jbG9uZURlZXAobmV3UHJlc2VuY2VzKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2luZWRQcmVzZW5jZVJlZnMgPSBzdGF0ZVtrZXldLm1hcCgobSkgPT4gbS5wcmVzZW5jZV9yZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1clByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBqb2luZWRQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwKTtcbiAgICAgICAgICAgICAgICBzdGF0ZVtrZXldLnVuc2hpZnQoLi4uY3VyUHJlc2VuY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uSm9pbihrZXksIGN1cnJlbnRQcmVzZW5jZXMsIG5ld1ByZXNlbmNlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcChsZWF2ZXMsIChrZXksIGxlZnRQcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50UHJlc2VuY2VzID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIGlmICghY3VycmVudFByZXNlbmNlcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBwcmVzZW5jZVJlZnNUb1JlbW92ZSA9IGxlZnRQcmVzZW5jZXMubWFwKChtKSA9PiBtLnByZXNlbmNlX3JlZik7XG4gICAgICAgICAgICBjdXJyZW50UHJlc2VuY2VzID0gY3VycmVudFByZXNlbmNlcy5maWx0ZXIoKG0pID0+IHByZXNlbmNlUmVmc1RvUmVtb3ZlLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMCk7XG4gICAgICAgICAgICBzdGF0ZVtrZXldID0gY3VycmVudFByZXNlbmNlcztcbiAgICAgICAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBsZWZ0UHJlc2VuY2VzKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGVba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBtYXAob2JqLCBmdW5jKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLm1hcCgoa2V5KSA9PiBmdW5jKGtleSwgb2JqW2tleV0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlICdtZXRhcycga2V5XG4gICAgICogQ2hhbmdlICdwaHhfcmVmJyB0byAncHJlc2VuY2VfcmVmJ1xuICAgICAqIFJlbW92ZSAncGh4X3JlZicgYW5kICdwaHhfcmVmX3ByZXYnXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHJldHVybnMge1xuICAgICAqICBhYmMxMjM6IFtcbiAgICAgKiAgICB7IHByZXNlbmNlX3JlZjogJzInLCB1c2VyX2lkOiAxIH0sXG4gICAgICogICAgeyBwcmVzZW5jZV9yZWY6ICczJywgdXNlcl9pZDogMiB9XG4gICAgICogIF1cbiAgICAgKiB9XG4gICAgICogUmVhbHRpbWVQcmVzZW5jZS50cmFuc2Zvcm1TdGF0ZSh7XG4gICAgICogIGFiYzEyMzoge1xuICAgICAqICAgIG1ldGFzOiBbXG4gICAgICogICAgICB7IHBoeF9yZWY6ICcyJywgcGh4X3JlZl9wcmV2OiAnMScgdXNlcl9pZDogMSB9LFxuICAgICAqICAgICAgeyBwaHhfcmVmOiAnMycsIHVzZXJfaWQ6IDIgfVxuICAgICAqICAgIF1cbiAgICAgKiAgfVxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLmNsb25lRGVlcChzdGF0ZSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdGF0ZSkucmVkdWNlKChuZXdTdGF0ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcmVzZW5jZXMgPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgaWYgKCdtZXRhcycgaW4gcHJlc2VuY2VzKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IHByZXNlbmNlcy5tZXRhcy5tYXAoKHByZXNlbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlbmNlWydwcmVzZW5jZV9yZWYnXSA9IHByZXNlbmNlWydwaHhfcmVmJ107XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcmVzZW5jZVsncGh4X3JlZiddO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJlc2VuY2VbJ3BoeF9yZWZfcHJldiddO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2VuY2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gcHJlc2VuY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgY2xvbmVEZWVwKG9iaikge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uSm9pbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxlci5vbkpvaW4gPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uTGVhdmUoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsZXIub25MZWF2ZSA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb25TeW5jKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGVyLm9uU3luYyA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgaW5QZW5kaW5nU3luY1N0YXRlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuam9pblJlZiB8fCB0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5fam9pblJlZigpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJlYWx0aW1lUHJlc2VuY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsdGltZVByZXNlbmNlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMiLCJSZWFsdGltZVByZXNlbmNlIiwiY29uc3RydWN0b3IiLCJjaGFubmVsIiwib3B0cyIsInN0YXRlIiwicGVuZGluZ0RpZmZzIiwiam9pblJlZiIsImVuYWJsZWQiLCJjYWxsZXIiLCJvbkpvaW4iLCJvbkxlYXZlIiwib25TeW5jIiwiZXZlbnRzIiwiZGlmZiIsIl9vbiIsIm5ld1N0YXRlIiwiX2pvaW5SZWYiLCJzeW5jU3RhdGUiLCJmb3JFYWNoIiwic3luY0RpZmYiLCJpblBlbmRpbmdTeW5jU3RhdGUiLCJwdXNoIiwia2V5IiwiY3VycmVudFByZXNlbmNlcyIsIm5ld1ByZXNlbmNlcyIsIl90cmlnZ2VyIiwiZXZlbnQiLCJsZWZ0UHJlc2VuY2VzIiwiY3VycmVudFN0YXRlIiwiY2xvbmVEZWVwIiwidHJhbnNmb3JtZWRTdGF0ZSIsInRyYW5zZm9ybVN0YXRlIiwiam9pbnMiLCJsZWF2ZXMiLCJtYXAiLCJwcmVzZW5jZXMiLCJuZXdQcmVzZW5jZVJlZnMiLCJtIiwicHJlc2VuY2VfcmVmIiwiY3VyUHJlc2VuY2VSZWZzIiwiam9pbmVkUHJlc2VuY2VzIiwiZmlsdGVyIiwiaW5kZXhPZiIsImxlbmd0aCIsIl9hIiwiam9pbmVkUHJlc2VuY2VSZWZzIiwiY3VyUHJlc2VuY2VzIiwidW5zaGlmdCIsInByZXNlbmNlUmVmc1RvUmVtb3ZlIiwib2JqIiwiZnVuYyIsImdldE93blByb3BlcnR5TmFtZXMiLCJyZWR1Y2UiLCJtZXRhcyIsInByZXNlbmNlIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiY2FsbGJhY2siLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/realtime-js/dist/main/RealtimePresence.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/realtime-js/dist/main/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/main/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebSocketFactory = exports.REALTIME_CHANNEL_STATES = exports.REALTIME_SUBSCRIBE_STATES = exports.REALTIME_PRESENCE_LISTEN_EVENTS = exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = exports.REALTIME_LISTEN_TYPES = exports.RealtimeClient = exports.RealtimeChannel = exports.RealtimePresence = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst RealtimeClient_1 = tslib_1.__importDefault(__webpack_require__(/*! ./RealtimeClient */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/RealtimeClient.js\"));\nexports.RealtimeClient = RealtimeClient_1.default;\nconst RealtimeChannel_1 = tslib_1.__importStar(__webpack_require__(/*! ./RealtimeChannel */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/RealtimeChannel.js\"));\nexports.RealtimeChannel = RealtimeChannel_1.default;\nObject.defineProperty(exports, \"REALTIME_LISTEN_TYPES\", ({\n    enumerable: true,\n    get: function() {\n        return RealtimeChannel_1.REALTIME_LISTEN_TYPES;\n    }\n}));\nObject.defineProperty(exports, \"REALTIME_POSTGRES_CHANGES_LISTEN_EVENT\", ({\n    enumerable: true,\n    get: function() {\n        return RealtimeChannel_1.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n    }\n}));\nObject.defineProperty(exports, \"REALTIME_SUBSCRIBE_STATES\", ({\n    enumerable: true,\n    get: function() {\n        return RealtimeChannel_1.REALTIME_SUBSCRIBE_STATES;\n    }\n}));\nObject.defineProperty(exports, \"REALTIME_CHANNEL_STATES\", ({\n    enumerable: true,\n    get: function() {\n        return RealtimeChannel_1.REALTIME_CHANNEL_STATES;\n    }\n}));\nconst RealtimePresence_1 = tslib_1.__importStar(__webpack_require__(/*! ./RealtimePresence */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/RealtimePresence.js\"));\nexports.RealtimePresence = RealtimePresence_1.default;\nObject.defineProperty(exports, \"REALTIME_PRESENCE_LISTEN_EVENTS\", ({\n    enumerable: true,\n    get: function() {\n        return RealtimePresence_1.REALTIME_PRESENCE_LISTEN_EVENTS;\n    }\n}));\nconst websocket_factory_1 = tslib_1.__importDefault(__webpack_require__(/*! ./lib/websocket-factory */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/websocket-factory.js\"));\nexports.WebSocketFactory = websocket_factory_1.default; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUdBLCtCQUErQixHQUFHQSxpQ0FBaUMsR0FBR0EsdUNBQXVDLEdBQUdBLDhDQUE4QyxHQUFHQSw2QkFBNkIsR0FBR0Esc0JBQXNCLEdBQUdBLHVCQUF1QixHQUFHQSx3QkFBd0IsR0FBRyxLQUFLO0FBQy9TLE1BQU1XLFVBQVVDLG1CQUFPQSxDQUFDLHVEQUFPO0FBQy9CLE1BQU1DLG1CQUFtQkYsUUFBUUcsZUFBZSxDQUFDRixtQkFBT0EsQ0FBQyxnR0FBa0I7QUFDM0VaLHNCQUFzQixHQUFHYSxpQkFBaUJFLE9BQU87QUFDakQsTUFBTUMsb0JBQW9CTCxRQUFRTSxZQUFZLENBQUNMLG1CQUFPQSxDQUFDLGtHQUFtQjtBQUMxRVosdUJBQXVCLEdBQUdnQixrQkFBa0JELE9BQU87QUFDbkRqQix5REFBd0Q7SUFBRW9CLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILGtCQUFrQlQscUJBQXFCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbkpULDBFQUF5RTtJQUFFb0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsa0JBQWtCVixzQ0FBc0M7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNyTFIsNkRBQTREO0lBQUVvQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxrQkFBa0JaLHlCQUF5QjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzNKTiwyREFBMEQ7SUFBRW9CLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILGtCQUFrQmIsdUJBQXVCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdkosTUFBTWlCLHFCQUFxQlQsUUFBUU0sWUFBWSxDQUFDTCxtQkFBT0EsQ0FBQyxvR0FBb0I7QUFDNUVaLHdCQUF3QixHQUFHb0IsbUJBQW1CTCxPQUFPO0FBQ3JEakIsbUVBQWtFO0lBQUVvQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxtQkFBbUJmLCtCQUErQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3hLLE1BQU1nQixzQkFBc0JWLFFBQVFHLGVBQWUsQ0FBQ0YsbUJBQU9BLENBQUMsOEdBQXlCO0FBQ3JGWix3QkFBd0IsR0FBR3FCLG9CQUFvQk4sT0FBTyxFQUN0RCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9pbmRleC5qcz85YTFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWJTb2NrZXRGYWN0b3J5ID0gZXhwb3J0cy5SRUFMVElNRV9DSEFOTkVMX1NUQVRFUyA9IGV4cG9ydHMuUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyA9IGV4cG9ydHMuUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyA9IGV4cG9ydHMuUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQgPSBleHBvcnRzLlJFQUxUSU1FX0xJU1RFTl9UWVBFUyA9IGV4cG9ydHMuUmVhbHRpbWVDbGllbnQgPSBleHBvcnRzLlJlYWx0aW1lQ2hhbm5lbCA9IGV4cG9ydHMuUmVhbHRpbWVQcmVzZW5jZSA9IHZvaWQgMDtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5jb25zdCBSZWFsdGltZUNsaWVudF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUmVhbHRpbWVDbGllbnRcIikpO1xuZXhwb3J0cy5SZWFsdGltZUNsaWVudCA9IFJlYWx0aW1lQ2xpZW50XzEuZGVmYXVsdDtcbmNvbnN0IFJlYWx0aW1lQ2hhbm5lbF8xID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vUmVhbHRpbWVDaGFubmVsXCIpKTtcbmV4cG9ydHMuUmVhbHRpbWVDaGFubmVsID0gUmVhbHRpbWVDaGFubmVsXzEuZGVmYXVsdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJFQUxUSU1FX0xJU1RFTl9UWVBFU1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUmVhbHRpbWVDaGFubmVsXzEuUkVBTFRJTUVfTElTVEVOX1RZUEVTOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJlYWx0aW1lQ2hhbm5lbF8xLlJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFU1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUmVhbHRpbWVDaGFubmVsXzEuUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSZWFsdGltZUNoYW5uZWxfMS5SRUFMVElNRV9DSEFOTkVMX1NUQVRFUzsgfSB9KTtcbmNvbnN0IFJlYWx0aW1lUHJlc2VuY2VfMSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL1JlYWx0aW1lUHJlc2VuY2VcIikpO1xuZXhwb3J0cy5SZWFsdGltZVByZXNlbmNlID0gUmVhbHRpbWVQcmVzZW5jZV8xLmRlZmF1bHQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSZWFsdGltZVByZXNlbmNlXzEuUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUzsgfSB9KTtcbmNvbnN0IHdlYnNvY2tldF9mYWN0b3J5XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9saWIvd2Vic29ja2V0LWZhY3RvcnlcIikpO1xuZXhwb3J0cy5XZWJTb2NrZXRGYWN0b3J5ID0gd2Vic29ja2V0X2ZhY3RvcnlfMS5kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiV2ViU29ja2V0RmFjdG9yeSIsIlJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTIiwiUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyIsIlJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMiLCJSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCIsIlJFQUxUSU1FX0xJU1RFTl9UWVBFUyIsIlJlYWx0aW1lQ2xpZW50IiwiUmVhbHRpbWVDaGFubmVsIiwiUmVhbHRpbWVQcmVzZW5jZSIsInRzbGliXzEiLCJyZXF1aXJlIiwiUmVhbHRpbWVDbGllbnRfMSIsIl9faW1wb3J0RGVmYXVsdCIsImRlZmF1bHQiLCJSZWFsdGltZUNoYW5uZWxfMSIsIl9faW1wb3J0U3RhciIsImVudW1lcmFibGUiLCJnZXQiLCJSZWFsdGltZVByZXNlbmNlXzEiLCJ3ZWJzb2NrZXRfZmFjdG9yeV8xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/realtime-js/dist/main/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/constants.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/main/lib/constants.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CONNECTION_STATE = exports.TRANSPORTS = exports.CHANNEL_EVENTS = exports.CHANNEL_STATES = exports.SOCKET_STATES = exports.MAX_PUSH_BUFFER_SIZE = exports.WS_CLOSE_NORMAL = exports.DEFAULT_TIMEOUT = exports.VERSION = exports.DEFAULT_VSN = exports.VSN_2_0_0 = exports.VSN_1_0_0 = exports.DEFAULT_VERSION = void 0;\nconst version_1 = __webpack_require__(/*! ./version */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/version.js\");\nexports.DEFAULT_VERSION = `realtime-js/${version_1.version}`;\nexports.VSN_1_0_0 = \"1.0.0\";\nexports.VSN_2_0_0 = \"2.0.0\";\nexports.DEFAULT_VSN = exports.VSN_2_0_0;\nexports.VERSION = version_1.version;\nexports.DEFAULT_TIMEOUT = 10000;\nexports.WS_CLOSE_NORMAL = 1000;\nexports.MAX_PUSH_BUFFER_SIZE = 100;\nvar SOCKET_STATES;\n(function(SOCKET_STATES) {\n    SOCKET_STATES[SOCKET_STATES[\"connecting\"] = 0] = \"connecting\";\n    SOCKET_STATES[SOCKET_STATES[\"open\"] = 1] = \"open\";\n    SOCKET_STATES[SOCKET_STATES[\"closing\"] = 2] = \"closing\";\n    SOCKET_STATES[SOCKET_STATES[\"closed\"] = 3] = \"closed\";\n})(SOCKET_STATES || (exports.SOCKET_STATES = SOCKET_STATES = {}));\nvar CHANNEL_STATES;\n(function(CHANNEL_STATES) {\n    CHANNEL_STATES[\"closed\"] = \"closed\";\n    CHANNEL_STATES[\"errored\"] = \"errored\";\n    CHANNEL_STATES[\"joined\"] = \"joined\";\n    CHANNEL_STATES[\"joining\"] = \"joining\";\n    CHANNEL_STATES[\"leaving\"] = \"leaving\";\n})(CHANNEL_STATES || (exports.CHANNEL_STATES = CHANNEL_STATES = {}));\nvar CHANNEL_EVENTS;\n(function(CHANNEL_EVENTS) {\n    CHANNEL_EVENTS[\"close\"] = \"phx_close\";\n    CHANNEL_EVENTS[\"error\"] = \"phx_error\";\n    CHANNEL_EVENTS[\"join\"] = \"phx_join\";\n    CHANNEL_EVENTS[\"reply\"] = \"phx_reply\";\n    CHANNEL_EVENTS[\"leave\"] = \"phx_leave\";\n    CHANNEL_EVENTS[\"access_token\"] = \"access_token\";\n})(CHANNEL_EVENTS || (exports.CHANNEL_EVENTS = CHANNEL_EVENTS = {}));\nvar TRANSPORTS;\n(function(TRANSPORTS) {\n    TRANSPORTS[\"websocket\"] = \"websocket\";\n})(TRANSPORTS || (exports.TRANSPORTS = TRANSPORTS = {}));\nvar CONNECTION_STATE;\n(function(CONNECTION_STATE) {\n    CONNECTION_STATE[\"Connecting\"] = \"connecting\";\n    CONNECTION_STATE[\"Open\"] = \"open\";\n    CONNECTION_STATE[\"Closing\"] = \"closing\";\n    CONNECTION_STATE[\"Closed\"] = \"closed\";\n})(CONNECTION_STATE || (exports.CONNECTION_STATE = CONNECTION_STATE = {})); //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBR0Esa0JBQWtCLEdBQUdBLHNCQUFzQixHQUFHQSxzQkFBc0IsR0FBR0EscUJBQXFCLEdBQUdBLDRCQUE0QixHQUFHQSx1QkFBdUIsR0FBR0EsdUJBQXVCLEdBQUdBLGVBQWUsR0FBR0EsbUJBQW1CLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUM1VCxNQUFNZSxZQUFZQyxtQkFBT0EsQ0FBQyxzRkFBVztBQUNyQ2hCLHVCQUF1QixHQUFHLENBQUMsWUFBWSxFQUFFZSxVQUFVRSxPQUFPLENBQUMsQ0FBQztBQUM1RGpCLGlCQUFpQixHQUFHO0FBQ3BCQSxpQkFBaUIsR0FBRztBQUNwQkEsbUJBQW1CLEdBQUdBLFFBQVFZLFNBQVM7QUFDdkNaLGVBQWUsR0FBR2UsVUFBVUUsT0FBTztBQUNuQ2pCLHVCQUF1QixHQUFHO0FBQzFCQSx1QkFBdUIsR0FBRztBQUMxQkEsNEJBQTRCLEdBQUc7QUFDL0IsSUFBSU07QUFDSCxVQUFVQSxhQUFhO0lBQ3BCQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHO0lBQ2pEQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQzNDQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzlDQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0FBQ2pELEdBQUdBLGlCQUFrQk4sQ0FBQUEscUJBQXFCLEdBQUdNLGdCQUFnQixDQUFDO0FBQzlELElBQUlEO0FBQ0gsVUFBVUEsY0FBYztJQUNyQkEsY0FBYyxDQUFDLFNBQVMsR0FBRztJQUMzQkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFNBQVMsR0FBRztJQUMzQkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztBQUNoQyxHQUFHQSxrQkFBbUJMLENBQUFBLHNCQUFzQixHQUFHSyxpQkFBaUIsQ0FBQztBQUNqRSxJQUFJRDtBQUNILFVBQVVBLGNBQWM7SUFDckJBLGNBQWMsQ0FBQyxRQUFRLEdBQUc7SUFDMUJBLGNBQWMsQ0FBQyxRQUFRLEdBQUc7SUFDMUJBLGNBQWMsQ0FBQyxPQUFPLEdBQUc7SUFDekJBLGNBQWMsQ0FBQyxRQUFRLEdBQUc7SUFDMUJBLGNBQWMsQ0FBQyxRQUFRLEdBQUc7SUFDMUJBLGNBQWMsQ0FBQyxlQUFlLEdBQUc7QUFDckMsR0FBR0Esa0JBQW1CSixDQUFBQSxzQkFBc0IsR0FBR0ksaUJBQWlCLENBQUM7QUFDakUsSUFBSUQ7QUFDSCxVQUFVQSxVQUFVO0lBQ2pCQSxVQUFVLENBQUMsWUFBWSxHQUFHO0FBQzlCLEdBQUdBLGNBQWVILENBQUFBLGtCQUFrQixHQUFHRyxhQUFhLENBQUM7QUFDckQsSUFBSUQ7QUFDSCxVQUFVQSxnQkFBZ0I7SUFDdkJBLGdCQUFnQixDQUFDLGFBQWEsR0FBRztJQUNqQ0EsZ0JBQWdCLENBQUMsT0FBTyxHQUFHO0lBQzNCQSxnQkFBZ0IsQ0FBQyxVQUFVLEdBQUc7SUFDOUJBLGdCQUFnQixDQUFDLFNBQVMsR0FBRztBQUNqQyxHQUFHQSxvQkFBcUJGLENBQUFBLHdCQUF3QixHQUFHRSxtQkFBbUIsQ0FBQyxLQUN2RSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvY29uc3RhbnRzLmpzPzliY2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNPTk5FQ1RJT05fU1RBVEUgPSBleHBvcnRzLlRSQU5TUE9SVFMgPSBleHBvcnRzLkNIQU5ORUxfRVZFTlRTID0gZXhwb3J0cy5DSEFOTkVMX1NUQVRFUyA9IGV4cG9ydHMuU09DS0VUX1NUQVRFUyA9IGV4cG9ydHMuTUFYX1BVU0hfQlVGRkVSX1NJWkUgPSBleHBvcnRzLldTX0NMT1NFX05PUk1BTCA9IGV4cG9ydHMuREVGQVVMVF9USU1FT1VUID0gZXhwb3J0cy5WRVJTSU9OID0gZXhwb3J0cy5ERUZBVUxUX1ZTTiA9IGV4cG9ydHMuVlNOXzJfMF8wID0gZXhwb3J0cy5WU05fMV8wXzAgPSBleHBvcnRzLkRFRkFVTFRfVkVSU0lPTiA9IHZvaWQgMDtcbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5leHBvcnRzLkRFRkFVTFRfVkVSU0lPTiA9IGByZWFsdGltZS1qcy8ke3ZlcnNpb25fMS52ZXJzaW9ufWA7XG5leHBvcnRzLlZTTl8xXzBfMCA9ICcxLjAuMCc7XG5leHBvcnRzLlZTTl8yXzBfMCA9ICcyLjAuMCc7XG5leHBvcnRzLkRFRkFVTFRfVlNOID0gZXhwb3J0cy5WU05fMl8wXzA7XG5leHBvcnRzLlZFUlNJT04gPSB2ZXJzaW9uXzEudmVyc2lvbjtcbmV4cG9ydHMuREVGQVVMVF9USU1FT1VUID0gMTAwMDA7XG5leHBvcnRzLldTX0NMT1NFX05PUk1BTCA9IDEwMDA7XG5leHBvcnRzLk1BWF9QVVNIX0JVRkZFUl9TSVpFID0gMTAwO1xudmFyIFNPQ0tFVF9TVEFURVM7XG4oZnVuY3Rpb24gKFNPQ0tFVF9TVEFURVMpIHtcbiAgICBTT0NLRVRfU1RBVEVTW1NPQ0tFVF9TVEFURVNbXCJjb25uZWN0aW5nXCJdID0gMF0gPSBcImNvbm5lY3RpbmdcIjtcbiAgICBTT0NLRVRfU1RBVEVTW1NPQ0tFVF9TVEFURVNbXCJvcGVuXCJdID0gMV0gPSBcIm9wZW5cIjtcbiAgICBTT0NLRVRfU1RBVEVTW1NPQ0tFVF9TVEFURVNbXCJjbG9zaW5nXCJdID0gMl0gPSBcImNsb3NpbmdcIjtcbiAgICBTT0NLRVRfU1RBVEVTW1NPQ0tFVF9TVEFURVNbXCJjbG9zZWRcIl0gPSAzXSA9IFwiY2xvc2VkXCI7XG59KShTT0NLRVRfU1RBVEVTIHx8IChleHBvcnRzLlNPQ0tFVF9TVEFURVMgPSBTT0NLRVRfU1RBVEVTID0ge30pKTtcbnZhciBDSEFOTkVMX1NUQVRFUztcbihmdW5jdGlvbiAoQ0hBTk5FTF9TVEFURVMpIHtcbiAgICBDSEFOTkVMX1NUQVRFU1tcImNsb3NlZFwiXSA9IFwiY2xvc2VkXCI7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJlcnJvcmVkXCJdID0gXCJlcnJvcmVkXCI7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJqb2luZWRcIl0gPSBcImpvaW5lZFwiO1xuICAgIENIQU5ORUxfU1RBVEVTW1wiam9pbmluZ1wiXSA9IFwiam9pbmluZ1wiO1xuICAgIENIQU5ORUxfU1RBVEVTW1wibGVhdmluZ1wiXSA9IFwibGVhdmluZ1wiO1xufSkoQ0hBTk5FTF9TVEFURVMgfHwgKGV4cG9ydHMuQ0hBTk5FTF9TVEFURVMgPSBDSEFOTkVMX1NUQVRFUyA9IHt9KSk7XG52YXIgQ0hBTk5FTF9FVkVOVFM7XG4oZnVuY3Rpb24gKENIQU5ORUxfRVZFTlRTKSB7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJjbG9zZVwiXSA9IFwicGh4X2Nsb3NlXCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJlcnJvclwiXSA9IFwicGh4X2Vycm9yXCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJqb2luXCJdID0gXCJwaHhfam9pblwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wicmVwbHlcIl0gPSBcInBoeF9yZXBseVwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wibGVhdmVcIl0gPSBcInBoeF9sZWF2ZVwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wiYWNjZXNzX3Rva2VuXCJdID0gXCJhY2Nlc3NfdG9rZW5cIjtcbn0pKENIQU5ORUxfRVZFTlRTIHx8IChleHBvcnRzLkNIQU5ORUxfRVZFTlRTID0gQ0hBTk5FTF9FVkVOVFMgPSB7fSkpO1xudmFyIFRSQU5TUE9SVFM7XG4oZnVuY3Rpb24gKFRSQU5TUE9SVFMpIHtcbiAgICBUUkFOU1BPUlRTW1wid2Vic29ja2V0XCJdID0gXCJ3ZWJzb2NrZXRcIjtcbn0pKFRSQU5TUE9SVFMgfHwgKGV4cG9ydHMuVFJBTlNQT1JUUyA9IFRSQU5TUE9SVFMgPSB7fSkpO1xudmFyIENPTk5FQ1RJT05fU1RBVEU7XG4oZnVuY3Rpb24gKENPTk5FQ1RJT05fU1RBVEUpIHtcbiAgICBDT05ORUNUSU9OX1NUQVRFW1wiQ29ubmVjdGluZ1wiXSA9IFwiY29ubmVjdGluZ1wiO1xuICAgIENPTk5FQ1RJT05fU1RBVEVbXCJPcGVuXCJdID0gXCJvcGVuXCI7XG4gICAgQ09OTkVDVElPTl9TVEFURVtcIkNsb3NpbmdcIl0gPSBcImNsb3NpbmdcIjtcbiAgICBDT05ORUNUSU9OX1NUQVRFW1wiQ2xvc2VkXCJdID0gXCJjbG9zZWRcIjtcbn0pKENPTk5FQ1RJT05fU1RBVEUgfHwgKGV4cG9ydHMuQ09OTkVDVElPTl9TVEFURSA9IENPTk5FQ1RJT05fU1RBVEUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNPTk5FQ1RJT05fU1RBVEUiLCJUUkFOU1BPUlRTIiwiQ0hBTk5FTF9FVkVOVFMiLCJDSEFOTkVMX1NUQVRFUyIsIlNPQ0tFVF9TVEFURVMiLCJNQVhfUFVTSF9CVUZGRVJfU0laRSIsIldTX0NMT1NFX05PUk1BTCIsIkRFRkFVTFRfVElNRU9VVCIsIlZFUlNJT04iLCJERUZBVUxUX1ZTTiIsIlZTTl8yXzBfMCIsIlZTTl8xXzBfMCIsIkRFRkFVTFRfVkVSU0lPTiIsInZlcnNpb25fMSIsInJlcXVpcmUiLCJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/push.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/main/lib/push.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst constants_1 = __webpack_require__(/*! ../lib/constants */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/constants.js\");\nclass Push {\n    /**\n     * Initializes the Push\n     *\n     * @param channel The Channel\n     * @param event The event, for example `\"phx_join\"`\n     * @param payload The payload, for example `{user_id: 123}`\n     * @param timeout The push timeout in milliseconds\n     */ constructor(channel, event, payload = {}, timeout = constants_1.DEFAULT_TIMEOUT){\n        this.channel = channel;\n        this.event = event;\n        this.payload = payload;\n        this.timeout = timeout;\n        this.sent = false;\n        this.timeoutTimer = undefined;\n        this.ref = \"\";\n        this.receivedResp = null;\n        this.recHooks = [];\n        this.refEvent = null;\n    }\n    resend(timeout) {\n        this.timeout = timeout;\n        this._cancelRefEvent();\n        this.ref = \"\";\n        this.refEvent = null;\n        this.receivedResp = null;\n        this.sent = false;\n        this.send();\n    }\n    send() {\n        if (this._hasReceived(\"timeout\")) {\n            return;\n        }\n        this.startTimeout();\n        this.sent = true;\n        this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload,\n            ref: this.ref,\n            join_ref: this.channel._joinRef()\n        });\n    }\n    updatePayload(payload) {\n        this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n    receive(status, callback) {\n        var _a;\n        if (this._hasReceived(status)) {\n            callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n        }\n        this.recHooks.push({\n            status,\n            callback\n        });\n        return this;\n    }\n    startTimeout() {\n        if (this.timeoutTimer) {\n            return;\n        }\n        this.ref = this.channel.socket._makeRef();\n        this.refEvent = this.channel._replyEventName(this.ref);\n        const callback = (payload)=>{\n            this._cancelRefEvent();\n            this._cancelTimeout();\n            this.receivedResp = payload;\n            this._matchReceive(payload);\n        };\n        this.channel._on(this.refEvent, {}, callback);\n        this.timeoutTimer = setTimeout(()=>{\n            this.trigger(\"timeout\", {});\n        }, this.timeout);\n    }\n    trigger(status, response) {\n        if (this.refEvent) this.channel._trigger(this.refEvent, {\n            status,\n            response\n        });\n    }\n    destroy() {\n        this._cancelRefEvent();\n        this._cancelTimeout();\n    }\n    _cancelRefEvent() {\n        if (!this.refEvent) {\n            return;\n        }\n        this.channel._off(this.refEvent, {});\n    }\n    _cancelTimeout() {\n        clearTimeout(this.timeoutTimer);\n        this.timeoutTimer = undefined;\n    }\n    _matchReceive({ status, response }) {\n        this.recHooks.filter((h)=>h.status === status).forEach((h)=>h.callback(response));\n    }\n    _hasReceived(status) {\n        return this.receivedResp && this.receivedResp.status === status;\n    }\n}\nexports[\"default\"] = Push; //# sourceMappingURL=push.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvcHVzaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxjQUFjQyxtQkFBT0EsQ0FBQywrRkFBa0I7QUFDOUMsTUFBTUM7SUFDRjs7Ozs7OztLQU9DLEdBQ0RDLFlBQVlDLE9BQU8sRUFBRUMsS0FBSyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFQyxVQUFVUCxZQUFZUSxlQUFlLENBQUU7UUFDN0UsSUFBSSxDQUFDSixPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLFlBQVksR0FBR0M7UUFDcEIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLFFBQVEsR0FBRyxFQUFFO1FBQ2xCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ3BCO0lBQ0FDLE9BQU9ULE9BQU8sRUFBRTtRQUNaLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ1UsZUFBZTtRQUNwQixJQUFJLENBQUNMLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0csUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0YsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0osSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDUyxJQUFJO0lBQ2I7SUFDQUEsT0FBTztRQUNILElBQUksSUFBSSxDQUFDQyxZQUFZLENBQUMsWUFBWTtZQUM5QjtRQUNKO1FBQ0EsSUFBSSxDQUFDQyxZQUFZO1FBQ2pCLElBQUksQ0FBQ1gsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDTCxPQUFPLENBQUNp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LCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvcHVzaC5qcz9iNGI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vbGliL2NvbnN0YW50c1wiKTtcbmNsYXNzIFB1c2gge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBQdXNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgQ2hhbm5lbFxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQsIGZvciBleGFtcGxlIGBcInBoeF9qb2luXCJgXG4gICAgICogQHBhcmFtIHBheWxvYWQgVGhlIHBheWxvYWQsIGZvciBleGFtcGxlIGB7dXNlcl9pZDogMTIzfWBcbiAgICAgKiBAcGFyYW0gdGltZW91dCBUaGUgcHVzaCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIGV2ZW50LCBwYXlsb2FkID0ge30sIHRpbWVvdXQgPSBjb25zdGFudHNfMS5ERUZBVUxUX1RJTUVPVVQpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aW1lb3V0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVmID0gJyc7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNIb29rcyA9IFtdO1xuICAgICAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgcmVzZW5kKHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgdGhpcy5fY2FuY2VsUmVmRXZlbnQoKTtcbiAgICAgICAgdGhpcy5yZWYgPSAnJztcbiAgICAgICAgdGhpcy5yZWZFdmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VuZCgpO1xuICAgIH1cbiAgICBzZW5kKCkge1xuICAgICAgICBpZiAodGhpcy5faGFzUmVjZWl2ZWQoJ3RpbWVvdXQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuc2VudCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5zb2NrZXQucHVzaCh7XG4gICAgICAgICAgICB0b3BpYzogdGhpcy5jaGFubmVsLnRvcGljLFxuICAgICAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgICAgICBwYXlsb2FkOiB0aGlzLnBheWxvYWQsXG4gICAgICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICAgICAgam9pbl9yZWY6IHRoaXMuY2hhbm5lbC5fam9pblJlZigpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXlsb2FkKSwgcGF5bG9hZCk7XG4gICAgfVxuICAgIHJlY2VpdmUoc3RhdHVzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZChzdGF0dXMpKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygoX2EgPSB0aGlzLnJlY2VpdmVkUmVzcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY0hvb2tzLnB1c2goeyBzdGF0dXMsIGNhbGxiYWNrIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhcnRUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0VGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZiA9IHRoaXMuY2hhbm5lbC5zb2NrZXQuX21ha2VSZWYoKTtcbiAgICAgICAgdGhpcy5yZWZFdmVudCA9IHRoaXMuY2hhbm5lbC5fcmVwbHlFdmVudE5hbWUodGhpcy5yZWYpO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsVGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBwYXlsb2FkO1xuICAgICAgICAgICAgdGhpcy5fbWF0Y2hSZWNlaXZlKHBheWxvYWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYW5uZWwuX29uKHRoaXMucmVmRXZlbnQsIHt9LCBjYWxsYmFjayk7XG4gICAgICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RpbWVvdXQnLCB7fSk7XG4gICAgICAgIH0sIHRoaXMudGltZW91dCk7XG4gICAgfVxuICAgIHRyaWdnZXIoc3RhdHVzLCByZXNwb25zZSkge1xuICAgICAgICBpZiAodGhpcy5yZWZFdmVudClcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcih0aGlzLnJlZkV2ZW50LCB7IHN0YXR1cywgcmVzcG9uc2UgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KCk7XG4gICAgICAgIHRoaXMuX2NhbmNlbFRpbWVvdXQoKTtcbiAgICB9XG4gICAgX2NhbmNlbFJlZkV2ZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMucmVmRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5uZWwuX29mZih0aGlzLnJlZkV2ZW50LCB7fSk7XG4gICAgfVxuICAgIF9jYW5jZWxUaW1lb3V0KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0VGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX21hdGNoUmVjZWl2ZSh7IHN0YXR1cywgcmVzcG9uc2UgfSkge1xuICAgICAgICB0aGlzLnJlY0hvb2tzLmZpbHRlcigoaCkgPT4gaC5zdGF0dXMgPT09IHN0YXR1cykuZm9yRWFjaCgoaCkgPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpO1xuICAgIH1cbiAgICBfaGFzUmVjZWl2ZWQoc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVkUmVzcCAmJiB0aGlzLnJlY2VpdmVkUmVzcC5zdGF0dXMgPT09IHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQdXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVzaC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjb25zdGFudHNfMSIsInJlcXVpcmUiLCJQdXNoIiwiY29uc3RydWN0b3IiLCJjaGFubmVsIiwiZXZlbnQiLCJwYXlsb2FkIiwidGltZW91dCIsIkRFRkFVTFRfVElNRU9VVCIsInNlbnQiLCJ0aW1lb3V0VGltZXIiLCJ1bmRlZmluZWQiLCJyZWYiLCJyZWNlaXZlZFJlc3AiLCJyZWNIb29rcyIsInJlZkV2ZW50IiwicmVzZW5kIiwiX2NhbmNlbFJlZkV2ZW50Iiwic2VuZCIsIl9oYXNSZWNlaXZlZCIsInN0YXJ0VGltZW91dCIsInNvY2tldCIsInB1c2giLCJ0b3BpYyIsImpvaW5fcmVmIiwiX2pvaW5SZWYiLCJ1cGRhdGVQYXlsb2FkIiwiYXNzaWduIiwicmVjZWl2ZSIsInN0YXR1cyIsImNhbGxiYWNrIiwiX2EiLCJyZXNwb25zZSIsIl9tYWtlUmVmIiwiX3JlcGx5RXZlbnROYW1lIiwiX2NhbmNlbFRpbWVvdXQiLCJfbWF0Y2hSZWNlaXZlIiwiX29uIiwic2V0VGltZW91dCIsInRyaWdnZXIiLCJfdHJpZ2dlciIsImRlc3Ryb3kiLCJfb2ZmIiwiY2xlYXJUaW1lb3V0IiwiZmlsdGVyIiwiaCIsImZvckVhY2giLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/push.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/serializer.js":
/*!************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/main/lib/serializer.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nclass Serializer {\n    constructor(allowedMetadataKeys){\n        this.HEADER_LENGTH = 1;\n        this.USER_BROADCAST_PUSH_META_LENGTH = 6;\n        this.KINDS = {\n            userBroadcastPush: 3,\n            userBroadcast: 4\n        };\n        this.BINARY_ENCODING = 0;\n        this.JSON_ENCODING = 1;\n        this.BROADCAST_EVENT = \"broadcast\";\n        this.allowedMetadataKeys = [];\n        this.allowedMetadataKeys = allowedMetadataKeys !== null && allowedMetadataKeys !== void 0 ? allowedMetadataKeys : [];\n    }\n    encode(msg, callback) {\n        if (msg.event === this.BROADCAST_EVENT && !(msg.payload instanceof ArrayBuffer) && typeof msg.payload.event === \"string\") {\n            return callback(this._binaryEncodeUserBroadcastPush(msg));\n        }\n        let payload = [\n            msg.join_ref,\n            msg.ref,\n            msg.topic,\n            msg.event,\n            msg.payload\n        ];\n        return callback(JSON.stringify(payload));\n    }\n    _binaryEncodeUserBroadcastPush(message) {\n        var _a;\n        if (this._isArrayBuffer((_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload)) {\n            return this._encodeBinaryUserBroadcastPush(message);\n        } else {\n            return this._encodeJsonUserBroadcastPush(message);\n        }\n    }\n    _encodeBinaryUserBroadcastPush(message) {\n        var _a, _b;\n        const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : new ArrayBuffer(0);\n        return this._encodeUserBroadcastPush(message, this.BINARY_ENCODING, userPayload);\n    }\n    _encodeJsonUserBroadcastPush(message) {\n        var _a, _b;\n        const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : {};\n        const encoder = new TextEncoder();\n        const encodedUserPayload = encoder.encode(JSON.stringify(userPayload)).buffer;\n        return this._encodeUserBroadcastPush(message, this.JSON_ENCODING, encodedUserPayload);\n    }\n    _encodeUserBroadcastPush(message, encodingType, encodedPayload) {\n        var _a, _b;\n        const topic = message.topic;\n        const ref = (_a = message.ref) !== null && _a !== void 0 ? _a : \"\";\n        const joinRef = (_b = message.join_ref) !== null && _b !== void 0 ? _b : \"\";\n        const userEvent = message.payload.event;\n        // Filter metadata based on allowed keys\n        const rest = this.allowedMetadataKeys ? this._pick(message.payload, this.allowedMetadataKeys) : {};\n        const metadata = Object.keys(rest).length === 0 ? \"\" : JSON.stringify(rest);\n        // Validate lengths don't exceed uint8 max value (255)\n        if (joinRef.length > 255) {\n            throw new Error(`joinRef length ${joinRef.length} exceeds maximum of 255`);\n        }\n        if (ref.length > 255) {\n            throw new Error(`ref length ${ref.length} exceeds maximum of 255`);\n        }\n        if (topic.length > 255) {\n            throw new Error(`topic length ${topic.length} exceeds maximum of 255`);\n        }\n        if (userEvent.length > 255) {\n            throw new Error(`userEvent length ${userEvent.length} exceeds maximum of 255`);\n        }\n        if (metadata.length > 255) {\n            throw new Error(`metadata length ${metadata.length} exceeds maximum of 255`);\n        }\n        const metaLength = this.USER_BROADCAST_PUSH_META_LENGTH + joinRef.length + ref.length + topic.length + userEvent.length + metadata.length;\n        const header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n        let view = new DataView(header);\n        let offset = 0;\n        view.setUint8(offset++, this.KINDS.userBroadcastPush); // kind\n        view.setUint8(offset++, joinRef.length);\n        view.setUint8(offset++, ref.length);\n        view.setUint8(offset++, topic.length);\n        view.setUint8(offset++, userEvent.length);\n        view.setUint8(offset++, metadata.length);\n        view.setUint8(offset++, encodingType);\n        Array.from(joinRef, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(ref, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(topic, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(userEvent, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(metadata, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        var combined = new Uint8Array(header.byteLength + encodedPayload.byteLength);\n        combined.set(new Uint8Array(header), 0);\n        combined.set(new Uint8Array(encodedPayload), header.byteLength);\n        return combined.buffer;\n    }\n    decode(rawPayload, callback) {\n        if (this._isArrayBuffer(rawPayload)) {\n            let result = this._binaryDecode(rawPayload);\n            return callback(result);\n        }\n        if (typeof rawPayload === \"string\") {\n            const jsonPayload = JSON.parse(rawPayload);\n            const [join_ref, ref, topic, event, payload] = jsonPayload;\n            return callback({\n                join_ref,\n                ref,\n                topic,\n                event,\n                payload\n            });\n        }\n        return callback({});\n    }\n    _binaryDecode(buffer) {\n        const view = new DataView(buffer);\n        const kind = view.getUint8(0);\n        const decoder = new TextDecoder();\n        switch(kind){\n            case this.KINDS.userBroadcast:\n                return this._decodeUserBroadcast(buffer, view, decoder);\n        }\n    }\n    _decodeUserBroadcast(buffer, view, decoder) {\n        const topicSize = view.getUint8(1);\n        const userEventSize = view.getUint8(2);\n        const metadataSize = view.getUint8(3);\n        const payloadEncoding = view.getUint8(4);\n        let offset = this.HEADER_LENGTH + 4;\n        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n        offset = offset + topicSize;\n        const userEvent = decoder.decode(buffer.slice(offset, offset + userEventSize));\n        offset = offset + userEventSize;\n        const metadata = decoder.decode(buffer.slice(offset, offset + metadataSize));\n        offset = offset + metadataSize;\n        const payload = buffer.slice(offset, buffer.byteLength);\n        const parsedPayload = payloadEncoding === this.JSON_ENCODING ? JSON.parse(decoder.decode(payload)) : payload;\n        const data = {\n            type: this.BROADCAST_EVENT,\n            event: userEvent,\n            payload: parsedPayload\n        };\n        // Metadata is optional and always JSON encoded\n        if (metadataSize > 0) {\n            data[\"meta\"] = JSON.parse(metadata);\n        }\n        return {\n            join_ref: null,\n            ref: null,\n            topic: topic,\n            event: this.BROADCAST_EVENT,\n            payload: data\n        };\n    }\n    _isArrayBuffer(buffer) {\n        var _a;\n        return buffer instanceof ArrayBuffer || ((_a = buffer === null || buffer === void 0 ? void 0 : buffer.constructor) === null || _a === void 0 ? void 0 : _a.name) === \"ArrayBuffer\";\n    }\n    _pick(obj, keys) {\n        if (!obj || typeof obj !== \"object\") {\n            return {};\n        }\n        return Object.fromEntries(Object.entries(obj).filter(([key])=>keys.includes(key)));\n    }\n}\nexports[\"default\"] = Serializer; //# sourceMappingURL=serializer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvc2VyaWFsaXplci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQztJQUNGQyxZQUFZQyxtQkFBbUIsQ0FBRTtRQUM3QixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLCtCQUErQixHQUFHO1FBQ3ZDLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1lBQUVDLG1CQUFtQjtZQUFHQyxlQUFlO1FBQUU7UUFDdEQsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDUixtQkFBbUIsR0FBRyxFQUFFO1FBQzdCLElBQUksQ0FBQ0EsbUJBQW1CLEdBQUdBLHdCQUF3QixRQUFRQSx3QkFBd0IsS0FBSyxJQUFJQSxzQkFBc0IsRUFBRTtJQUN4SDtJQUNBUyxPQUFPQyxHQUFHLEVBQUVDLFFBQVEsRUFBRTtRQUNsQixJQUFJRCxJQUFJRSxLQUFLLEtBQUssSUFBSSxDQUFDSixlQUFlLElBQ2xDLENBQUVFLENBQUFBLElBQUlHLE9BQU8sWUFBWUMsV0FBVSxLQUNuQyxPQUFPSixJQUFJRyxPQUFPLENBQUNELEtBQUssS0FBSyxVQUFVO1lBQ3ZDLE9BQU9ELFNBQVMsSUFBSSxDQUFDSSw4QkFBOEIsQ0FBQ0w7UUFDeEQ7UUFDQSxJQUFJRyxVQUFVO1lBQUNILElBQUlNLFFBQVE7WUFBRU4sSUFBSU8sR0FBRztZQUFFUCxJQUFJUSxLQUFLO1lBQUVSLElBQUlFLEtBQUs7WUFBRUYsSUFBSUcsT0FBTztTQUFDO1FBQ3hFLE9BQU9GLFNBQVNRLEtBQUtDLFNBQVMsQ0FBQ1A7SUFDbkM7SUFDQUUsK0JBQStCTSxPQUFPLEVBQUU7UUFDcEMsSUFBSUM7UUFDSixJQUFJLElBQUksQ0FB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QSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU9qQyxXQUFXLE1BQU0sUUFBUXVCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3NELElBQUksTUFBTTtJQUN6SztJQUNBdEMsTUFBTXVDLEdBQUcsRUFBRXJDLElBQUksRUFBRTtRQUNiLElBQUksQ0FBQ3FDLE9BQU8sT0FBT0EsUUFBUSxVQUFVO1lBQ2pDLE9BQU8sQ0FBQztRQUNaO1FBQ0EsT0FBT25GLE9BQU9vRixXQUFXLENBQUNwRixPQUFPcUYsT0FBTyxDQUFDRixLQUFLRyxNQUFNLENBQUMsQ0FBQyxDQUFDQyxJQUFJLEdBQUt6QyxLQUFLMEMsUUFBUSxDQUFDRDtJQUNsRjtBQUNKO0FBQ0FyRixrQkFBZSxHQUFHRSxZQUNsQixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvc2VyaWFsaXplci5qcz84OTI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgU2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3IoYWxsb3dlZE1ldGFkYXRhS2V5cykge1xuICAgICAgICB0aGlzLkhFQURFUl9MRU5HVEggPSAxO1xuICAgICAgICB0aGlzLlVTRVJfQlJPQURDQVNUX1BVU0hfTUVUQV9MRU5HVEggPSA2O1xuICAgICAgICB0aGlzLktJTkRTID0geyB1c2VyQnJvYWRjYXN0UHVzaDogMywgdXNlckJyb2FkY2FzdDogNCB9O1xuICAgICAgICB0aGlzLkJJTkFSWV9FTkNPRElORyA9IDA7XG4gICAgICAgIHRoaXMuSlNPTl9FTkNPRElORyA9IDE7XG4gICAgICAgIHRoaXMuQlJPQURDQVNUX0VWRU5UID0gJ2Jyb2FkY2FzdCc7XG4gICAgICAgIHRoaXMuYWxsb3dlZE1ldGFkYXRhS2V5cyA9IFtdO1xuICAgICAgICB0aGlzLmFsbG93ZWRNZXRhZGF0YUtleXMgPSBhbGxvd2VkTWV0YWRhdGFLZXlzICE9PSBudWxsICYmIGFsbG93ZWRNZXRhZGF0YUtleXMgIT09IHZvaWQgMCA/IGFsbG93ZWRNZXRhZGF0YUtleXMgOiBbXTtcbiAgICB9XG4gICAgZW5jb2RlKG1zZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKG1zZy5ldmVudCA9PT0gdGhpcy5CUk9BRENBU1RfRVZFTlQgJiZcbiAgICAgICAgICAgICEobXNnLnBheWxvYWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiZcbiAgICAgICAgICAgIHR5cGVvZiBtc2cucGF5bG9hZC5ldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9iaW5hcnlFbmNvZGVVc2VyQnJvYWRjYXN0UHVzaChtc2cpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGF5bG9hZCA9IFttc2cuam9pbl9yZWYsIG1zZy5yZWYsIG1zZy50b3BpYywgbXNnLmV2ZW50LCBtc2cucGF5bG9hZF07XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgfVxuICAgIF9iaW5hcnlFbmNvZGVVc2VyQnJvYWRjYXN0UHVzaChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuX2lzQXJyYXlCdWZmZXIoKF9hID0gbWVzc2FnZS5wYXlsb2FkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF5bG9hZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVCaW5hcnlVc2VyQnJvYWRjYXN0UHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVKc29uVXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2VuY29kZUJpbmFyeVVzZXJCcm9hZGNhc3RQdXNoKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgdXNlclBheWxvYWQgPSAoX2IgPSAoX2EgPSBtZXNzYWdlLnBheWxvYWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVVc2VyQnJvYWRjYXN0UHVzaChtZXNzYWdlLCB0aGlzLkJJTkFSWV9FTkNPRElORywgdXNlclBheWxvYWQpO1xuICAgIH1cbiAgICBfZW5jb2RlSnNvblVzZXJCcm9hZGNhc3RQdXNoKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgdXNlclBheWxvYWQgPSAoX2IgPSAoX2EgPSBtZXNzYWdlLnBheWxvYWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICBjb25zdCBlbmNvZGVkVXNlclBheWxvYWQgPSBlbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeSh1c2VyUGF5bG9hZCkpLmJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVVzZXJCcm9hZGNhc3RQdXNoKG1lc3NhZ2UsIHRoaXMuSlNPTl9FTkNPRElORywgZW5jb2RlZFVzZXJQYXlsb2FkKTtcbiAgICB9XG4gICAgX2VuY29kZVVzZXJCcm9hZGNhc3RQdXNoKG1lc3NhZ2UsIGVuY29kaW5nVHlwZSwgZW5jb2RlZFBheWxvYWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgdG9waWMgPSBtZXNzYWdlLnRvcGljO1xuICAgICAgICBjb25zdCByZWYgPSAoX2EgPSBtZXNzYWdlLnJlZikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgIGNvbnN0IGpvaW5SZWYgPSAoX2IgPSBtZXNzYWdlLmpvaW5fcmVmKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgICAgICAgY29uc3QgdXNlckV2ZW50ID0gbWVzc2FnZS5wYXlsb2FkLmV2ZW50O1xuICAgICAgICAvLyBGaWx0ZXIgbWV0YWRhdGEgYmFzZWQgb24gYWxsb3dlZCBrZXlzXG4gICAgICAgIGNvbnN0IHJlc3QgPSB0aGlzLmFsbG93ZWRNZXRhZGF0YUtleXNcbiAgICAgICAgICAgID8gdGhpcy5fcGljayhtZXNzYWdlLnBheWxvYWQsIHRoaXMuYWxsb3dlZE1ldGFkYXRhS2V5cylcbiAgICAgICAgICAgIDoge307XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gT2JqZWN0LmtleXMocmVzdCkubGVuZ3RoID09PSAwID8gJycgOiBKU09OLnN0cmluZ2lmeShyZXN0KTtcbiAgICAgICAgLy8gVmFsaWRhdGUgbGVuZ3RocyBkb24ndCBleGNlZWQgdWludDggbWF4IHZhbHVlICgyNTUpXG4gICAgICAgIGlmIChqb2luUmVmLmxlbmd0aCA+IDI1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBqb2luUmVmIGxlbmd0aCAke2pvaW5SZWYubGVuZ3RofSBleGNlZWRzIG1heGltdW0gb2YgMjU1YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZi5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVmIGxlbmd0aCAke3JlZi5sZW5ndGh9IGV4Y2VlZHMgbWF4aW11bSBvZiAyNTVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9waWMubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRvcGljIGxlbmd0aCAke3RvcGljLmxlbmd0aH0gZXhjZWVkcyBtYXhpbXVtIG9mIDI1NWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyRXZlbnQubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVzZXJFdmVudCBsZW5ndGggJHt1c2VyRXZlbnQubGVuZ3RofSBleGNlZWRzIG1heGltdW0gb2YgMjU1YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhLmxlbmd0aCA+IDI1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtZXRhZGF0YSBsZW5ndGggJHttZXRhZGF0YS5sZW5ndGh9IGV4Y2VlZHMgbWF4aW11bSBvZiAyNTVgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhTGVuZ3RoID0gdGhpcy5VU0VSX0JST0FEQ0FTVF9QVVNIX01FVEFfTEVOR1RIICtcbiAgICAgICAgICAgIGpvaW5SZWYubGVuZ3RoICtcbiAgICAgICAgICAgIHJlZi5sZW5ndGggK1xuICAgICAgICAgICAgdG9waWMubGVuZ3RoICtcbiAgICAgICAgICAgIHVzZXJFdmVudC5sZW5ndGggK1xuICAgICAgICAgICAgbWV0YWRhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5IRUFERVJfTEVOR1RIICsgbWV0YUxlbmd0aCk7XG4gICAgICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGhlYWRlcik7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCB0aGlzLktJTkRTLnVzZXJCcm9hZGNhc3RQdXNoKTsgLy8ga2luZFxuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBqb2luUmVmLmxlbmd0aCk7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHJlZi5sZW5ndGgpO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCB0b3BpYy5sZW5ndGgpO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCB1c2VyRXZlbnQubGVuZ3RoKTtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgbWV0YWRhdGEubGVuZ3RoKTtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgZW5jb2RpbmdUeXBlKTtcbiAgICAgICAgQXJyYXkuZnJvbShqb2luUmVmLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIEFycmF5LmZyb20ocmVmLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIEFycmF5LmZyb20odG9waWMsIChjaGFyKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgQXJyYXkuZnJvbSh1c2VyRXZlbnQsIChjaGFyKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgQXJyYXkuZnJvbShtZXRhZGF0YSwgKGNoYXIpID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB2YXIgY29tYmluZWQgPSBuZXcgVWludDhBcnJheShoZWFkZXIuYnl0ZUxlbmd0aCArIGVuY29kZWRQYXlsb2FkLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkoaGVhZGVyKSwgMCk7XG4gICAgICAgIGNvbWJpbmVkLnNldChuZXcgVWludDhBcnJheShlbmNvZGVkUGF5bG9hZCksIGhlYWRlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkLmJ1ZmZlcjtcbiAgICB9XG4gICAgZGVjb2RlKHJhd1BheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0FycmF5QnVmZmVyKHJhd1BheWxvYWQpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fYmluYXJ5RGVjb2RlKHJhd1BheWxvYWQpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByYXdQYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QganNvblBheWxvYWQgPSBKU09OLnBhcnNlKHJhd1BheWxvYWQpO1xuICAgICAgICAgICAgY29uc3QgW2pvaW5fcmVmLCByZWYsIHRvcGljLCBldmVudCwgcGF5bG9hZF0gPSBqc29uUGF5bG9hZDtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh7IGpvaW5fcmVmLCByZWYsIHRvcGljLCBldmVudCwgcGF5bG9hZCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soe30pO1xuICAgIH1cbiAgICBfYmluYXJ5RGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGtpbmQgPSB2aWV3LmdldFVpbnQ4KDApO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSB0aGlzLktJTkRTLnVzZXJCcm9hZGNhc3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVVzZXJCcm9hZGNhc3QoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZGVjb2RlVXNlckJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpIHtcbiAgICAgICAgY29uc3QgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgxKTtcbiAgICAgICAgY29uc3QgdXNlckV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMik7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhU2l6ZSA9IHZpZXcuZ2V0VWludDgoMyk7XG4gICAgICAgIGNvbnN0IHBheWxvYWRFbmNvZGluZyA9IHZpZXcuZ2V0VWludDgoNCk7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyA0O1xuICAgICAgICBjb25zdCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpO1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemU7XG4gICAgICAgIGNvbnN0IHVzZXJFdmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHVzZXJFdmVudFNpemUpKTtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdXNlckV2ZW50U2l6ZTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBtZXRhZGF0YVNpemUpKTtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgbWV0YWRhdGFTaXplO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjb25zdCBwYXJzZWRQYXlsb2FkID0gcGF5bG9hZEVuY29kaW5nID09PSB0aGlzLkpTT05fRU5DT0RJTkcgPyBKU09OLnBhcnNlKGRlY29kZXIuZGVjb2RlKHBheWxvYWQpKSA6IHBheWxvYWQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLkJST0FEQ0FTVF9FVkVOVCxcbiAgICAgICAgICAgIGV2ZW50OiB1c2VyRXZlbnQsXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXJzZWRQYXlsb2FkLFxuICAgICAgICB9O1xuICAgICAgICAvLyBNZXRhZGF0YSBpcyBvcHRpb25hbCBhbmQgYWx3YXlzIEpTT04gZW5jb2RlZFxuICAgICAgICBpZiAobWV0YWRhdGFTaXplID4gMCkge1xuICAgICAgICAgICAgZGF0YVsnbWV0YSddID0gSlNPTi5wYXJzZShtZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgam9pbl9yZWY6IG51bGwsIHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogdGhpcy5CUk9BRENBU1RfRVZFTlQsIHBheWxvYWQ6IGRhdGEgfTtcbiAgICB9XG4gICAgX2lzQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8ICgoX2EgPSBidWZmZXIgPT09IG51bGwgfHwgYnVmZmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBidWZmZXIuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PT0gJ0FycmF5QnVmZmVyJztcbiAgICB9XG4gICAgX3BpY2sob2JqLCBrZXlzKSB7XG4gICAgICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvYmopLmZpbHRlcigoW2tleV0pID0+IGtleXMuaW5jbHVkZXMoa2V5KSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNlcmlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJpYWxpemVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNlcmlhbGl6ZXIiLCJjb25zdHJ1Y3RvciIsImFsbG93ZWRNZXRhZGF0YUtleXMiLCJIRUFERVJfTEVOR1RIIiwiVVNFUl9CUk9BRENBU1RfUFVTSF9NRVRBX0xFTkdUSCIsIktJTkRTIiwidXNlckJyb2FkY2FzdFB1c2giLCJ1c2VyQnJvYWRjYXN0IiwiQklOQVJZX0VOQ09ESU5HIiwiSlNPTl9FTkNPRElORyIsIkJST0FEQ0FTVF9FVkVOVCIsImVuY29kZSIsIm1zZyIsImNhbGxiYWNrIiwiZXZlbnQiLCJwYXlsb2FkIiwiQXJyYXlCdWZmZXIiLCJfYmluYXJ5RW5jb2RlVXNlckJyb2FkY2FzdFB1c2giLCJqb2luX3JlZiIsInJlZiIsInRvcGljIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1lc3NhZ2UiLCJfYSIsIl9pc0FycmF5QnVmZmVyIiwiX2VuY29kZUJpbmFyeVVzZXJCcm9hZGNhc3RQdXNoIiwiX2VuY29kZUpzb25Vc2VyQnJvYWRjYXN0UHVzaCIsIl9iIiwidXNlclBheWxvYWQiLCJfZW5jb2RlVXNlckJyb2FkY2FzdFB1c2giLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGVkVXNlclBheWxvYWQiLCJidWZmZXIiLCJlbmNvZGluZ1R5cGUiLCJlbmNvZGVkUGF5bG9hZCIsImpvaW5SZWYiLCJ1c2VyRXZlbnQiLCJyZXN0IiwiX3BpY2siLCJtZXRhZGF0YSIsImtleXMiLCJsZW5ndGgiLCJFcnJvciIsIm1ldGFMZW5ndGgiLCJoZWFkZXIiLCJ2aWV3IiwiRGF0YVZpZXciLCJvZmZzZXQiLCJzZXRVaW50OCIsIkFycmF5IiwiZnJvbSIsImNoYXIiLCJjaGFyQ29kZUF0IiwiY29tYmluZWQiLCJVaW50OEFycmF5IiwiYnl0ZUxlbmd0aCIsInNldCIsImRlY29kZSIsInJhd1BheWxvYWQiLCJyZXN1bHQiLCJfYmluYXJ5RGVjb2RlIiwianNvblBheWxvYWQiLCJwYXJzZSIsImtpbmQiLCJnZXRVaW50OCIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsIl9kZWNvZGVVc2VyQnJvYWRjYXN0IiwidG9waWNTaXplIiwidXNlckV2ZW50U2l6ZSIsIm1ldGFkYXRhU2l6ZSIsInBheWxvYWRFbmNvZGluZyIsInNsaWNlIiwicGFyc2VkUGF5bG9hZCIsImRhdGEiLCJ0eXBlIiwibmFtZSIsIm9iaiIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsImZpbHRlciIsImtleSIsImluY2x1ZGVzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/serializer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/timer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/main/lib/timer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */ class Timer {\n    constructor(callback, timerCalc){\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n        this.timer = undefined;\n        this.tries = 0;\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n    }\n    reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n        this.timer = undefined;\n    }\n    // Cancels any previous scheduleTimeout and schedules callback\n    scheduleTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(()=>{\n            this.tries = this.tries + 1;\n            this.callback();\n        }, this.timerCalc(this.tries + 1));\n    }\n}\nexports[\"default\"] = Timer; //# sourceMappingURL=timer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvdGltZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0Q7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxNQUFNQztJQUNGQyxZQUFZQyxRQUFRLEVBQUVDLFNBQVMsQ0FBRTtRQUM3QixJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsS0FBSyxHQUFHQztRQUNiLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDSixRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtJQUNyQjtJQUNBSSxRQUFRO1FBQ0osSUFBSSxDQUFDRCxLQUFLLEdBQUc7UUFDYkUsYUFBYSxJQUFJLENBQUNKLEtBQUs7UUFDdkIsSUFBSSxDQUFDQSxLQUFLLEdBQUdDO0lBQ2pCO0lBQ0EsOERBQThEO0lBQzlESSxrQkFBa0I7UUFDZEQsYUFBYSxJQUFJLENBQUNKLEtBQUs7UUFDdkIsSUFBSSxDQUFDQSxLQUFLLEdBQUdNLFdBQVc7WUFDcEIsSUFBSSxDQUFDSixLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLLEdBQUc7WUFDMUIsSUFBSSxDQUFDSixRQUFRO1FBQ2pCLEdBQUcsSUFBSSxDQUFDQyxTQUFTLENBQUMsSUFBSSxDQUFDRyxLQUFLLEdBQUc7SUFDbkM7QUFDSjtBQUNBUixrQkFBZSxHQUFHRSxPQUNsQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvdGltZXIuanM/NTA3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ3JlYXRlcyBhIHRpbWVyIHRoYXQgYWNjZXB0cyBhIGB0aW1lckNhbGNgIGZ1bmN0aW9uIHRvIHBlcmZvcm0gY2FsY3VsYXRlZCB0aW1lb3V0IHJldHJpZXMsIHN1Y2ggYXMgZXhwb25lbnRpYWwgYmFja29mZi5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgbGV0IHJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHRoaXMuY29ubmVjdCgpLCBmdW5jdGlvbih0cmllcyl7XG4gKiAgICAgIHJldHVybiBbMTAwMCwgNTAwMCwgMTAwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAqICAgIH0pXG4gKiAgICByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKiAgICByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciA1MDAwXG4gKiAgICByZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gKiAgICByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKi9cbmNsYXNzIFRpbWVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgdGltZXJDYWxjKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy50aW1lckNhbGMgPSB0aW1lckNhbGM7XG4gICAgICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudHJpZXMgPSAwO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy50cmllcyA9IDA7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gQ2FuY2VscyBhbnkgcHJldmlvdXMgc2NoZWR1bGVUaW1lb3V0IGFuZCBzY2hlZHVsZXMgY2FsbGJhY2tcbiAgICBzY2hlZHVsZVRpbWVvdXQoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmllcyA9IHRoaXMudHJpZXMgKyAxO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgICAgICB9LCB0aGlzLnRpbWVyQ2FsYyh0aGlzLnRyaWVzICsgMSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFRpbWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVGltZXIiLCJjb25zdHJ1Y3RvciIsImNhbGxiYWNrIiwidGltZXJDYWxjIiwidGltZXIiLCJ1bmRlZmluZWQiLCJ0cmllcyIsInJlc2V0IiwiY2xlYXJUaW1lb3V0Iiwic2NoZWR1bGVUaW1lb3V0Iiwic2V0VGltZW91dCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/timer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/transformers.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/main/lib/transformers.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/**\n * Helpers to convert the change Payload into native JS types.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.httpEndpointURL = exports.toTimestampString = exports.toArray = exports.toJson = exports.toNumber = exports.toBoolean = exports.convertCell = exports.convertColumn = exports.convertChangeData = exports.PostgresTypes = void 0;\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nvar PostgresTypes;\n(function(PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"text\"] = \"text\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (exports.PostgresTypes = PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */ const convertChangeData = (columns, record, options = {})=>{\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    if (!record) {\n        return {};\n    }\n    return Object.keys(record).reduce((acc, rec_key)=>{\n        acc[rec_key] = (0, exports.convertColumn)(rec_key, columns, record, skipTypes);\n        return acc;\n    }, {});\n};\nexports.convertChangeData = convertChangeData;\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */ const convertColumn = (columnName, columns, record, skipTypes)=>{\n    const column = columns.find((x)=>x.name === columnName);\n    const colType = column === null || column === void 0 ? void 0 : column.type;\n    const value = record[columnName];\n    if (colType && !skipTypes.includes(colType)) {\n        return (0, exports.convertCell)(colType, value);\n    }\n    return noop(value);\n};\nexports.convertColumn = convertColumn;\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */ const convertCell = (type, value)=>{\n    // if data type is an array\n    if (type.charAt(0) === \"_\") {\n        const dataType = type.slice(1, type.length);\n        return (0, exports.toArray)(value, dataType);\n    }\n    // If not null, convert to correct type.\n    switch(type){\n        case PostgresTypes.bool:\n            return (0, exports.toBoolean)(value);\n        case PostgresTypes.float4:\n        case PostgresTypes.float8:\n        case PostgresTypes.int2:\n        case PostgresTypes.int4:\n        case PostgresTypes.int8:\n        case PostgresTypes.numeric:\n        case PostgresTypes.oid:\n            return (0, exports.toNumber)(value);\n        case PostgresTypes.json:\n        case PostgresTypes.jsonb:\n            return (0, exports.toJson)(value);\n        case PostgresTypes.timestamp:\n            return (0, exports.toTimestampString)(value); // Format to be consistent with PostgREST\n        case PostgresTypes.abstime:\n        case PostgresTypes.date:\n        case PostgresTypes.daterange:\n        case PostgresTypes.int4range:\n        case PostgresTypes.int8range:\n        case PostgresTypes.money:\n        case PostgresTypes.reltime:\n        case PostgresTypes.text:\n        case PostgresTypes.time:\n        case PostgresTypes.timestamptz:\n        case PostgresTypes.timetz:\n        case PostgresTypes.tsrange:\n        case PostgresTypes.tstzrange:\n            return noop(value);\n        default:\n            // Return the value for remaining types\n            return noop(value);\n    }\n};\nexports.convertCell = convertCell;\nconst noop = (value)=>{\n    return value;\n};\nconst toBoolean = (value)=>{\n    switch(value){\n        case \"t\":\n            return true;\n        case \"f\":\n            return false;\n        default:\n            return value;\n    }\n};\nexports.toBoolean = toBoolean;\nconst toNumber = (value)=>{\n    if (typeof value === \"string\") {\n        const parsedValue = parseFloat(value);\n        if (!Number.isNaN(parsedValue)) {\n            return parsedValue;\n        }\n    }\n    return value;\n};\nexports.toNumber = toNumber;\nconst toJson = (value)=>{\n    if (typeof value === \"string\") {\n        try {\n            return JSON.parse(value);\n        } catch (_a) {\n            return value;\n        }\n    }\n    return value;\n};\nexports.toJson = toJson;\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */ const toArray = (value, type)=>{\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    const lastIdx = value.length - 1;\n    const closeBrace = value[lastIdx];\n    const openBrace = value[0];\n    // Confirm value is a Postgres array by checking curly brackets\n    if (openBrace === \"{\" && closeBrace === \"}\") {\n        let arr;\n        const valTrim = value.slice(1, lastIdx);\n        // TODO: find a better solution to separate Postgres array data\n        try {\n            arr = JSON.parse(\"[\" + valTrim + \"]\");\n        } catch (_) {\n            // WARNING: splitting on comma does not cover all edge cases\n            arr = valTrim ? valTrim.split(\",\") : [];\n        }\n        return arr.map((val)=>(0, exports.convertCell)(type, val));\n    }\n    return value;\n};\nexports.toArray = toArray;\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */ const toTimestampString = (value)=>{\n    if (typeof value === \"string\") {\n        return value.replace(\" \", \"T\");\n    }\n    return value;\n};\nexports.toTimestampString = toTimestampString;\nconst httpEndpointURL = (socketUrl)=>{\n    const wsUrl = new URL(socketUrl);\n    wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, \"http\");\n    wsUrl.pathname = wsUrl.pathname.replace(/\\/+$/, \"\") // remove all trailing slashes\n    .replace(/\\/socket\\/websocket$/i, \"\") // remove the socket/websocket path\n    .replace(/\\/socket$/i, \"\") // remove the socket path\n    .replace(/\\/websocket$/i, \"\"); // remove the websocket path\n    if (wsUrl.pathname === \"\" || wsUrl.pathname === \"/\") {\n        wsUrl.pathname = \"/api/broadcast\";\n    } else {\n        wsUrl.pathname = wsUrl.pathname + \"/api/broadcast\";\n    }\n    return wsUrl.href;\n};\nexports.httpEndpointURL = httpEndpointURL; //# sourceMappingURL=transformers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvdHJhbnNmb3JtZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7O0NBRUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHQSx5QkFBeUIsR0FBR0EsZUFBZSxHQUFHQSxjQUFjLEdBQUdBLGdCQUFnQixHQUFHQSxpQkFBaUIsR0FBR0EsbUJBQW1CLEdBQUdBLHFCQUFxQixHQUFHQSx5QkFBeUIsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUN2TywwRUFBMEU7QUFDMUUseUZBQXlGO0FBQ3pGLElBQUlXO0FBQ0gsVUFBVUEsYUFBYTtJQUNwQkEsYUFBYSxDQUFDLFVBQVUsR0FBRztJQUMzQkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLFlBQVksR0FBRztJQUM3QkEsYUFBYSxDQUFDLFNBQVMsR0FBRztJQUMxQkEsYUFBYSxDQUFDLFNBQVMsR0FBRztJQUMxQkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLFlBQVksR0FBRztJQUM3QkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLFlBQVksR0FBRztJQUM3QkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLFFBQVEsR0FBRztJQUN6QkEsYUFBYSxDQUFDLFFBQVEsR0FBRztJQUN6QkEsYUFBYSxDQUFDLFVBQVUsR0FBRztJQUMzQkEsYUFBYSxDQUFDLE1BQU0sR0FBRztJQUN2QkEsYUFBYSxDQUFDLFVBQVUsR0FBRztJQUMzQkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLE9BQU8sR0FBRztJQUN4QkEsYUFBYSxDQUFDLFlBQVksR0FBRztJQUM3QkEs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SCxNQUFNRyxRQUFRLEdBQUc7SUFDdEM7SUFDQSxPQUFPSCxNQUFNSSxJQUFJO0FBQ3JCO0FBQ0EvRSx1QkFBdUIsR0FBR0UsaUJBQzFCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tYWluL2xpYi90cmFuc2Zvcm1lcnMuanM/YzI1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogSGVscGVycyB0byBjb252ZXJ0IHRoZSBjaGFuZ2UgUGF5bG9hZCBpbnRvIG5hdGl2ZSBKUyB0eXBlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5odHRwRW5kcG9pbnRVUkwgPSBleHBvcnRzLnRvVGltZXN0YW1wU3RyaW5nID0gZXhwb3J0cy50b0FycmF5ID0gZXhwb3J0cy50b0pzb24gPSBleHBvcnRzLnRvTnVtYmVyID0gZXhwb3J0cy50b0Jvb2xlYW4gPSBleHBvcnRzLmNvbnZlcnRDZWxsID0gZXhwb3J0cy5jb252ZXJ0Q29sdW1uID0gZXhwb3J0cy5jb252ZXJ0Q2hhbmdlRGF0YSA9IGV4cG9ydHMuUG9zdGdyZXNUeXBlcyA9IHZvaWQgMDtcbi8vIEFkYXB0ZWQgZnJvbSBlcGdzcWwgKHNyYy9lcGdzcWxfYmluYXJ5LmVybCksIHRoaXMgbW9kdWxlIGxpY2Vuc2VkIHVuZGVyXG4vLyAzLWNsYXVzZSBCU0QgZm91bmQgaGVyZTogaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2VwZ3NxbC9lcGdzcWwvZGV2ZWwvTElDRU5TRVxudmFyIFBvc3RncmVzVHlwZXM7XG4oZnVuY3Rpb24gKFBvc3RncmVzVHlwZXMpIHtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiYWJzdGltZVwiXSA9IFwiYWJzdGltZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJib29sXCJdID0gXCJib29sXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImRhdGVcIl0gPSBcImRhdGVcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiZGF0ZXJhbmdlXCJdID0gXCJkYXRlcmFuZ2VcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiZmxvYXQ0XCJdID0gXCJmbG9hdDRcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiZmxvYXQ4XCJdID0gXCJmbG9hdDhcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50MlwiXSA9IFwiaW50MlwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQ0XCJdID0gXCJpbnQ0XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImludDRyYW5nZVwiXSA9IFwiaW50NHJhbmdlXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImludDhcIl0gPSBcImludDhcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50OHJhbmdlXCJdID0gXCJpbnQ4cmFuZ2VcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wianNvblwiXSA9IFwianNvblwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJqc29uYlwiXSA9IFwianNvbmJcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wibW9uZXlcIl0gPSBcIm1vbmV5XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcIm51bWVyaWNcIl0gPSBcIm51bWVyaWNcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wib2lkXCJdID0gXCJvaWRcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wicmVsdGltZVwiXSA9IFwicmVsdGltZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0ZXh0XCJdID0gXCJ0ZXh0XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRpbWVcIl0gPSBcInRpbWVcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGltZXN0YW1wXCJdID0gXCJ0aW1lc3RhbXBcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGltZXN0YW1wdHpcIl0gPSBcInRpbWVzdGFtcHR6XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRpbWV0elwiXSA9IFwidGltZXR6XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRzcmFuZ2VcIl0gPSBcInRzcmFuZ2VcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widHN0enJhbmdlXCJdID0gXCJ0c3R6cmFuZ2VcIjtcbn0pKFBvc3RncmVzVHlwZXMgfHwgKGV4cG9ydHMuUG9zdGdyZXNUeXBlcyA9IFBvc3RncmVzVHlwZXMgPSB7fSkpO1xuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBjb2x1bW5zIGFuZCBhbiBvYmplY3Qgb2Ygc3RyaW5nIHZhbHVlcyB0aGVuIGNvbnZlcnRzIGVhY2ggc3RyaW5nIHZhbHVlXG4gKiB0byBpdHMgbWFwcGVkIHR5cGUuXG4gKlxuICogQHBhcmFtIHt7bmFtZTogU3RyaW5nLCB0eXBlOiBTdHJpbmd9W119IGNvbHVtbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBtYXAgb2YgdmFyaW91cyBvcHRpb25zIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gdGhlIG1hcHBlclxuICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5za2lwVHlwZXMgVGhlIGFycmF5IG9mIHR5cGVzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWRcbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2hhbmdlRGF0YShbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiczMyd9LCB7fSlcbiAqIC8vPT57IGZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAzMyB9XG4gKi9cbmNvbnN0IGNvbnZlcnRDaGFuZ2VEYXRhID0gKGNvbHVtbnMsIHJlY29yZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNraXBUeXBlcyA9IChfYSA9IG9wdGlvbnMuc2tpcFR5cGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhyZWNvcmQpLnJlZHVjZSgoYWNjLCByZWNfa2V5KSA9PiB7XG4gICAgICAgIGFjY1tyZWNfa2V5XSA9ICgwLCBleHBvcnRzLmNvbnZlcnRDb2x1bW4pKHJlY19rZXksIGNvbHVtbnMsIHJlY29yZCwgc2tpcFR5cGVzKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59O1xuZXhwb3J0cy5jb252ZXJ0Q2hhbmdlRGF0YSA9IGNvbnZlcnRDaGFuZ2VEYXRhO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgdmFsdWUgb2YgYW4gaW5kaXZpZHVhbCBjb2x1bW4uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbk5hbWUgVGhlIGNvbHVtbiB0aGF0IHlvdSB3YW50IHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7e25hbWU6IFN0cmluZywgdHlwZTogU3RyaW5nfVtdfSBjb2x1bW5zIEFsbCBvZiB0aGUgY29sdW1uc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCBUaGUgbWFwIG9mIHN0cmluZyB2YWx1ZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHNraXBUeXBlcyBBbiBhcnJheSBvZiB0eXBlcyB0aGF0IHNob3VsZCBub3QgYmUgY29udmVydGVkXG4gKiBAcmV0dXJuIHtvYmplY3R9IFVzZWxlc3MgaW5mb3JtYXRpb25cbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q29sdW1uKCdhZ2UnLCBbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAnMzMnfSwgW10pXG4gKiAvLz0+IDMzXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q29sdW1uKCdhZ2UnLCBbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAnMzMnfSwgWydpbnQ0J10pXG4gKiAvLz0+IFwiMzNcIlxuICovXG5jb25zdCBjb252ZXJ0Q29sdW1uID0gKGNvbHVtbk5hbWUsIGNvbHVtbnMsIHJlY29yZCwgc2tpcFR5cGVzKSA9PiB7XG4gICAgY29uc3QgY29sdW1uID0gY29sdW1ucy5maW5kKCh4KSA9PiB4Lm5hbWUgPT09IGNvbHVtbk5hbWUpO1xuICAgIGNvbnN0IGNvbFR5cGUgPSBjb2x1bW4gPT09IG51bGwgfHwgY29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2x1bW4udHlwZTtcbiAgICBjb25zdCB2YWx1ZSA9IHJlY29yZFtjb2x1bW5OYW1lXTtcbiAgICBpZiAoY29sVHlwZSAmJiAhc2tpcFR5cGVzLmluY2x1ZGVzKGNvbFR5cGUpKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5jb252ZXJ0Q2VsbCkoY29sVHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbm9vcCh2YWx1ZSk7XG59O1xuZXhwb3J0cy5jb252ZXJ0Q29sdW1uID0gY29udmVydENvbHVtbjtcbi8qKlxuICogSWYgdGhlIHZhbHVlIG9mIHRoZSBjZWxsIGlzIGBudWxsYCwgcmV0dXJucyBudWxsLlxuICogT3RoZXJ3aXNlIGNvbnZlcnRzIHRoZSBzdHJpbmcgdmFsdWUgdG8gdGhlIGNvcnJlY3QgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgcG9zdGdyZXMgY29sdW1uIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgY2VsbCB2YWx1ZVxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdib29sJywgJ3QnKVxuICogLy89PiB0cnVlXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnaW50OCcsICcxMCcpXG4gKiAvLz0+IDEwXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnX2ludDQnLCAnezEsMiwzLDR9JylcbiAqIC8vPT4gWzEsMiwzLDRdXG4gKi9cbmNvbnN0IGNvbnZlcnRDZWxsID0gKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgLy8gaWYgZGF0YSB0eXBlIGlzIGFuIGFycmF5XG4gICAgaWYgKHR5cGUuY2hhckF0KDApID09PSAnXycpIHtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB0eXBlLnNsaWNlKDEsIHR5cGUubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLnRvQXJyYXkpKHZhbHVlLCBkYXRhVHlwZSk7XG4gICAgfVxuICAgIC8vIElmIG5vdCBudWxsLCBjb252ZXJ0IHRvIGNvcnJlY3QgdHlwZS5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmJvb2w6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMudG9Cb29sZWFuKSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5mbG9hdDQ6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5mbG9hdDg6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQyOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50NDpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDg6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5udW1lcmljOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMub2lkOlxuICAgICAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLnRvTnVtYmVyKSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5qc29uOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuanNvbmI6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMudG9Kc29uKSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lc3RhbXA6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMudG9UaW1lc3RhbXBTdHJpbmcpKHZhbHVlKTsgLy8gRm9ybWF0IHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBQb3N0Z1JFU1RcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmFic3RpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmRhdGU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmRhdGVyYW5nZTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDRyYW5nZTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDhyYW5nZTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLm1vbmV5OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMucmVsdGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudGV4dDpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWVzdGFtcHR6OiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1ldHo6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRzcmFuZ2U6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50c3R6cmFuZ2U6XG4gICAgICAgICAgICByZXR1cm4gbm9vcCh2YWx1ZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciByZW1haW5pbmcgdHlwZXNcbiAgICAgICAgICAgIHJldHVybiBub29wKHZhbHVlKTtcbiAgICB9XG59O1xuZXhwb3J0cy5jb252ZXJ0Q2VsbCA9IGNvbnZlcnRDZWxsO1xuY29uc3Qgbm9vcCA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCB0b0Jvb2xlYW4gPSAodmFsdWUpID0+IHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG5leHBvcnRzLnRvQm9vbGVhbiA9IHRvQm9vbGVhbjtcbmNvbnN0IHRvTnVtYmVyID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydHMudG9OdW1iZXIgPSB0b051bWJlcjtcbmNvbnN0IHRvSnNvbiA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydHMudG9Kc29uID0gdG9Kc29uO1xuLyoqXG4gKiBDb252ZXJ0cyBhIFBvc3RncmVzIEFycmF5IGludG8gYSBuYXRpdmUgSlMgYXJyYXlcbiAqXG4gKiBAZXhhbXBsZSB0b0FycmF5KCd7fScsICdpbnQ0JylcbiAqIC8vPT4gW11cbiAqIEBleGFtcGxlIHRvQXJyYXkoJ3tcIlsyMDIxLTAxLTAxLDIwMjEtMTItMzEpXCIsXCIoMjAyMS0wMS0wMSwyMDIxLTEyLTMyXVwifScsICdkYXRlcmFuZ2UnKVxuICogLy89PiBbJ1syMDIxLTAxLTAxLDIwMjEtMTItMzEpJywgJygyMDIxLTAxLTAxLDIwMjEtMTItMzJdJ11cbiAqIEBleGFtcGxlIHRvQXJyYXkoWzEsMiwzLDRdLCAnaW50NCcpXG4gKiAvLz0+IFsxLDIsMyw0XVxuICovXG5jb25zdCB0b0FycmF5ID0gKHZhbHVlLCB0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0SWR4ID0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBjbG9zZUJyYWNlID0gdmFsdWVbbGFzdElkeF07XG4gICAgY29uc3Qgb3BlbkJyYWNlID0gdmFsdWVbMF07XG4gICAgLy8gQ29uZmlybSB2YWx1ZSBpcyBhIFBvc3RncmVzIGFycmF5IGJ5IGNoZWNraW5nIGN1cmx5IGJyYWNrZXRzXG4gICAgaWYgKG9wZW5CcmFjZSA9PT0gJ3snICYmIGNsb3NlQnJhY2UgPT09ICd9Jykge1xuICAgICAgICBsZXQgYXJyO1xuICAgICAgICBjb25zdCB2YWxUcmltID0gdmFsdWUuc2xpY2UoMSwgbGFzdElkeCk7XG4gICAgICAgIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgc29sdXRpb24gdG8gc2VwYXJhdGUgUG9zdGdyZXMgYXJyYXkgZGF0YVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXJyID0gSlNPTi5wYXJzZSgnWycgKyB2YWxUcmltICsgJ10nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gV0FSTklORzogc3BsaXR0aW5nIG9uIGNvbW1hIGRvZXMgbm90IGNvdmVyIGFsbCBlZGdlIGNhc2VzXG4gICAgICAgICAgICBhcnIgPSB2YWxUcmltID8gdmFsVHJpbS5zcGxpdCgnLCcpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyci5tYXAoKHZhbCkgPT4gKDAsIGV4cG9ydHMuY29udmVydENlbGwpKHR5cGUsIHZhbCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcbi8qKlxuICogRml4ZXMgdGltZXN0YW1wIHRvIGJlIElTTy04NjAxLiBTd2FwcyB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgZGF0ZSBhbmQgdGltZSBmb3IgYSAnVCdcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2Uvc3VwYWJhc2UvaXNzdWVzLzE4XG4gKlxuICogQGV4YW1wbGUgdG9UaW1lc3RhbXBTdHJpbmcoJzIwMTktMDktMTAgMDA6MDA6MDAnKVxuICogLy89PiAnMjAxOS0wOS0xMFQwMDowMDowMCdcbiAqL1xuY29uc3QgdG9UaW1lc3RhbXBTdHJpbmcgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgnICcsICdUJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnRzLnRvVGltZXN0YW1wU3RyaW5nID0gdG9UaW1lc3RhbXBTdHJpbmc7XG5jb25zdCBodHRwRW5kcG9pbnRVUkwgPSAoc29ja2V0VXJsKSA9PiB7XG4gICAgY29uc3Qgd3NVcmwgPSBuZXcgVVJMKHNvY2tldFVybCk7XG4gICAgd3NVcmwucHJvdG9jb2wgPSB3c1VybC5wcm90b2NvbC5yZXBsYWNlKC9ed3MvaSwgJ2h0dHAnKTtcbiAgICB3c1VybC5wYXRobmFtZSA9IHdzVXJsLnBhdGhuYW1lXG4gICAgICAgIC5yZXBsYWNlKC9cXC8rJC8sICcnKSAvLyByZW1vdmUgYWxsIHRyYWlsaW5nIHNsYXNoZXNcbiAgICAgICAgLnJlcGxhY2UoL1xcL3NvY2tldFxcL3dlYnNvY2tldCQvaSwgJycpIC8vIHJlbW92ZSB0aGUgc29ja2V0L3dlYnNvY2tldCBwYXRoXG4gICAgICAgIC5yZXBsYWNlKC9cXC9zb2NrZXQkL2ksICcnKSAvLyByZW1vdmUgdGhlIHNvY2tldCBwYXRoXG4gICAgICAgIC5yZXBsYWNlKC9cXC93ZWJzb2NrZXQkL2ksICcnKTsgLy8gcmVtb3ZlIHRoZSB3ZWJzb2NrZXQgcGF0aFxuICAgIGlmICh3c1VybC5wYXRobmFtZSA9PT0gJycgfHwgd3NVcmwucGF0aG5hbWUgPT09ICcvJykge1xuICAgICAgICB3c1VybC5wYXRobmFtZSA9ICcvYXBpL2Jyb2FkY2FzdCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3c1VybC5wYXRobmFtZSA9IHdzVXJsLnBhdGhuYW1lICsgJy9hcGkvYnJvYWRjYXN0JztcbiAgICB9XG4gICAgcmV0dXJuIHdzVXJsLmhyZWY7XG59O1xuZXhwb3J0cy5odHRwRW5kcG9pbnRVUkwgPSBodHRwRW5kcG9pbnRVUkw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm1lcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaHR0cEVuZHBvaW50VVJMIiwidG9UaW1lc3RhbXBTdHJpbmciLCJ0b0FycmF5IiwidG9Kc29uIiwidG9OdW1iZXIiLCJ0b0Jvb2xlYW4iLCJjb252ZXJ0Q2VsbCIsImNvbnZlcnRDb2x1bW4iLCJjb252ZXJ0Q2hhbmdlRGF0YSIsIlBvc3RncmVzVHlwZXMiLCJjb2x1bW5zIiwicmVjb3JkIiwib3B0aW9ucyIsIl9hIiwic2tpcFR5cGVzIiwia2V5cyIsInJlZHVjZSIsImFjYyIsInJlY19rZXkiLCJjb2x1bW5OYW1lIiwiY29sdW1uIiwiZmluZCIsIngiLCJuYW1lIiwiY29sVHlwZSIsInR5cGUiLCJpbmNsdWRlcyIsIm5vb3AiLCJjaGFyQXQiLCJkYXRhVHlwZSIsInNsaWNlIiwibGVuZ3RoIiwiYm9vbCIsImZsb2F0NCIsImZsb2F0OCIsImludDIiLCJpbnQ0IiwiaW50OCIsIm51bWVyaWMiLCJvaWQiLCJqc29uIiwianNvbmIiLCJ0aW1lc3RhbXAiLCJhYnN0aW1lIiwiZGF0ZSIsImRhdGVyYW5nZSIsImludDRyYW5nZSIsImludDhyYW5nZSIsIm1vbmV5IiwicmVsdGltZSIsInRleHQiLCJ0aW1lIiwidGltZXN0YW1wdHoiLCJ0aW1ldHoiLCJ0c3JhbmdlIiwidHN0enJhbmdlIiwicGFyc2VkVmFsdWUiLCJwYXJzZUZsb2F0IiwiTnVtYmVyIiwiaXNOYU4iLCJKU09OIiwicGFyc2UiLCJsYXN0SWR4IiwiY2xvc2VCcmFjZSIsIm9wZW5CcmFjZSIsImFyciIsInZhbFRyaW0iLCJfIiwic3BsaXQiLCJtYXAiLCJ2YWwiLCJyZXBsYWNlIiwic29ja2V0VXJsIiwid3NVcmwiLCJVUkwiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwiaHJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/transformers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/version.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/main/lib/version.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.version = void 0;\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nexports.version = \"2.91.0\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHLEtBQUs7QUFDdkIsNkVBQTZFO0FBQzdFLGdFQUFnRTtBQUNoRSx1RUFBdUU7QUFDdkUsaUVBQWlFO0FBQ2pFLGtFQUFrRTtBQUNsRSxpRUFBaUU7QUFDakVBLGVBQWUsR0FBRyxVQUNsQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvdmVyc2lvbi5qcz80YjA4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuLy8gR2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkgZHVyaW5nIHJlbGVhc2VzIGJ5IHNjcmlwdHMvdXBkYXRlLXZlcnNpb24tZmlsZXMudHNcbi8vIFRoaXMgZmlsZSBwcm92aWRlcyBydW50aW1lIGFjY2VzcyB0byB0aGUgcGFja2FnZSB2ZXJzaW9uIGZvcjpcbi8vIC0gSFRUUCByZXF1ZXN0IGhlYWRlcnMgKGUuZy4sIFgtQ2xpZW50LUluZm8gaGVhZGVyIGZvciBBUEkgcmVxdWVzdHMpXG4vLyAtIERlYnVnZ2luZyBhbmQgc3VwcG9ydCAoaWRlbnRpZnlpbmcgd2hpY2ggdmVyc2lvbiBpcyBydW5uaW5nKVxuLy8gLSBUZWxlbWV0cnkgYW5kIGxvZ2dpbmcgKHZlcnNpb24gcmVwb3J0aW5nIGluIGVycm9ycy9hbmFseXRpY3MpXG4vLyAtIEVuc3VyaW5nIGJ1aWxkIGFydGlmYWN0cyBtYXRjaCB0aGUgcHVibGlzaGVkIHBhY2thZ2UgdmVyc2lvblxuZXhwb3J0cy52ZXJzaW9uID0gJzIuOTEuMCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/websocket-factory.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/main/lib/websocket-factory.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebSocketFactory = void 0;\n/**\n * Utilities for creating WebSocket instances across runtimes.\n */ class WebSocketFactory {\n    /**\n     * Static-only utility  prevent instantiation.\n     */ constructor(){}\n    static detectEnvironment() {\n        var _a;\n        if (typeof WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: WebSocket\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && typeof globalThis.WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: globalThis.WebSocket\n            };\n        }\n        if (typeof global !== \"undefined\" && typeof global.WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: global.WebSocket\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && typeof globalThis.WebSocketPair !== \"undefined\" && typeof globalThis.WebSocket === \"undefined\") {\n            return {\n                type: \"cloudflare\",\n                error: \"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.\",\n                workaround: \"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime.\"\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && globalThis.EdgeRuntime || typeof navigator !== \"undefined\" && ((_a = navigator.userAgent) === null || _a === void 0 ? void 0 : _a.includes(\"Vercel-Edge\"))) {\n            return {\n                type: \"unsupported\",\n                error: \"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.\",\n                workaround: \"Use serverless functions or a different deployment target for WebSocket functionality.\"\n            };\n        }\n        // Use dynamic property access to avoid Next.js Edge Runtime static analysis warnings\n        const _process = globalThis[\"process\"];\n        if (_process) {\n            const processVersions = _process[\"versions\"];\n            if (processVersions && processVersions[\"node\"]) {\n                // Remove 'v' prefix if present and parse the major version\n                const versionString = processVersions[\"node\"];\n                const nodeVersion = parseInt(versionString.replace(/^v/, \"\").split(\".\")[0]);\n                // Node.js 22+ should have native WebSocket\n                if (nodeVersion >= 22) {\n                    // Check if native WebSocket is available (should be in Node.js 22+)\n                    if (typeof globalThis.WebSocket !== \"undefined\") {\n                        return {\n                            type: \"native\",\n                            constructor: globalThis.WebSocket\n                        };\n                    }\n                    // If not available, user needs to provide it\n                    return {\n                        type: \"unsupported\",\n                        error: `Node.js ${nodeVersion} detected but native WebSocket not found.`,\n                        workaround: \"Provide a WebSocket implementation via the transport option.\"\n                    };\n                }\n                // Node.js < 22 doesn't have native WebSocket\n                return {\n                    type: \"unsupported\",\n                    error: `Node.js ${nodeVersion} detected without native WebSocket support.`,\n                    workaround: 'For Node.js < 22, install \"ws\" package and provide it via the transport option:\\n' + 'import ws from \"ws\"\\n' + \"new RealtimeClient(url, { transport: ws })\"\n                };\n            }\n        }\n        return {\n            type: \"unsupported\",\n            error: \"Unknown JavaScript runtime without WebSocket support.\",\n            workaround: \"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation.\"\n        };\n    }\n    /**\n     * Returns the best available WebSocket constructor for the current runtime.\n     *\n     * @example\n     * ```ts\n     * const WS = WebSocketFactory.getWebSocketConstructor()\n     * const socket = new WS('wss://realtime.supabase.co/socket')\n     * ```\n     */ static getWebSocketConstructor() {\n        const env = this.detectEnvironment();\n        if (env.constructor) {\n            return env.constructor;\n        }\n        let errorMessage = env.error || \"WebSocket not supported in this environment.\";\n        if (env.workaround) {\n            errorMessage += `\\n\\nSuggested solution: ${env.workaround}`;\n        }\n        throw new Error(errorMessage);\n    }\n    /**\n     * Creates a WebSocket using the detected constructor.\n     *\n     * @example\n     * ```ts\n     * const socket = WebSocketFactory.createWebSocket('wss://realtime.supabase.co/socket')\n     * ```\n     */ static createWebSocket(url, protocols) {\n        const WS = this.getWebSocketConstructor();\n        return new WS(url, protocols);\n    }\n    /**\n     * Detects whether the runtime can establish WebSocket connections.\n     *\n     * @example\n     * ```ts\n     * if (!WebSocketFactory.isWebSocketSupported()) {\n     *   console.warn('Falling back to long polling')\n     * }\n     * ```\n     */ static isWebSocketSupported() {\n        try {\n            const env = this.detectEnvironment();\n            return env.type === \"native\" || env.type === \"ws\";\n        } catch (_a) {\n            return false;\n        }\n    }\n}\nexports.WebSocketFactory = WebSocketFactory;\nexports[\"default\"] = WebSocketFactory; //# sourceMappingURL=websocket-factory.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbWFpbi9saWIvd2Vic29ja2V0LWZhY3RvcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHLEtBQUs7QUFDaEM7O0NBRUMsR0FDRCxNQUFNRTtJQUNGOztLQUVDLEdBQ0RDLGFBQWMsQ0FBRTtJQUNoQixPQUFPQyxvQkFBb0I7UUFDdkIsSUFBSUM7UUFDSixJQUFJLE9BQU9DLGNBQWMsYUFBYTtZQUNsQyxPQUFPO2dCQUFFQyxNQUFNO2dCQUFVSixhQUFhRztZQUFVO1FBQ3BEO1FBQ0EsSUFBSSxPQUFPRSxlQUFlLGVBQWUsT0FBT0EsV0FBV0YsU0FBUyxLQUFLLGFBQWE7WUFDbEYsT0FBTztnQkFBRUMsTUFBTTtnQkFBVUosYUFBYUssV0FBV0YsU0FBUztZQUFDO1FBQy9EO1FBQ0EsSUFBSSxPQUFPRyxXQUFXLGVBQWUsT0FBT0EsT0FBT0gsU0FBUyxLQUFLLGFBQWE7WUFDMUUsT0FBTztnQkFBRUMsTUFBTTtnQkFBVUosYUFBYU0sT0FBT0gsU0FBUztZQUFDO1FBQzNEO1FBQ0EsSUFBSSxPQUFPRSxlQUFlLGVBQ3RCLE9BQU9BLFdBQVdFLGFBQWEsS0FBSyxlQUNwQyxPQUFPRixXQUFXRixTQUFTLEtBQUssYUFBYTtZQUM3QyxPQUFPO2dCQUNIQyxNQUFNO2dCQUNOSSxPQUFPO2dCQUNQQyxZQUFZO1lBQ2hCO1FBQ0o7UUFDQSxJQUFJLE9BQVFKLGVBQWUsZUFBZUEsV0FBV0ssV0FBVyxJQUMzRCxPQUFPQyxjQUFjLGVBQWdCLEVBQUNULEtBQUtTLFVBQVVDLFNBQVMsTUFBTSxRQUFRVixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdXLFFBQVEsQ0FBQyxjQUFhLEdBQUs7WUFDcEksT0FBTztnQkFDSFQsTUFBTTtnQkFDTkksT0FBTztnQkFDUEMsWUFBWTtZQUNoQjtRQUNKO1FBQ0EscUZBQXFGO1FBQ3JGLE1BQU1LLFdBQVdULFVBQVUsQ0FBQyxVQUFVO1FBQ3RDLElBQUlTLFVBQVU7WUFDVixNQUFNQyxrQkFBa0JELFFBQVEsQ0FBQyxXQUFXO1lBQzVDLElBQUlDLG1CQUFtQkEsZUFBZSxDQUFDLE9BQU8sRUFBRTtnQkFDNUMsMkRBQTJEO2dCQUMzRCxNQUFNQyxnQkFBZ0JELGVBQWUsQ0FBQyxPQUFPO2dCQUM3QyxNQUFNRSxjQUFjQyxTQUFTRixjQUFjRyxPQUFPLENBQUMsTUFBTSxJQUFJQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQzFFLDJDQUEyQztnQkFDM0MsSUFBSUgsZUFBZSxJQUFJO29CQUNuQixvRUFBb0U7b0JBQ3BFLElBQUksT0FBT1osV0FBV0YsU0FBUyxLQUFLLGFBQWE7d0JBQzdDLE9BQU87NEJBQUVDLE1BQU07NEJBQVVKLGFBQWFLLFdBQVdGLFNBQVM7d0JBQUM7b0JBQy9EO29CQUNBLDZDQUE2QztvQkFDN0MsT0FBTzt3QkFDSEMsTUFBTTt3QkFDTkksT0FBTyxDQUFDLFFBQVEsRUFBRVMsWUFBWSx5Q0FBeUMsQ0FBQzt3QkFDeEVSLFlBQVk7b0JBQ2hCO2dCQUNKO2dCQUNBLDZDQUE2QztnQkFDN0MsT0FBTztvQkFDSEwsTUFBTTtvQkFDTkksT0FBTyxDQUFDLFFBQVEsRUFBRVMsWUFBWSwyQ0FBMkMsQ0FBQztvQkFDMUVSLFlBQVksc0ZBQ1IsMEJBQ0E7Z0JBQ1I7WUFDSjtRQUNKO1FBQ0EsT0FBTztZQUNITCxNQUFNO1lBQ05JLE9BQU87WUFDUEMsWUFBWTtRQUNoQjtJQUNKO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRCxPQUFPWSwwQkFBMEI7UUFDN0IsTUFBTUMsTUFBTSxJQUFJLENBQUNyQixpQkFBaUI7UUFDbEMsSUFBSXFCLElBQUl0QixXQUFXLEVBQUU7WUFDakIsT0FBT3NCLElBQUl0QixXQUFXO1FBQzFCO1FBQ0EsSUFBSXVCLGVBQWVELElBQUlkLEtBQUssSUFBSTtRQUNoQyxJQUFJYyxJQUFJYixVQUFVLEVBQUU7WUFDaEJjLGdCQUFnQixDQUFDLHdCQUF3QixFQUFFRCxJQUFJYixVQUFVLENBQUMsQ0FBQztRQUMvRDtRQUNBLE1BQU0sSUFBSWUsTUFBTUQ7SUFDcEI7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsT0FBT0UsZ0JBQWdCQyxHQUFHLEVBQUVDLFNBQVMsRUFBRTtRQUNuQyxNQUFNQyxLQUFLLElBQUksQ0FBQ1AsdUJBQXVCO1FBQ3ZDLE9BQU8sSUFBSU8sR0FBR0YsS0FBS0M7SUFDdkI7SUFDQTs7Ozs7Ozs7O0tBU0MsR0FDRCxPQUFPRSx1QkFBdUI7UUFDMUIsSUFBSTtZQUNBLE1BQU1QLE1BQU0sSUFBSSxDQUFDckIsaUJBQWlCO1lBQ2xDLE9BQU9xQixJQUFJbEIsSUFBSSxLQUFLLFlBQVlrQixJQUFJbEIsSUFBSSxLQUFLO1FBQ2pELEVBQ0EsT0FBT0YsSUFBSTtZQUNQLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQUwsd0JBQXdCLEdBQUdFO0FBQzNCRixrQkFBZSxHQUFHRSxrQkFDbEIsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21haW4vbGliL3dlYnNvY2tldC1mYWN0b3J5LmpzPzE0OTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYlNvY2tldEZhY3RvcnkgPSB2b2lkIDA7XG4vKipcbiAqIFV0aWxpdGllcyBmb3IgY3JlYXRpbmcgV2ViU29ja2V0IGluc3RhbmNlcyBhY3Jvc3MgcnVudGltZXMuXG4gKi9cbmNsYXNzIFdlYlNvY2tldEZhY3Rvcnkge1xuICAgIC8qKlxuICAgICAqIFN0YXRpYy1vbmx5IHV0aWxpdHkg4oCTIHByZXZlbnQgaW5zdGFudGlhdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIHN0YXRpYyBkZXRlY3RFbnZpcm9ubWVudCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICduYXRpdmUnLCBjb25zdHJ1Y3RvcjogV2ViU29ja2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5XZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnbmF0aXZlJywgY29uc3RydWN0b3I6IGdsb2JhbFRoaXMuV2ViU29ja2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWwuV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ25hdGl2ZScsIGNvbnN0cnVjdG9yOiBnbG9iYWwuV2ViU29ja2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbFRoaXMuV2ViU29ja2V0UGFpciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Nsb3VkZmxhcmUnLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnQ2xvdWRmbGFyZSBXb3JrZXJzIGRldGVjdGVkLiBXZWJTb2NrZXQgY2xpZW50cyBhcmUgbm90IHN1cHBvcnRlZCBpbiBDbG91ZGZsYXJlIFdvcmtlcnMuJyxcbiAgICAgICAgICAgICAgICB3b3JrYXJvdW5kOiAnVXNlIENsb3VkZmxhcmUgV29ya2VycyBXZWJTb2NrZXQgQVBJIGZvciBzZXJ2ZXItc2lkZSBXZWJTb2NrZXQgaGFuZGxpbmcsIG9yIGRlcGxveSB0byBhIGRpZmZlcmVudCBydW50aW1lLicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICgodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuRWRnZVJ1bnRpbWUpIHx8XG4gICAgICAgICAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKChfYSA9IG5hdmlnYXRvci51c2VyQWdlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcygnVmVyY2VsLUVkZ2UnKSkpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd1bnN1cHBvcnRlZCcsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdFZGdlIHJ1bnRpbWUgZGV0ZWN0ZWQgKFZlcmNlbCBFZGdlL05ldGxpZnkgRWRnZSkuIFdlYlNvY2tldHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gZWRnZSBmdW5jdGlvbnMuJyxcbiAgICAgICAgICAgICAgICB3b3JrYXJvdW5kOiAnVXNlIHNlcnZlcmxlc3MgZnVuY3Rpb25zIG9yIGEgZGlmZmVyZW50IGRlcGxveW1lbnQgdGFyZ2V0IGZvciBXZWJTb2NrZXQgZnVuY3Rpb25hbGl0eS4nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgZHluYW1pYyBwcm9wZXJ0eSBhY2Nlc3MgdG8gYXZvaWQgTmV4dC5qcyBFZGdlIFJ1bnRpbWUgc3RhdGljIGFuYWx5c2lzIHdhcm5pbmdzXG4gICAgICAgIGNvbnN0IF9wcm9jZXNzID0gZ2xvYmFsVGhpc1sncHJvY2VzcyddO1xuICAgICAgICBpZiAoX3Byb2Nlc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NWZXJzaW9ucyA9IF9wcm9jZXNzWyd2ZXJzaW9ucyddO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3NWZXJzaW9ucyAmJiBwcm9jZXNzVmVyc2lvbnNbJ25vZGUnXSkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSAndicgcHJlZml4IGlmIHByZXNlbnQgYW5kIHBhcnNlIHRoZSBtYWpvciB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvblN0cmluZyA9IHByb2Nlc3NWZXJzaW9uc1snbm9kZSddO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVWZXJzaW9uID0gcGFyc2VJbnQodmVyc2lvblN0cmluZy5yZXBsYWNlKC9edi8sICcnKS5zcGxpdCgnLicpWzBdKTtcbiAgICAgICAgICAgICAgICAvLyBOb2RlLmpzIDIyKyBzaG91bGQgaGF2ZSBuYXRpdmUgV2ViU29ja2V0XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVWZXJzaW9uID49IDIyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG5hdGl2ZSBXZWJTb2NrZXQgaXMgYXZhaWxhYmxlIChzaG91bGQgYmUgaW4gTm9kZS5qcyAyMispXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5XZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnbmF0aXZlJywgY29uc3RydWN0b3I6IGdsb2JhbFRoaXMuV2ViU29ja2V0IH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90IGF2YWlsYWJsZSwgdXNlciBuZWVkcyB0byBwcm92aWRlIGl0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndW5zdXBwb3J0ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBOb2RlLmpzICR7bm9kZVZlcnNpb259IGRldGVjdGVkIGJ1dCBuYXRpdmUgV2ViU29ja2V0IG5vdCBmb3VuZC5gLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2Fyb3VuZDogJ1Byb3ZpZGUgYSBXZWJTb2NrZXQgaW1wbGVtZW50YXRpb24gdmlhIHRoZSB0cmFuc3BvcnQgb3B0aW9uLicsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vZGUuanMgPCAyMiBkb2Vzbid0IGhhdmUgbmF0aXZlIFdlYlNvY2tldFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1bnN1cHBvcnRlZCcsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBgTm9kZS5qcyAke25vZGVWZXJzaW9ufSBkZXRlY3RlZCB3aXRob3V0IG5hdGl2ZSBXZWJTb2NrZXQgc3VwcG9ydC5gLFxuICAgICAgICAgICAgICAgICAgICB3b3JrYXJvdW5kOiAnRm9yIE5vZGUuanMgPCAyMiwgaW5zdGFsbCBcIndzXCIgcGFja2FnZSBhbmQgcHJvdmlkZSBpdCB2aWEgdGhlIHRyYW5zcG9ydCBvcHRpb246XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW1wb3J0IHdzIGZyb20gXCJ3c1wiXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV3IFJlYWx0aW1lQ2xpZW50KHVybCwgeyB0cmFuc3BvcnQ6IHdzIH0pJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAndW5zdXBwb3J0ZWQnLFxuICAgICAgICAgICAgZXJyb3I6ICdVbmtub3duIEphdmFTY3JpcHQgcnVudGltZSB3aXRob3V0IFdlYlNvY2tldCBzdXBwb3J0LicsXG4gICAgICAgICAgICB3b3JrYXJvdW5kOiBcIkVuc3VyZSB5b3UncmUgcnVubmluZyBpbiBhIHN1cHBvcnRlZCBlbnZpcm9ubWVudCAoYnJvd3NlciwgTm9kZS5qcywgRGVubykgb3IgcHJvdmlkZSBhIGN1c3RvbSBXZWJTb2NrZXQgaW1wbGVtZW50YXRpb24uXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJlc3QgYXZhaWxhYmxlIFdlYlNvY2tldCBjb25zdHJ1Y3RvciBmb3IgdGhlIGN1cnJlbnQgcnVudGltZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBXUyA9IFdlYlNvY2tldEZhY3RvcnkuZ2V0V2ViU29ja2V0Q29uc3RydWN0b3IoKVxuICAgICAqIGNvbnN0IHNvY2tldCA9IG5ldyBXUygnd3NzOi8vcmVhbHRpbWUuc3VwYWJhc2UuY28vc29ja2V0JylcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0V2ViU29ja2V0Q29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IGVudiA9IHRoaXMuZGV0ZWN0RW52aXJvbm1lbnQoKTtcbiAgICAgICAgaWYgKGVudi5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVudi5jb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gZW52LmVycm9yIHx8ICdXZWJTb2NrZXQgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50Lic7XG4gICAgICAgIGlmIChlbnYud29ya2Fyb3VuZCkge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGBcXG5cXG5TdWdnZXN0ZWQgc29sdXRpb246ICR7ZW52Lndvcmthcm91bmR9YDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFdlYlNvY2tldCB1c2luZyB0aGUgZGV0ZWN0ZWQgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3Qgc29ja2V0ID0gV2ViU29ja2V0RmFjdG9yeS5jcmVhdGVXZWJTb2NrZXQoJ3dzczovL3JlYWx0aW1lLnN1cGFiYXNlLmNvL3NvY2tldCcpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVdlYlNvY2tldCh1cmwsIHByb3RvY29scykge1xuICAgICAgICBjb25zdCBXUyA9IHRoaXMuZ2V0V2ViU29ja2V0Q29uc3RydWN0b3IoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBXUyh1cmwsIHByb3RvY29scyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVjdHMgd2hldGhlciB0aGUgcnVudGltZSBjYW4gZXN0YWJsaXNoIFdlYlNvY2tldCBjb25uZWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpZiAoIVdlYlNvY2tldEZhY3RvcnkuaXNXZWJTb2NrZXRTdXBwb3J0ZWQoKSkge1xuICAgICAqICAgY29uc29sZS53YXJuKCdGYWxsaW5nIGJhY2sgdG8gbG9uZyBwb2xsaW5nJylcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGlzV2ViU29ja2V0U3VwcG9ydGVkKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW52ID0gdGhpcy5kZXRlY3RFbnZpcm9ubWVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIGVudi50eXBlID09PSAnbmF0aXZlJyB8fCBlbnYudHlwZSA9PT0gJ3dzJztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuV2ViU29ja2V0RmFjdG9yeSA9IFdlYlNvY2tldEZhY3Rvcnk7XG5leHBvcnRzLmRlZmF1bHQgPSBXZWJTb2NrZXRGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2Vic29ja2V0LWZhY3RvcnkuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiV2ViU29ja2V0RmFjdG9yeSIsImNvbnN0cnVjdG9yIiwiZGV0ZWN0RW52aXJvbm1lbnQiLCJfYSIsIldlYlNvY2tldCIsInR5cGUiLCJnbG9iYWxUaGlzIiwiZ2xvYmFsIiwiV2ViU29ja2V0UGFpciIsImVycm9yIiwid29ya2Fyb3VuZCIsIkVkZ2VSdW50aW1lIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaW5jbHVkZXMiLCJfcHJvY2VzcyIsInByb2Nlc3NWZXJzaW9ucyIsInZlcnNpb25TdHJpbmciLCJub2RlVmVyc2lvbiIsInBhcnNlSW50IiwicmVwbGFjZSIsInNwbGl0IiwiZ2V0V2ViU29ja2V0Q29uc3RydWN0b3IiLCJlbnYiLCJlcnJvck1lc3NhZ2UiLCJFcnJvciIsImNyZWF0ZVdlYlNvY2tldCIsInVybCIsInByb3RvY29scyIsIldTIiwiaXNXZWJTb2NrZXRTdXBwb3J0ZWQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/realtime-js/dist/main/lib/websocket-factory.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/ssr/dist/main/cookies.js":
/*!*********************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/main/cookies.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createStorageFromOptions = createStorageFromOptions;\nexports.applyServerStorage = applyServerStorage;\nconst cookie_1 = __webpack_require__(/*! cookie */ \"(rsc)/./node_modules/cookie/dist/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/utils/index.js\");\nconst BASE64_PREFIX = \"base64-\";\n/**\n * Creates a storage client that handles cookies correctly for browser and\n * server clients with or without properly provided cookie methods.\n *\n * @param options The options passed to createBrowserClient or createServer client.\n *\n * @param isServerClient Whether it's called from createServerClient.\n */ function createStorageFromOptions(options, isServerClient) {\n    const cookies = options.cookies ?? null;\n    const cookieEncoding = options.cookieEncoding;\n    const setItems = {};\n    const removedItems = {};\n    let getAll;\n    let setAll;\n    if (cookies) {\n        if (\"get\" in cookies) {\n            // Just get is not enough, because the client needs to see what cookies\n            // are already set and unset them if necessary. To attempt to fix this\n            // behavior for most use cases, we pass \"hints\" which is the keys of the\n            // storage items. They are then converted to their corresponding cookie\n            // chunk names and are fetched with get. Only 5 chunks are fetched, which\n            // should be enough for the majority of use cases, but does not solve\n            // those with very large sessions.\n            const getWithHints = async (keyHints)=>{\n                // optimistically find the first 5 potential chunks for the specified key\n                const chunkNames = keyHints.flatMap((keyHint)=>[\n                        keyHint,\n                        ...Array.from({\n                            length: 5\n                        }).map((_, i)=>`${keyHint}.${i}`)\n                    ]);\n                const chunks = [];\n                for(let i = 0; i < chunkNames.length; i += 1){\n                    const value = await cookies.get(chunkNames[i]);\n                    if (!value && typeof value !== \"string\") {\n                        continue;\n                    }\n                    chunks.push({\n                        name: chunkNames[i],\n                        value\n                    });\n                }\n                // TODO: detect and log stale chunks error\n                return chunks;\n            };\n            getAll = async (keyHints)=>await getWithHints(keyHints);\n            if (\"set\" in cookies && \"remove\" in cookies) {\n                setAll = async (setCookies)=>{\n                    for(let i = 0; i < setCookies.length; i += 1){\n                        const { name, value, options } = setCookies[i];\n                        if (value) {\n                            await cookies.set(name, value, options);\n                        } else {\n                            await cookies.remove(name, options);\n                        }\n                    }\n                };\n            } else if (isServerClient) {\n                setAll = async ()=>{\n                    console.warn(\"@supabase/ssr: createServerClient was configured without set and remove cookie methods, but the client needs to set cookies. This can lead to issues such as random logouts, early session termination or increased token refresh requests. If in NextJS, check your middleware.ts file, route handlers and server actions for correctness. Consider switching to the getAll and setAll cookie methods instead of get, set and remove which are deprecated and can be difficult to use correctly.\");\n                };\n            } else {\n                throw new Error(\"@supabase/ssr: createBrowserClient requires configuring a getAll and setAll cookie method (deprecated: alternatively both get, set and remove can be used)\");\n            }\n        } else if (\"getAll\" in cookies) {\n            getAll = async ()=>await cookies.getAll();\n            if (\"setAll\" in cookies) {\n                setAll = cookies.setAll;\n            } else if (isServerClient) {\n                setAll = async ()=>{\n                    console.warn(\"@supabase/ssr: createServerClient was configured without the setAll cookie method, but the client needs to set cookies. This can lead to issues such as random logouts, early session termination or increased token refresh requests. If in NextJS, check your middleware.ts file, route handlers and server actions for correctness.\");\n                };\n            } else {\n                throw new Error(\"@supabase/ssr: createBrowserClient requires configuring both getAll and setAll cookie methods (deprecated: alternatively both get, set and remove can be used)\");\n            }\n        } else {\n            // neither get nor getAll is present on cookies, only will occur if pure JavaScript is used, but cookies is an object\n            throw new Error(`@supabase/ssr: ${isServerClient ? \"createServerClient\" : \"createBrowserClient\"} requires configuring getAll and setAll cookie methods (deprecated: alternatively use get, set and remove).${(0, utils_1.isBrowser)() ? \" As this is called in a browser runtime, consider removing the cookies option object to use the document.cookie API automatically.\" : \"\"}`);\n        }\n    } else if (!isServerClient && (0, utils_1.isBrowser)()) {\n        // The environment is browser, so use the document.cookie API to implement getAll and setAll.\n        const noHintGetAll = ()=>{\n            const parsed = (0, cookie_1.parse)(document.cookie);\n            return Object.keys(parsed).map((name)=>({\n                    name,\n                    value: parsed[name] ?? \"\"\n                }));\n        };\n        getAll = ()=>noHintGetAll();\n        setAll = (setCookies)=>{\n            setCookies.forEach(({ name, value, options })=>{\n                document.cookie = (0, cookie_1.serialize)(name, value, options);\n            });\n        };\n    } else if (isServerClient) {\n        throw new Error(\"@supabase/ssr: createServerClient must be initialized with cookie options that specify getAll and setAll functions (deprecated, not recommended: alternatively use get, set and remove)\");\n    } else {\n        // getting cookies when there's no window but we're in browser mode can be OK, because the developer probably is not using auth functions\n        getAll = ()=>{\n            return [];\n        };\n        // this is NOT OK because the developer is using auth functions that require setting some state, so that must error out\n        setAll = ()=>{\n            throw new Error(\"@supabase/ssr: createBrowserClient in non-browser runtimes (including Next.js pre-rendering mode) was not initialized cookie options that specify getAll and setAll functions (deprecated: alternatively use get, set and remove), but they were needed\");\n        };\n    }\n    if (!isServerClient) {\n        // This is the storage client to be used in browsers. It only\n        // works on the cookies abstraction, unlike the server client\n        // which only uses cookies to read the initial state. When an\n        // item is set, cookies are both cleared and set to values so\n        // that stale chunks are not left remaining.\n        return {\n            getAll,\n            setAll,\n            setItems,\n            removedItems,\n            storage: {\n                isServer: false,\n                getItem: async (key)=>{\n                    const allCookies = await getAll([\n                        key\n                    ]);\n                    const chunkedCookie = await (0, utils_1.combineChunks)(key, async (chunkName)=>{\n                        const cookie = allCookies?.find(({ name })=>name === chunkName) || null;\n                        if (!cookie) {\n                            return null;\n                        }\n                        return cookie.value;\n                    });\n                    if (!chunkedCookie) {\n                        return null;\n                    }\n                    let decoded = chunkedCookie;\n                    if (chunkedCookie.startsWith(BASE64_PREFIX)) {\n                        decoded = (0, utils_1.stringFromBase64URL)(chunkedCookie.substring(BASE64_PREFIX.length));\n                    }\n                    return decoded;\n                },\n                setItem: async (key, value)=>{\n                    const allCookies = await getAll([\n                        key\n                    ]);\n                    const cookieNames = allCookies?.map(({ name })=>name) || [];\n                    const removeCookies = new Set(cookieNames.filter((name)=>(0, utils_1.isChunkLike)(name, key)));\n                    let encoded = value;\n                    if (cookieEncoding === \"base64url\") {\n                        encoded = BASE64_PREFIX + (0, utils_1.stringToBase64URL)(value);\n                    }\n                    const setCookies = (0, utils_1.createChunks)(key, encoded);\n                    setCookies.forEach(({ name })=>{\n                        removeCookies.delete(name);\n                    });\n                    const removeCookieOptions = {\n                        ...utils_1.DEFAULT_COOKIE_OPTIONS,\n                        ...options?.cookieOptions,\n                        maxAge: 0\n                    };\n                    const setCookieOptions = {\n                        ...utils_1.DEFAULT_COOKIE_OPTIONS,\n                        ...options?.cookieOptions,\n                        maxAge: utils_1.DEFAULT_COOKIE_OPTIONS.maxAge\n                    };\n                    // the NextJS cookieStore API can get confused if the `name` from\n                    // options.cookieOptions leaks\n                    delete removeCookieOptions.name;\n                    delete setCookieOptions.name;\n                    const allToSet = [\n                        ...[\n                            ...removeCookies\n                        ].map((name)=>({\n                                name,\n                                value: \"\",\n                                options: removeCookieOptions\n                            })),\n                        ...setCookies.map(({ name, value })=>({\n                                name,\n                                value,\n                                options: setCookieOptions\n                            }))\n                    ];\n                    if (allToSet.length > 0) {\n                        await setAll(allToSet);\n                    }\n                },\n                removeItem: async (key)=>{\n                    const allCookies = await getAll([\n                        key\n                    ]);\n                    const cookieNames = allCookies?.map(({ name })=>name) || [];\n                    const removeCookies = cookieNames.filter((name)=>(0, utils_1.isChunkLike)(name, key));\n                    const removeCookieOptions = {\n                        ...utils_1.DEFAULT_COOKIE_OPTIONS,\n                        ...options?.cookieOptions,\n                        maxAge: 0\n                    };\n                    // the NextJS cookieStore API can get confused if the `name` from\n                    // options.cookieOptions leaks\n                    delete removeCookieOptions.name;\n                    if (removeCookies.length > 0) {\n                        await setAll(removeCookies.map((name)=>({\n                                name,\n                                value: \"\",\n                                options: removeCookieOptions\n                            })));\n                    }\n                }\n            }\n        };\n    }\n    // This is the server client. It only uses getAll to read the initial\n    // state. Any subsequent changes to the items is persisted in the\n    // setItems and removedItems objects. createServerClient *must* use\n    // getAll, setAll and the values in setItems and removedItems to\n    // persist the changes *at once* when appropriate (usually only when\n    // the TOKEN_REFRESHED, USER_UPDATED or SIGNED_OUT events are fired by\n    // the Supabase Auth client).\n    return {\n        getAll,\n        setAll,\n        setItems,\n        removedItems,\n        storage: {\n            // to signal to the libraries that these cookies are\n            // coming from a server environment and their value\n            // should not be trusted\n            isServer: true,\n            getItem: async (key)=>{\n                if (typeof setItems[key] === \"string\") {\n                    return setItems[key];\n                }\n                if (removedItems[key]) {\n                    return null;\n                }\n                const allCookies = await getAll([\n                    key\n                ]);\n                const chunkedCookie = await (0, utils_1.combineChunks)(key, async (chunkName)=>{\n                    const cookie = allCookies?.find(({ name })=>name === chunkName) || null;\n                    if (!cookie) {\n                        return null;\n                    }\n                    return cookie.value;\n                });\n                if (!chunkedCookie) {\n                    return null;\n                }\n                let decoded = chunkedCookie;\n                if (typeof chunkedCookie === \"string\" && chunkedCookie.startsWith(BASE64_PREFIX)) {\n                    decoded = (0, utils_1.stringFromBase64URL)(chunkedCookie.substring(BASE64_PREFIX.length));\n                }\n                return decoded;\n            },\n            setItem: async (key, value)=>{\n                // We don't have an `onAuthStateChange` event that can let us know that\n                // the PKCE code verifier is being set. Therefore, if we see it being\n                // set, we need to apply the storage (call `setAll` so the cookie is\n                // set properly).\n                if (key.endsWith(\"-code-verifier\")) {\n                    await applyServerStorage({\n                        getAll,\n                        setAll,\n                        // pretend only that the code verifier was set\n                        setItems: {\n                            [key]: value\n                        },\n                        // pretend that nothing was removed\n                        removedItems: {}\n                    }, {\n                        cookieOptions: options?.cookieOptions ?? null,\n                        cookieEncoding\n                    });\n                }\n                setItems[key] = value;\n                delete removedItems[key];\n            },\n            removeItem: async (key)=>{\n                // Intentionally not applying the storage when the key is the PKCE code\n                // verifier, as usually right after it's removed other items are set,\n                // so application of the storage will be handled by the\n                // `onAuthStateChange` callback that follows removal -- usually as part\n                // of the `exchangeCodeForSession` call.\n                delete setItems[key];\n                removedItems[key] = true;\n            }\n        }\n    };\n}\n/**\n * When createServerClient needs to apply the created storage to cookies, it\n * should call this function which handles correcly setting cookies for stored\n * and removed items in the storage.\n */ async function applyServerStorage({ getAll, setAll, setItems, removedItems }, options) {\n    const cookieEncoding = options.cookieEncoding;\n    const cookieOptions = options.cookieOptions ?? null;\n    const allCookies = await getAll([\n        ...setItems ? Object.keys(setItems) : [],\n        ...removedItems ? Object.keys(removedItems) : []\n    ]);\n    const cookieNames = allCookies?.map(({ name })=>name) || [];\n    const removeCookies = Object.keys(removedItems).flatMap((itemName)=>{\n        return cookieNames.filter((name)=>(0, utils_1.isChunkLike)(name, itemName));\n    });\n    const setCookies = Object.keys(setItems).flatMap((itemName)=>{\n        const removeExistingCookiesForItem = new Set(cookieNames.filter((name)=>(0, utils_1.isChunkLike)(name, itemName)));\n        let encoded = setItems[itemName];\n        if (cookieEncoding === \"base64url\") {\n            encoded = BASE64_PREFIX + (0, utils_1.stringToBase64URL)(encoded);\n        }\n        const chunks = (0, utils_1.createChunks)(itemName, encoded);\n        chunks.forEach((chunk)=>{\n            removeExistingCookiesForItem.delete(chunk.name);\n        });\n        removeCookies.push(...removeExistingCookiesForItem);\n        return chunks;\n    });\n    const removeCookieOptions = {\n        ...utils_1.DEFAULT_COOKIE_OPTIONS,\n        ...cookieOptions,\n        maxAge: 0\n    };\n    const setCookieOptions = {\n        ...utils_1.DEFAULT_COOKIE_OPTIONS,\n        ...cookieOptions,\n        maxAge: utils_1.DEFAULT_COOKIE_OPTIONS.maxAge\n    };\n    // the NextJS cookieStore API can get confused if the `name` from\n    // options.cookieOptions leaks\n    delete removeCookieOptions.name;\n    delete setCookieOptions.name;\n    await setAll([\n        ...removeCookies.map((name)=>({\n                name,\n                value: \"\",\n                options: removeCookieOptions\n            })),\n        ...setCookies.map(({ name, value })=>({\n                name,\n                value,\n                options: setCookieOptions\n            }))\n    ]);\n} //# sourceMappingURL=cookies.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vY29va2llcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0NBQWdDLEdBQUdFO0FBQ25DRiwwQkFBMEIsR0FBR0c7QUFDN0IsTUFBTUMsV0FBV0MsbUJBQU9BLENBQUMseURBQVE7QUFDakMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsNEVBQVM7QUFDakMsTUFBTUUsZ0JBQWdCO0FBQ3RCOzs7Ozs7O0NBT0MsR0FDRCxTQUFTTCx5QkFBeUJNLE9BQU8sRUFBRUMsY0FBYztJQUNyRCxNQUFNQyxVQUFVRixRQUFRRSxPQUFPLElBQUk7SUFDbkMsTUFBTUMsaUJBQWlCSCxRQUFRRyxjQUFjO0lBQzdDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNQyxlQUFlLENBQUM7SUFDdEIsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlMLFNBQVM7UUFDVCxJQUFJLFNBQVNBLFNBQVM7WUFDbEIsdUVBQXVFO1lBQ3ZFLHNFQUFzRTtZQUN0RSx3RUFBd0U7WUFDeEUsdUVBQXVFO1lBQ3ZFLHlFQUF5RTtZQUN6RSxxRUFBcUU7WUFDckUsa0NBQWtDO1lBQ2xDLE1BQU1NLGVBQWUsT0FBT0M7Z0JBQ3hCLHlFQUF5RTtnQkFDekUsTUFBTUMsYUFBYUQsU0FBU0UsT0FBTyxDQUFDLENBQUNDLFVBQVk7d0JBQzdDQTsyQkFDR0MsTUFBTUMsSUFBSSxDQUFDOzRCQUFFQyxRQUFRO3dCQUFFLEdBQUdDLEdBQUcsQ0FBQyxDQUFDQyxHQUFHQyxJQUFNLENBQUMsRUFBRU4sUUFBUSxDQUFDLEVBQUVNLEVBQUUsQ0FBQztxQkFDL0Q7Z0JBQ0QsTUFBTUMsU0FBUyxFQUFFO2dCQUNqQixJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSVIsV0FBV0ssTUFBTSxFQUFFRyxLQUFLLEVBQUc7b0JBQzNDLE1BQU16QixRQUFRLE1BQU1TLFFBQVFrQixHQUFHLENBQUNWLFVBQVUsQ0FBQ1EsRUFBRTtvQkFDN0MsSUFBSSxDQUFDekIsU0FBUyxPQUFPQSxVQUFVLFVBQVU7d0JBQ3JDO29CQUNKO29CQUNBMEIsT0FBT0UsSUFBSSxDQUFDO3dCQUFFQyxNQUFNWixVQUFVLENBQUNRLEVBQUU7d0JBQUV6QjtvQkFBTTtnQkFDN0M7Z0JBQ0EsMENBQTBDO2dCQUMxQyxPQUFPMEI7WUFDWDtZQUNBYixTQUFTLE9BQU9HLFdBQWEsTUFBTUQsYUFBYUM7WUFDaEQsSUFBSSxTQUFTUCxXQUFXLFlBQVlBLFNBQVM7Z0JBQ3pDSyxTQUFTLE9BQU9nQjtvQkFDWixJQUFLLElBQUlMLElBQUksR0FBR0EsSUFBSUssV0FBV1IsTUFBTSxFQUFFRyxLQUFLLEVBQUc7d0JBQzNDLE1BQU0sRUFBRUksSUFBSSxFQUFFN0IsS0FBSyxFQUFFTyxPQUFPLEVBQUUsR0FBR3VCLFVBQVUsQ0FBQ0wsRUFBRTt3QkFDOUMsSUFBSXpCLE9BQU87NEJBQ1AsTUFBTVMsUUFBUXNCLEdBQUcsQ0FBQ0YsTUFBTTdCLE9BQU9PO3dCQUNuQyxPQUNLOzRCQUNELE1BQU1FLFFBQVF1QixNQUFNLENBQUNILE1BQU10Qjt3QkFDL0I7b0JBQ0o7Z0JBQ0o7WUFDSixPQUNLLElBQUlDLGdCQUFnQjtnQkFDckJNLFNBQVM7b0JBQ0xtQixRQUFRQyxJQUFJLENBQUM7Z0JBQ2pCO1lBQ0osT0FDSztnQkFDRCxNQUFNLElBQUlDLE1BQU07WUFDcEI7UUFDSixPQUNLLElBQUksWUFBWTFCLFNBQVM7WUFDMUJJLFNBQVMsVUFBWSxNQUFNSixRQUFRSSxNQUFNO1lBQ3pDLElBQUksWUFBWUosU0FBUztnQkFDckJLLFNBQVNMLFFBQVFLLE1BQU07WUFDM0IsT0FDSyxJQUFJTixnQkFBZ0I7Z0JBQ3JCTSxTQUFTO29CQUNMbUIsUUFBUUMsSUFBSSxDQUFDO2dCQUNqQjtZQUNKLE9BQ0s7Z0JBQ0QsTUFBTSxJQUFJQyxNQUFNO1lBQ3BCO1FBQ0osT0FDSztZQUNELHFIQUFxSDtZQUNySCxNQUFNLElBQUlBLE1BQU0sQ0FBQyxlQUFlLEVBQUUzQixpQkFBaUIsdUJBQXVCLHNCQUFzQiwyR0FBMkcsRUFBRSxDQUFDLEdBQUdILFFBQVErQixTQUFTLE1BQU0sdUlBQXVJLEdBQUcsQ0FBQztRQUN2WDtJQUNKLE9BQ0ssSUFBSSxDQUFDNUIsa0JBQWtCLENBQUMsR0FBR0gsUUFBUStCLFNBQVMsS0FBSztRQUNsRCw2RkFBNkY7UUFDN0YsTUFBTUMsZUFBZTtZQUNqQixNQUFNQyxTQUFTLENBQUMsR0FBR25DLFNBQVNvQyxLQUFLLEVBQUVDLFNBQVNDLE1BQU07WUFDbEQsT0FBTzVDLE9BQU82QyxJQUFJLENBQUNKLFFBQVFmLEdBQUcsQ0FBQyxDQUFDTSxPQUFVO29CQUN0Q0E7b0JBQ0E3QixPQUFPc0MsTUFBTSxDQUFDVCxLQUFLLElBQUk7Z0JBQzNCO1FBQ0o7UUFDQWhCLFNBQVMsSUFBTXdCO1FBQ2Z2QixTQUFTLENBQUNnQjtZQUNOQSxXQUFXYSxPQUFPLENBQUMsQ0FBQyxFQUFFZCxJQUFJLEVBQUU3QixLQUFLLEVBQUVPLE9BQU8sRUFBRTtnQkFDeENpQyxTQUFTQyxNQUFNLEdBQUcsQ0FBQyxHQUFHdEMsU0FBU3lDLFNBQVMsRUFBRWYsTUFBTTdCLE9BQU9PO1lBQzNEO1FBQ0o7SUFDSixPQUNLLElBQUlDLGdCQUFnQjtRQUNyQixNQUFNLElBQUkyQixNQUFNO0lBQ3BCLE9BQ0s7UUFDRCx5SUFBeUk7UUFDekl0QixTQUFTO1lBQ0wsT0FBTyxFQUFFO1FBQ2I7UUFDQSx1SEFBdUg7UUFDdkhDLFNBQVM7WUFDTCxNQUFNLElBQUlxQixNQUFNO1FBQ3BCO0lBQ0o7SUFDQSxJQUFJLENBQUMzQixnQkFBZ0I7UUFDakIsNkRBQTZEO1FBQzdELDZEQUE2RDtRQUM3RCw2REFBNkQ7UUFDN0QsNkRBQTZEO1FBQzdELDRDQUE0QztRQUM1QyxPQUFPO1lBQ0hLO1lBQ0FDO1lBQ0FIO1lBQ0FDO1lBQ0FpQyxTQUFTO2dCQUNMQyxVQUFVO2dCQUNWQyxTQUFTLE9BQU9DO29CQUNaLE1BQU1DLGFBQWEsTUFBTXBDLE9BQU87d0JBQUNtQztxQkFBSTtvQkFDckMsTUFBTUUsZ0JBQWdCLE1BQU0sQ0FBQyxHQUFHN0MsUUFBUThDLGFBQWEsRUFBRUgsS0FBSyxPQUFPSTt3QkFDL0QsTUFBTVgsU0FBU1EsWUFBWUksS0FBSyxDQUFDLEVBQUV4QixJQUFJLEVBQUUsR0FBS0EsU0FBU3VCLGNBQWM7d0JBQ3JFLElBQUksQ0FBQ1gsUUFBUTs0QkFDVCxPQUFPO3dCQUNYO3dCQUNBLE9BQU9BLE9BQU96QyxLQUFLO29CQUN2QjtvQkFDQSxJQUFJLENBQUNrRCxlQUFlO3dCQUNoQixPQUFPO29CQUNYO29CQUNBLElBQUlJLFVBQVVKO29CQUNkLElBQUlBLGNBQWNLLFVBQVUsQ0FBQ2pELGdCQUFnQjt3QkFDekNnRCxVQUFVLENBQUMsR0FBR2pELFFBQVFtRCxtQkFBbUIsRUFBRU4sY0FBY08sU0FBUyxDQUFDbkQsY0FBY2dCLE1BQU07b0JBQzNGO29CQUNBLE9BQU9nQztnQkFDWDtnQkFDQUksU0FBUyxPQUFPVixLQUFLaEQ7b0JBQ2pCLE1BQU1pRCxhQUFhLE1BQU1wQyxPQUFPO3dCQUFDbUM7cUJBQUk7b0JBQ3JDLE1BQU1XLGNBQWNWLFlBQVkxQixJQUFJLENBQUMsRUFBRU0sSUFBSSxFQUFFLEdBQUtBLFNBQVMsRUFBRTtvQkFDN0QsTUFBTStCLGdCQUFnQixJQUFJQyxJQUFJRixZQUFZRyxNQUFNLENBQUMsQ0FBQ2pDLE9BQVMsQ0FBQyxHQUFHeEIsUUFBUTBELFdBQVcsRUFBRWxDLE1BQU1tQjtvQkFDMUYsSUFBSWdCLFVBQVVoRTtvQkFDZCxJQUFJVSxtQkFBbUIsYUFBYTt3QkFDaENzRCxVQUFVMUQsZ0JBQWdCLENBQUMsR0FBR0QsUUFBUTRELGlCQUFpQixFQUFFakU7b0JBQzdEO29CQUNBLE1BQU04QixhQUFhLENBQUMsR0FBR3pCLFFBQVE2RCxZQUFZLEVBQUVsQixLQUFLZ0I7b0JBQ2xEbEMsV0FBV2EsT0FBTyxDQUFDLENBQUMsRUFBRWQsSUFBSSxFQUFFO3dCQUN4QitCLGNBQWNPLE1BQU0sQ0FBQ3RDO29CQUN6QjtvQkFDQSxNQUFNdUMsc0JBQXNCO3dCQUN4QixHQUFHL0QsUUFBUWdFLHNCQUFzQjt3QkFDakMsR0FBRzlELFNBQVMrRCxhQUFhO3dCQUN6QkMsUUFBUTtvQkFDWjtvQkFDQSxNQUFNQyxtQkFBbUI7d0JBQ3JCLEdBQUduRSxRQUFRZ0Usc0JBQXNCO3dCQUNqQyxHQUFHOUQsU0FBUytELGFBQWE7d0JBQ3pCQyxRQUFRbEUsUUFBUWdFLHNCQUFzQixDQUFDRSxNQUFNO29CQUNqRDtvQkFDQSxpRUFBaUU7b0JBQ2pFLDhCQUE4QjtvQkFDOUIsT0FBT0gsb0JBQW9CdkMsSUFBSTtvQkFDL0IsT0FBTzJDLGlCQUFpQjNDLElBQUk7b0JBQzVCLE1BQU00QyxXQUFXOzJCQUNWOytCQUFJYjt5QkFBYyxDQUFDckMsR0FBRyxDQUFDLENBQUNNLE9BQVU7Z0NBQ2pDQTtnQ0FDQTdCLE9BQU87Z0NBQ1BPLFNBQVM2RDs0QkFDYjsyQkFDR3RDLFdBQVdQLEdBQUcsQ0FBQyxDQUFDLEVBQUVNLElBQUksRUFBRTdCLEtBQUssRUFBRSxHQUFNO2dDQUNwQzZCO2dDQUNBN0I7Z0NBQ0FPLFNBQVNpRTs0QkFDYjtxQkFDSDtvQkFDRCxJQUFJQyxTQUFTbkQsTUFBTSxHQUFHLEdBQUc7d0JBQ3JCLE1BQU1SLE9BQU8yRDtvQkFDakI7Z0JBQ0o7Z0JBQ0FDLFlBQVksT0FBTzFCO29CQUNmLE1BQU1DLGFBQWEsTUFBTXBDLE9BQU87d0JBQUNtQztxQkFBSTtvQkFDckMsTUFBTVcsY0FBY1YsWUFBWTFCLElBQUksQ0FBQyxFQUFFTSxJQUFJLEVBQUUsR0FBS0EsU0FBUyxFQUFFO29CQUM3RCxNQUFNK0IsZ0JBQWdCRCxZQUFZRyxNQUFNLENBQUMsQ0FBQ2pDLE9BQVMsQ0FBQyxHQUFHeEIsUUFBUTBELFdBQVcsRUFBRWxDLE1BQU1tQjtvQkFDbEYsTUFBTW9CLHNCQUFzQjt3QkFDeEIsR0FBRy9ELFFBQVFnRSxzQkFBc0I7d0JBQ2pDLEdBQUc5RCxTQUFTK0QsYUFBYTt3QkFDekJDLFFBQVE7b0JBQ1o7b0JBQ0EsaUVBQWlFO29CQUNqRSw4QkFBOEI7b0JBQzlCLE9BQU9ILG9CQUFvQnZDLElBQUk7b0JBQy9CLElBQUkrQixjQUFjdEMsTUFBTSxHQUFHLEdBQUc7d0JBQzFCLE1BQU1SLE9BQU84QyxjQUFjckMsR0FBRyxDQUFDLENBQUNNLE9BQVU7Z0NBQ3RDQTtnQ0FDQTdCLE9BQU87Z0NBQ1BPLFNBQVM2RDs0QkFDYjtvQkFDSjtnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUNBLHFFQUFxRTtJQUNyRSxpRUFBaUU7SUFDakUsbUVBQW1FO0lBQ25FLGdFQUFnRTtJQUNoRSxvRUFBb0U7SUFDcEUsc0VBQXNFO0lBQ3RFLDZCQUE2QjtJQUM3QixPQUFPO1FBQ0h2RDtRQUNBQztRQUNBSDtRQUNBQztRQUNBaUMsU0FBUztZQUNMLG9EQUFvRDtZQUNwRCxtREFBbUQ7WUFDbkQsd0JBQXdCO1lBQ3hCQyxVQUFVO1lBQ1ZDLFNBQVMsT0FBT0M7Z0JBQ1osSUFBSSxPQUFPckMsUUFBUSxDQUFDcUMsSUFBSSxLQUFLLFVBQVU7b0JBQ25DLE9BQU9yQyxRQUFRLENBQUNxQyxJQUFJO2dCQUN4QjtnQkFDQSxJQUFJcEMsWUFBWSxDQUFDb0MsSUFBSSxFQUFFO29CQUNuQixPQUFPO2dCQUNYO2dCQUNBLE1BQU1DLGFBQWEsTUFBTXBDLE9BQU87b0JBQUNtQztpQkFBSTtnQkFDckMsTUFBTUUsZ0JBQWdCLE1BQU0sQ0FBQyxHQUFHN0MsUUFBUThDLGFBQWEsRUFBRUgsS0FBSyxPQUFPSTtvQkFDL0QsTUFBTVgsU0FBU1EsWUFBWUksS0FBSyxDQUFDLEVBQUV4QixJQUFJLEVBQUUsR0FBS0EsU0FBU3VCLGNBQWM7b0JBQ3JFLElBQUksQ0FBQ1gsUUFBUTt3QkFDVCxPQUFPO29CQUNYO29CQUNBLE9BQU9BLE9BQU96QyxLQUFLO2dCQUN2QjtnQkFDQSxJQUFJLENBQUNrRCxlQUFlO29CQUNoQixPQUFPO2dCQUNYO2dCQUNBLElBQUlJLFVBQVVKO2dCQUNkLElBQUksT0FBT0Esa0JBQWtCLFlBQ3pCQSxjQUFjSyxVQUFVLENBQUNqRCxnQkFBZ0I7b0JBQ3pDZ0QsVUFBVSxDQUFDLEdBQUdqRCxRQUFRbUQsbUJBQW1CLEVBQUVOLGNBQWNPLFNBQVMsQ0FBQ25ELGNBQWNnQixNQUFNO2dCQUMzRjtnQkFDQSxPQUFPZ0M7WUFDWDtZQUNBSSxTQUFTLE9BQU9WLEtBQUtoRDtnQkFDakIsdUVBQXVFO2dCQUN2RSxxRUFBcUU7Z0JBQ3JFLG9FQUFvRTtnQkFDcEUsaUJBQWlCO2dCQUNqQixJQUFJZ0QsSUFBSTJCLFFBQVEsQ0FBQyxtQkFBbUI7b0JBQ2hDLE1BQU16RSxtQkFBbUI7d0JBQ3JCVzt3QkFDQUM7d0JBQ0EsOENBQThDO3dCQUM5Q0gsVUFBVTs0QkFBRSxDQUFDcUMsSUFBSSxFQUFFaEQ7d0JBQU07d0JBQ3pCLG1DQUFtQzt3QkFDbkNZLGNBQWMsQ0FBQztvQkFDbkIsR0FBRzt3QkFDQzBELGVBQWUvRCxTQUFTK0QsaUJBQWlCO3dCQUN6QzVEO29CQUNKO2dCQUNKO2dCQUNBQyxRQUFRLENBQUNxQyxJQUFJLEdBQUdoRDtnQkFDaEIsT0FBT1ksWUFBWSxDQUFDb0MsSUFBSTtZQUM1QjtZQUNBMEIsWUFBWSxPQUFPMUI7Z0JBQ2YsdUVBQXVFO2dCQUN2RSxxRUFBcUU7Z0JBQ3JFLHVEQUF1RDtnQkFDdkQsdUVBQXVFO2dCQUN2RSx3Q0FBd0M7Z0JBQ3hDLE9BQU9yQyxRQUFRLENBQUNxQyxJQUFJO2dCQUNwQnBDLFlBQVksQ0FBQ29DLElBQUksR0FBRztZQUN4QjtRQUNKO0lBQ0o7QUFDSjtBQUNBOzs7O0NBSUMsR0FDRCxlQUFlOUMsbUJBQW1CLEVBQUVXLE1BQU0sRUFBRUMsTUFBTSxFQUFFSCxRQUFRLEVBQUVDLFlBQVksRUFBRyxFQUFFTCxPQUFPO0lBQ2xGLE1BQU1HLGlCQUFpQkgsUUFBUUcsY0FBYztJQUM3QyxNQUFNNEQsZ0JBQWdCL0QsUUFBUStELGFBQWEsSUFBSTtJQUMvQyxNQUFNckIsYUFBYSxNQUFNcEMsT0FBTztXQUN4QkYsV0FBV2QsT0FBTzZDLElBQUksQ0FBQy9CLFlBQVksRUFBRTtXQUNyQ0MsZUFBZWYsT0FBTzZDLElBQUksQ0FBQzlCLGdCQUFnQixFQUFFO0tBQ3BEO0lBQ0QsTUFBTStDLGNBQWNWLFlBQVkxQixJQUFJLENBQUMsRUFBRU0sSUFBSSxFQUFFLEdBQUtBLFNBQVMsRUFBRTtJQUM3RCxNQUFNK0IsZ0JBQWdCL0QsT0FBTzZDLElBQUksQ0FBQzlCLGNBQWNNLE9BQU8sQ0FBQyxDQUFDMEQ7UUFDckQsT0FBT2pCLFlBQVlHLE1BQU0sQ0FBQyxDQUFDakMsT0FBUyxDQUFDLEdBQUd4QixRQUFRMEQsV0FBVyxFQUFFbEMsTUFBTStDO0lBQ3ZFO0lBQ0EsTUFBTTlDLGFBQWFqQyxPQUFPNkMsSUFBSSxDQUFDL0IsVUFBVU8sT0FBTyxDQUFDLENBQUMwRDtRQUM5QyxNQUFNQywrQkFBK0IsSUFBSWhCLElBQUlGLFlBQVlHLE1BQU0sQ0FBQyxDQUFDakMsT0FBUyxDQUFDLEdBQUd4QixRQUFRMEQsV0FBVyxFQUFFbEMsTUFBTStDO1FBQ3pHLElBQUlaLFVBQVVyRCxRQUFRLENBQUNpRSxTQUFTO1FBQ2hDLElBQUlsRSxtQkFBbUIsYUFBYTtZQUNoQ3NELFVBQVUxRCxnQkFBZ0IsQ0FBQyxHQUFHRCxRQUFRNEQsaUJBQWlCLEVBQUVEO1FBQzdEO1FBQ0EsTUFBTXRDLFNBQVMsQ0FBQyxHQUFHckIsUUFBUTZELFlBQVksRUFBRVUsVUFBVVo7UUFDbkR0QyxPQUFPaUIsT0FBTyxDQUFDLENBQUNtQztZQUNaRCw2QkFBNkJWLE1BQU0sQ0FBQ1csTUFBTWpELElBQUk7UUFDbEQ7UUFDQStCLGNBQWNoQyxJQUFJLElBQUlpRDtRQUN0QixPQUFPbkQ7SUFDWDtJQUNBLE1BQU0wQyxzQkFBc0I7UUFDeEIsR0FBRy9ELFFBQVFnRSxzQkFBc0I7UUFDakMsR0FBR0MsYUFBYTtRQUNoQkMsUUFBUTtJQUNaO0lBQ0EsTUFBTUMsbUJBQW1CO1FBQ3JCLEdBQUduRSxRQUFRZ0Usc0JBQXNCO1FBQ2pDLEdBQUdDLGFBQWE7UUFDaEJDLFFBQVFsRSxRQUFRZ0Usc0JBQXNCLENBQUNFLE1BQU07SUFDakQ7SUFDQSxpRUFBaUU7SUFDakUsOEJBQThCO0lBQzlCLE9BQU9ILG9CQUFvQnZDLElBQUk7SUFDL0IsT0FBTzJDLGlCQUFpQjNDLElBQUk7SUFDNUIsTUFBTWYsT0FBTztXQUNOOEMsY0FBY3JDLEdBQUcsQ0FBQyxDQUFDTSxPQUFVO2dCQUM1QkE7Z0JBQ0E3QixPQUFPO2dCQUNQTyxTQUFTNkQ7WUFDYjtXQUNHdEMsV0FBV1AsR0FBRyxDQUFDLENBQUMsRUFBRU0sSUFBSSxFQUFFN0IsS0FBSyxFQUFFLEdBQU07Z0JBQ3BDNkI7Z0JBQ0E3QjtnQkFDQU8sU0FBU2lFO1lBQ2I7S0FDSDtBQUNMLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zc3IvZGlzdC9tYWluL2Nvb2tpZXMuanM/NTk2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlU3RvcmFnZUZyb21PcHRpb25zID0gY3JlYXRlU3RvcmFnZUZyb21PcHRpb25zO1xuZXhwb3J0cy5hcHBseVNlcnZlclN0b3JhZ2UgPSBhcHBseVNlcnZlclN0b3JhZ2U7XG5jb25zdCBjb29raWVfMSA9IHJlcXVpcmUoXCJjb29raWVcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBCQVNFNjRfUFJFRklYID0gXCJiYXNlNjQtXCI7XG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yYWdlIGNsaWVudCB0aGF0IGhhbmRsZXMgY29va2llcyBjb3JyZWN0bHkgZm9yIGJyb3dzZXIgYW5kXG4gKiBzZXJ2ZXIgY2xpZW50cyB3aXRoIG9yIHdpdGhvdXQgcHJvcGVybHkgcHJvdmlkZWQgY29va2llIG1ldGhvZHMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIGNyZWF0ZUJyb3dzZXJDbGllbnQgb3IgY3JlYXRlU2VydmVyIGNsaWVudC5cbiAqXG4gKiBAcGFyYW0gaXNTZXJ2ZXJDbGllbnQgV2hldGhlciBpdCdzIGNhbGxlZCBmcm9tIGNyZWF0ZVNlcnZlckNsaWVudC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RvcmFnZUZyb21PcHRpb25zKG9wdGlvbnMsIGlzU2VydmVyQ2xpZW50KSB7XG4gICAgY29uc3QgY29va2llcyA9IG9wdGlvbnMuY29va2llcyA/PyBudWxsO1xuICAgIGNvbnN0IGNvb2tpZUVuY29kaW5nID0gb3B0aW9ucy5jb29raWVFbmNvZGluZztcbiAgICBjb25zdCBzZXRJdGVtcyA9IHt9O1xuICAgIGNvbnN0IHJlbW92ZWRJdGVtcyA9IHt9O1xuICAgIGxldCBnZXRBbGw7XG4gICAgbGV0IHNldEFsbDtcbiAgICBpZiAoY29va2llcykge1xuICAgICAgICBpZiAoXCJnZXRcIiBpbiBjb29raWVzKSB7XG4gICAgICAgICAgICAvLyBKdXN0IGdldCBpcyBub3QgZW5vdWdoLCBiZWNhdXNlIHRoZSBjbGllbnQgbmVlZHMgdG8gc2VlIHdoYXQgY29va2llc1xuICAgICAgICAgICAgLy8gYXJlIGFscmVhZHkgc2V0IGFuZCB1bnNldCB0aGVtIGlmIG5lY2Vzc2FyeS4gVG8gYXR0ZW1wdCB0byBmaXggdGhpc1xuICAgICAgICAgICAgLy8gYmVoYXZpb3IgZm9yIG1vc3QgdXNlIGNhc2VzLCB3ZSBwYXNzIFwiaGludHNcIiB3aGljaCBpcyB0aGUga2V5cyBvZiB0aGVcbiAgICAgICAgICAgIC8vIHN0b3JhZ2UgaXRlbXMuIFRoZXkgYXJlIHRoZW4gY29udmVydGVkIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgY29va2llXG4gICAgICAgICAgICAvLyBjaHVuayBuYW1lcyBhbmQgYXJlIGZldGNoZWQgd2l0aCBnZXQuIE9ubHkgNSBjaHVua3MgYXJlIGZldGNoZWQsIHdoaWNoXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgZW5vdWdoIGZvciB0aGUgbWFqb3JpdHkgb2YgdXNlIGNhc2VzLCBidXQgZG9lcyBub3Qgc29sdmVcbiAgICAgICAgICAgIC8vIHRob3NlIHdpdGggdmVyeSBsYXJnZSBzZXNzaW9ucy5cbiAgICAgICAgICAgIGNvbnN0IGdldFdpdGhIaW50cyA9IGFzeW5jIChrZXlIaW50cykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIG9wdGltaXN0aWNhbGx5IGZpbmQgdGhlIGZpcnN0IDUgcG90ZW50aWFsIGNodW5rcyBmb3IgdGhlIHNwZWNpZmllZCBrZXlcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua05hbWVzID0ga2V5SGludHMuZmxhdE1hcCgoa2V5SGludCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICBrZXlIaW50LFxuICAgICAgICAgICAgICAgICAgICAuLi5BcnJheS5mcm9tKHsgbGVuZ3RoOiA1IH0pLm1hcCgoXywgaSkgPT4gYCR7a2V5SGludH0uJHtpfWApLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtOYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGNvb2tpZXMuZ2V0KGNodW5rTmFtZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goeyBuYW1lOiBjaHVua05hbWVzW2ldLCB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZGV0ZWN0IGFuZCBsb2cgc3RhbGUgY2h1bmtzIGVycm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnZXRBbGwgPSBhc3luYyAoa2V5SGludHMpID0+IGF3YWl0IGdldFdpdGhIaW50cyhrZXlIaW50cyk7XG4gICAgICAgICAgICBpZiAoXCJzZXRcIiBpbiBjb29raWVzICYmIFwicmVtb3ZlXCIgaW4gY29va2llcykge1xuICAgICAgICAgICAgICAgIHNldEFsbCA9IGFzeW5jIChzZXRDb29raWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Q29va2llcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBuYW1lLCB2YWx1ZSwgb3B0aW9ucyB9ID0gc2V0Q29va2llc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNvb2tpZXMuc2V0KG5hbWUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNvb2tpZXMucmVtb3ZlKG5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU2VydmVyQ2xpZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0QWxsID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJAc3VwYWJhc2Uvc3NyOiBjcmVhdGVTZXJ2ZXJDbGllbnQgd2FzIGNvbmZpZ3VyZWQgd2l0aG91dCBzZXQgYW5kIHJlbW92ZSBjb29raWUgbWV0aG9kcywgYnV0IHRoZSBjbGllbnQgbmVlZHMgdG8gc2V0IGNvb2tpZXMuIFRoaXMgY2FuIGxlYWQgdG8gaXNzdWVzIHN1Y2ggYXMgcmFuZG9tIGxvZ291dHMsIGVhcmx5IHNlc3Npb24gdGVybWluYXRpb24gb3IgaW5jcmVhc2VkIHRva2VuIHJlZnJlc2ggcmVxdWVzdHMuIElmIGluIE5leHRKUywgY2hlY2sgeW91ciBtaWRkbGV3YXJlLnRzIGZpbGUsIHJvdXRlIGhhbmRsZXJzIGFuZCBzZXJ2ZXIgYWN0aW9ucyBmb3IgY29ycmVjdG5lc3MuIENvbnNpZGVyIHN3aXRjaGluZyB0byB0aGUgZ2V0QWxsIGFuZCBzZXRBbGwgY29va2llIG1ldGhvZHMgaW5zdGVhZCBvZiBnZXQsIHNldCBhbmQgcmVtb3ZlIHdoaWNoIGFyZSBkZXByZWNhdGVkIGFuZCBjYW4gYmUgZGlmZmljdWx0IHRvIHVzZSBjb3JyZWN0bHkuXCIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAc3VwYWJhc2Uvc3NyOiBjcmVhdGVCcm93c2VyQ2xpZW50IHJlcXVpcmVzIGNvbmZpZ3VyaW5nIGEgZ2V0QWxsIGFuZCBzZXRBbGwgY29va2llIG1ldGhvZCAoZGVwcmVjYXRlZDogYWx0ZXJuYXRpdmVseSBib3RoIGdldCwgc2V0IGFuZCByZW1vdmUgY2FuIGJlIHVzZWQpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFwiZ2V0QWxsXCIgaW4gY29va2llcykge1xuICAgICAgICAgICAgZ2V0QWxsID0gYXN5bmMgKCkgPT4gYXdhaXQgY29va2llcy5nZXRBbGwoKTtcbiAgICAgICAgICAgIGlmIChcInNldEFsbFwiIGluIGNvb2tpZXMpIHtcbiAgICAgICAgICAgICAgICBzZXRBbGwgPSBjb29raWVzLnNldEFsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU2VydmVyQ2xpZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0QWxsID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJAc3VwYWJhc2Uvc3NyOiBjcmVhdGVTZXJ2ZXJDbGllbnQgd2FzIGNvbmZpZ3VyZWQgd2l0aG91dCB0aGUgc2V0QWxsIGNvb2tpZSBtZXRob2QsIGJ1dCB0aGUgY2xpZW50IG5lZWRzIHRvIHNldCBjb29raWVzLiBUaGlzIGNhbiBsZWFkIHRvIGlzc3VlcyBzdWNoIGFzIHJhbmRvbSBsb2dvdXRzLCBlYXJseSBzZXNzaW9uIHRlcm1pbmF0aW9uIG9yIGluY3JlYXNlZCB0b2tlbiByZWZyZXNoIHJlcXVlc3RzLiBJZiBpbiBOZXh0SlMsIGNoZWNrIHlvdXIgbWlkZGxld2FyZS50cyBmaWxlLCByb3V0ZSBoYW5kbGVycyBhbmQgc2VydmVyIGFjdGlvbnMgZm9yIGNvcnJlY3RuZXNzLlwiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQHN1cGFiYXNlL3NzcjogY3JlYXRlQnJvd3NlckNsaWVudCByZXF1aXJlcyBjb25maWd1cmluZyBib3RoIGdldEFsbCBhbmQgc2V0QWxsIGNvb2tpZSBtZXRob2RzIChkZXByZWNhdGVkOiBhbHRlcm5hdGl2ZWx5IGJvdGggZ2V0LCBzZXQgYW5kIHJlbW92ZSBjYW4gYmUgdXNlZClcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBuZWl0aGVyIGdldCBub3IgZ2V0QWxsIGlzIHByZXNlbnQgb24gY29va2llcywgb25seSB3aWxsIG9jY3VyIGlmIHB1cmUgSmF2YVNjcmlwdCBpcyB1c2VkLCBidXQgY29va2llcyBpcyBhbiBvYmplY3RcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL3NzcjogJHtpc1NlcnZlckNsaWVudCA/IFwiY3JlYXRlU2VydmVyQ2xpZW50XCIgOiBcImNyZWF0ZUJyb3dzZXJDbGllbnRcIn0gcmVxdWlyZXMgY29uZmlndXJpbmcgZ2V0QWxsIGFuZCBzZXRBbGwgY29va2llIG1ldGhvZHMgKGRlcHJlY2F0ZWQ6IGFsdGVybmF0aXZlbHkgdXNlIGdldCwgc2V0IGFuZCByZW1vdmUpLiR7KDAsIHV0aWxzXzEuaXNCcm93c2VyKSgpID8gXCIgQXMgdGhpcyBpcyBjYWxsZWQgaW4gYSBicm93c2VyIHJ1bnRpbWUsIGNvbnNpZGVyIHJlbW92aW5nIHRoZSBjb29raWVzIG9wdGlvbiBvYmplY3QgdG8gdXNlIHRoZSBkb2N1bWVudC5jb29raWUgQVBJIGF1dG9tYXRpY2FsbHkuXCIgOiBcIlwifWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc1NlcnZlckNsaWVudCAmJiAoMCwgdXRpbHNfMS5pc0Jyb3dzZXIpKCkpIHtcbiAgICAgICAgLy8gVGhlIGVudmlyb25tZW50IGlzIGJyb3dzZXIsIHNvIHVzZSB0aGUgZG9jdW1lbnQuY29va2llIEFQSSB0byBpbXBsZW1lbnQgZ2V0QWxsIGFuZCBzZXRBbGwuXG4gICAgICAgIGNvbnN0IG5vSGludEdldEFsbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9ICgwLCBjb29raWVfMS5wYXJzZSkoZG9jdW1lbnQuY29va2llKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJzZWQpLm1hcCgobmFtZSkgPT4gKHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZWRbbmFtZV0gPz8gXCJcIixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgZ2V0QWxsID0gKCkgPT4gbm9IaW50R2V0QWxsKCk7XG4gICAgICAgIHNldEFsbCA9IChzZXRDb29raWVzKSA9PiB7XG4gICAgICAgICAgICBzZXRDb29raWVzLmZvckVhY2goKHsgbmFtZSwgdmFsdWUsIG9wdGlvbnMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9ICgwLCBjb29raWVfMS5zZXJpYWxpemUpKG5hbWUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1NlcnZlckNsaWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAc3VwYWJhc2Uvc3NyOiBjcmVhdGVTZXJ2ZXJDbGllbnQgbXVzdCBiZSBpbml0aWFsaXplZCB3aXRoIGNvb2tpZSBvcHRpb25zIHRoYXQgc3BlY2lmeSBnZXRBbGwgYW5kIHNldEFsbCBmdW5jdGlvbnMgKGRlcHJlY2F0ZWQsIG5vdCByZWNvbW1lbmRlZDogYWx0ZXJuYXRpdmVseSB1c2UgZ2V0LCBzZXQgYW5kIHJlbW92ZSlcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBnZXR0aW5nIGNvb2tpZXMgd2hlbiB0aGVyZSdzIG5vIHdpbmRvdyBidXQgd2UncmUgaW4gYnJvd3NlciBtb2RlIGNhbiBiZSBPSywgYmVjYXVzZSB0aGUgZGV2ZWxvcGVyIHByb2JhYmx5IGlzIG5vdCB1c2luZyBhdXRoIGZ1bmN0aW9uc1xuICAgICAgICBnZXRBbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG4gICAgICAgIC8vIHRoaXMgaXMgTk9UIE9LIGJlY2F1c2UgdGhlIGRldmVsb3BlciBpcyB1c2luZyBhdXRoIGZ1bmN0aW9ucyB0aGF0IHJlcXVpcmUgc2V0dGluZyBzb21lIHN0YXRlLCBzbyB0aGF0IG11c3QgZXJyb3Igb3V0XG4gICAgICAgIHNldEFsbCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBzdXBhYmFzZS9zc3I6IGNyZWF0ZUJyb3dzZXJDbGllbnQgaW4gbm9uLWJyb3dzZXIgcnVudGltZXMgKGluY2x1ZGluZyBOZXh0LmpzIHByZS1yZW5kZXJpbmcgbW9kZSkgd2FzIG5vdCBpbml0aWFsaXplZCBjb29raWUgb3B0aW9ucyB0aGF0IHNwZWNpZnkgZ2V0QWxsIGFuZCBzZXRBbGwgZnVuY3Rpb25zIChkZXByZWNhdGVkOiBhbHRlcm5hdGl2ZWx5IHVzZSBnZXQsIHNldCBhbmQgcmVtb3ZlKSwgYnV0IHRoZXkgd2VyZSBuZWVkZWRcIik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICghaXNTZXJ2ZXJDbGllbnQpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgc3RvcmFnZSBjbGllbnQgdG8gYmUgdXNlZCBpbiBicm93c2Vycy4gSXQgb25seVxuICAgICAgICAvLyB3b3JrcyBvbiB0aGUgY29va2llcyBhYnN0cmFjdGlvbiwgdW5saWtlIHRoZSBzZXJ2ZXIgY2xpZW50XG4gICAgICAgIC8vIHdoaWNoIG9ubHkgdXNlcyBjb29raWVzIHRvIHJlYWQgdGhlIGluaXRpYWwgc3RhdGUuIFdoZW4gYW5cbiAgICAgICAgLy8gaXRlbSBpcyBzZXQsIGNvb2tpZXMgYXJlIGJvdGggY2xlYXJlZCBhbmQgc2V0IHRvIHZhbHVlcyBzb1xuICAgICAgICAvLyB0aGF0IHN0YWxlIGNodW5rcyBhcmUgbm90IGxlZnQgcmVtYWluaW5nLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0QWxsLCAvLyBmb3IgdHlwZSBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgc2V0QWxsLCAvLyBmb3IgdHlwZSBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgc2V0SXRlbXMsIC8vIGZvciB0eXBlIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICByZW1vdmVkSXRlbXMsIC8vIGZvciB0eXBlIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICBzdG9yYWdlOiB7XG4gICAgICAgICAgICAgICAgaXNTZXJ2ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGdldEl0ZW06IGFzeW5jIChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsQ29va2llcyA9IGF3YWl0IGdldEFsbChba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rZWRDb29raWUgPSBhd2FpdCAoMCwgdXRpbHNfMS5jb21iaW5lQ2h1bmtzKShrZXksIGFzeW5jIChjaHVua05hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb2tpZSA9IGFsbENvb2tpZXM/LmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBjaHVua05hbWUpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvb2tpZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvb2tpZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2h1bmtlZENvb2tpZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlY29kZWQgPSBjaHVua2VkQ29va2llO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtlZENvb2tpZS5zdGFydHNXaXRoKEJBU0U2NF9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkID0gKDAsIHV0aWxzXzEuc3RyaW5nRnJvbUJhc2U2NFVSTCkoY2h1bmtlZENvb2tpZS5zdWJzdHJpbmcoQkFTRTY0X1BSRUZJWC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldEl0ZW06IGFzeW5jIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbENvb2tpZXMgPSBhd2FpdCBnZXRBbGwoW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb29raWVOYW1lcyA9IGFsbENvb2tpZXM/Lm1hcCgoeyBuYW1lIH0pID0+IG5hbWUpIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVDb29raWVzID0gbmV3IFNldChjb29raWVOYW1lcy5maWx0ZXIoKG5hbWUpID0+ICgwLCB1dGlsc18xLmlzQ2h1bmtMaWtlKShuYW1lLCBrZXkpKSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmNvZGVkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb29raWVFbmNvZGluZyA9PT0gXCJiYXNlNjR1cmxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZCA9IEJBU0U2NF9QUkVGSVggKyAoMCwgdXRpbHNfMS5zdHJpbmdUb0Jhc2U2NFVSTCkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldENvb2tpZXMgPSAoMCwgdXRpbHNfMS5jcmVhdGVDaHVua3MpKGtleSwgZW5jb2RlZCk7XG4gICAgICAgICAgICAgICAgICAgIHNldENvb2tpZXMuZm9yRWFjaCgoeyBuYW1lIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNvb2tpZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlQ29va2llT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnV0aWxzXzEuREVGQVVMVF9DT09LSUVfT1BUSU9OUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnM/LmNvb2tpZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhBZ2U6IDAsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldENvb2tpZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi51dGlsc18xLkRFRkFVTFRfQ09PS0lFX09QVElPTlMsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5jb29raWVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4QWdlOiB1dGlsc18xLkRFRkFVTFRfQ09PS0lFX09QVElPTlMubWF4QWdlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgTmV4dEpTIGNvb2tpZVN0b3JlIEFQSSBjYW4gZ2V0IGNvbmZ1c2VkIGlmIHRoZSBgbmFtZWAgZnJvbVxuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zLmNvb2tpZU9wdGlvbnMgbGVha3NcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlbW92ZUNvb2tpZU9wdGlvbnMubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNldENvb2tpZU9wdGlvbnMubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsVG9TZXQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5bLi4ucmVtb3ZlQ29va2llc10ubWFwKChuYW1lKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogcmVtb3ZlQ29va2llT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnNldENvb2tpZXMubWFwKCh7IG5hbWUsIHZhbHVlIH0pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBzZXRDb29raWVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsVG9TZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2V0QWxsKGFsbFRvU2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVtb3ZlSXRlbTogYXN5bmMgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxDb29raWVzID0gYXdhaXQgZ2V0QWxsKFtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29va2llTmFtZXMgPSBhbGxDb29raWVzPy5tYXAoKHsgbmFtZSB9KSA9PiBuYW1lKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlQ29va2llcyA9IGNvb2tpZU5hbWVzLmZpbHRlcigobmFtZSkgPT4gKDAsIHV0aWxzXzEuaXNDaHVua0xpa2UpKG5hbWUsIGtleSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVDb29raWVPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udXRpbHNfMS5ERUZBVUxUX0NPT0tJRV9PUFRJT05TLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uY29va2llT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEFnZTogMCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIE5leHRKUyBjb29raWVTdG9yZSBBUEkgY2FuIGdldCBjb25mdXNlZCBpZiB0aGUgYG5hbWVgIGZyb21cbiAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9ucy5jb29raWVPcHRpb25zIGxlYWtzXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZW1vdmVDb29raWVPcHRpb25zLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVDb29raWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNldEFsbChyZW1vdmVDb29raWVzLm1hcCgobmFtZSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHJlbW92ZUNvb2tpZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIHNlcnZlciBjbGllbnQuIEl0IG9ubHkgdXNlcyBnZXRBbGwgdG8gcmVhZCB0aGUgaW5pdGlhbFxuICAgIC8vIHN0YXRlLiBBbnkgc3Vic2VxdWVudCBjaGFuZ2VzIHRvIHRoZSBpdGVtcyBpcyBwZXJzaXN0ZWQgaW4gdGhlXG4gICAgLy8gc2V0SXRlbXMgYW5kIHJlbW92ZWRJdGVtcyBvYmplY3RzLiBjcmVhdGVTZXJ2ZXJDbGllbnQgKm11c3QqIHVzZVxuICAgIC8vIGdldEFsbCwgc2V0QWxsIGFuZCB0aGUgdmFsdWVzIGluIHNldEl0ZW1zIGFuZCByZW1vdmVkSXRlbXMgdG9cbiAgICAvLyBwZXJzaXN0IHRoZSBjaGFuZ2VzICphdCBvbmNlKiB3aGVuIGFwcHJvcHJpYXRlICh1c3VhbGx5IG9ubHkgd2hlblxuICAgIC8vIHRoZSBUT0tFTl9SRUZSRVNIRUQsIFVTRVJfVVBEQVRFRCBvciBTSUdORURfT1VUIGV2ZW50cyBhcmUgZmlyZWQgYnlcbiAgICAvLyB0aGUgU3VwYWJhc2UgQXV0aCBjbGllbnQpLlxuICAgIHJldHVybiB7XG4gICAgICAgIGdldEFsbCxcbiAgICAgICAgc2V0QWxsLFxuICAgICAgICBzZXRJdGVtcyxcbiAgICAgICAgcmVtb3ZlZEl0ZW1zLFxuICAgICAgICBzdG9yYWdlOiB7XG4gICAgICAgICAgICAvLyB0byBzaWduYWwgdG8gdGhlIGxpYnJhcmllcyB0aGF0IHRoZXNlIGNvb2tpZXMgYXJlXG4gICAgICAgICAgICAvLyBjb21pbmcgZnJvbSBhIHNlcnZlciBlbnZpcm9ubWVudCBhbmQgdGhlaXIgdmFsdWVcbiAgICAgICAgICAgIC8vIHNob3VsZCBub3QgYmUgdHJ1c3RlZFxuICAgICAgICAgICAgaXNTZXJ2ZXI6IHRydWUsXG4gICAgICAgICAgICBnZXRJdGVtOiBhc3luYyAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXRJdGVtc1trZXldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRJdGVtc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZEl0ZW1zW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbENvb2tpZXMgPSBhd2FpdCBnZXRBbGwoW2tleV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rZWRDb29raWUgPSBhd2FpdCAoMCwgdXRpbHNfMS5jb21iaW5lQ2h1bmtzKShrZXksIGFzeW5jIChjaHVua05hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29va2llID0gYWxsQ29va2llcz8uZmluZCgoeyBuYW1lIH0pID0+IG5hbWUgPT09IGNodW5rTmFtZSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb29raWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb29raWUudmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaHVua2VkQ29va2llKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZGVjb2RlZCA9IGNodW5rZWRDb29raWU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVua2VkQ29va2llID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgICAgIGNodW5rZWRDb29raWUuc3RhcnRzV2l0aChCQVNFNjRfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkID0gKDAsIHV0aWxzXzEuc3RyaW5nRnJvbUJhc2U2NFVSTCkoY2h1bmtlZENvb2tpZS5zdWJzdHJpbmcoQkFTRTY0X1BSRUZJWC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0SXRlbTogYXN5bmMgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGFuIGBvbkF1dGhTdGF0ZUNoYW5nZWAgZXZlbnQgdGhhdCBjYW4gbGV0IHVzIGtub3cgdGhhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBQS0NFIGNvZGUgdmVyaWZpZXIgaXMgYmVpbmcgc2V0LiBUaGVyZWZvcmUsIGlmIHdlIHNlZSBpdCBiZWluZ1xuICAgICAgICAgICAgICAgIC8vIHNldCwgd2UgbmVlZCB0byBhcHBseSB0aGUgc3RvcmFnZSAoY2FsbCBgc2V0QWxsYCBzbyB0aGUgY29va2llIGlzXG4gICAgICAgICAgICAgICAgLy8gc2V0IHByb3Blcmx5KS5cbiAgICAgICAgICAgICAgICBpZiAoa2V5LmVuZHNXaXRoKFwiLWNvZGUtdmVyaWZpZXJcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYXBwbHlTZXJ2ZXJTdG9yYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXRlbmQgb25seSB0aGF0IHRoZSBjb2RlIHZlcmlmaWVyIHdhcyBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEl0ZW1zOiB7IFtrZXldOiB2YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldGVuZCB0aGF0IG5vdGhpbmcgd2FzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtczoge30sXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZU9wdGlvbnM6IG9wdGlvbnM/LmNvb2tpZU9wdGlvbnMgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZUVuY29kaW5nLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0SXRlbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZW1vdmVkSXRlbXNba2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVJdGVtOiBhc3luYyAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBub3QgYXBwbHlpbmcgdGhlIHN0b3JhZ2Ugd2hlbiB0aGUga2V5IGlzIHRoZSBQS0NFIGNvZGVcbiAgICAgICAgICAgICAgICAvLyB2ZXJpZmllciwgYXMgdXN1YWxseSByaWdodCBhZnRlciBpdCdzIHJlbW92ZWQgb3RoZXIgaXRlbXMgYXJlIHNldCxcbiAgICAgICAgICAgICAgICAvLyBzbyBhcHBsaWNhdGlvbiBvZiB0aGUgc3RvcmFnZSB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlXG4gICAgICAgICAgICAgICAgLy8gYG9uQXV0aFN0YXRlQ2hhbmdlYCBjYWxsYmFjayB0aGF0IGZvbGxvd3MgcmVtb3ZhbCAtLSB1c3VhbGx5IGFzIHBhcnRcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgYGV4Y2hhbmdlQ29kZUZvclNlc3Npb25gIGNhbGwuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHNldEl0ZW1zW2tleV07XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBXaGVuIGNyZWF0ZVNlcnZlckNsaWVudCBuZWVkcyB0byBhcHBseSB0aGUgY3JlYXRlZCBzdG9yYWdlIHRvIGNvb2tpZXMsIGl0XG4gKiBzaG91bGQgY2FsbCB0aGlzIGZ1bmN0aW9uIHdoaWNoIGhhbmRsZXMgY29ycmVjbHkgc2V0dGluZyBjb29raWVzIGZvciBzdG9yZWRcbiAqIGFuZCByZW1vdmVkIGl0ZW1zIGluIHRoZSBzdG9yYWdlLlxuICovXG5hc3luYyBmdW5jdGlvbiBhcHBseVNlcnZlclN0b3JhZ2UoeyBnZXRBbGwsIHNldEFsbCwgc2V0SXRlbXMsIHJlbW92ZWRJdGVtcywgfSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvb2tpZUVuY29kaW5nID0gb3B0aW9ucy5jb29raWVFbmNvZGluZztcbiAgICBjb25zdCBjb29raWVPcHRpb25zID0gb3B0aW9ucy5jb29raWVPcHRpb25zID8/IG51bGw7XG4gICAgY29uc3QgYWxsQ29va2llcyA9IGF3YWl0IGdldEFsbChbXG4gICAgICAgIC4uLihzZXRJdGVtcyA/IE9iamVjdC5rZXlzKHNldEl0ZW1zKSA6IFtdKSxcbiAgICAgICAgLi4uKHJlbW92ZWRJdGVtcyA/IE9iamVjdC5rZXlzKHJlbW92ZWRJdGVtcykgOiBbXSksXG4gICAgXSk7XG4gICAgY29uc3QgY29va2llTmFtZXMgPSBhbGxDb29raWVzPy5tYXAoKHsgbmFtZSB9KSA9PiBuYW1lKSB8fCBbXTtcbiAgICBjb25zdCByZW1vdmVDb29raWVzID0gT2JqZWN0LmtleXMocmVtb3ZlZEl0ZW1zKS5mbGF0TWFwKChpdGVtTmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gY29va2llTmFtZXMuZmlsdGVyKChuYW1lKSA9PiAoMCwgdXRpbHNfMS5pc0NodW5rTGlrZSkobmFtZSwgaXRlbU5hbWUpKTtcbiAgICB9KTtcbiAgICBjb25zdCBzZXRDb29raWVzID0gT2JqZWN0LmtleXMoc2V0SXRlbXMpLmZsYXRNYXAoKGl0ZW1OYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbW92ZUV4aXN0aW5nQ29va2llc0Zvckl0ZW0gPSBuZXcgU2V0KGNvb2tpZU5hbWVzLmZpbHRlcigobmFtZSkgPT4gKDAsIHV0aWxzXzEuaXNDaHVua0xpa2UpKG5hbWUsIGl0ZW1OYW1lKSkpO1xuICAgICAgICBsZXQgZW5jb2RlZCA9IHNldEl0ZW1zW2l0ZW1OYW1lXTtcbiAgICAgICAgaWYgKGNvb2tpZUVuY29kaW5nID09PSBcImJhc2U2NHVybFwiKSB7XG4gICAgICAgICAgICBlbmNvZGVkID0gQkFTRTY0X1BSRUZJWCArICgwLCB1dGlsc18xLnN0cmluZ1RvQmFzZTY0VVJMKShlbmNvZGVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHVua3MgPSAoMCwgdXRpbHNfMS5jcmVhdGVDaHVua3MpKGl0ZW1OYW1lLCBlbmNvZGVkKTtcbiAgICAgICAgY2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiB7XG4gICAgICAgICAgICByZW1vdmVFeGlzdGluZ0Nvb2tpZXNGb3JJdGVtLmRlbGV0ZShjaHVuay5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZUNvb2tpZXMucHVzaCguLi5yZW1vdmVFeGlzdGluZ0Nvb2tpZXNGb3JJdGVtKTtcbiAgICAgICAgcmV0dXJuIGNodW5rcztcbiAgICB9KTtcbiAgICBjb25zdCByZW1vdmVDb29raWVPcHRpb25zID0ge1xuICAgICAgICAuLi51dGlsc18xLkRFRkFVTFRfQ09PS0lFX09QVElPTlMsXG4gICAgICAgIC4uLmNvb2tpZU9wdGlvbnMsXG4gICAgICAgIG1heEFnZTogMCxcbiAgICB9O1xuICAgIGNvbnN0IHNldENvb2tpZU9wdGlvbnMgPSB7XG4gICAgICAgIC4uLnV0aWxzXzEuREVGQVVMVF9DT09LSUVfT1BUSU9OUyxcbiAgICAgICAgLi4uY29va2llT3B0aW9ucyxcbiAgICAgICAgbWF4QWdlOiB1dGlsc18xLkRFRkFVTFRfQ09PS0lFX09QVElPTlMubWF4QWdlLFxuICAgIH07XG4gICAgLy8gdGhlIE5leHRKUyBjb29raWVTdG9yZSBBUEkgY2FuIGdldCBjb25mdXNlZCBpZiB0aGUgYG5hbWVgIGZyb21cbiAgICAvLyBvcHRpb25zLmNvb2tpZU9wdGlvbnMgbGVha3NcbiAgICBkZWxldGUgcmVtb3ZlQ29va2llT3B0aW9ucy5uYW1lO1xuICAgIGRlbGV0ZSBzZXRDb29raWVPcHRpb25zLm5hbWU7XG4gICAgYXdhaXQgc2V0QWxsKFtcbiAgICAgICAgLi4ucmVtb3ZlQ29va2llcy5tYXAoKG5hbWUpID0+ICh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IFwiXCIsXG4gICAgICAgICAgICBvcHRpb25zOiByZW1vdmVDb29raWVPcHRpb25zLFxuICAgICAgICB9KSksXG4gICAgICAgIC4uLnNldENvb2tpZXMubWFwKCh7IG5hbWUsIHZhbHVlIH0pID0+ICh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBvcHRpb25zOiBzZXRDb29raWVPcHRpb25zLFxuICAgICAgICB9KSksXG4gICAgXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb29raWVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZVN0b3JhZ2VGcm9tT3B0aW9ucyIsImFwcGx5U2VydmVyU3RvcmFnZSIsImNvb2tpZV8xIiwicmVxdWlyZSIsInV0aWxzXzEiLCJCQVNFNjRfUFJFRklYIiwib3B0aW9ucyIsImlzU2VydmVyQ2xpZW50IiwiY29va2llcyIsImNvb2tpZUVuY29kaW5nIiwic2V0SXRlbXMiLCJyZW1vdmVkSXRlbXMiLCJnZXRBbGwiLCJzZXRBbGwiLCJnZXRXaXRoSGludHMiLCJrZXlIaW50cyIsImNodW5rTmFtZXMiLCJmbGF0TWFwIiwia2V5SGludCIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIm1hcCIsIl8iLCJpIiwiY2h1bmtzIiwiZ2V0IiwicHVzaCIsIm5hbWUiLCJzZXRDb29raWVzIiwic2V0IiwicmVtb3ZlIiwiY29uc29sZSIsIndhcm4iLCJFcnJvciIsImlzQnJvd3NlciIsIm5vSGludEdldEFsbCIsInBhcnNlZCIsInBhcnNlIiwiZG9jdW1lbnQiLCJjb29raWUiLCJrZXlzIiwiZm9yRWFjaCIsInNlcmlhbGl6ZSIsInN0b3JhZ2UiLCJpc1NlcnZlciIsImdldEl0ZW0iLCJrZXkiLCJhbGxDb29raWVzIiwiY2h1bmtlZENvb2tpZSIsImNvbWJpbmVDaHVua3MiLCJjaHVua05hbWUiLCJmaW5kIiwiZGVjb2RlZCIsInN0YXJ0c1dpdGgiLCJzdHJpbmdGcm9tQmFzZTY0VVJMIiwic3Vic3RyaW5nIiwic2V0SXRlbSIsImNvb2tpZU5hbWVzIiwicmVtb3ZlQ29va2llcyIsIlNldCIsImZpbHRlciIsImlzQ2h1bmtMaWtlIiwiZW5jb2RlZCIsInN0cmluZ1RvQmFzZTY0VVJMIiwiY3JlYXRlQ2h1bmtzIiwiZGVsZXRlIiwicmVtb3ZlQ29va2llT3B0aW9ucyIsIkRFRkFVTFRfQ09PS0lFX09QVElPTlMiLCJjb29raWVPcHRpb25zIiwibWF4QWdlIiwic2V0Q29va2llT3B0aW9ucyIsImFsbFRvU2V0IiwicmVtb3ZlSXRlbSIsImVuZHNXaXRoIiwiaXRlbU5hbWUiLCJyZW1vdmVFeGlzdGluZ0Nvb2tpZXNGb3JJdGVtIiwiY2h1bmsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/ssr/dist/main/cookies.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/ssr/dist/main/createBrowserClient.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/main/createBrowserClient.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createBrowserClient = createBrowserClient;\nconst supabase_js_1 = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/index.cjs\");\nconst version_1 = __webpack_require__(/*! ./version */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/version.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/utils/index.js\");\nconst cookies_1 = __webpack_require__(/*! ./cookies */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/cookies.js\");\nlet cachedBrowserClient;\nfunction createBrowserClient(supabaseUrl, supabaseKey, options) {\n    // singleton client is created only if isSingleton is set to true, or if isSingleton is not defined and we detect a browser\n    const shouldUseSingleton = options?.isSingleton === true || (!options || !(\"isSingleton\" in options)) && (0, utils_1.isBrowser)();\n    if (shouldUseSingleton && cachedBrowserClient) {\n        return cachedBrowserClient;\n    }\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(`@supabase/ssr: Your project's URL and API key are required to create a Supabase client!\\n\\nCheck your Supabase project's API settings to find these values\\n\\nhttps://supabase.com/dashboard/project/_/settings/api`);\n    }\n    const { storage } = (0, cookies_1.createStorageFromOptions)({\n        ...options,\n        cookieEncoding: options?.cookieEncoding ?? \"base64url\"\n    }, false);\n    const client = (0, supabase_js_1.createClient)(supabaseUrl, supabaseKey, {\n        // TODO: resolve type error\n        ...options,\n        global: {\n            ...options?.global,\n            headers: {\n                ...options?.global?.headers,\n                \"X-Client-Info\": `supabase-ssr/${version_1.VERSION} createBrowserClient`\n            }\n        },\n        auth: {\n            ...options?.auth,\n            ...options?.cookieOptions?.name ? {\n                storageKey: options.cookieOptions.name\n            } : null,\n            flowType: \"pkce\",\n            autoRefreshToken: (0, utils_1.isBrowser)(),\n            detectSessionInUrl: (0, utils_1.isBrowser)(),\n            persistSession: true,\n            storage,\n            ...options?.cookies && \"encode\" in options.cookies && options.cookies.encode === \"tokens-only\" ? {\n                userStorage: options?.auth?.userStorage ?? window.localStorage\n            } : null\n        }\n    });\n    if (shouldUseSingleton) {\n        cachedBrowserClient = client;\n    }\n    return client;\n} //# sourceMappingURL=createBrowserClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vY3JlYXRlQnJvd3NlckNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMkJBQTJCLEdBQUdFO0FBQzlCLE1BQU1DLGdCQUFnQkMsbUJBQU9BLENBQUMsd0ZBQXVCO0FBQ3JELE1BQU1DLFlBQVlELG1CQUFPQSxDQUFDLDBFQUFXO0FBQ3JDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLDRFQUFTO0FBQ2pDLE1BQU1HLFlBQVlILG1CQUFPQSxDQUFDLDBFQUFXO0FBQ3JDLElBQUlJO0FBQ0osU0FBU04sb0JBQW9CTyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsT0FBTztJQUMxRCwySEFBMkg7SUFDM0gsTUFBTUMscUJBQXFCRCxTQUFTRSxnQkFBZ0IsUUFDL0MsQ0FBQyxDQUFDRixXQUFXLENBQUUsa0JBQWlCQSxPQUFNLENBQUMsS0FBTSxDQUFDLEdBQUdMLFFBQVFRLFNBQVM7SUFDdkUsSUFBSUYsc0JBQXNCSixxQkFBcUI7UUFDM0MsT0FBT0E7SUFDWDtJQUNBLElBQUksQ0FBQ0MsZUFBZSxDQUFDQyxhQUFhO1FBQzlCLE1BQU0sSUFBSUssTUFBTSxDQUFDLG1OQUFtTixDQUFDO0lBQ3pPO0lBQ0EsTUFBTSxFQUFFQyxPQUFPLEVBQUUsR0FBRyxDQUFDLEdBQUdULFVBQVVVLHdCQUF3QixFQUFFO1FBQ3hELEdBQUdOLE9BQU87UUFDVk8sZ0JBQWdCUCxTQUFTTyxrQkFBa0I7SUFDL0MsR0FBRztJQUNILE1BQU1DLFNBQVMsQ0FBQyxHQUFHaEIsY0FBY2lCLFlBQVksRUFBRVgsYUFBYUMsYUFBYTtRQUNyRSwyQkFBMkI7UUFDM0IsR0FBR0MsT0FBTztRQUNWVSxRQUFRO1lBQ0osR0FBR1YsU0FBU1UsTUFBTTtZQUNsQkMsU0FBUztnQkFDTCxHQUFHWCxTQUFTVSxRQUFRQyxPQUFPO2dCQUMzQixpQkFBaUIsQ0FBQyxhQUFhLEVBQUVqQixVQUFVa0IsT0FBTyxDQUFDLG9CQUFvQixDQUFDO1lBQzVFO1FBQ0o7UUFDQUMsTUFBTTtZQUNGLEdBQUdiLFNBQVNhLElBQUk7WUFDaEIsR0FBSWIsU0FBU2MsZUFBZUMsT0FDdEI7Z0JBQUVDLFlBQVloQixRQUFRYyxhQUFhLENBQUNDLElBQUk7WUFBQyxJQUN6QyxJQUFJO1lBQ1ZFLFVBQVU7WUFDVkMsa0JBQWtCLENBQUMsR0FBR3ZCLFFBQVFRLFNBQVM7WUFDdkNnQixvQkFBb0IsQ0FBQyxHQUFHeEIsUUFBUVEsU0FBUztZQUN6Q2lCLGdCQUFnQjtZQUNoQmY7WUFDQSxHQUFJTCxTQUFTcUIsV0FDVCxZQUFZckIsUUFBUXFCLE9BQU8sSUFDM0JyQixRQUFRcUIsT0FBTyxDQUFDQyxNQUFNLEtBQUssZ0JBQ3pCO2dCQUNFQyxhQUFhdkIsU0FBU2EsTUFBTVUsZUFBZUMsT0FBT0MsWUFBWTtZQUNsRSxJQUNFLElBQUk7UUFDZDtJQUNKO0lBQ0EsSUFBSXhCLG9CQUFvQjtRQUNwQkosc0JBQXNCVztJQUMxQjtJQUNBLE9BQU9BO0FBQ1gsRUFDQSwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vY3JlYXRlQnJvd3NlckNsaWVudC5qcz9iMDhiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVCcm93c2VyQ2xpZW50ID0gY3JlYXRlQnJvd3NlckNsaWVudDtcbmNvbnN0IHN1cGFiYXNlX2pzXzEgPSByZXF1aXJlKFwiQHN1cGFiYXNlL3N1cGFiYXNlLWpzXCIpO1xuY29uc3QgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGNvb2tpZXNfMSA9IHJlcXVpcmUoXCIuL2Nvb2tpZXNcIik7XG5sZXQgY2FjaGVkQnJvd3NlckNsaWVudDtcbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5LCBvcHRpb25zKSB7XG4gICAgLy8gc2luZ2xldG9uIGNsaWVudCBpcyBjcmVhdGVkIG9ubHkgaWYgaXNTaW5nbGV0b24gaXMgc2V0IHRvIHRydWUsIG9yIGlmIGlzU2luZ2xldG9uIGlzIG5vdCBkZWZpbmVkIGFuZCB3ZSBkZXRlY3QgYSBicm93c2VyXG4gICAgY29uc3Qgc2hvdWxkVXNlU2luZ2xldG9uID0gb3B0aW9ucz8uaXNTaW5nbGV0b24gPT09IHRydWUgfHxcbiAgICAgICAgKCghb3B0aW9ucyB8fCAhKFwiaXNTaW5nbGV0b25cIiBpbiBvcHRpb25zKSkgJiYgKDAsIHV0aWxzXzEuaXNCcm93c2VyKSgpKTtcbiAgICBpZiAoc2hvdWxkVXNlU2luZ2xldG9uICYmIGNhY2hlZEJyb3dzZXJDbGllbnQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEJyb3dzZXJDbGllbnQ7XG4gICAgfVxuICAgIGlmICghc3VwYWJhc2VVcmwgfHwgIXN1cGFiYXNlS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL3NzcjogWW91ciBwcm9qZWN0J3MgVVJMIGFuZCBBUEkga2V5IGFyZSByZXF1aXJlZCB0byBjcmVhdGUgYSBTdXBhYmFzZSBjbGllbnQhXFxuXFxuQ2hlY2sgeW91ciBTdXBhYmFzZSBwcm9qZWN0J3MgQVBJIHNldHRpbmdzIHRvIGZpbmQgdGhlc2UgdmFsdWVzXFxuXFxuaHR0cHM6Ly9zdXBhYmFzZS5jb20vZGFzaGJvYXJkL3Byb2plY3QvXy9zZXR0aW5ncy9hcGlgKTtcbiAgICB9XG4gICAgY29uc3QgeyBzdG9yYWdlIH0gPSAoMCwgY29va2llc18xLmNyZWF0ZVN0b3JhZ2VGcm9tT3B0aW9ucykoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBjb29raWVFbmNvZGluZzogb3B0aW9ucz8uY29va2llRW5jb2RpbmcgPz8gXCJiYXNlNjR1cmxcIixcbiAgICB9LCBmYWxzZSk7XG4gICAgY29uc3QgY2xpZW50ID0gKDAsIHN1cGFiYXNlX2pzXzEuY3JlYXRlQ2xpZW50KShzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIHtcbiAgICAgICAgLy8gVE9ETzogcmVzb2x2ZSB0eXBlIGVycm9yXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGdsb2JhbDoge1xuICAgICAgICAgICAgLi4ub3B0aW9ucz8uZ2xvYmFsLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnM/Lmdsb2JhbD8uaGVhZGVycyxcbiAgICAgICAgICAgICAgICBcIlgtQ2xpZW50LUluZm9cIjogYHN1cGFiYXNlLXNzci8ke3ZlcnNpb25fMS5WRVJTSU9OfSBjcmVhdGVCcm93c2VyQ2xpZW50YCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnM/LmF1dGgsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucz8uY29va2llT3B0aW9ucz8ubmFtZVxuICAgICAgICAgICAgICAgID8geyBzdG9yYWdlS2V5OiBvcHRpb25zLmNvb2tpZU9wdGlvbnMubmFtZSB9XG4gICAgICAgICAgICAgICAgOiBudWxsKSxcbiAgICAgICAgICAgIGZsb3dUeXBlOiBcInBrY2VcIixcbiAgICAgICAgICAgIGF1dG9SZWZyZXNoVG9rZW46ICgwLCB1dGlsc18xLmlzQnJvd3NlcikoKSxcbiAgICAgICAgICAgIGRldGVjdFNlc3Npb25JblVybDogKDAsIHV0aWxzXzEuaXNCcm93c2VyKSgpLFxuICAgICAgICAgICAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gICAgICAgICAgICBzdG9yYWdlLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnM/LmNvb2tpZXMgJiZcbiAgICAgICAgICAgICAgICBcImVuY29kZVwiIGluIG9wdGlvbnMuY29va2llcyAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29va2llcy5lbmNvZGUgPT09IFwidG9rZW5zLW9ubHlcIlxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICB1c2VyU3RvcmFnZTogb3B0aW9ucz8uYXV0aD8udXNlclN0b3JhZ2UgPz8gd2luZG93LmxvY2FsU3RvcmFnZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBudWxsKSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBpZiAoc2hvdWxkVXNlU2luZ2xldG9uKSB7XG4gICAgICAgIGNhY2hlZEJyb3dzZXJDbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIHJldHVybiBjbGllbnQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVCcm93c2VyQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZUJyb3dzZXJDbGllbnQiLCJzdXBhYmFzZV9qc18xIiwicmVxdWlyZSIsInZlcnNpb25fMSIsInV0aWxzXzEiLCJjb29raWVzXzEiLCJjYWNoZWRCcm93c2VyQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJzdXBhYmFzZUtleSIsIm9wdGlvbnMiLCJzaG91bGRVc2VTaW5nbGV0b24iLCJpc1NpbmdsZXRvbiIsImlzQnJvd3NlciIsIkVycm9yIiwic3RvcmFnZSIsImNyZWF0ZVN0b3JhZ2VGcm9tT3B0aW9ucyIsImNvb2tpZUVuY29kaW5nIiwiY2xpZW50IiwiY3JlYXRlQ2xpZW50IiwiZ2xvYmFsIiwiaGVhZGVycyIsIlZFUlNJT04iLCJhdXRoIiwiY29va2llT3B0aW9ucyIsIm5hbWUiLCJzdG9yYWdlS2V5IiwiZmxvd1R5cGUiLCJhdXRvUmVmcmVzaFRva2VuIiwiZGV0ZWN0U2Vzc2lvbkluVXJsIiwicGVyc2lzdFNlc3Npb24iLCJjb29raWVzIiwiZW5jb2RlIiwidXNlclN0b3JhZ2UiLCJ3aW5kb3ciLCJsb2NhbFN0b3JhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/ssr/dist/main/createBrowserClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/ssr/dist/main/createServerClient.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/main/createServerClient.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createServerClient = createServerClient;\nconst supabase_js_1 = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/index.cjs\");\nconst version_1 = __webpack_require__(/*! ./version */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/version.js\");\nconst cookies_1 = __webpack_require__(/*! ./cookies */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/cookies.js\");\nconst helpers_1 = __webpack_require__(/*! ./utils/helpers */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/utils/helpers.js\");\nfunction createServerClient(supabaseUrl, supabaseKey, options) {\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(`Your project's URL and Key are required to create a Supabase client!\\n\\nCheck your Supabase project's API settings to find these values\\n\\nhttps://supabase.com/dashboard/project/_/settings/api`);\n    }\n    const { storage, getAll, setAll, setItems, removedItems } = (0, cookies_1.createStorageFromOptions)({\n        ...options,\n        cookieEncoding: options?.cookieEncoding ?? \"base64url\"\n    }, true);\n    const client = (0, supabase_js_1.createClient)(supabaseUrl, supabaseKey, {\n        // TODO: resolve type error\n        ...options,\n        global: {\n            ...options?.global,\n            headers: {\n                ...options?.global?.headers,\n                \"X-Client-Info\": `supabase-ssr/${version_1.VERSION} createServerClient`\n            }\n        },\n        auth: {\n            ...options?.cookieOptions?.name ? {\n                storageKey: options.cookieOptions.name\n            } : null,\n            ...options?.auth,\n            flowType: \"pkce\",\n            autoRefreshToken: false,\n            detectSessionInUrl: false,\n            persistSession: true,\n            storage,\n            ...options?.cookies && \"encode\" in options.cookies && options.cookies.encode === \"tokens-only\" ? {\n                userStorage: options?.auth?.userStorage ?? (0, helpers_1.memoryLocalStorageAdapter)()\n            } : null\n        }\n    });\n    client.auth.onAuthStateChange(async (event)=>{\n        // The SIGNED_IN event is fired very often, but we don't need to\n        // apply the storage each time it fires, only if there are changes\n        // that need to be set -- which is if setItems / removeItems have\n        // data.\n        const hasStorageChanges = Object.keys(setItems).length > 0 || Object.keys(removedItems).length > 0;\n        if (hasStorageChanges && (event === \"SIGNED_IN\" || event === \"TOKEN_REFRESHED\" || event === \"USER_UPDATED\" || event === \"PASSWORD_RECOVERY\" || event === \"SIGNED_OUT\" || event === \"MFA_CHALLENGE_VERIFIED\")) {\n            await (0, cookies_1.applyServerStorage)({\n                getAll,\n                setAll,\n                setItems,\n                removedItems\n            }, {\n                cookieOptions: options?.cookieOptions ?? null,\n                cookieEncoding: options?.cookieEncoding ?? \"base64url\"\n            });\n        }\n    });\n    return client;\n} //# sourceMappingURL=createServerClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vY3JlYXRlU2VydmVyQ2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBR0U7QUFDN0IsTUFBTUMsZ0JBQWdCQyxtQkFBT0EsQ0FBQyx3RkFBdUI7QUFDckQsTUFBTUMsWUFBWUQsbUJBQU9BLENBQUMsMEVBQVc7QUFDckMsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUMsMEVBQVc7QUFDckMsTUFBTUcsWUFBWUgsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQzNDLFNBQVNGLG1CQUFtQk0sV0FBVyxFQUFFQyxXQUFXLEVBQUVDLE9BQU87SUFDekQsSUFBSSxDQUFDRixlQUFlLENBQUNDLGFBQWE7UUFDOUIsTUFBTSxJQUFJRSxNQUFNLENBQUMsZ01BQWdNLENBQUM7SUFDdE47SUFDQSxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsWUFBWSxFQUFFLEdBQUcsQ0FBQyxHQUFHVixVQUFVVyx3QkFBd0IsRUFBRTtRQUNoRyxHQUFHUCxPQUFPO1FBQ1ZRLGdCQUFnQlIsU0FBU1Esa0JBQWtCO0lBQy9DLEdBQUc7SUFDSCxNQUFNQyxTQUFTLENBQUMsR0FBR2hCLGNBQWNpQixZQUFZLEVBQUVaLGFBQWFDLGFBQWE7UUFDckUsMkJBQTJCO1FBQzNCLEdBQUdDLE9BQU87UUFDVlcsUUFBUTtZQUNKLEdBQUdYLFNBQVNXLE1BQU07WUFDbEJDLFNBQVM7Z0JBQ0wsR0FBR1osU0FBU1csUUFBUUMsT0FBTztnQkFDM0IsaUJBQWlCLENBQUMsYUFBYSxFQUFFakIsVUFBVWtCLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQztZQUMzRTtRQUNKO1FBQ0FDLE1BQU07WUFDRixHQUFJZCxTQUFTZSxlQUFlQyxPQUN0QjtnQkFBRUMsWUFBWWpCLFFBQVFlLGFBQWEsQ0FBQ0MsSUFBSTtZQUFDLElBQ3pDLElBQUk7WUFDVixHQUFHaEIsU0FBU2MsSUFBSTtZQUNoQkksVUFBVTtZQUNWQyxrQkFBa0I7WUFDbEJDLG9CQUFvQjtZQUNwQkMsZ0JBQWdCO1lBQ2hCbkI7WUFDQSxHQUFJRixTQUFTc0IsV0FDVCxZQUFZdEIsUUFBUXNCLE9BQU8sSUFDM0J0QixRQUFRc0IsT0FBTyxDQUFDQyxNQUFNLEtBQUssZ0JBQ3pCO2dCQUNFQyxhQUFheEIsU0FBU2MsTUFBTVUsZUFBZSxDQUFDLEdBQUczQixVQUFVNEIseUJBQXlCO1lBQ3RGLElBQ0UsSUFBSTtRQUNkO0lBQ0o7SUFDQWhCLE9BQU9LLElBQUksQ0FBQ1ksaUJBQWlCLENBQUMsT0FBT0M7UUFDakMsZ0VBQWdFO1FBQ2hFLGtFQUFrRTtRQUNsRSxpRUFBaUU7UUFDakUsUUFBUTtRQUNSLE1BQU1DLG9CQUFvQnhDLE9BQU95QyxJQUFJLENBQUN4QixVQUFVeUIsTUFBTSxHQUFHLEtBQUsxQyxPQUFPeUMsSUFBSSxDQUFDdkIsY0FBY3dCLE1BQU0sR0FBRztRQUNqRyxJQUFJRixxQkFDQ0QsQ0FBQUEsVUFBVSxlQUNQQSxVQUFVLHFCQUNWQSxVQUFVLGtCQUNWQSxVQUFVLHVCQUNWQSxVQUFVLGdCQUNWQSxVQUFVLHdCQUF1QixHQUFJO1lBQ3pDLE1BQU0sQ0FBQyxHQUFHL0IsVUFBVW1DLGtCQUFrQixFQUFFO2dCQUFFNUI7Z0JBQVFDO2dCQUFRQztnQkFBVUM7WUFBYSxHQUFHO2dCQUNoRlMsZUFBZWYsU0FBU2UsaUJBQWlCO2dCQUN6Q1AsZ0JBQWdCUixTQUFTUSxrQkFBa0I7WUFDL0M7UUFDSjtJQUNKO0lBQ0EsT0FBT0M7QUFDWCxFQUNBLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3NyL2Rpc3QvbWFpbi9jcmVhdGVTZXJ2ZXJDbGllbnQuanM/YWIxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlU2VydmVyQ2xpZW50ID0gY3JlYXRlU2VydmVyQ2xpZW50O1xuY29uc3Qgc3VwYWJhc2VfanNfMSA9IHJlcXVpcmUoXCJAc3VwYWJhc2Uvc3VwYWJhc2UtanNcIik7XG5jb25zdCB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuY29uc3QgY29va2llc18xID0gcmVxdWlyZShcIi4vY29va2llc1wiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2hlbHBlcnNcIik7XG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKCFzdXBhYmFzZVVybCB8fCAhc3VwYWJhc2VLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3VyIHByb2plY3QncyBVUkwgYW5kIEtleSBhcmUgcmVxdWlyZWQgdG8gY3JlYXRlIGEgU3VwYWJhc2UgY2xpZW50IVxcblxcbkNoZWNrIHlvdXIgU3VwYWJhc2UgcHJvamVjdCdzIEFQSSBzZXR0aW5ncyB0byBmaW5kIHRoZXNlIHZhbHVlc1xcblxcbmh0dHBzOi8vc3VwYWJhc2UuY29tL2Rhc2hib2FyZC9wcm9qZWN0L18vc2V0dGluZ3MvYXBpYCk7XG4gICAgfVxuICAgIGNvbnN0IHsgc3RvcmFnZSwgZ2V0QWxsLCBzZXRBbGwsIHNldEl0ZW1zLCByZW1vdmVkSXRlbXMgfSA9ICgwLCBjb29raWVzXzEuY3JlYXRlU3RvcmFnZUZyb21PcHRpb25zKSh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGNvb2tpZUVuY29kaW5nOiBvcHRpb25zPy5jb29raWVFbmNvZGluZyA/PyBcImJhc2U2NHVybFwiLFxuICAgIH0sIHRydWUpO1xuICAgIGNvbnN0IGNsaWVudCA9ICgwLCBzdXBhYmFzZV9qc18xLmNyZWF0ZUNsaWVudCkoc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5LCB7XG4gICAgICAgIC8vIFRPRE86IHJlc29sdmUgdHlwZSBlcnJvclxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBnbG9iYWw6IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnM/Lmdsb2JhbCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5nbG9iYWw/LmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgXCJYLUNsaWVudC1JbmZvXCI6IGBzdXBhYmFzZS1zc3IvJHt2ZXJzaW9uXzEuVkVSU0lPTn0gY3JlYXRlU2VydmVyQ2xpZW50YCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICAgIC4uLihvcHRpb25zPy5jb29raWVPcHRpb25zPy5uYW1lXG4gICAgICAgICAgICAgICAgPyB7IHN0b3JhZ2VLZXk6IG9wdGlvbnMuY29va2llT3B0aW9ucy5uYW1lIH1cbiAgICAgICAgICAgICAgICA6IG51bGwpLFxuICAgICAgICAgICAgLi4ub3B0aW9ucz8uYXV0aCxcbiAgICAgICAgICAgIGZsb3dUeXBlOiBcInBrY2VcIixcbiAgICAgICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiBmYWxzZSxcbiAgICAgICAgICAgIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICAgICAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgICAgIC4uLihvcHRpb25zPy5jb29raWVzICYmXG4gICAgICAgICAgICAgICAgXCJlbmNvZGVcIiBpbiBvcHRpb25zLmNvb2tpZXMgJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvb2tpZXMuZW5jb2RlID09PSBcInRva2Vucy1vbmx5XCJcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgdXNlclN0b3JhZ2U6IG9wdGlvbnM/LmF1dGg/LnVzZXJTdG9yYWdlID8/ICgwLCBoZWxwZXJzXzEubWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlcikoKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBudWxsKSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjbGllbnQuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZShhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgLy8gVGhlIFNJR05FRF9JTiBldmVudCBpcyBmaXJlZCB2ZXJ5IG9mdGVuLCBidXQgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAvLyBhcHBseSB0aGUgc3RvcmFnZSBlYWNoIHRpbWUgaXQgZmlyZXMsIG9ubHkgaWYgdGhlcmUgYXJlIGNoYW5nZXNcbiAgICAgICAgLy8gdGhhdCBuZWVkIHRvIGJlIHNldCAtLSB3aGljaCBpcyBpZiBzZXRJdGVtcyAvIHJlbW92ZUl0ZW1zIGhhdmVcbiAgICAgICAgLy8gZGF0YS5cbiAgICAgICAgY29uc3QgaGFzU3RvcmFnZUNoYW5nZXMgPSBPYmplY3Qua2V5cyhzZXRJdGVtcykubGVuZ3RoID4gMCB8fCBPYmplY3Qua2V5cyhyZW1vdmVkSXRlbXMpLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmIChoYXNTdG9yYWdlQ2hhbmdlcyAmJlxuICAgICAgICAgICAgKGV2ZW50ID09PSBcIlNJR05FRF9JTlwiIHx8XG4gICAgICAgICAgICAgICAgZXZlbnQgPT09IFwiVE9LRU5fUkVGUkVTSEVEXCIgfHxcbiAgICAgICAgICAgICAgICBldmVudCA9PT0gXCJVU0VSX1VQREFURURcIiB8fFxuICAgICAgICAgICAgICAgIGV2ZW50ID09PSBcIlBBU1NXT1JEX1JFQ09WRVJZXCIgfHxcbiAgICAgICAgICAgICAgICBldmVudCA9PT0gXCJTSUdORURfT1VUXCIgfHxcbiAgICAgICAgICAgICAgICBldmVudCA9PT0gXCJNRkFfQ0hBTExFTkdFX1ZFUklGSUVEXCIpKSB7XG4gICAgICAgICAgICBhd2FpdCAoMCwgY29va2llc18xLmFwcGx5U2VydmVyU3RvcmFnZSkoeyBnZXRBbGwsIHNldEFsbCwgc2V0SXRlbXMsIHJlbW92ZWRJdGVtcyB9LCB7XG4gICAgICAgICAgICAgICAgY29va2llT3B0aW9uczogb3B0aW9ucz8uY29va2llT3B0aW9ucyA/PyBudWxsLFxuICAgICAgICAgICAgICAgIGNvb2tpZUVuY29kaW5nOiBvcHRpb25zPy5jb29raWVFbmNvZGluZyA/PyBcImJhc2U2NHVybFwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xpZW50O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlU2VydmVyQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZVNlcnZlckNsaWVudCIsInN1cGFiYXNlX2pzXzEiLCJyZXF1aXJlIiwidmVyc2lvbl8xIiwiY29va2llc18xIiwiaGVscGVyc18xIiwic3VwYWJhc2VVcmwiLCJzdXBhYmFzZUtleSIsIm9wdGlvbnMiLCJFcnJvciIsInN0b3JhZ2UiLCJnZXRBbGwiLCJzZXRBbGwiLCJzZXRJdGVtcyIsInJlbW92ZWRJdGVtcyIsImNyZWF0ZVN0b3JhZ2VGcm9tT3B0aW9ucyIsImNvb2tpZUVuY29kaW5nIiwiY2xpZW50IiwiY3JlYXRlQ2xpZW50IiwiZ2xvYmFsIiwiaGVhZGVycyIsIlZFUlNJT04iLCJhdXRoIiwiY29va2llT3B0aW9ucyIsIm5hbWUiLCJzdG9yYWdlS2V5IiwiZmxvd1R5cGUiLCJhdXRvUmVmcmVzaFRva2VuIiwiZGV0ZWN0U2Vzc2lvbkluVXJsIiwicGVyc2lzdFNlc3Npb24iLCJjb29raWVzIiwiZW5jb2RlIiwidXNlclN0b3JhZ2UiLCJtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyIiwib25BdXRoU3RhdGVDaGFuZ2UiLCJldmVudCIsImhhc1N0b3JhZ2VDaGFuZ2VzIiwia2V5cyIsImxlbmd0aCIsImFwcGx5U2VydmVyU3RvcmFnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/ssr/dist/main/createServerClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/ssr/dist/main/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/main/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n// Check if this package is being used as one of the deprecated auth-helpers packages\nif (typeof process !== \"undefined\" && process.env?.npm_package_name) {\n    const packageName = process.env.npm_package_name;\n    const deprecatedPackages = [\n        \"@supabase/auth-helpers-nextjs\",\n        \"@supabase/auth-helpers-react\",\n        \"@supabase/auth-helpers-remix\",\n        \"@supabase/auth-helpers-sveltekit\"\n    ];\n    if (deprecatedPackages.includes(packageName)) {\n        console.warn(`\n\n   IMPORTANT: Package Consolidation Notice                                \n                                                                            \n The ${packageName.padEnd(35)} package name is deprecated.  \n                                                                            \n You are now using @supabase/ssr - a unified solution for all frameworks.  \n                                                                            \n The auth-helpers packages have been consolidated into @supabase/ssr       \n to provide better maintenance and consistent APIs across frameworks.      \n                                                                            \n Please update your package.json to use @supabase/ssr directly:            \n   npm uninstall ${packageName.padEnd(42)} \n   npm install @supabase/ssr                                               \n                                                                            \n For more information, visit:                                              \n https://supabase.com/docs/guides/auth/server-side                         \n\n    `);\n    }\n}\n__exportStar(__webpack_require__(/*! ./createBrowserClient */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/createBrowserClient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./createServerClient */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/createServerClient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/utils/index.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QscUZBQXFGO0FBQ3JGLElBQUksT0FBT0MsWUFBWSxlQUFlQSxRQUFRQyxHQUFHLEVBQUVDLGtCQUFrQjtJQUNqRSxNQUFNQyxjQUFjSCxRQUFRQyxHQUFHLENBQUNDLGdCQUFnQjtJQUNoRCxNQUFNRSxxQkFBcUI7UUFDdkI7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELElBQUlBLG1CQUFtQkMsUUFBUSxDQUFDRixjQUFjO1FBQzFDRyxRQUFRQyxJQUFJLENBQUMsQ0FBQzs7OztNQUloQixFQUFFSixZQUFZSyxNQUFNLENBQUMsSUFBSTs7Ozs7Ozs7a0JBUWIsRUFBRUwsWUFBWUssTUFBTSxDQUFDLElBQUk7Ozs7OztJQU12QyxDQUFDO0lBQ0Q7QUFDSjtBQUNBZixhQUFhZ0IsbUJBQU9BLENBQUMsa0dBQXVCLEdBQUdmO0FBQy9DRCxhQUFhZ0IsbUJBQU9BLENBQUMsZ0dBQXNCLEdBQUdmO0FBQzlDRCxhQUFhZ0IsbUJBQU9BLENBQUMsc0VBQVMsR0FBR2Y7QUFDakNELGFBQWFnQixtQkFBT0EsQ0FBQyw0RUFBUyxHQUFHZixVQUNqQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vaW5kZXguanM/MWE5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gQ2hlY2sgaWYgdGhpcyBwYWNrYWdlIGlzIGJlaW5nIHVzZWQgYXMgb25lIG9mIHRoZSBkZXByZWNhdGVkIGF1dGgtaGVscGVycyBwYWNrYWdlc1xuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Py5ucG1fcGFja2FnZV9uYW1lKSB7XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSBwcm9jZXNzLmVudi5ucG1fcGFja2FnZV9uYW1lO1xuICAgIGNvbnN0IGRlcHJlY2F0ZWRQYWNrYWdlcyA9IFtcbiAgICAgICAgXCJAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqc1wiLFxuICAgICAgICBcIkBzdXBhYmFzZS9hdXRoLWhlbHBlcnMtcmVhY3RcIixcbiAgICAgICAgXCJAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLXJlbWl4XCIsXG4gICAgICAgIFwiQHN1cGFiYXNlL2F1dGgtaGVscGVycy1zdmVsdGVraXRcIixcbiAgICBdO1xuICAgIGlmIChkZXByZWNhdGVkUGFja2FnZXMuaW5jbHVkZXMocGFja2FnZU5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgXG7ilZTilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZdcbuKVkSDimqDvuI8gIElNUE9SVEFOVDogUGFja2FnZSBDb25zb2xpZGF0aW9uIE5vdGljZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pWRXG7ilZEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pWRXG7ilZEgVGhlICR7cGFja2FnZU5hbWUucGFkRW5kKDM1KX0gcGFja2FnZSBuYW1lIGlzIGRlcHJlY2F0ZWQuICDilZFcbuKVkSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilZFcbuKVkSBZb3UgYXJlIG5vdyB1c2luZyBAc3VwYWJhc2Uvc3NyIC0gYSB1bmlmaWVkIHNvbHV0aW9uIGZvciBhbGwgZnJhbWV3b3Jrcy4gIOKVkVxu4pWRICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKVkVxu4pWRIFRoZSBhdXRoLWhlbHBlcnMgcGFja2FnZXMgaGF2ZSBiZWVuIGNvbnNvbGlkYXRlZCBpbnRvIEBzdXBhYmFzZS9zc3IgICAgICAg4pWRXG7ilZEgdG8gcHJvdmlkZSBiZXR0ZXIgbWFpbnRlbmFuY2UgYW5kIGNvbnNpc3RlbnQgQVBJcyBhY3Jvc3MgZnJhbWV3b3Jrcy4gICAgICDilZFcbuKVkSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilZFcbuKVkSBQbGVhc2UgdXBkYXRlIHlvdXIgcGFja2FnZS5qc29uIHRvIHVzZSBAc3VwYWJhc2Uvc3NyIGRpcmVjdGx5OiAgICAgICAgICAgIOKVkVxu4pWRICAgbnBtIHVuaW5zdGFsbCAke3BhY2thZ2VOYW1lLnBhZEVuZCg0Mil9IOKVkVxu4pWRICAgbnBtIGluc3RhbGwgQHN1cGFiYXNlL3NzciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pWRXG7ilZEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pWRXG7ilZEgRm9yIG1vcmUgaW5mb3JtYXRpb24sIHZpc2l0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilZFcbuKVkSBodHRwczovL3N1cGFiYXNlLmNvbS9kb2NzL2d1aWRlcy9hdXRoL3NlcnZlci1zaWRlICAgICAgICAgICAgICAgICAgICAgICAgIOKVkVxu4pWa4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWdXG4gICAgYCk7XG4gICAgfVxufVxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NyZWF0ZUJyb3dzZXJDbGllbnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NyZWF0ZVNlcnZlckNsaWVudFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydFN0YXIiLCJleHBvcnRzIiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZhbHVlIiwicHJvY2VzcyIsImVudiIsIm5wbV9wYWNrYWdlX25hbWUiLCJwYWNrYWdlTmFtZSIsImRlcHJlY2F0ZWRQYWNrYWdlcyIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iLCJwYWRFbmQiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/ssr/dist/main/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/ssr/dist/main/types.js":
/*!*******************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/main/types.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUMsRUFDN0QsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zc3IvZGlzdC9tYWluL3R5cGVzLmpzPzRhYzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/ssr/dist/main/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/ssr/dist/main/utils/base64url.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/main/utils/base64url.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.stringToBase64URL = stringToBase64URL;\nexports.stringFromBase64URL = stringFromBase64URL;\nexports.codepointToUTF8 = codepointToUTF8;\nexports.stringToUTF8 = stringToUTF8;\nexports.stringFromUTF8 = stringFromUTF8;\n/**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */ const TO_BASE64URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".split(\"\");\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */ const IGNORE_BASE64URL = \" \t\\n\\r=\".split(\"\");\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */ const FROM_BASE64URL = (()=>{\n    const charMap = new Array(128);\n    for(let i = 0; i < charMap.length; i += 1){\n        charMap[i] = -1;\n    }\n    for(let i = 0; i < IGNORE_BASE64URL.length; i += 1){\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n    }\n    for(let i = 0; i < TO_BASE64URL.length; i += 1){\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n    }\n    return charMap;\n})();\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */ function stringToBase64URL(str) {\n    const base64 = [];\n    let queue = 0;\n    let queuedBits = 0;\n    const emitter = (byte)=>{\n        queue = queue << 8 | byte;\n        queuedBits += 8;\n        while(queuedBits >= 6){\n            const pos = queue >> queuedBits - 6 & 63;\n            base64.push(TO_BASE64URL[pos]);\n            queuedBits -= 6;\n        }\n    };\n    stringToUTF8(str, emitter);\n    if (queuedBits > 0) {\n        queue = queue << 6 - queuedBits;\n        queuedBits = 6;\n        while(queuedBits >= 6){\n            const pos = queue >> queuedBits - 6 & 63;\n            base64.push(TO_BASE64URL[pos]);\n            queuedBits -= 6;\n        }\n    }\n    return base64.join(\"\");\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */ function stringFromBase64URL(str) {\n    const conv = [];\n    const emit = (codepoint)=>{\n        conv.push(String.fromCodePoint(codepoint));\n    };\n    const state = {\n        utf8seq: 0,\n        codepoint: 0\n    };\n    let queue = 0;\n    let queuedBits = 0;\n    for(let i = 0; i < str.length; i += 1){\n        const codepoint = str.charCodeAt(i);\n        const bits = FROM_BASE64URL[codepoint];\n        if (bits > -1) {\n            // valid Base64-URL character\n            queue = queue << 6 | bits;\n            queuedBits += 6;\n            while(queuedBits >= 8){\n                stringFromUTF8(queue >> queuedBits - 8 & 0xff, state, emit);\n                queuedBits -= 8;\n            }\n        } else if (bits === -2) {\n            continue;\n        } else {\n            throw new Error(`Invalid Base64-URL character \"${str.at(i)}\" at position ${i}`);\n        }\n    }\n    return conv.join(\"\");\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */ function codepointToUTF8(codepoint, emit) {\n    if (codepoint <= 0x7f) {\n        emit(codepoint);\n        return;\n    } else if (codepoint <= 0x7ff) {\n        emit(0xc0 | codepoint >> 6);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0xffff) {\n        emit(0xe0 | codepoint >> 12);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0x10ffff) {\n        emit(0xf0 | codepoint >> 18);\n        emit(0x80 | codepoint >> 12 & 0x3f);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    }\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */ function stringToUTF8(str, emit) {\n    for(let i = 0; i < str.length; i += 1){\n        let codepoint = str.charCodeAt(i);\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\n            // range where the next UTF-16 codepoint needs to be combined with the\n            // current one to get the Unicode codepoint\n            const highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;\n            const lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n            i += 1;\n        }\n        codepointToUTF8(codepoint, emit);\n    }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */ function stringFromUTF8(byte, state, emit) {\n    if (state.utf8seq === 0) {\n        if (byte <= 0x7f) {\n            emit(byte);\n            return;\n        }\n        // count the number of 1 leading bits until you reach 0\n        for(let leadingBit = 1; leadingBit < 6; leadingBit += 1){\n            if ((byte >> 7 - leadingBit & 1) === 0) {\n                state.utf8seq = leadingBit;\n                break;\n            }\n        }\n        if (state.utf8seq === 2) {\n            state.codepoint = byte & 31;\n        } else if (state.utf8seq === 3) {\n            state.codepoint = byte & 15;\n        } else if (state.utf8seq === 4) {\n            state.codepoint = byte & 7;\n        } else {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.utf8seq -= 1;\n    } else if (state.utf8seq > 0) {\n        if (byte <= 0x7f) {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.codepoint = state.codepoint << 6 | byte & 63;\n        state.utf8seq -= 1;\n        if (state.utf8seq === 0) {\n            emit(state.codepoint);\n        }\n    }\n} //# sourceMappingURL=base64url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vdXRpbHMvYmFzZTY0dXJsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Q0FJQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUdFO0FBQzVCRiwyQkFBMkIsR0FBR0c7QUFDOUJILHVCQUF1QixHQUFHSTtBQUMxQkosb0JBQW9CLEdBQUdLO0FBQ3ZCTCxzQkFBc0IsR0FBR007QUFDekI7OztDQUdDLEdBQ0QsTUFBTUMsZUFBZSxtRUFBbUVDLEtBQUssQ0FBQztBQUM5Rjs7O0NBR0MsR0FDRCxNQUFNQyxtQkFBbUIsVUFBV0QsS0FBSyxDQUFDO0FBQzFDOzs7Q0FHQyxHQUNELE1BQU1FLGlCQUFpQixDQUFDO0lBQ3BCLE1BQU1DLFVBQVUsSUFBSUMsTUFBTTtJQUMxQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsUUFBUUcsTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDeENGLE9BQU8sQ0FBQ0UsRUFBRSxHQUFHLENBQUM7SUFDbEI7SUFDQSxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSUosaUJBQWlCSyxNQUFNLEVBQUVELEtBQUssRUFBRztRQUNqREYsT0FBTyxDQUFDRixnQkFBZ0IsQ0FBQ0ksRUFBRSxDQUFDRSxVQUFVLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDbEQ7SUFDQSxJQUFLLElBQUlGLElBQUksR0FBR0EsSUFBSU4sYUFBYU8sTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDN0NGLE9BQU8sQ0FBQ0osWUFBWSxDQUFDTSxFQUFFLENBQUNFLFVBQVUsQ0FBQyxHQUFHLEdBQUdGO0lBQzdDO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVNULGtCQUFrQmMsR0FBRztJQUMxQixNQUFNQyxTQUFTLEVBQUU7SUFDakIsSUFBSUMsUUFBUTtJQUNaLElBQUlDLGFBQWE7SUFDakIsTUFBTUMsVUFBVSxDQUFDQztRQUNiSCxRQUFRLFNBQVUsSUFBS0c7UUFDdkJGLGNBQWM7UUFDZCxNQUFPQSxjQUFjLEVBQUc7WUFDcEIsTUFBTUcsTUFBTSxTQUFXSCxhQUFhLElBQU07WUFDMUNGLE9BQU9NLElBQUksQ0FBQ2hCLFlBQVksQ0FBQ2UsSUFBSTtZQUM3QkgsY0FBYztRQUNsQjtJQUNKO0lBQ0FkLGFBQWFXLEtBQUtJO0lBQ2xCLElBQUlELGFBQWEsR0FBRztRQUNoQkQsUUFBUUEsU0FBVSxJQUFJQztRQUN0QkEsYUFBYTtRQUNiLE1BQU9BLGNBQWMsRUFBRztZQUNwQixNQUFNRyxNQUFNLFNBQVdILGFBQWEsSUFBTTtZQUMxQ0YsT0FBT00sSUFBSSxDQUFDaEIsWUFBWSxDQUFDZSxJQUFJO1lBQzdCSCxjQUFjO1FBQ2xCO0lBQ0o7SUFDQSxPQUFPRixPQUFPTyxJQUFJLENBQUM7QUFDdkI7QUFDQTs7Ozs7Q0FLQyxHQUNELFNBQVNyQixvQkFBb0JhLEdBQUc7SUFDNUIsTUFBTVMsT0FBTyxFQUFFO0lBQ2YsTUFBTUMsT0FBTyxDQUFDQztRQUNWRixLQUFLRixJQUFJLENBQUNLLE9BQU9DLGFBQWEsQ0FBQ0Y7SUFDbkM7SUFDQSxNQUFNRyxRQUFRO1FBQ1ZDLFNBQVM7UUFDVEosV0FBVztJQUNmO0lBQ0EsSUFBSVQsUUFBUTtJQUNaLElBQUlDLGFBQWE7SUFDakIsSUFBSyxJQUFJTixJQUFJLEdBQUdBLElBQUlHLElBQUlGLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3BDLE1BQU1jLFlBQVlYLElBQUlELFVBQVUsQ0FBQ0Y7UUFDakMsTUFBTW1CLE9BQU90QixjQUFjLENBQUNpQixVQUFVO1FBQ3RDLElBQUlLLE9BQU8sQ0FBQyxHQUFHO1lBQ1gsNkJBQTZCO1lBQzdCZCxRQUFRLFNBQVUsSUFBS2M7WUFDdkJiLGNBQWM7WUFDZCxNQUFPQSxjQUFjLEVBQUc7Z0JBQ3BCYixlQUFlLFNBQVdhLGFBQWEsSUFBTSxNQUFNVyxPQUFPSjtnQkFDMURQLGNBQWM7WUFDbEI7UUFDSixPQUNLLElBQUlhLFNBQVMsQ0FBQyxHQUFHO1lBRWxCO1FBQ0osT0FDSztZQUNELE1BQU0sSUFBSUMsTUFBTSxDQUFDLDhCQUE4QixFQUFFakIsSUFBSWtCLEVBQUUsQ0FBQ3JCLEdBQUcsY0FBYyxFQUFFQSxFQUFFLENBQUM7UUFDbEY7SUFDSjtJQUNBLE9BQU9ZLEtBQUtELElBQUksQ0FBQztBQUNyQjtBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU3BCLGdCQUFnQnVCLFNBQVMsRUFBRUQsSUFBSTtJQUNwQyxJQUFJQyxhQUFhLE1BQU07UUFDbkJELEtBQUtDO1FBQ0w7SUFDSixPQUNLLElBQUlBLGFBQWEsT0FBTztRQUN6QkQsS0FBSyxPQUFRQyxhQUFhO1FBQzFCRCxLQUFLLE9BQVFDLFlBQVk7UUFDekI7SUFDSixPQUNLLElBQUlBLGFBQWEsUUFBUTtRQUMxQkQsS0FBSyxPQUFRQyxhQUFhO1FBQzFCRCxLQUFLLE9BQVEsYUFBYyxJQUFLO1FBQ2hDQSxLQUFLLE9BQVFDLFlBQVk7UUFDekI7SUFDSixPQUNLLElBQUlBLGFBQWEsVUFBVTtRQUM1QkQsS0FBSyxPQUFRQyxhQUFhO1FBQzFCRCxLQUFLLE9BQVEsYUFBYyxLQUFNO1FBQ2pDQSxLQUFLLE9BQVEsYUFBYyxJQUFLO1FBQ2hDQSxLQUFLLE9BQVFDLFlBQVk7UUFDekI7SUFDSjtJQUNBLE1BQU0sSUFBSU0sTUFBTSxDQUFDLGdDQUFnQyxFQUFFTixVQUFVUSxRQUFRLENBQUMsSUFBSSxDQUFDO0FBQy9FO0FBQ0E7Ozs7O0NBS0MsR0FDRCxTQUFTOUIsYUFBYVcsR0FBRyxFQUFFVSxJQUFJO0lBQzNCLElBQUssSUFBSWIsSUFBSSxHQUFHQSxJQUFJRyxJQUFJRixNQUFNLEVBQUVELEtBQUssRUFBRztRQUNwQyxJQUFJYyxZQUFZWCxJQUFJRCxVQUFVLENBQUNGO1FBQy9CLElBQUljLFlBQVksVUFBVUEsYUFBYSxRQUFRO1lBQzNDLHVFQUF1RTtZQUN2RSxzRUFBc0U7WUFDdEUsMkNBQTJDO1lBQzNDLE1BQU1TLGdCQUFnQixDQUFFVCxZQUFZLE1BQUssSUFBSyxRQUFTO1lBQ3ZELE1BQU1VLGVBQWUsSUFBS3RCLFVBQVUsQ0FBQ0YsSUFBSSxLQUFLLFNBQVU7WUFDeERjLFlBQVksQ0FBQ1UsZUFBZUQsYUFBWSxJQUFLO1lBQzdDdkIsS0FBSztRQUNUO1FBQ0FULGdCQUFnQnVCLFdBQVdEO0lBQy9CO0FBQ0o7QUFDQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU3BCLGVBQWVlLElBQUksRUFBRVMsS0FBSyxFQUFFSixJQUFJO0lBQ3JDLElBQUlJLE1BQU1DLE9BQU8sS0FBSyxHQUFHO1FBQ3JCLElBQUlWLFFBQVEsTUFBTTtZQUNkSyxLQUFLTDtZQUNMO1FBQ0o7UUFDQSx1REFBdUQ7UUFDdkQsSUFBSyxJQUFJaUIsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGNBQWMsRUFBRztZQUN0RCxJQUFJLENBQUMsUUFBVSxJQUFJQSxhQUFlLE9BQU8sR0FBRztnQkFDeENSLE1BQU1DLE9BQU8sR0FBR087Z0JBQ2hCO1lBQ0o7UUFDSjtRQUNBLElBQUlSLE1BQU1DLE9BQU8sS0FBSyxHQUFHO1lBQ3JCRCxNQUFNSCxTQUFTLEdBQUdOLE9BQU87UUFDN0IsT0FDSyxJQUFJUyxNQUFNQyxPQUFPLEtBQUssR0FBRztZQUMxQkQsTUFBTUgsU0FBUyxHQUFHTixPQUFPO1FBQzdCLE9BQ0ssSUFBSVMsTUFBTUMsT0FBTyxLQUFLLEdBQUc7WUFDMUJELE1BQU1ILFNBQVMsR0FBR04sT0FBTztRQUM3QixPQUNLO1lBQ0QsTUFBTSxJQUFJWSxNQUFNO1FBQ3BCO1FBQ0FILE1BQU1DLE9BQU8sSUFBSTtJQUNyQixPQUNLLElBQUlELE1BQU1DLE9BQU8sR0FBRyxHQUFHO1FBQ3hCLElBQUlWLFFBQVEsTUFBTTtZQUNkLE1BQU0sSUFBSVksTUFBTTtRQUNwQjtRQUNBSCxNQUFNSCxTQUFTLEdBQUcsTUFBT0EsU0FBUyxJQUFJLElBQU1OLE9BQU87UUFDbkRTLE1BQU1DLE9BQU8sSUFBSTtRQUNqQixJQUFJRCxNQUFNQyxPQUFPLEtBQUssR0FBRztZQUNyQkwsS0FBS0ksTUFBTUgsU0FBUztRQUN4QjtJQUNKO0FBQ0osRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vdXRpbHMvYmFzZTY0dXJsLmpzPzJkNDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEF2b2lkIG1vZGlmeWluZyB0aGlzIGZpbGUuIEl0J3MgcGFydCBvZlxuICogaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlLWNvbW11bml0eS9iYXNlNjR1cmwtanMuICBTdWJtaXQgYWxsIGZpeGVzIG9uXG4gKiB0aGF0IHJlcG8hXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RyaW5nVG9CYXNlNjRVUkwgPSBzdHJpbmdUb0Jhc2U2NFVSTDtcbmV4cG9ydHMuc3RyaW5nRnJvbUJhc2U2NFVSTCA9IHN0cmluZ0Zyb21CYXNlNjRVUkw7XG5leHBvcnRzLmNvZGVwb2ludFRvVVRGOCA9IGNvZGVwb2ludFRvVVRGODtcbmV4cG9ydHMuc3RyaW5nVG9VVEY4ID0gc3RyaW5nVG9VVEY4O1xuZXhwb3J0cy5zdHJpbmdGcm9tVVRGOCA9IHN0cmluZ0Zyb21VVEY4O1xuLyoqXG4gKiBBbiBhcnJheSBvZiBjaGFyYWN0ZXJzIHRoYXQgZW5jb2RlIDYgYml0cyBpbnRvIGEgQmFzZTY0LVVSTCBhbHBoYWJldFxuICogY2hhcmFjdGVyLlxuICovXG5jb25zdCBUT19CQVNFNjRVUkwgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV9cIi5zcGxpdChcIlwiKTtcbi8qKlxuICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGNhbiBhcHBlYXIgaW4gYSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nIGJ1dFxuICogc2hvdWxkIGJlIGlnbm9yZWQuXG4gKi9cbmNvbnN0IElHTk9SRV9CQVNFNjRVUkwgPSBcIiBcXHRcXG5cXHI9XCIuc3BsaXQoXCJcIik7XG4vKipcbiAqIEFuIGFycmF5IG9mIDEyOCBudW1iZXJzIHRoYXQgbWFwIGEgQmFzZTY0LVVSTCBjaGFyYWN0ZXIgdG8gNiBiaXRzLCBvciBpZiAtMlxuICogdXNlZCB0byBza2lwIHRoZSBjaGFyYWN0ZXIsIG9yIGlmIC0xIHVzZWQgdG8gZXJyb3Igb3V0LlxuICovXG5jb25zdCBGUk9NX0JBU0U2NFVSTCA9ICgoKSA9PiB7XG4gICAgY29uc3QgY2hhck1hcCA9IG5ldyBBcnJheSgxMjgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhck1hcC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjaGFyTWFwW2ldID0gLTE7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSUdOT1JFX0JBU0U2NFVSTC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjaGFyTWFwW0lHTk9SRV9CQVNFNjRVUkxbaV0uY2hhckNvZGVBdCgwKV0gPSAtMjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUT19CQVNFNjRVUkwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY2hhck1hcFtUT19CQVNFNjRVUkxbaV0uY2hhckNvZGVBdCgwKV0gPSBpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhck1hcDtcbn0pKCk7XG4vKipcbiAqIENvbnZlcnRzIGEgSmF2YVNjcmlwdCBzdHJpbmcgKHdoaWNoIG1heSBpbmNsdWRlIGFueSB2YWxpZCBjaGFyYWN0ZXIpIGludG8gYVxuICogQmFzZTY0LVVSTCBlbmNvZGVkIHN0cmluZy4gVGhlIHN0cmluZyBpcyBmaXJzdCBlbmNvZGVkIGluIFVURi04IHdoaWNoIGlzXG4gKiB0aGVuIGVuY29kZWQgYXMgQmFzZTY0LVVSTC5cbiAqXG4gKiBAcGFyYW0gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9CYXNlNjRVUkwoc3RyKSB7XG4gICAgY29uc3QgYmFzZTY0ID0gW107XG4gICAgbGV0IHF1ZXVlID0gMDtcbiAgICBsZXQgcXVldWVkQml0cyA9IDA7XG4gICAgY29uc3QgZW1pdHRlciA9IChieXRlKSA9PiB7XG4gICAgICAgIHF1ZXVlID0gKHF1ZXVlIDw8IDgpIHwgYnl0ZTtcbiAgICAgICAgcXVldWVkQml0cyArPSA4O1xuICAgICAgICB3aGlsZSAocXVldWVkQml0cyA+PSA2KSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSAocXVldWUgPj4gKHF1ZXVlZEJpdHMgLSA2KSkgJiA2MztcbiAgICAgICAgICAgIGJhc2U2NC5wdXNoKFRPX0JBU0U2NFVSTFtwb3NdKTtcbiAgICAgICAgICAgIHF1ZXVlZEJpdHMgLT0gNjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc3RyaW5nVG9VVEY4KHN0ciwgZW1pdHRlcik7XG4gICAgaWYgKHF1ZXVlZEJpdHMgPiAwKSB7XG4gICAgICAgIHF1ZXVlID0gcXVldWUgPDwgKDYgLSBxdWV1ZWRCaXRzKTtcbiAgICAgICAgcXVldWVkQml0cyA9IDY7XG4gICAgICAgIHdoaWxlIChxdWV1ZWRCaXRzID49IDYpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IChxdWV1ZSA+PiAocXVldWVkQml0cyAtIDYpKSAmIDYzO1xuICAgICAgICAgICAgYmFzZTY0LnB1c2goVE9fQkFTRTY0VVJMW3Bvc10pO1xuICAgICAgICAgICAgcXVldWVkQml0cyAtPSA2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYXNlNjQuam9pbihcIlwiKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IHN0cmluZy4gSXQgaXMgYXNzdW1lZFxuICogdGhhdCB0aGUgdW5kZXJseWluZyBzdHJpbmcgaGFzIGJlZW4gZW5jb2RlZCBhcyBVVEYtOC5cbiAqXG4gKiBAcGFyYW0gc3RyIFRoZSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHJpbmdGcm9tQmFzZTY0VVJMKHN0cikge1xuICAgIGNvbnN0IGNvbnYgPSBbXTtcbiAgICBjb25zdCBlbWl0ID0gKGNvZGVwb2ludCkgPT4ge1xuICAgICAgICBjb252LnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZXBvaW50KSk7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgdXRmOHNlcTogMCxcbiAgICAgICAgY29kZXBvaW50OiAwLFxuICAgIH07XG4gICAgbGV0IHF1ZXVlID0gMDtcbiAgICBsZXQgcXVldWVkQml0cyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY29kZXBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBGUk9NX0JBU0U2NFVSTFtjb2RlcG9pbnRdO1xuICAgICAgICBpZiAoYml0cyA+IC0xKSB7XG4gICAgICAgICAgICAvLyB2YWxpZCBCYXNlNjQtVVJMIGNoYXJhY3RlclxuICAgICAgICAgICAgcXVldWUgPSAocXVldWUgPDwgNikgfCBiaXRzO1xuICAgICAgICAgICAgcXVldWVkQml0cyArPSA2O1xuICAgICAgICAgICAgd2hpbGUgKHF1ZXVlZEJpdHMgPj0gOCkge1xuICAgICAgICAgICAgICAgIHN0cmluZ0Zyb21VVEY4KChxdWV1ZSA+PiAocXVldWVkQml0cyAtIDgpKSAmIDB4ZmYsIHN0YXRlLCBlbWl0KTtcbiAgICAgICAgICAgICAgICBxdWV1ZWRCaXRzIC09IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYml0cyA9PT0gLTIpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBzcGFjZXMsIHRhYnMsIG5ld2xpbmVzLCA9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBCYXNlNjQtVVJMIGNoYXJhY3RlciBcIiR7c3RyLmF0KGkpfVwiIGF0IHBvc2l0aW9uICR7aX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udi5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgY29kZXBvaW50IHRvIGEgbXVsdGktYnl0ZSBVVEYtOCBzZXF1ZW5jZS5cbiAqXG4gKiBAcGFyYW0gY29kZXBvaW50IFRoZSBVbmljb2RlIGNvZGVwb2ludC5cbiAqIEBwYXJhbSBlbWl0ICAgICAgRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggVVRGLTggYnl0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvZGVwb2ludC5cbiAqL1xuZnVuY3Rpb24gY29kZXBvaW50VG9VVEY4KGNvZGVwb2ludCwgZW1pdCkge1xuICAgIGlmIChjb2RlcG9pbnQgPD0gMHg3Zikge1xuICAgICAgICBlbWl0KGNvZGVwb2ludCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZXBvaW50IDw9IDB4N2ZmKSB7XG4gICAgICAgIGVtaXQoMHhjMCB8IChjb2RlcG9pbnQgPj4gNikpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoY29kZXBvaW50ICYgMHgzZikpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVwb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgZW1pdCgweGUwIHwgKGNvZGVwb2ludCA+PiAxMikpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoKGNvZGVwb2ludCA+PiA2KSAmIDB4M2YpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKGNvZGVwb2ludCAmIDB4M2YpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlcG9pbnQgPD0gMHgxMGZmZmYpIHtcbiAgICAgICAgZW1pdCgweGYwIHwgKGNvZGVwb2ludCA+PiAxOCkpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoKGNvZGVwb2ludCA+PiAxMikgJiAweDNmKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8ICgoY29kZXBvaW50ID4+IDYpICYgMHgzZikpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoY29kZXBvaW50ICYgMHgzZikpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIFVuaWNvZGUgY29kZXBvaW50OiAke2NvZGVwb2ludC50b1N0cmluZygxNil9YCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgSmF2YVNjcmlwdCBzdHJpbmcgdG8gYSBzZXF1ZW5jZSBvZiBVVEYtOCBieXRlcy5cbiAqXG4gKiBAcGFyYW0gc3RyICBUaGUgc3RyaW5nIHRvIGNvbnZlcnQgdG8gVVRGLTguXG4gKiBAcGFyYW0gZW1pdCBGdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBVVEYtOCBieXRlIG9mIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsIGVtaXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgY29kZXBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlcG9pbnQgPiAweGQ3ZmYgJiYgY29kZXBvaW50IDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgLy8gbW9zdCBVVEYtMTYgY29kZXBvaW50cyBhcmUgVW5pY29kZSBjb2RlcG9pbnRzLCBleGNlcHQgdmFsdWVzIGluIHRoaXNcbiAgICAgICAgICAgIC8vIHJhbmdlIHdoZXJlIHRoZSBuZXh0IFVURi0xNiBjb2RlcG9pbnQgbmVlZHMgdG8gYmUgY29tYmluZWQgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgb25lIHRvIGdldCB0aGUgVW5pY29kZSBjb2RlcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hTdXJyb2dhdGUgPSAoKGNvZGVwb2ludCAtIDB4ZDgwMCkgKiAweDQwMCkgJiAweGZmZmY7XG4gICAgICAgICAgICBjb25zdCBsb3dTdXJyb2dhdGUgPSAoc3RyLmNoYXJDb2RlQXQoaSArIDEpIC0gMHhkYzAwKSAmIDB4ZmZmZjtcbiAgICAgICAgICAgIGNvZGVwb2ludCA9IChsb3dTdXJyb2dhdGUgfCBoaWdoU3Vycm9nYXRlKSArIDB4MTAwMDA7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29kZXBvaW50VG9VVEY4KGNvZGVwb2ludCwgZW1pdCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVURi04IGJ5dGUgdG8gYSBVbmljb2RlIGNvZGVwb2ludC5cbiAqXG4gKiBAcGFyYW0gYnl0ZSAgVGhlIFVURi04IGJ5dGUgbmV4dCBpbiB0aGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0gc3RhdGUgVGhlIHNoYXJlZCBzdGF0ZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIFVURi04IGJ5dGVzIGluIHRoZVxuICogICAgICAgICAgICAgIHNlcXVlbmNlLCBhbiBvYmplY3Qgd2l0aCB0aGUgc2hhcGUgYHsgdXRmOHNlcTogMCwgY29kZXBvaW50OiAwIH1gLlxuICogQHBhcmFtIGVtaXQgIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGNvZGVwb2ludC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nRnJvbVVURjgoYnl0ZSwgc3RhdGUsIGVtaXQpIHtcbiAgICBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMCkge1xuICAgICAgICBpZiAoYnl0ZSA8PSAweDdmKSB7XG4gICAgICAgICAgICBlbWl0KGJ5dGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgMSBsZWFkaW5nIGJpdHMgdW50aWwgeW91IHJlYWNoIDBcbiAgICAgICAgZm9yIChsZXQgbGVhZGluZ0JpdCA9IDE7IGxlYWRpbmdCaXQgPCA2OyBsZWFkaW5nQml0ICs9IDEpIHtcbiAgICAgICAgICAgIGlmICgoKGJ5dGUgPj4gKDcgLSBsZWFkaW5nQml0KSkgJiAxKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnV0ZjhzZXEgPSBsZWFkaW5nQml0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS51dGY4c2VxID09PSAyKSB7XG4gICAgICAgICAgICBzdGF0ZS5jb2RlcG9pbnQgPSBieXRlICYgMzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMykge1xuICAgICAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gYnl0ZSAmIDE1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDQpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvZGVwb2ludCA9IGJ5dGUgJiA3O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBVVEYtOCBzZXF1ZW5jZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS51dGY4c2VxIC09IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlLnV0ZjhzZXEgPiAwKSB7XG4gICAgICAgIGlmIChieXRlIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgVVRGLTggc2VxdWVuY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gKHN0YXRlLmNvZGVwb2ludCA8PCA2KSB8IChieXRlICYgNjMpO1xuICAgICAgICBzdGF0ZS51dGY4c2VxIC09IDE7XG4gICAgICAgIGlmIChzdGF0ZS51dGY4c2VxID09PSAwKSB7XG4gICAgICAgICAgICBlbWl0KHN0YXRlLmNvZGVwb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjR1cmwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic3RyaW5nVG9CYXNlNjRVUkwiLCJzdHJpbmdGcm9tQmFzZTY0VVJMIiwiY29kZXBvaW50VG9VVEY4Iiwic3RyaW5nVG9VVEY4Iiwic3RyaW5nRnJvbVVURjgiLCJUT19CQVNFNjRVUkwiLCJzcGxpdCIsIklHTk9SRV9CQVNFNjRVUkwiLCJGUk9NX0JBU0U2NFVSTCIsImNoYXJNYXAiLCJBcnJheSIsImkiLCJsZW5ndGgiLCJjaGFyQ29kZUF0Iiwic3RyIiwiYmFzZTY0IiwicXVldWUiLCJxdWV1ZWRCaXRzIiwiZW1pdHRlciIsImJ5dGUiLCJwb3MiLCJwdXNoIiwiam9pbiIsImNvbnYiLCJlbWl0IiwiY29kZXBvaW50IiwiU3RyaW5nIiwiZnJvbUNvZGVQb2ludCIsInN0YXRlIiwidXRmOHNlcSIsImJpdHMiLCJFcnJvciIsImF0IiwidG9TdHJpbmciLCJoaWdoU3Vycm9nYXRlIiwibG93U3Vycm9nYXRlIiwibGVhZGluZ0JpdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/ssr/dist/main/utils/base64url.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/ssr/dist/main/utils/chunker.js":
/*!***************************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/main/utils/chunker.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MAX_CHUNK_SIZE = void 0;\nexports.isChunkLike = isChunkLike;\nexports.createChunks = createChunks;\nexports.combineChunks = combineChunks;\nexports.deleteChunks = deleteChunks;\nexports.MAX_CHUNK_SIZE = 3180;\nconst CHUNK_LIKE_REGEX = /^(.*)[.](0|[1-9][0-9]*)$/;\nfunction isChunkLike(cookieName, key) {\n    if (cookieName === key) {\n        return true;\n    }\n    const chunkLike = cookieName.match(CHUNK_LIKE_REGEX);\n    if (chunkLike && chunkLike[1] === key) {\n        return true;\n    }\n    return false;\n}\n/**\n * create chunks from a string and return an array of object\n */ function createChunks(key, value, chunkSize) {\n    const resolvedChunkSize = chunkSize ?? exports.MAX_CHUNK_SIZE;\n    let encodedValue = encodeURIComponent(value);\n    if (encodedValue.length <= resolvedChunkSize) {\n        return [\n            {\n                name: key,\n                value\n            }\n        ];\n    }\n    const chunks = [];\n    while(encodedValue.length > 0){\n        let encodedChunkHead = encodedValue.slice(0, resolvedChunkSize);\n        const lastEscapePos = encodedChunkHead.lastIndexOf(\"%\");\n        // Check if the last escaped character is truncated.\n        if (lastEscapePos > resolvedChunkSize - 3) {\n            // If so, reslice the string to exclude the whole escape sequence.\n            // We only reduce the size of the string as the chunk must\n            // be smaller than the chunk size.\n            encodedChunkHead = encodedChunkHead.slice(0, lastEscapePos);\n        }\n        let valueHead = \"\";\n        // Check if the chunk was split along a valid unicode boundary.\n        while(encodedChunkHead.length > 0){\n            try {\n                // Try to decode the chunk back and see if it is valid.\n                // Stop when the chunk is valid.\n                valueHead = decodeURIComponent(encodedChunkHead);\n                break;\n            } catch (error) {\n                if (error instanceof URIError && encodedChunkHead.at(-3) === \"%\" && encodedChunkHead.length > 3) {\n                    encodedChunkHead = encodedChunkHead.slice(0, encodedChunkHead.length - 3);\n                } else {\n                    throw error;\n                }\n            }\n        }\n        chunks.push(valueHead);\n        encodedValue = encodedValue.slice(encodedChunkHead.length);\n    }\n    return chunks.map((value, i)=>({\n            name: `${key}.${i}`,\n            value\n        }));\n}\n// Get fully constructed chunks\nasync function combineChunks(key, retrieveChunk) {\n    const value = await retrieveChunk(key);\n    if (value) {\n        return value;\n    }\n    let values = [];\n    for(let i = 0;; i++){\n        const chunkName = `${key}.${i}`;\n        const chunk = await retrieveChunk(chunkName);\n        if (!chunk) {\n            break;\n        }\n        values.push(chunk);\n    }\n    if (values.length > 0) {\n        return values.join(\"\");\n    }\n    return null;\n}\nasync function deleteChunks(key, retrieveChunk, removeChunk) {\n    const value = await retrieveChunk(key);\n    if (value) {\n        await removeChunk(key);\n    }\n    for(let i = 0;; i++){\n        const chunkName = `${key}.${i}`;\n        const chunk = await retrieveChunk(chunkName);\n        if (!chunk) {\n            break;\n        }\n        await removeChunk(chunkName);\n    }\n} //# sourceMappingURL=chunker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vdXRpbHMvY2h1bmtlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUcsS0FBSztBQUM5QkEsbUJBQW1CLEdBQUdHO0FBQ3RCSCxvQkFBb0IsR0FBR0k7QUFDdkJKLHFCQUFxQixHQUFHSztBQUN4Qkwsb0JBQW9CLEdBQUdNO0FBQ3ZCTixzQkFBc0IsR0FBRztBQUN6QixNQUFNTyxtQkFBbUI7QUFDekIsU0FBU0osWUFBWUssVUFBVSxFQUFFQyxHQUFHO0lBQ2hDLElBQUlELGVBQWVDLEtBQUs7UUFDcEIsT0FBTztJQUNYO0lBQ0EsTUFBTUMsWUFBWUYsV0FBV0csS0FBSyxDQUFDSjtJQUNuQyxJQUFJRyxhQUFhQSxTQUFTLENBQUMsRUFBRSxLQUFLRCxLQUFLO1FBQ25DLE9BQU87SUFDWDtJQUNBLE9BQU87QUFDWDtBQUNBOztDQUVDLEdBQ0QsU0FBU0wsYUFBYUssR0FBRyxFQUFFUixLQUFLLEVBQUVXLFNBQVM7SUFDdkMsTUFBTUMsb0JBQW9CRCxhQUFhWixRQUFRRSxjQUFjO0lBQzdELElBQUlZLGVBQWVDLG1CQUFtQmQ7SUFDdEMsSUFBSWEsYUFBYUUsTUFBTSxJQUFJSCxtQkFBbUI7UUFDMUMsT0FBTztZQUFDO2dCQUFFSSxNQUFNUjtnQkFBS1I7WUFBTTtTQUFFO0lBQ2pDO0lBQ0EsTUFBTWlCLFNBQVMsRUFBRTtJQUNqQixNQUFPSixhQUFhRSxNQUFNLEdBQUcsRUFBRztRQUM1QixJQUFJRyxtQkFBbUJMLGFBQWFNLEtBQUssQ0FBQyxHQUFHUDtRQUM3QyxNQUFNUSxnQkFBZ0JGLGlCQUFpQkcsV0FBVyxDQUFDO1FBQ25ELG9EQUFvRDtRQUNwRCxJQUFJRCxnQkFBZ0JSLG9CQUFvQixHQUFHO1lBQ3ZDLGtFQUFrRTtZQUNsRSwwREFBMEQ7WUFDMUQsa0NBQWtDO1lBQ2xDTSxtQkFBbUJBLGlCQUFpQkMsS0FBSyxDQUFDLEdBQUdDO1FBQ2pEO1FBQ0EsSUFBSUUsWUFBWTtRQUNoQiwrREFBK0Q7UUFDL0QsTUFBT0osaUJBQWlCSCxNQUFNLEdBQUcsRUFBRztZQUNoQyxJQUFJO2dCQUNBLHVEQUF1RDtnQkFDdkQsZ0NBQWdDO2dCQUNoQ08sWUFBWUMsbUJBQW1CTDtnQkFDL0I7WUFDSixFQUNBLE9BQU9NLE9BQU87Z0JBQ1YsSUFBSUEsaUJBQWlCQyxZQUNqQlAsaUJBQWlCUSxFQUFFLENBQUMsQ0FBQyxPQUFPLE9BQzVCUixpQkFBaUJILE1BQU0sR0FBRyxHQUFHO29CQUM3QkcsbUJBQW1CQSxpQkFBaUJDLEtBQUssQ0FBQyxHQUFHRCxpQkFBaUJILE1BQU0sR0FBRztnQkFDM0UsT0FDSztvQkFDRCxNQUFNUztnQkFDVjtZQUNKO1FBQ0o7UUFDQVAsT0FBT1UsSUFBSSxDQUFDTDtRQUNaVCxlQUFlQSxhQUFhTSxLQUFLLENBQUNELGlCQUFpQkgsTUFBTTtJQUM3RDtJQUNBLE9BQU9FLE9BQU9XLEdBQUcsQ0FBQyxDQUFDNUIsT0FBTzZCLElBQU87WUFBRWIsTUFBTSxDQUFDLEVBQUVSLElBQUksQ0FBQyxFQUFFcUIsRUFBRSxDQUFDO1lBQUU3QjtRQUFNO0FBQ2xFO0FBQ0EsK0JBQStCO0FBQy9CLGVBQWVJLGNBQWNJLEdBQUcsRUFBRXNCLGFBQWE7SUFDM0MsTUFBTTlCLFFBQVEsTUFBTThCLGNBQWN0QjtJQUNsQyxJQUFJUixPQUFPO1FBQ1AsT0FBT0E7SUFDWDtJQUNBLElBQUkrQixTQUFTLEVBQUU7SUFDZixJQUFLLElBQUlGLElBQUksSUFBSUEsSUFBSztRQUNsQixNQUFNRyxZQUFZLENBQUMsRUFBRXhCLElBQUksQ0FBQyxFQUFFcUIsRUFBRSxDQUFDO1FBQy9CLE1BQU1JLFFBQVEsTUFBTUgsY0FBY0U7UUFDbEMsSUFBSSxDQUFDQyxPQUFPO1lBQ1I7UUFDSjtRQUNBRixPQUFPSixJQUFJLENBQUNNO0lBQ2hCO0lBQ0EsSUFBSUYsT0FBT2hCLE1BQU0sR0FBRyxHQUFHO1FBQ25CLE9BQU9nQixPQUFPRyxJQUFJLENBQUM7SUFDdkI7SUFDQSxPQUFPO0FBQ1g7QUFDQSxlQUFlN0IsYUFBYUcsR0FBRyxFQUFFc0IsYUFBYSxFQUFFSyxXQUFXO0lBQ3ZELE1BQU1uQyxRQUFRLE1BQU04QixjQUFjdEI7SUFDbEMsSUFBSVIsT0FBTztRQUNQLE1BQU1tQyxZQUFZM0I7SUFDdEI7SUFDQSxJQUFLLElBQUlxQixJQUFJLElBQUlBLElBQUs7UUFDbEIsTUFBTUcsWUFBWSxDQUFDLEVBQUV4QixJQUFJLENBQUMsRUFBRXFCLEVBQUUsQ0FBQztRQUMvQixNQUFNSSxRQUFRLE1BQU1ILGNBQWNFO1FBQ2xDLElBQUksQ0FBQ0MsT0FBTztZQUNSO1FBQ0o7UUFDQSxNQUFNRSxZQUFZSDtJQUN0QjtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zc3IvZGlzdC9tYWluL3V0aWxzL2NodW5rZXIuanM/OGI0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTUFYX0NIVU5LX1NJWkUgPSB2b2lkIDA7XG5leHBvcnRzLmlzQ2h1bmtMaWtlID0gaXNDaHVua0xpa2U7XG5leHBvcnRzLmNyZWF0ZUNodW5rcyA9IGNyZWF0ZUNodW5rcztcbmV4cG9ydHMuY29tYmluZUNodW5rcyA9IGNvbWJpbmVDaHVua3M7XG5leHBvcnRzLmRlbGV0ZUNodW5rcyA9IGRlbGV0ZUNodW5rcztcbmV4cG9ydHMuTUFYX0NIVU5LX1NJWkUgPSAzMTgwO1xuY29uc3QgQ0hVTktfTElLRV9SRUdFWCA9IC9eKC4qKVsuXSgwfFsxLTldWzAtOV0qKSQvO1xuZnVuY3Rpb24gaXNDaHVua0xpa2UoY29va2llTmFtZSwga2V5KSB7XG4gICAgaWYgKGNvb2tpZU5hbWUgPT09IGtleSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtMaWtlID0gY29va2llTmFtZS5tYXRjaChDSFVOS19MSUtFX1JFR0VYKTtcbiAgICBpZiAoY2h1bmtMaWtlICYmIGNodW5rTGlrZVsxXSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIGNyZWF0ZSBjaHVua3MgZnJvbSBhIHN0cmluZyBhbmQgcmV0dXJuIGFuIGFycmF5IG9mIG9iamVjdFxuICovXG5mdW5jdGlvbiBjcmVhdGVDaHVua3Moa2V5LCB2YWx1ZSwgY2h1bmtTaXplKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRDaHVua1NpemUgPSBjaHVua1NpemUgPz8gZXhwb3J0cy5NQVhfQ0hVTktfU0laRTtcbiAgICBsZXQgZW5jb2RlZFZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICBpZiAoZW5jb2RlZFZhbHVlLmxlbmd0aCA8PSByZXNvbHZlZENodW5rU2l6ZSkge1xuICAgICAgICByZXR1cm4gW3sgbmFtZToga2V5LCB2YWx1ZSB9XTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgd2hpbGUgKGVuY29kZWRWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBlbmNvZGVkQ2h1bmtIZWFkID0gZW5jb2RlZFZhbHVlLnNsaWNlKDAsIHJlc29sdmVkQ2h1bmtTaXplKTtcbiAgICAgICAgY29uc3QgbGFzdEVzY2FwZVBvcyA9IGVuY29kZWRDaHVua0hlYWQubGFzdEluZGV4T2YoXCIlXCIpO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgbGFzdCBlc2NhcGVkIGNoYXJhY3RlciBpcyB0cnVuY2F0ZWQuXG4gICAgICAgIGlmIChsYXN0RXNjYXBlUG9zID4gcmVzb2x2ZWRDaHVua1NpemUgLSAzKSB7XG4gICAgICAgICAgICAvLyBJZiBzbywgcmVzbGljZSB0aGUgc3RyaW5nIHRvIGV4Y2x1ZGUgdGhlIHdob2xlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgcmVkdWNlIHRoZSBzaXplIG9mIHRoZSBzdHJpbmcgYXMgdGhlIGNodW5rIG11c3RcbiAgICAgICAgICAgIC8vIGJlIHNtYWxsZXIgdGhhbiB0aGUgY2h1bmsgc2l6ZS5cbiAgICAgICAgICAgIGVuY29kZWRDaHVua0hlYWQgPSBlbmNvZGVkQ2h1bmtIZWFkLnNsaWNlKDAsIGxhc3RFc2NhcGVQb3MpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWx1ZUhlYWQgPSBcIlwiO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2h1bmsgd2FzIHNwbGl0IGFsb25nIGEgdmFsaWQgdW5pY29kZSBib3VuZGFyeS5cbiAgICAgICAgd2hpbGUgKGVuY29kZWRDaHVua0hlYWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBjaHVuayBiYWNrIGFuZCBzZWUgaWYgaXQgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgLy8gU3RvcCB3aGVuIHRoZSBjaHVuayBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICB2YWx1ZUhlYWQgPSBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlZENodW5rSGVhZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBVUklFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVkQ2h1bmtIZWFkLmF0KC0zKSA9PT0gXCIlXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZENodW5rSGVhZC5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWRDaHVua0hlYWQgPSBlbmNvZGVkQ2h1bmtIZWFkLnNsaWNlKDAsIGVuY29kZWRDaHVua0hlYWQubGVuZ3RoIC0gMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtzLnB1c2godmFsdWVIZWFkKTtcbiAgICAgICAgZW5jb2RlZFZhbHVlID0gZW5jb2RlZFZhbHVlLnNsaWNlKGVuY29kZWRDaHVua0hlYWQubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rcy5tYXAoKHZhbHVlLCBpKSA9PiAoeyBuYW1lOiBgJHtrZXl9LiR7aX1gLCB2YWx1ZSB9KSk7XG59XG4vLyBHZXQgZnVsbHkgY29uc3RydWN0ZWQgY2h1bmtzXG5hc3luYyBmdW5jdGlvbiBjb21iaW5lQ2h1bmtzKGtleSwgcmV0cmlldmVDaHVuaykge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcmV0cmlldmVDaHVuayhrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBjb25zdCBjaHVua05hbWUgPSBgJHtrZXl9LiR7aX1gO1xuICAgICAgICBjb25zdCBjaHVuayA9IGF3YWl0IHJldHJpZXZlQ2h1bmsoY2h1bmtOYW1lKTtcbiAgICAgICAgaWYgKCFjaHVuaykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5qb2luKFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUNodW5rcyhrZXksIHJldHJpZXZlQ2h1bmssIHJlbW92ZUNodW5rKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCByZXRyaWV2ZUNodW5rKGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGF3YWl0IHJlbW92ZUNodW5rKGtleSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNodW5rTmFtZSA9IGAke2tleX0uJHtpfWA7XG4gICAgICAgIGNvbnN0IGNodW5rID0gYXdhaXQgcmV0cmlldmVDaHVuayhjaHVua05hbWUpO1xuICAgICAgICBpZiAoIWNodW5rKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByZW1vdmVDaHVuayhjaHVua05hbWUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTUFYX0NIVU5LX1NJWkUiLCJpc0NodW5rTGlrZSIsImNyZWF0ZUNodW5rcyIsImNvbWJpbmVDaHVua3MiLCJkZWxldGVDaHVua3MiLCJDSFVOS19MSUtFX1JFR0VYIiwiY29va2llTmFtZSIsImtleSIsImNodW5rTGlrZSIsIm1hdGNoIiwiY2h1bmtTaXplIiwicmVzb2x2ZWRDaHVua1NpemUiLCJlbmNvZGVkVmFsdWUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJsZW5ndGgiLCJuYW1lIiwiY2h1bmtzIiwiZW5jb2RlZENodW5rSGVhZCIsInNsaWNlIiwibGFzdEVzY2FwZVBvcyIsImxhc3RJbmRleE9mIiwidmFsdWVIZWFkIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXJyb3IiLCJVUklFcnJvciIsImF0IiwicHVzaCIsIm1hcCIsImkiLCJyZXRyaWV2ZUNodW5rIiwidmFsdWVzIiwiY2h1bmtOYW1lIiwiY2h1bmsiLCJqb2luIiwicmVtb3ZlQ2h1bmsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/ssr/dist/main/utils/chunker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/ssr/dist/main/utils/constants.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/main/utils/constants.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DEFAULT_COOKIE_OPTIONS = void 0;\nexports.DEFAULT_COOKIE_OPTIONS = {\n    path: \"/\",\n    sameSite: \"lax\",\n    httpOnly: false,\n    // https://developer.chrome.com/blog/cookie-max-age-expires\n    // https://httpwg.org/http-extensions/draft-ietf-httpbis-rfc6265bis.html#name-cookie-lifetime-limits\n    maxAge: 400 * 24 * 60 * 60\n}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vdXRpbHMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw4QkFBOEIsR0FBRyxLQUFLO0FBQ3RDQSw4QkFBOEIsR0FBRztJQUM3QkcsTUFBTTtJQUNOQyxVQUFVO0lBQ1ZDLFVBQVU7SUFDViwyREFBMkQ7SUFDM0Qsb0dBQW9HO0lBQ3BHQyxRQUFRLE1BQU0sS0FBSyxLQUFLO0FBQzVCLEdBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zc3IvZGlzdC9tYWluL3V0aWxzL2NvbnN0YW50cy5qcz9iNjY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX0NPT0tJRV9PUFRJT05TID0gdm9pZCAwO1xuZXhwb3J0cy5ERUZBVUxUX0NPT0tJRV9PUFRJT05TID0ge1xuICAgIHBhdGg6IFwiL1wiLFxuICAgIHNhbWVTaXRlOiBcImxheFwiLFxuICAgIGh0dHBPbmx5OiBmYWxzZSxcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2Jsb2cvY29va2llLW1heC1hZ2UtZXhwaXJlc1xuICAgIC8vIGh0dHBzOi8vaHR0cHdnLm9yZy9odHRwLWV4dGVuc2lvbnMvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMuaHRtbCNuYW1lLWNvb2tpZS1saWZldGltZS1saW1pdHNcbiAgICBtYXhBZ2U6IDQwMCAqIDI0ICogNjAgKiA2MCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiREVGQVVMVF9DT09LSUVfT1BUSU9OUyIsInBhdGgiLCJzYW1lU2l0ZSIsImh0dHBPbmx5IiwibWF4QWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/ssr/dist/main/utils/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/ssr/dist/main/utils/helpers.js":
/*!***************************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/main/utils/helpers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.serialize = exports.parse = void 0;\nexports.parseCookieHeader = parseCookieHeader;\nexports.serializeCookieHeader = serializeCookieHeader;\nexports.isBrowser = isBrowser;\nexports.memoryLocalStorageAdapter = memoryLocalStorageAdapter;\nconst cookie = __importStar(__webpack_require__(/*! cookie */ \"(rsc)/./node_modules/cookie/dist/index.js\"));\n/**\n * @deprecated Since v0.4.0: Please use {@link parseCookieHeader}. `parse` will\n * not be available for import starting v1.0.0 of `@supabase/ssr`.\n */ exports.parse = cookie.parse;\n/**\n * @deprecated Since v0.4.0: Please use {@link serializeCookieHeader}.\n * `serialize` will not be available for import starting v1.0.0 of\n * `@supabase/ssr`.\n */ exports.serialize = cookie.serialize;\n/**\n * Parses the `Cookie` HTTP header into an array of cookie name-value objects.\n *\n * @param header The `Cookie` HTTP header. Decodes cookie names and values from\n * URI encoding first.\n */ function parseCookieHeader(header) {\n    const parsed = cookie.parse(header);\n    return Object.keys(parsed ?? {}).map((name)=>({\n            name,\n            value: parsed[name]\n        }));\n}\n/**\n * Converts the arguments to a valid `Set-Cookie` header. Non US-ASCII chars\n * and other forbidden cookie chars will be URI encoded.\n *\n * @param name Name of cookie.\n * @param value Value of cookie.\n */ function serializeCookieHeader(name, value, options) {\n    return cookie.serialize(name, value, options);\n}\nfunction isBrowser() {\n    return  false && 0;\n}\n/**\n * Returns a localStorage-like object that stores the key-value pairs in\n * memory.\n */ function memoryLocalStorageAdapter(store = {}) {\n    return {\n        getItem: (key)=>{\n            return store[key] || null;\n        },\n        setItem: (key, value)=>{\n            store[key] = value;\n        },\n        removeItem: (key)=>{\n            delete store[key];\n        }\n    };\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vdXRpbHMvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLHFCQUFxQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGtCQUFrQixJQUFNZixDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGaEIsT0FBT2MsY0FBYyxDQUFDWixHQUFHLFdBQVc7UUFBRVUsWUFBWTtRQUFNSyxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU2QsQ0FBQyxFQUFFYyxDQUFDO0lBQ2RkLENBQUMsQ0FBQyxVQUFVLEdBQUdjO0FBQ25CO0FBQ0EsSUFBSUUsZUFBZSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFlBQVksSUFBSyxTQUFVQyxHQUFHO0lBQzNELElBQUlBLE9BQU9BLElBQUlWLFVBQVUsRUFBRSxPQUFPVTtJQUNsQyxJQUFJQyxTQUFTLENBQUM7SUFDZCxJQUFJRCxPQUFPLE1BQU07UUFBQSxJQUFLLElBQUlmLEtBQUtlLElBQUssSUFBSWYsTUFBTSxhQUFhSixPQUFPcUIsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osS0FBS2YsSUFBSUwsZ0JBQWdCcUIsUUFBUUQsS0FBS2Y7SUFBRTtJQUN4SVcsbUJBQW1CSyxRQUFRRDtJQUMzQixPQUFPQztBQUNYO0FBQ0FwQiw4Q0FBNkM7SUFBRWlCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RPLGlCQUFpQixHQUFHQSxhQUFhLEdBQUcsS0FBSztBQUN6Q0EseUJBQXlCLEdBQUdHO0FBQzVCSCw2QkFBNkIsR0FBR0k7QUFDaENKLGlCQUFpQixHQUFHSztBQUNwQkwsaUNBQWlDLEdBQUdNO0FBQ3BDLE1BQU1DLFNBQVNiLGFBQWFjLG1CQUFPQSxDQUFDLHlEQUFRO0FBQzVDOzs7Q0FHQyxHQUNEUixhQUFhLEdBQUdPLE9BQU9MLEtBQUs7QUFDNUI7Ozs7Q0FJQyxHQUNERixpQkFBaUIsR0FBR08sT0FBT04sU0FBUztBQUNwQzs7Ozs7Q0FLQyxHQUNELFNBQVNFLGtCQUFrQk0sTUFBTTtJQUM3QixNQUFNQyxTQUFTSCxPQUFPTCxLQUFLLENBQUNPO0lBQzVCLE9BQU9qQyxPQUFPbUMsSUFBSSxDQUFDRCxVQUFVLENBQUMsR0FBR0UsR0FBRyxDQUFDLENBQUNDLE9BQVU7WUFDNUNBO1lBQ0FwQixPQUFPaUIsTUFBTSxDQUFDRyxLQUFLO1FBQ3ZCO0FBQ0o7QUFDQTs7Ozs7O0NBTUMsR0FDRCxTQUFTVCxzQkFBc0JTLElBQUksRUFBRXBCLEtBQUssRUFBRXFCLE9BQU87SUFDL0MsT0FBT1AsT0FBT04sU0FBUyxDQUFDWSxNQUFNcEIsT0FBT3FCO0FBQ3pDO0FBQ0EsU0FBU1Q7SUFDTCxPQUFRLE1BQTZCLElBQUksQ0FBc0M7QUFDbkY7QUFDQTs7O0NBR0MsR0FDRCxTQUFTQywwQkFBMEJXLFFBQVEsQ0FBQyxDQUFDO0lBQ3pDLE9BQU87UUFDSEMsU0FBUyxDQUFDQztZQUNOLE9BQU9GLEtBQUssQ0FBQ0UsSUFBSSxJQUFJO1FBQ3pCO1FBQ0FDLFNBQVMsQ0FBQ0QsS0FBSzFCO1lBQ1h3QixLQUFLLENBQUNFLElBQUksR0FBRzFCO1FBQ2pCO1FBQ0E0QixZQUFZLENBQUNGO1lBQ1QsT0FBT0YsS0FBSyxDQUFDRSxJQUFJO1FBQ3JCO0lBQ0o7QUFDSixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3NyL2Rpc3QvbWFpbi91dGlscy9oZWxwZXJzLmpzPzNhNGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2VyaWFsaXplID0gZXhwb3J0cy5wYXJzZSA9IHZvaWQgMDtcbmV4cG9ydHMucGFyc2VDb29raWVIZWFkZXIgPSBwYXJzZUNvb2tpZUhlYWRlcjtcbmV4cG9ydHMuc2VyaWFsaXplQ29va2llSGVhZGVyID0gc2VyaWFsaXplQ29va2llSGVhZGVyO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG5leHBvcnRzLm1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyO1xuY29uc3QgY29va2llID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJjb29raWVcIikpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBTaW5jZSB2MC40LjA6IFBsZWFzZSB1c2Uge0BsaW5rIHBhcnNlQ29va2llSGVhZGVyfS4gYHBhcnNlYCB3aWxsXG4gKiBub3QgYmUgYXZhaWxhYmxlIGZvciBpbXBvcnQgc3RhcnRpbmcgdjEuMC4wIG9mIGBAc3VwYWJhc2Uvc3NyYC5cbiAqL1xuZXhwb3J0cy5wYXJzZSA9IGNvb2tpZS5wYXJzZTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgU2luY2UgdjAuNC4wOiBQbGVhc2UgdXNlIHtAbGluayBzZXJpYWxpemVDb29raWVIZWFkZXJ9LlxuICogYHNlcmlhbGl6ZWAgd2lsbCBub3QgYmUgYXZhaWxhYmxlIGZvciBpbXBvcnQgc3RhcnRpbmcgdjEuMC4wIG9mXG4gKiBgQHN1cGFiYXNlL3NzcmAuXG4gKi9cbmV4cG9ydHMuc2VyaWFsaXplID0gY29va2llLnNlcmlhbGl6ZTtcbi8qKlxuICogUGFyc2VzIHRoZSBgQ29va2llYCBIVFRQIGhlYWRlciBpbnRvIGFuIGFycmF5IG9mIGNvb2tpZSBuYW1lLXZhbHVlIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGhlYWRlciBUaGUgYENvb2tpZWAgSFRUUCBoZWFkZXIuIERlY29kZXMgY29va2llIG5hbWVzIGFuZCB2YWx1ZXMgZnJvbVxuICogVVJJIGVuY29kaW5nIGZpcnN0LlxuICovXG5mdW5jdGlvbiBwYXJzZUNvb2tpZUhlYWRlcihoZWFkZXIpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBjb29raWUucGFyc2UoaGVhZGVyKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyc2VkID8/IHt9KS5tYXAoKG5hbWUpID0+ICh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlOiBwYXJzZWRbbmFtZV0sXG4gICAgfSkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgYXJndW1lbnRzIHRvIGEgdmFsaWQgYFNldC1Db29raWVgIGhlYWRlci4gTm9uIFVTLUFTQ0lJIGNoYXJzXG4gKiBhbmQgb3RoZXIgZm9yYmlkZGVuIGNvb2tpZSBjaGFycyB3aWxsIGJlIFVSSSBlbmNvZGVkLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgY29va2llLlxuICogQHBhcmFtIHZhbHVlIFZhbHVlIG9mIGNvb2tpZS5cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplQ29va2llSGVhZGVyKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNvb2tpZS5zZXJpYWxpemUobmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGxvY2FsU3RvcmFnZS1saWtlIG9iamVjdCB0aGF0IHN0b3JlcyB0aGUga2V5LXZhbHVlIHBhaXJzIGluXG4gKiBtZW1vcnkuXG4gKi9cbmZ1bmN0aW9uIG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIoc3RvcmUgPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldEl0ZW06IChrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZVtrZXldIHx8IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEl0ZW06IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBzdG9yZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUl0ZW06IChrZXkpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtrZXldO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJleHBvcnRzIiwic2VyaWFsaXplIiwicGFyc2UiLCJwYXJzZUNvb2tpZUhlYWRlciIsInNlcmlhbGl6ZUNvb2tpZUhlYWRlciIsImlzQnJvd3NlciIsIm1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIiLCJjb29raWUiLCJyZXF1aXJlIiwiaGVhZGVyIiwicGFyc2VkIiwia2V5cyIsIm1hcCIsIm5hbWUiLCJvcHRpb25zIiwid2luZG93IiwiZG9jdW1lbnQiLCJzdG9yZSIsImdldEl0ZW0iLCJrZXkiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/ssr/dist/main/utils/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/ssr/dist/main/utils/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/main/utils/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/utils/helpers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/utils/constants.js\"), exports);\n__exportStar(__webpack_require__(/*! ./chunker */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/utils/chunker.js\"), exports);\n__exportStar(__webpack_require__(/*! ./base64url */ \"(rsc)/./node_modules/@supabase/ssr/dist/main/utils/base64url.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0ROLGFBQWFPLG1CQUFPQSxDQUFDLGdGQUFXLEdBQUdOO0FBQ25DRCxhQUFhTyxtQkFBT0EsQ0FBQyxvRkFBYSxHQUFHTjtBQUNyQ0QsYUFBYU8sbUJBQU9BLENBQUMsZ0ZBQVcsR0FBR047QUFDbkNELGFBQWFPLG1CQUFPQSxDQUFDLG9GQUFhLEdBQUdOLFVBQ3JDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3NyL2Rpc3QvbWFpbi91dGlscy9pbmRleC5qcz9kZGFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29uc3RhbnRzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jaHVua2VyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlNjR1cmxcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/ssr/dist/main/utils/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/ssr/dist/main/version.js":
/*!*********************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/main/version.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.VERSION = void 0;\nexports.VERSION = \"0.8.0\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHLEtBQUs7QUFDdkJBLGVBQWUsR0FBRyxTQUNsQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21haW4vdmVyc2lvbi5qcz9hMGVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WRVJTSU9OID0gdm9pZCAwO1xuZXhwb3J0cy5WRVJTSU9OID0gJzAuOC4wJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVkVSU0lPTiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/ssr/dist/main/version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/postgrest-js/dist/index.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/index.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n//#region src/PostgrestError.ts\n/**\n* Error format\n*\n* {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n*/ var PostgrestError = class extends Error {\n    /**\n\t* @example\n\t* ```ts\n\t* import PostgrestError from '@supabase/postgrest-js'\n\t*\n\t* throw new PostgrestError({\n\t*   message: 'Row level security prevented the request',\n\t*   details: 'RLS denied the insert',\n\t*   hint: 'Check your policies',\n\t*   code: 'PGRST301',\n\t* })\n\t* ```\n\t*/ constructor(context){\n        super(context.message);\n        this.name = \"PostgrestError\";\n        this.details = context.details;\n        this.hint = context.hint;\n        this.code = context.code;\n    }\n};\n//#endregion\n//#region src/PostgrestBuilder.ts\nvar PostgrestBuilder = class {\n    /**\n\t* Creates a builder configured for a specific PostgREST request.\n\t*\n\t* @example\n\t* ```ts\n\t* import PostgrestQueryBuilder from '@supabase/postgrest-js'\n\t*\n\t* const builder = new PostgrestQueryBuilder(\n\t*   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n\t*   { headers: new Headers({ apikey: 'public-anon-key' }) }\n\t* )\n\t* ```\n\t*/ constructor(builder){\n        var _builder$shouldThrowO, _builder$isMaybeSingl;\n        this.shouldThrowOnError = false;\n        this.method = builder.method;\n        this.url = builder.url;\n        this.headers = new Headers(builder.headers);\n        this.schema = builder.schema;\n        this.body = builder.body;\n        this.shouldThrowOnError = (_builder$shouldThrowO = builder.shouldThrowOnError) !== null && _builder$shouldThrowO !== void 0 ? _builder$shouldThrowO : false;\n        this.signal = builder.signal;\n        this.isMaybeSingle = (_builder$isMaybeSingl = builder.isMaybeSingle) !== null && _builder$isMaybeSingl !== void 0 ? _builder$isMaybeSingl : false;\n        if (builder.fetch) this.fetch = builder.fetch;\n        else this.fetch = fetch;\n    }\n    /**\n\t* If there's an error with the query, throwOnError will reject the promise by\n\t* throwing the error instead of returning it as part of a successful response.\n\t*\n\t* {@link https://github.com/supabase/supabase-js/issues/92}\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Set an HTTP header for the request.\n\t*/ setHeader(name, value) {\n        this.headers = new Headers(this.headers);\n        this.headers.set(name, value);\n        return this;\n    }\n    then(onfulfilled, onrejected) {\n        var _this = this;\n        if (this.schema === void 0) {} else if ([\n            \"GET\",\n            \"HEAD\"\n        ].includes(this.method)) this.headers.set(\"Accept-Profile\", this.schema);\n        else this.headers.set(\"Content-Profile\", this.schema);\n        if (this.method !== \"GET\" && this.method !== \"HEAD\") this.headers.set(\"Content-Type\", \"application/json\");\n        const _fetch = this.fetch;\n        let res = _fetch(this.url.toString(), {\n            method: this.method,\n            headers: this.headers,\n            body: JSON.stringify(this.body),\n            signal: this.signal\n        }).then(async (res$1)=>{\n            let error = null;\n            let data = null;\n            let count = null;\n            let status = res$1.status;\n            let statusText = res$1.statusText;\n            if (res$1.ok) {\n                var _this$headers$get2, _res$headers$get;\n                if (_this.method !== \"HEAD\") {\n                    var _this$headers$get;\n                    const body = await res$1.text();\n                    if (body === \"\") {} else if (_this.headers.get(\"Accept\") === \"text/csv\") data = body;\n                    else if (_this.headers.get(\"Accept\") && ((_this$headers$get = _this.headers.get(\"Accept\")) === null || _this$headers$get === void 0 ? void 0 : _this$headers$get.includes(\"application/vnd.pgrst.plan+text\"))) data = body;\n                    else data = JSON.parse(body);\n                }\n                const countHeader = (_this$headers$get2 = _this.headers.get(\"Prefer\")) === null || _this$headers$get2 === void 0 ? void 0 : _this$headers$get2.match(/count=(exact|planned|estimated)/);\n                const contentRange = (_res$headers$get = res$1.headers.get(\"content-range\")) === null || _res$headers$get === void 0 ? void 0 : _res$headers$get.split(\"/\");\n                if (countHeader && contentRange && contentRange.length > 1) count = parseInt(contentRange[1]);\n                if (_this.isMaybeSingle && _this.method === \"GET\" && Array.isArray(data)) if (data.length > 1) {\n                    error = {\n                        code: \"PGRST116\",\n                        details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n                        hint: null,\n                        message: \"JSON object requested, multiple (or no) rows returned\"\n                    };\n                    data = null;\n                    count = null;\n                    status = 406;\n                    statusText = \"Not Acceptable\";\n                } else if (data.length === 1) data = data[0];\n                else data = null;\n            } else {\n                var _error$details;\n                const body = await res$1.text();\n                try {\n                    error = JSON.parse(body);\n                    if (Array.isArray(error) && res$1.status === 404) {\n                        data = [];\n                        error = null;\n                        status = 200;\n                        statusText = \"OK\";\n                    }\n                } catch (_unused) {\n                    if (res$1.status === 404 && body === \"\") {\n                        status = 204;\n                        statusText = \"No Content\";\n                    } else error = {\n                        message: body\n                    };\n                }\n                if (error && _this.isMaybeSingle && (error === null || error === void 0 || (_error$details = error.details) === null || _error$details === void 0 ? void 0 : _error$details.includes(\"0 rows\"))) {\n                    error = null;\n                    status = 200;\n                    statusText = \"OK\";\n                }\n                if (error && _this.shouldThrowOnError) throw new PostgrestError(error);\n            }\n            return {\n                error,\n                data,\n                count,\n                status,\n                statusText\n            };\n        });\n        if (!this.shouldThrowOnError) res = res.catch((fetchError)=>{\n            var _fetchError$name2;\n            let errorDetails = \"\";\n            const cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;\n            if (cause) {\n                var _cause$message, _cause$code, _fetchError$name, _cause$name;\n                const causeMessage = (_cause$message = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _cause$message !== void 0 ? _cause$message : \"\";\n                const causeCode = (_cause$code = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _cause$code !== void 0 ? _cause$code : \"\";\n                errorDetails = `${(_fetchError$name = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name !== void 0 ? _fetchError$name : \"FetchError\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`;\n                errorDetails += `\\n\\nCaused by: ${(_cause$name = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _cause$name !== void 0 ? _cause$name : \"Error\"}: ${causeMessage}`;\n                if (causeCode) errorDetails += ` (${causeCode})`;\n                if (cause === null || cause === void 0 ? void 0 : cause.stack) errorDetails += `\\n${cause.stack}`;\n            } else {\n                var _fetchError$stack;\n                errorDetails = (_fetchError$stack = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _fetchError$stack !== void 0 ? _fetchError$stack : \"\";\n            }\n            return {\n                error: {\n                    message: `${(_fetchError$name2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name2 !== void 0 ? _fetchError$name2 : \"FetchError\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,\n                    details: errorDetails,\n                    hint: \"\",\n                    code: \"\"\n                },\n                data: null,\n                count: null,\n                status: 0,\n                statusText: \"\"\n            };\n        });\n        return res.then(onfulfilled, onrejected);\n    }\n    /**\n\t* Override the type of the returned `data`.\n\t*\n\t* @typeParam NewResult - The new result type to override with\n\t* @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n\t*/ returns() {\n        /* istanbul ignore next */ return this;\n    }\n    /**\n\t* Override the type of the returned `data` field in the response.\n\t*\n\t* @typeParam NewResult - The new type to cast the response data to\n\t* @typeParam Options - Optional type configuration (defaults to { merge: true })\n\t* @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n\t* @example\n\t* ```typescript\n\t* // Merge with existing types (default behavior)\n\t* const query = supabase\n\t*   .from('users')\n\t*   .select()\n\t*   .overrideTypes<{ custom_field: string }>()\n\t*\n\t* // Replace existing types completely\n\t* const replaceQuery = supabase\n\t*   .from('users')\n\t*   .select()\n\t*   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n\t* ```\n\t* @returns A PostgrestBuilder instance with the new type\n\t*/ overrideTypes() {\n        return this;\n    }\n};\n//#endregion\n//#region src/PostgrestTransformBuilder.ts\nvar PostgrestTransformBuilder = class extends PostgrestBuilder {\n    /**\n\t* Perform a SELECT on the query result.\n\t*\n\t* By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n\t* return modified rows. By calling this method, modified rows are returned in\n\t* `data`.\n\t*\n\t* @param columns - The columns to retrieve, separated by commas\n\t*/ select(columns) {\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c)=>{\n            if (/\\s/.test(c) && !quoted) return \"\";\n            if (c === '\"') quoted = !quoted;\n            return c;\n        }).join(\"\");\n        this.url.searchParams.set(\"select\", cleanedColumns);\n        this.headers.append(\"Prefer\", \"return=representation\");\n        return this;\n    }\n    /**\n\t* Order the query result by `column`.\n\t*\n\t* You can call this method multiple times to order by multiple columns.\n\t*\n\t* You can order referenced tables, but it only affects the ordering of the\n\t* parent table if you use `!inner` in the query.\n\t*\n\t* @param column - The column to order by\n\t* @param options - Named parameters\n\t* @param options.ascending - If `true`, the result will be in ascending order\n\t* @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n\t* `null`s appear last.\n\t* @param options.referencedTable - Set this to order a referenced table by\n\t* its columns\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {\n        const key = referencedTable ? `${referencedTable}.order` : \"order\";\n        const existingOrder = this.url.searchParams.get(key);\n        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : \"\"}${column}.${ascending ? \"asc\" : \"desc\"}${nullsFirst === void 0 ? \"\" : nullsFirst ? \".nullsfirst\" : \".nullslast\"}`);\n        return this;\n    }\n    /**\n\t* Limit the query result by `count`.\n\t*\n\t* @param count - The maximum number of rows to return\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to limit rows of referenced\n\t* tables instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ limit(count, { foreignTable, referencedTable = foreignTable } = {}) {\n        const key = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n        this.url.searchParams.set(key, `${count}`);\n        return this;\n    }\n    /**\n\t* Limit the query result by starting at an offset `from` and ending at the offset `to`.\n\t* Only records within this range are returned.\n\t* This respects the query order and if there is no order clause the range could behave unexpectedly.\n\t* The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n\t* and fourth rows of the query.\n\t*\n\t* @param from - The starting index from which to limit the result\n\t* @param to - The last index to which to limit the result\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to limit rows of referenced\n\t* tables instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {\n        const keyOffset = typeof referencedTable === \"undefined\" ? \"offset\" : `${referencedTable}.offset`;\n        const keyLimit = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n        this.url.searchParams.set(keyOffset, `${from}`);\n        this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n        return this;\n    }\n    /**\n\t* Set the AbortSignal for the fetch request.\n\t*\n\t* @param signal - The AbortSignal to use for the fetch request\n\t*/ abortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    /**\n\t* Return `data` as a single object instead of an array of objects.\n\t*\n\t* Query result must be one row (e.g. using `.limit(1)`), otherwise this\n\t* returns an error.\n\t*/ single() {\n        this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n        return this;\n    }\n    /**\n\t* Return `data` as a single object instead of an array of objects.\n\t*\n\t* Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n\t* this returns an error.\n\t*/ maybeSingle() {\n        if (this.method === \"GET\") this.headers.set(\"Accept\", \"application/json\");\n        else this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n        this.isMaybeSingle = true;\n        return this;\n    }\n    /**\n\t* Return `data` as a string in CSV format.\n\t*/ csv() {\n        this.headers.set(\"Accept\", \"text/csv\");\n        return this;\n    }\n    /**\n\t* Return `data` as an object in [GeoJSON](https://geojson.org) format.\n\t*/ geojson() {\n        this.headers.set(\"Accept\", \"application/geo+json\");\n        return this;\n    }\n    /**\n\t* Return `data` as the EXPLAIN plan for the query.\n\t*\n\t* You need to enable the\n\t* [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n\t* setting before using this method.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.analyze - If `true`, the query will be executed and the\n\t* actual run time will be returned\n\t*\n\t* @param options.verbose - If `true`, the query identifier will be returned\n\t* and `data` will include the output columns of the query\n\t*\n\t* @param options.settings - If `true`, include information on configuration\n\t* parameters that affect query planning\n\t*\n\t* @param options.buffers - If `true`, include information on buffer usage\n\t*\n\t* @param options.wal - If `true`, include information on WAL record generation\n\t*\n\t* @param options.format - The format of the output, can be `\"text\"` (default)\n\t* or `\"json\"`\n\t*/ explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = \"text\" } = {}) {\n        var _this$headers$get;\n        const options = [\n            analyze ? \"analyze\" : null,\n            verbose ? \"verbose\" : null,\n            settings ? \"settings\" : null,\n            buffers ? \"buffers\" : null,\n            wal ? \"wal\" : null\n        ].filter(Boolean).join(\"|\");\n        const forMediatype = (_this$headers$get = this.headers.get(\"Accept\")) !== null && _this$headers$get !== void 0 ? _this$headers$get : \"application/json\";\n        this.headers.set(\"Accept\", `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`);\n        if (format === \"json\") return this;\n        else return this;\n    }\n    /**\n\t* Rollback the query.\n\t*\n\t* `data` will still be returned, but the query is not committed.\n\t*/ rollback() {\n        this.headers.append(\"Prefer\", \"tx=rollback\");\n        return this;\n    }\n    /**\n\t* Override the type of the returned `data`.\n\t*\n\t* @typeParam NewResult - The new result type to override with\n\t* @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n\t*/ returns() {\n        return this;\n    }\n    /**\n\t* Set the maximum number of rows that can be affected by the query.\n\t* Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n\t*\n\t* @param value - The maximum number of rows that can be affected\n\t*/ maxAffected(value) {\n        this.headers.append(\"Prefer\", \"handling=strict\");\n        this.headers.append(\"Prefer\", `max-affected=${value}`);\n        return this;\n    }\n};\n//#endregion\n//#region src/PostgrestFilterBuilder.ts\nconst PostgrestReservedCharsRegexp = /* @__PURE__ */ new RegExp(\"[,()]\");\nvar PostgrestFilterBuilder = class extends PostgrestTransformBuilder {\n    /**\n\t* Match only rows where `column` is equal to `value`.\n\t*\n\t* To check if the value of `column` is NULL, you should use `.is()` instead.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ eq(column, value) {\n        this.url.searchParams.append(column, `eq.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is not equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ neq(column, value) {\n        this.url.searchParams.append(column, `neq.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is greater than `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ gt(column, value) {\n        this.url.searchParams.append(column, `gt.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is greater than or equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ gte(column, value) {\n        this.url.searchParams.append(column, `gte.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is less than `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ lt(column, value) {\n        this.url.searchParams.append(column, `lt.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is less than or equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ lte(column, value) {\n        this.url.searchParams.append(column, `lte.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches `pattern` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The pattern to match with\n\t*/ like(column, pattern) {\n        this.url.searchParams.append(column, `like.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches all of `patterns` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ likeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `like(all).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches any of `patterns` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ likeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `like(any).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches `pattern` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The pattern to match with\n\t*/ ilike(column, pattern) {\n        this.url.searchParams.append(column, `ilike.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches all of `patterns` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ ilikeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(all).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches any of `patterns` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ ilikeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(any).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches the PostgreSQL regex `pattern`\n\t* case-sensitively (using the `~` operator).\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The PostgreSQL regular expression pattern to match with\n\t*/ regexMatch(column, pattern) {\n        this.url.searchParams.append(column, `match.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches the PostgreSQL regex `pattern`\n\t* case-insensitively (using the `~*` operator).\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The PostgreSQL regular expression pattern to match with\n\t*/ regexIMatch(column, pattern) {\n        this.url.searchParams.append(column, `imatch.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` IS `value`.\n\t*\n\t* For non-boolean columns, this is only relevant for checking if the value of\n\t* `column` is NULL by setting `value` to `null`.\n\t*\n\t* For boolean columns, you can also set `value` to `true` or `false` and it\n\t* will behave the same way as `.eq()`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ is(column, value) {\n        this.url.searchParams.append(column, `is.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` IS DISTINCT FROM `value`.\n\t*\n\t* Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values\n\t* are considered equal (not distinct), and comparing `NULL` with any non-NULL\n\t* value returns true (distinct).\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ isDistinct(column, value) {\n        this.url.searchParams.append(column, `isdistinct.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is included in the `values` array.\n\t*\n\t* @param column - The column to filter on\n\t* @param values - The values array to filter with\n\t*/ in(column, values) {\n        const cleanedValues = Array.from(new Set(values)).map((s)=>{\n            if (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`;\n            else return `${s}`;\n        }).join(\",\");\n        this.url.searchParams.append(column, `in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is NOT included in the `values` array.\n\t*\n\t* @param column - The column to filter on\n\t* @param values - The values array to filter with\n\t*/ notIn(column, values) {\n        const cleanedValues = Array.from(new Set(values)).map((s)=>{\n            if (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`;\n            else return `${s}`;\n        }).join(\",\");\n        this.url.searchParams.append(column, `not.in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n\t* Only relevant for jsonb, array, and range columns. Match only rows where\n\t* `column` contains every element appearing in `value`.\n\t*\n\t* @param column - The jsonb, array, or range column to filter on\n\t* @param value - The jsonb, array, or range value to filter with\n\t*/ contains(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, `cs.${value}`);\n        else if (Array.isArray(value)) this.url.searchParams.append(column, `cs.{${value.join(\",\")}}`);\n        else this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n        return this;\n    }\n    /**\n\t* Only relevant for jsonb, array, and range columns. Match only rows where\n\t* every element appearing in `column` is contained by `value`.\n\t*\n\t* @param column - The jsonb, array, or range column to filter on\n\t* @param value - The jsonb, array, or range value to filter with\n\t*/ containedBy(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, `cd.${value}`);\n        else if (Array.isArray(value)) this.url.searchParams.append(column, `cd.{${value.join(\",\")}}`);\n        else this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is greater than any element in `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeGt(column, range) {\n        this.url.searchParams.append(column, `sr.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is either contained in `range` or greater than any element in\n\t* `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeGte(column, range) {\n        this.url.searchParams.append(column, `nxl.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is less than any element in `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeLt(column, range) {\n        this.url.searchParams.append(column, `sl.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is either contained in `range` or less than any element in\n\t* `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeLte(column, range) {\n        this.url.searchParams.append(column, `nxr.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where `column` is\n\t* mutually exclusive to `range` and there can be no element between the two\n\t* ranges.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeAdjacent(column, range) {\n        this.url.searchParams.append(column, `adj.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for array and range columns. Match only rows where\n\t* `column` and `value` have an element in common.\n\t*\n\t* @param column - The array or range column to filter on\n\t* @param value - The array or range value to filter with\n\t*/ overlaps(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, `ov.${value}`);\n        else this.url.searchParams.append(column, `ov.{${value.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Only relevant for text and tsvector columns. Match only rows where\n\t* `column` matches the query string in `query`.\n\t*\n\t* @param column - The text or tsvector column to filter on\n\t* @param query - The query text to match with\n\t* @param options - Named parameters\n\t* @param options.config - The text search configuration to use\n\t* @param options.type - Change how the `query` text is interpreted\n\t*/ textSearch(column, query, { config, type } = {}) {\n        let typePart = \"\";\n        if (type === \"plain\") typePart = \"pl\";\n        else if (type === \"phrase\") typePart = \"ph\";\n        else if (type === \"websearch\") typePart = \"w\";\n        const configPart = config === void 0 ? \"\" : `(${config})`;\n        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n        return this;\n    }\n    /**\n\t* Match only rows where each column in `query` keys is equal to its\n\t* associated value. Shorthand for multiple `.eq()`s.\n\t*\n\t* @param query - The object to filter with, with column names as keys mapped\n\t* to their filter values\n\t*/ match(query) {\n        Object.entries(query).forEach(([column, value])=>{\n            this.url.searchParams.append(column, `eq.${value}`);\n        });\n        return this;\n    }\n    /**\n\t* Match only rows which doesn't satisfy the filter.\n\t*\n\t* Unlike most filters, `opearator` and `value` are used as-is and need to\n\t* follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure they are properly sanitized.\n\t*\n\t* @param column - The column to filter on\n\t* @param operator - The operator to be negated to filter with, following\n\t* PostgREST syntax\n\t* @param value - The value to filter with, following PostgREST syntax\n\t*/ not(column, operator, value) {\n        this.url.searchParams.append(column, `not.${operator}.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows which satisfy at least one of the filters.\n\t*\n\t* Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure it's properly sanitized.\n\t*\n\t* It's currently not possible to do an `.or()` filter across multiple tables.\n\t*\n\t* @param filters - The filters to use, following PostgREST syntax\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to filter on referenced tables\n\t* instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `referencedTable` instead\n\t*/ or(filters, { foreignTable, referencedTable = foreignTable } = {}) {\n        const key = referencedTable ? `${referencedTable}.or` : \"or\";\n        this.url.searchParams.append(key, `(${filters})`);\n        return this;\n    }\n    /**\n\t* Match only rows which satisfy the filter. This is an escape hatch - you\n\t* should use the specific filter methods wherever possible.\n\t*\n\t* Unlike most filters, `opearator` and `value` are used as-is and need to\n\t* follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure they are properly sanitized.\n\t*\n\t* @param column - The column to filter on\n\t* @param operator - The operator to filter with, following PostgREST syntax\n\t* @param value - The value to filter with, following PostgREST syntax\n\t*/ filter(column, operator, value) {\n        this.url.searchParams.append(column, `${operator}.${value}`);\n        return this;\n    }\n};\n//#endregion\n//#region src/PostgrestQueryBuilder.ts\nvar PostgrestQueryBuilder = class {\n    /**\n\t* Creates a query builder scoped to a Postgres table or view.\n\t*\n\t* @example\n\t* ```ts\n\t* import PostgrestQueryBuilder from '@supabase/postgrest-js'\n\t*\n\t* const query = new PostgrestQueryBuilder(\n\t*   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n\t*   { headers: { apikey: 'public-anon-key' } }\n\t* )\n\t* ```\n\t*/ constructor(url, { headers = {}, schema, fetch: fetch$1 }){\n        this.url = url;\n        this.headers = new Headers(headers);\n        this.schema = schema;\n        this.fetch = fetch$1;\n    }\n    /**\n\t* Clone URL and headers to prevent shared state between operations.\n\t*/ cloneRequestState() {\n        return {\n            url: new URL(this.url.toString()),\n            headers: new Headers(this.headers)\n        };\n    }\n    /**\n\t* Perform a SELECT query on the table or view.\n\t*\n\t* @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t*\n\t* @param options.count - Count algorithm to use to count rows in the table or view.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ select(columns, options) {\n        const { head = false, count } = options !== null && options !== void 0 ? options : {};\n        const method = head ? \"HEAD\" : \"GET\";\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c)=>{\n            if (/\\s/.test(c) && !quoted) return \"\";\n            if (c === '\"') quoted = !quoted;\n            return c;\n        }).join(\"\");\n        const { url, headers } = this.cloneRequestState();\n        url.searchParams.set(\"select\", cleanedColumns);\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t* Perform an INSERT into the table or view.\n\t*\n\t* By default, inserted rows are not returned. To return it, chain the call\n\t* with `.select()`.\n\t*\n\t* @param values - The values to insert. Pass an object to insert a single row\n\t* or an array to insert multiple rows.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count inserted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @param options.defaultToNull - Make missing fields default to `null`.\n\t* Otherwise, use the default value for the column. Only applies for bulk\n\t* inserts.\n\t*/ insert(values, { count, defaultToNull = true } = {}) {\n        var _this$fetch;\n        const method = \"POST\";\n        const { url, headers } = this.cloneRequestState();\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        if (!defaultToNull) headers.append(\"Prefer\", `missing=default`);\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>`\"${column}\"`);\n                url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch\n        });\n    }\n    /**\n\t* Perform an UPSERT on the table or view. Depending on the column(s) passed\n\t* to `onConflict`, `.upsert()` allows you to perform the equivalent of\n\t* `.insert()` if a row with the corresponding `onConflict` columns doesn't\n\t* exist, or if it does exist, perform an alternative action depending on\n\t* `ignoreDuplicates`.\n\t*\n\t* By default, upserted rows are not returned. To return it, chain the call\n\t* with `.select()`.\n\t*\n\t* @param values - The values to upsert with. Pass an object to upsert a\n\t* single row or an array to upsert multiple rows.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n\t* duplicate rows are determined. Two rows are duplicates if all the\n\t* `onConflict` columns are equal.\n\t*\n\t* @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n\t* `false`, duplicate rows are merged with existing rows.\n\t*\n\t* @param options.count - Count algorithm to use to count upserted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @param options.defaultToNull - Make missing fields default to `null`.\n\t* Otherwise, use the default value for the column. This only applies when\n\t* inserting new rows, not when merging with existing rows under\n\t* `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n\t*\n\t* @example Upsert a single row using a unique key\n\t* ```ts\n\t* // Upserting a single row, overwriting based on the 'username' unique column\n\t* const { data, error } = await supabase\n\t*   .from('users')\n\t*   .upsert({ username: 'supabot' }, { onConflict: 'username' })\n\t*\n\t* // Example response:\n\t* // {\n\t* //   data: [\n\t* //     { id: 4, message: 'bar', username: 'supabot' }\n\t* //   ],\n\t* //   error: null\n\t* // }\n\t* ```\n\t*\n\t* @example Upsert with conflict resolution and exact row counting\n\t* ```ts\n\t* // Upserting and returning exact count\n\t* const { data, error, count } = await supabase\n\t*   .from('users')\n\t*   .upsert(\n\t*     {\n\t*       id: 3,\n\t*       message: 'foo',\n\t*       username: 'supabot'\n\t*     },\n\t*     {\n\t*       onConflict: 'username',\n\t*       count: 'exact'\n\t*     }\n\t*   )\n\t*\n\t* // Example response:\n\t* // {\n\t* //   data: [\n\t* //     {\n\t* //       id: 42,\n\t* //       handle: \"saoirse\",\n\t* //       display_name: \"Saoirse\"\n\t* //     }\n\t* //   ],\n\t* //   count: 1,\n\t* //   error: null\n\t* // }\n\t* ```\n\t*/ upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {\n        var _this$fetch2;\n        const method = \"POST\";\n        const { url, headers } = this.cloneRequestState();\n        headers.append(\"Prefer\", `resolution=${ignoreDuplicates ? \"ignore\" : \"merge\"}-duplicates`);\n        if (onConflict !== void 0) url.searchParams.set(\"on_conflict\", onConflict);\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        if (!defaultToNull) headers.append(\"Prefer\", \"missing=default\");\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>`\"${column}\"`);\n                url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch2 = this.fetch) !== null && _this$fetch2 !== void 0 ? _this$fetch2 : fetch\n        });\n    }\n    /**\n\t* Perform an UPDATE on the table or view.\n\t*\n\t* By default, updated rows are not returned. To return it, chain the call\n\t* with `.select()` after filters.\n\t*\n\t* @param values - The values to update with\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count updated rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ update(values, { count } = {}) {\n        var _this$fetch3;\n        const method = \"PATCH\";\n        const { url, headers } = this.cloneRequestState();\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch3 = this.fetch) !== null && _this$fetch3 !== void 0 ? _this$fetch3 : fetch\n        });\n    }\n    /**\n\t* Perform a DELETE on the table or view.\n\t*\n\t* By default, deleted rows are not returned. To return it, chain the call\n\t* with `.select()` after filters.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count deleted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ delete({ count } = {}) {\n        var _this$fetch4;\n        const method = \"DELETE\";\n        const { url, headers } = this.cloneRequestState();\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            fetch: (_this$fetch4 = this.fetch) !== null && _this$fetch4 !== void 0 ? _this$fetch4 : fetch\n        });\n    }\n};\n//#endregion\n//#region src/PostgrestClient.ts\n/**\n* PostgREST client.\n*\n* @typeParam Database - Types for the schema from the [type\n* generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n*\n* @typeParam SchemaName - Postgres schema to switch to. Must be a string\n* literal, the same one passed to the constructor. If the schema is not\n* `\"public\"`, this must be supplied manually.\n*/ var PostgrestClient = class PostgrestClient {\n    /**\n\t* Creates a PostgREST client.\n\t*\n\t* @param url - URL of the PostgREST endpoint\n\t* @param options - Named parameters\n\t* @param options.headers - Custom headers\n\t* @param options.schema - Postgres schema to switch to\n\t* @param options.fetch - Custom fetch\n\t* @example\n\t* ```ts\n\t* import PostgrestClient from '@supabase/postgrest-js'\n\t*\n\t* const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {\n\t*   headers: { apikey: 'public-anon-key' },\n\t*   schema: 'public',\n\t* })\n\t* ```\n\t*/ constructor(url, { headers = {}, schema, fetch: fetch$1 } = {}){\n        this.url = url;\n        this.headers = new Headers(headers);\n        this.schemaName = schema;\n        this.fetch = fetch$1;\n    }\n    /**\n\t* Perform a query on a table or a view.\n\t*\n\t* @param relation - The table or view name to query\n\t*/ from(relation) {\n        if (!relation || typeof relation !== \"string\" || relation.trim() === \"\") throw new Error(\"Invalid relation name: relation must be a non-empty string.\");\n        return new PostgrestQueryBuilder(new URL(`${this.url}/${relation}`), {\n            headers: new Headers(this.headers),\n            schema: this.schemaName,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t* Select a schema to query or perform an function (rpc) call.\n\t*\n\t* The schema needs to be on the list of exposed schemas inside Supabase.\n\t*\n\t* @param schema - The schema to query\n\t*/ schema(schema) {\n        return new PostgrestClient(this.url, {\n            headers: this.headers,\n            schema,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t* Perform a function call.\n\t*\n\t* @param fn - The function name to call\n\t* @param args - The arguments to pass to the function call\n\t* @param options - Named parameters\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t* @param options.get - When set to `true`, the function will be called with\n\t* read-only access mode.\n\t* @param options.count - Count algorithm to use to count rows returned by the\n\t* function. Only applicable for [set-returning\n\t* functions](https://www.postgresql.org/docs/current/functions-srf.html).\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @example\n\t* ```ts\n\t* // For cross-schema functions where type inference fails, use overrideTypes:\n\t* const { data } = await supabase\n\t*   .schema('schema_b')\n\t*   .rpc('function_a', {})\n\t*   .overrideTypes<{ id: string; user_id: string }[]>()\n\t* ```\n\t*/ rpc(fn, args = {}, { head = false, get = false, count } = {}) {\n        var _this$fetch;\n        let method;\n        const url = new URL(`${this.url}/rpc/${fn}`);\n        let body;\n        const _isObject = (v)=>v !== null && typeof v === \"object\" && (!Array.isArray(v) || v.some(_isObject));\n        const _hasObjectArg = head && Object.values(args).some(_isObject);\n        if (_hasObjectArg) {\n            method = \"POST\";\n            body = args;\n        } else if (head || get) {\n            method = head ? \"HEAD\" : \"GET\";\n            Object.entries(args).filter(([_, value])=>value !== void 0).map(([name, value])=>[\n                    name,\n                    Array.isArray(value) ? `{${value.join(\",\")}}` : `${value}`\n                ]).forEach(([name, value])=>{\n                url.searchParams.append(name, value);\n            });\n        } else {\n            method = \"POST\";\n            body = args;\n        }\n        const headers = new Headers(this.headers);\n        if (_hasObjectArg) headers.set(\"Prefer\", count ? `count=${count},return=minimal` : \"return=minimal\");\n        else if (count) headers.set(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schemaName,\n            body,\n            fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch\n        });\n    }\n};\n//#endregion\n//#region src/index.ts\nvar src_default = {\n    PostgrestClient,\n    PostgrestQueryBuilder,\n    PostgrestFilterBuilder,\n    PostgrestTransformBuilder,\n    PostgrestBuilder,\n    PostgrestError\n};\n//#endregion\nexports.PostgrestBuilder = PostgrestBuilder;\nexports.PostgrestClient = PostgrestClient;\nexports.PostgrestError = PostgrestError;\nexports.PostgrestFilterBuilder = PostgrestFilterBuilder;\nexports.PostgrestQueryBuilder = PostgrestQueryBuilder;\nexports.PostgrestTransformBuilder = PostgrestTransformBuilder;\nexports[\"default\"] = src_default; //# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiO0FBQUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELCtCQUErQjtBQUMvQjs7OztBQUlBLEdBQ0EsSUFBSUMsaUJBQWlCLGNBQWNDO0lBQ2xDOzs7Ozs7Ozs7Ozs7Q0FZQSxHQUNBQyxZQUFZQyxPQUFPLENBQUU7UUFDcEIsS0FBSyxDQUFDQSxRQUFRQyxPQUFPO1FBQ3JCLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxPQUFPLEdBQUdILFFBQVFHLE9BQU87UUFDOUIsSUFBSSxDQUFDQyxJQUFJLEdBQUdKLFFBQVFJLElBQUk7UUFDeEIsSUFBSSxDQUFDQyxJQUFJLEdBQUdMLFFBQVFLLElBQUk7SUFDekI7QUFDRDtBQUVBLFlBQVk7QUFDWixpQ0FBaUM7QUFDakMsSUFBSUMsbUJBQW1CO0lBQ3RCOzs7Ozs7Ozs7Ozs7Q0FZQSxHQUNBUCxZQUFZUSxPQUFPLENBQUU7UUFDcEIsSUFBSUMsdUJBQXVCQztRQUMzQixJQUFJLENBQUNDLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0MsTUFBTSxHQUFHSixRQUFRSSxNQUFNO1FBQzVCLElBQUksQ0FBQ0MsR0FBRyxHQUFHTCxRQUFRSyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlDLFFBQVFQLFFBQVFNLE9BQU87UUFDMUMsSUFBSSxDQUFDRSxNQUFNLEdBQUdSLFFBQVFRLE1BQU07UUFDNUIsSUFBSSxDQUFDQyxJQUFJLEdBQUdULFFBQVFTLElBQUk7UUFDeEIsSUFBSSxDQUFDTixrQkFBa0IsR0FBRyxDQUFDRix3QkFBd0JELFFBQVFHLGtCQUFrQixNQUFNLFFBQVFGLDBCQUEwQixLQUFLLElBQUlBLHdCQUF3QjtRQUN0SixJQUFJLENBQUNTLE1BQU0sR0FBR1YsUUFBUVUsTUFBTTtRQUM1QixJQUFJLENBQUNDLGFB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UUFBUSxJQUFJLENBQUNELE9BQU87UUFDeEMsSUFBSW9MLGVBQWVwTCxRQUFRUyxHQUFHLENBQUMsVUFBVWMsUUFBUSxDQUFDLE1BQU0sRUFBRUEsTUFBTSxlQUFlLENBQUMsR0FBRzthQUM5RSxJQUFJQSxPQUFPdkIsUUFBUVMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUVjLE1BQU0sQ0FBQztRQUN0RCxPQUFPLElBQUlnRix1QkFBdUI7WUFDakN6RztZQUNBQztZQUNBQztZQUNBRSxRQUFRLElBQUksQ0FBQ3lLLFVBQVU7WUFDdkJ4SztZQUNBRyxPQUFPLENBQUNxSixjQUFjLElBQUksQ0FBQ3JKLEtBQUssTUFBTSxRQUFRcUosZ0JBQWdCLEtBQUssSUFBSUEsY0FBY3JKO1FBQ3RGO0lBQ0Q7QUFDRDtBQUVBLFlBQVk7QUFDWixzQkFBc0I7QUFDdEIsSUFBSWdMLGNBQWM7SUFDakJaO0lBQ0F0QjtJQUNBN0M7SUFDQTdDO0lBQ0FqRTtJQUNBVDtBQUNEO0FBRUEsWUFBWTtBQUNaRix3QkFBd0IsR0FBR1c7QUFDM0JYLHVCQUF1QixHQUFHNEw7QUFDMUI1TCxzQkFBc0IsR0FBR0U7QUFDekJGLDhCQUE4QixHQUFHeUg7QUFDakN6SCw2QkFBNkIsR0FBR3NLO0FBQ2hDdEssaUNBQWlDLEdBQUc0RTtBQUNwQzVFLGtCQUFlLEdBQUd3TSxhQUNsQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2luZGV4LmNqcz85YjU4Il0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vI3JlZ2lvbiBzcmMvUG9zdGdyZXN0RXJyb3IudHNcbi8qKlxuKiBFcnJvciBmb3JtYXRcbipcbioge0BsaW5rIGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWw/aGlnaGxpZ2h0PW9wdGlvbnMjZXJyb3JzLWFuZC1odHRwLXN0YXR1cy1jb2Rlc31cbiovXG52YXIgUG9zdGdyZXN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0LyoqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0c1xuXHQqIGltcG9ydCBQb3N0Z3Jlc3RFcnJvciBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuXHQqXG5cdCogdGhyb3cgbmV3IFBvc3RncmVzdEVycm9yKHtcblx0KiAgIG1lc3NhZ2U6ICdSb3cgbGV2ZWwgc2VjdXJpdHkgcHJldmVudGVkIHRoZSByZXF1ZXN0Jyxcblx0KiAgIGRldGFpbHM6ICdSTFMgZGVuaWVkIHRoZSBpbnNlcnQnLFxuXHQqICAgaGludDogJ0NoZWNrIHlvdXIgcG9saWNpZXMnLFxuXHQqICAgY29kZTogJ1BHUlNUMzAxJyxcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG5cdFx0c3VwZXIoY29udGV4dC5tZXNzYWdlKTtcblx0XHR0aGlzLm5hbWUgPSBcIlBvc3RncmVzdEVycm9yXCI7XG5cdFx0dGhpcy5kZXRhaWxzID0gY29udGV4dC5kZXRhaWxzO1xuXHRcdHRoaXMuaGludCA9IGNvbnRleHQuaGludDtcblx0XHR0aGlzLmNvZGUgPSBjb250ZXh0LmNvZGU7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9Qb3N0Z3Jlc3RCdWlsZGVyLnRzXG52YXIgUG9zdGdyZXN0QnVpbGRlciA9IGNsYXNzIHtcblx0LyoqXG5cdCogQ3JlYXRlcyBhIGJ1aWxkZXIgY29uZmlndXJlZCBmb3IgYSBzcGVjaWZpYyBQb3N0Z1JFU1QgcmVxdWVzdC5cblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHNcblx0KiBpbXBvcnQgUG9zdGdyZXN0UXVlcnlCdWlsZGVyIGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnXG5cdCpcblx0KiBjb25zdCBidWlsZGVyID0gbmV3IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcihcblx0KiAgIG5ldyBVUkwoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9yZXN0L3YxL3VzZXJzJyksXG5cdCogICB7IGhlYWRlcnM6IG5ldyBIZWFkZXJzKHsgYXBpa2V5OiAncHVibGljLWFub24ta2V5JyB9KSB9XG5cdCogKVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3RvcihidWlsZGVyKSB7XG5cdFx0dmFyIF9idWlsZGVyJHNob3VsZFRocm93TywgX2J1aWxkZXIkaXNNYXliZVNpbmdsO1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG5cdFx0dGhpcy5tZXRob2QgPSBidWlsZGVyLm1ldGhvZDtcblx0XHR0aGlzLnVybCA9IGJ1aWxkZXIudXJsO1xuXHRcdHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGJ1aWxkZXIuaGVhZGVycyk7XG5cdFx0dGhpcy5zY2hlbWEgPSBidWlsZGVyLnNjaGVtYTtcblx0XHR0aGlzLmJvZHkgPSBidWlsZGVyLmJvZHk7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSAoX2J1aWxkZXIkc2hvdWxkVGhyb3dPID0gYnVpbGRlci5zaG91bGRUaHJvd09uRXJyb3IpICE9PSBudWxsICYmIF9idWlsZGVyJHNob3VsZFRocm93TyAhPT0gdm9pZCAwID8gX2J1aWxkZXIkc2hvdWxkVGhyb3dPIDogZmFsc2U7XG5cdFx0dGhpcy5zaWduYWwgPSBidWlsZGVyLnNpZ25hbDtcblx0XHR0aGlzLmlzTWF5YmVTaW5nbGUgPSAoX2J1aWxkZXIkaXNNYXliZVNpbmdsID0gYnVpbGRlci5pc01heWJlU2luZ2xlKSAhPT0gbnVsbCAmJiBfYnVpbGRlciRpc01heWJlU2luZ2wgIT09IHZvaWQgMCA/IF9idWlsZGVyJGlzTWF5YmVTaW5nbCA6IGZhbHNlO1xuXHRcdGlmIChidWlsZGVyLmZldGNoKSB0aGlzLmZldGNoID0gYnVpbGRlci5mZXRjaDtcblx0XHRlbHNlIHRoaXMuZmV0Y2ggPSBmZXRjaDtcblx0fVxuXHQvKipcblx0KiBJZiB0aGVyZSdzIGFuIGVycm9yIHdpdGggdGhlIHF1ZXJ5LCB0aHJvd09uRXJyb3Igd2lsbCByZWplY3QgdGhlIHByb21pc2UgYnlcblx0KiB0aHJvd2luZyB0aGUgZXJyb3IgaW5zdGVhZCBvZiByZXR1cm5pbmcgaXQgYXMgcGFydCBvZiBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG5cdCpcblx0KiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3N1cGFiYXNlLWpzL2lzc3Vlcy85Mn1cblx0Ki9cblx0dGhyb3dPbkVycm9yKCkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBTZXQgYW4gSFRUUCBoZWFkZXIgZm9yIHRoZSByZXF1ZXN0LlxuXHQqL1xuXHRzZXRIZWFkZXIobmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpO1xuXHRcdHRoaXMuaGVhZGVycy5zZXQobmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdGlmICh0aGlzLnNjaGVtYSA9PT0gdm9pZCAwKSB7fSBlbHNlIGlmIChbXCJHRVRcIiwgXCJIRUFEXCJdLmluY2x1ZGVzKHRoaXMubWV0aG9kKSkgdGhpcy5oZWFkZXJzLnNldChcIkFjY2VwdC1Qcm9maWxlXCIsIHRoaXMuc2NoZW1hKTtcblx0XHRlbHNlIHRoaXMuaGVhZGVycy5zZXQoXCJDb250ZW50LVByb2ZpbGVcIiwgdGhpcy5zY2hlbWEpO1xuXHRcdGlmICh0aGlzLm1ldGhvZCAhPT0gXCJHRVRcIiAmJiB0aGlzLm1ldGhvZCAhPT0gXCJIRUFEXCIpIHRoaXMuaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHRcdGNvbnN0IF9mZXRjaCA9IHRoaXMuZmV0Y2g7XG5cdFx0bGV0IHJlcyA9IF9mZXRjaCh0aGlzLnVybC50b1N0cmluZygpLCB7XG5cdFx0XHRtZXRob2Q6IHRoaXMubWV0aG9kLFxuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0Ym9keTogSlNPTi5zdHJpbmdpZnkodGhpcy5ib2R5KSxcblx0XHRcdHNpZ25hbDogdGhpcy5zaWduYWxcblx0XHR9KS50aGVuKGFzeW5jIChyZXMkMSkgPT4ge1xuXHRcdFx0bGV0IGVycm9yID0gbnVsbDtcblx0XHRcdGxldCBkYXRhID0gbnVsbDtcblx0XHRcdGxldCBjb3VudCA9IG51bGw7XG5cdFx0XHRsZXQgc3RhdHVzID0gcmVzJDEuc3RhdHVzO1xuXHRcdFx0bGV0IHN0YXR1c1RleHQgPSByZXMkMS5zdGF0dXNUZXh0O1xuXHRcdFx0aWYgKHJlcyQxLm9rKSB7XG5cdFx0XHRcdHZhciBfdGhpcyRoZWFkZXJzJGdldDIsIF9yZXMkaGVhZGVycyRnZXQ7XG5cdFx0XHRcdGlmIChfdGhpcy5tZXRob2QgIT09IFwiSEVBRFwiKSB7XG5cdFx0XHRcdFx0dmFyIF90aGlzJGhlYWRlcnMkZ2V0O1xuXHRcdFx0XHRcdGNvbnN0IGJvZHkgPSBhd2FpdCByZXMkMS50ZXh0KCk7XG5cdFx0XHRcdFx0aWYgKGJvZHkgPT09IFwiXCIpIHt9IGVsc2UgaWYgKF90aGlzLmhlYWRlcnMuZ2V0KFwiQWNjZXB0XCIpID09PSBcInRleHQvY3N2XCIpIGRhdGEgPSBib2R5O1xuXHRcdFx0XHRcdGVsc2UgaWYgKF90aGlzLmhlYWRlcnMuZ2V0KFwiQWNjZXB0XCIpICYmICgoX3RoaXMkaGVhZGVycyRnZXQgPSBfdGhpcy5oZWFkZXJzLmdldChcIkFjY2VwdFwiKSkgPT09IG51bGwgfHwgX3RoaXMkaGVhZGVycyRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGhlYWRlcnMkZ2V0LmluY2x1ZGVzKFwiYXBwbGljYXRpb24vdm5kLnBncnN0LnBsYW4rdGV4dFwiKSkpIGRhdGEgPSBib2R5O1xuXHRcdFx0XHRcdGVsc2UgZGF0YSA9IEpTT04ucGFyc2UoYm9keSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgY291bnRIZWFkZXIgPSAoX3RoaXMkaGVhZGVycyRnZXQyID0gX3RoaXMuaGVhZGVycy5nZXQoXCJQcmVmZXJcIikpID09PSBudWxsIHx8IF90aGlzJGhlYWRlcnMkZ2V0MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkaGVhZGVycyRnZXQyLm1hdGNoKC9jb3VudD0oZXhhY3R8cGxhbm5lZHxlc3RpbWF0ZWQpLyk7XG5cdFx0XHRcdGNvbnN0IGNvbnRlbnRSYW5nZSA9IChfcmVzJGhlYWRlcnMkZ2V0ID0gcmVzJDEuaGVhZGVycy5nZXQoXCJjb250ZW50LXJhbmdlXCIpKSA9PT0gbnVsbCB8fCBfcmVzJGhlYWRlcnMkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzJGhlYWRlcnMkZ2V0LnNwbGl0KFwiL1wiKTtcblx0XHRcdFx0aWYgKGNvdW50SGVhZGVyICYmIGNvbnRlbnRSYW5nZSAmJiBjb250ZW50UmFuZ2UubGVuZ3RoID4gMSkgY291bnQgPSBwYXJzZUludChjb250ZW50UmFuZ2VbMV0pO1xuXHRcdFx0XHRpZiAoX3RoaXMuaXNNYXliZVNpbmdsZSAmJiBfdGhpcy5tZXRob2QgPT09IFwiR0VUXCIgJiYgQXJyYXkuaXNBcnJheShkYXRhKSkgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGVycm9yID0ge1xuXHRcdFx0XHRcdFx0Y29kZTogXCJQR1JTVDExNlwiLFxuXHRcdFx0XHRcdFx0ZGV0YWlsczogYFJlc3VsdHMgY29udGFpbiAke2RhdGEubGVuZ3RofSByb3dzLCBhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24gcmVxdWlyZXMgMSByb3dgLFxuXHRcdFx0XHRcdFx0aGludDogbnVsbCxcblx0XHRcdFx0XHRcdG1lc3NhZ2U6IFwiSlNPTiBvYmplY3QgcmVxdWVzdGVkLCBtdWx0aXBsZSAob3Igbm8pIHJvd3MgcmV0dXJuZWRcIlxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0ZGF0YSA9IG51bGw7XG5cdFx0XHRcdFx0Y291bnQgPSBudWxsO1xuXHRcdFx0XHRcdHN0YXR1cyA9IDQwNjtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJOb3QgQWNjZXB0YWJsZVwiO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGRhdGEubGVuZ3RoID09PSAxKSBkYXRhID0gZGF0YVswXTtcblx0XHRcdFx0ZWxzZSBkYXRhID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBfZXJyb3IkZGV0YWlscztcblx0XHRcdFx0Y29uc3QgYm9keSA9IGF3YWl0IHJlcyQxLnRleHQoKTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRlcnJvciA9IEpTT04ucGFyc2UoYm9keSk7XG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZXJyb3IpICYmIHJlcyQxLnN0YXR1cyA9PT0gNDA0KSB7XG5cdFx0XHRcdFx0XHRkYXRhID0gW107XG5cdFx0XHRcdFx0XHRlcnJvciA9IG51bGw7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAyMDA7XG5cdFx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJPS1wiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoX3VudXNlZCkge1xuXHRcdFx0XHRcdGlmIChyZXMkMS5zdGF0dXMgPT09IDQwNCAmJiBib2R5ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAyMDQ7XG5cdFx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJObyBDb250ZW50XCI7XG5cdFx0XHRcdFx0fSBlbHNlIGVycm9yID0geyBtZXNzYWdlOiBib2R5IH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVycm9yICYmIF90aGlzLmlzTWF5YmVTaW5nbGUgJiYgKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgfHwgKF9lcnJvciRkZXRhaWxzID0gZXJyb3IuZGV0YWlscykgPT09IG51bGwgfHwgX2Vycm9yJGRldGFpbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lcnJvciRkZXRhaWxzLmluY2x1ZGVzKFwiMCByb3dzXCIpKSkge1xuXHRcdFx0XHRcdGVycm9yID0gbnVsbDtcblx0XHRcdFx0XHRzdGF0dXMgPSAyMDA7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiT0tcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZXJyb3IgJiYgX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBuZXcgUG9zdGdyZXN0RXJyb3IoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXJyb3IsXG5cdFx0XHRcdGRhdGEsXG5cdFx0XHRcdGNvdW50LFxuXHRcdFx0XHRzdGF0dXMsXG5cdFx0XHRcdHN0YXR1c1RleHRcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0aWYgKCF0aGlzLnNob3VsZFRocm93T25FcnJvcikgcmVzID0gcmVzLmNhdGNoKChmZXRjaEVycm9yKSA9PiB7XG5cdFx0XHR2YXIgX2ZldGNoRXJyb3IkbmFtZTI7XG5cdFx0XHRsZXQgZXJyb3JEZXRhaWxzID0gXCJcIjtcblx0XHRcdGNvbnN0IGNhdXNlID0gZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLmNhdXNlO1xuXHRcdFx0aWYgKGNhdXNlKSB7XG5cdFx0XHRcdHZhciBfY2F1c2UkbWVzc2FnZSwgX2NhdXNlJGNvZGUsIF9mZXRjaEVycm9yJG5hbWUsIF9jYXVzZSRuYW1lO1xuXHRcdFx0XHRjb25zdCBjYXVzZU1lc3NhZ2UgPSAoX2NhdXNlJG1lc3NhZ2UgPSBjYXVzZSA9PT0gbnVsbCB8fCBjYXVzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2F1c2UubWVzc2FnZSkgIT09IG51bGwgJiYgX2NhdXNlJG1lc3NhZ2UgIT09IHZvaWQgMCA/IF9jYXVzZSRtZXNzYWdlIDogXCJcIjtcblx0XHRcdFx0Y29uc3QgY2F1c2VDb2RlID0gKF9jYXVzZSRjb2RlID0gY2F1c2UgPT09IG51bGwgfHwgY2F1c2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhdXNlLmNvZGUpICE9PSBudWxsICYmIF9jYXVzZSRjb2RlICE9PSB2b2lkIDAgPyBfY2F1c2UkY29kZSA6IFwiXCI7XG5cdFx0XHRcdGVycm9yRGV0YWlscyA9IGAkeyhfZmV0Y2hFcnJvciRuYW1lID0gZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLm5hbWUpICE9PSBudWxsICYmIF9mZXRjaEVycm9yJG5hbWUgIT09IHZvaWQgMCA/IF9mZXRjaEVycm9yJG5hbWUgOiBcIkZldGNoRXJyb3JcIn06ICR7ZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLm1lc3NhZ2V9YDtcblx0XHRcdFx0ZXJyb3JEZXRhaWxzICs9IGBcXG5cXG5DYXVzZWQgYnk6ICR7KF9jYXVzZSRuYW1lID0gY2F1c2UgPT09IG51bGwgfHwgY2F1c2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhdXNlLm5hbWUpICE9PSBudWxsICYmIF9jYXVzZSRuYW1lICE9PSB2b2lkIDAgPyBfY2F1c2UkbmFtZSA6IFwiRXJyb3JcIn06ICR7Y2F1c2VNZXNzYWdlfWA7XG5cdFx0XHRcdGlmIChjYXVzZUNvZGUpIGVycm9yRGV0YWlscyArPSBgICgke2NhdXNlQ29kZX0pYDtcblx0XHRcdFx0aWYgKGNhdXNlID09PSBudWxsIHx8IGNhdXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXVzZS5zdGFjaykgZXJyb3JEZXRhaWxzICs9IGBcXG4ke2NhdXNlLnN0YWNrfWA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgX2ZldGNoRXJyb3Ikc3RhY2s7XG5cdFx0XHRcdGVycm9yRGV0YWlscyA9IChfZmV0Y2hFcnJvciRzdGFjayA9IGZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5zdGFjaykgIT09IG51bGwgJiYgX2ZldGNoRXJyb3Ikc3RhY2sgIT09IHZvaWQgMCA/IF9mZXRjaEVycm9yJHN0YWNrIDogXCJcIjtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGVycm9yOiB7XG5cdFx0XHRcdFx0bWVzc2FnZTogYCR7KF9mZXRjaEVycm9yJG5hbWUyID0gZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLm5hbWUpICE9PSBudWxsICYmIF9mZXRjaEVycm9yJG5hbWUyICE9PSB2b2lkIDAgPyBfZmV0Y2hFcnJvciRuYW1lMiA6IFwiRmV0Y2hFcnJvclwifTogJHtmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IubWVzc2FnZX1gLFxuXHRcdFx0XHRcdGRldGFpbHM6IGVycm9yRGV0YWlscyxcblx0XHRcdFx0XHRoaW50OiBcIlwiLFxuXHRcdFx0XHRcdGNvZGU6IFwiXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0Y291bnQ6IG51bGwsXG5cdFx0XHRcdHN0YXR1czogMCxcblx0XHRcdFx0c3RhdHVzVGV4dDogXCJcIlxuXHRcdFx0fTtcblx0XHR9KTtcblx0XHRyZXR1cm4gcmVzLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuXHR9XG5cdC8qKlxuXHQqIE92ZXJyaWRlIHRoZSB0eXBlIG9mIHRoZSByZXR1cm5lZCBgZGF0YWAuXG5cdCpcblx0KiBAdHlwZVBhcmFtIE5ld1Jlc3VsdCAtIFRoZSBuZXcgcmVzdWx0IHR5cGUgdG8gb3ZlcnJpZGUgd2l0aFxuXHQqIEBkZXByZWNhdGVkIFVzZSBvdmVycmlkZVR5cGVzPHlvdXJUeXBlLCB7IG1lcmdlOiBmYWxzZSB9PigpIG1ldGhvZCBhdCB0aGUgZW5kIG9mIHlvdXIgY2FsbCBjaGFpbiBpbnN0ZWFkXG5cdCovXG5cdHJldHVybnMoKSB7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPdmVycmlkZSB0aGUgdHlwZSBvZiB0aGUgcmV0dXJuZWQgYGRhdGFgIGZpZWxkIGluIHRoZSByZXNwb25zZS5cblx0KlxuXHQqIEB0eXBlUGFyYW0gTmV3UmVzdWx0IC0gVGhlIG5ldyB0eXBlIHRvIGNhc3QgdGhlIHJlc3BvbnNlIGRhdGEgdG9cblx0KiBAdHlwZVBhcmFtIE9wdGlvbnMgLSBPcHRpb25hbCB0eXBlIGNvbmZpZ3VyYXRpb24gKGRlZmF1bHRzIHRvIHsgbWVyZ2U6IHRydWUgfSlcblx0KiBAdHlwZVBhcmFtIE9wdGlvbnMubWVyZ2UgLSBXaGVuIHRydWUsIG1lcmdlcyB0aGUgbmV3IHR5cGUgd2l0aCBleGlzdGluZyByZXR1cm4gdHlwZS4gV2hlbiBmYWxzZSwgcmVwbGFjZXMgdGhlIGV4aXN0aW5nIHR5cGVzIGVudGlyZWx5IChkZWZhdWx0cyB0byB0cnVlKVxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIC8vIE1lcmdlIHdpdGggZXhpc3RpbmcgdHlwZXMgKGRlZmF1bHQgYmVoYXZpb3IpXG5cdCogY29uc3QgcXVlcnkgPSBzdXBhYmFzZVxuXHQqICAgLmZyb20oJ3VzZXJzJylcblx0KiAgIC5zZWxlY3QoKVxuXHQqICAgLm92ZXJyaWRlVHlwZXM8eyBjdXN0b21fZmllbGQ6IHN0cmluZyB9PigpXG5cdCpcblx0KiAvLyBSZXBsYWNlIGV4aXN0aW5nIHR5cGVzIGNvbXBsZXRlbHlcblx0KiBjb25zdCByZXBsYWNlUXVlcnkgPSBzdXBhYmFzZVxuXHQqICAgLmZyb20oJ3VzZXJzJylcblx0KiAgIC5zZWxlY3QoKVxuXHQqICAgLm92ZXJyaWRlVHlwZXM8eyBpZDogbnVtYmVyOyBuYW1lOiBzdHJpbmcgfSwgeyBtZXJnZTogZmFsc2UgfT4oKVxuXHQqIGBgYFxuXHQqIEByZXR1cm5zIEEgUG9zdGdyZXN0QnVpbGRlciBpbnN0YW5jZSB3aXRoIHRoZSBuZXcgdHlwZVxuXHQqL1xuXHRvdmVycmlkZVR5cGVzKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlci50c1xudmFyIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFBvc3RncmVzdEJ1aWxkZXIge1xuXHQvKipcblx0KiBQZXJmb3JtIGEgU0VMRUNUIG9uIHRoZSBxdWVyeSByZXN1bHQuXG5cdCpcblx0KiBCeSBkZWZhdWx0LCBgLmluc2VydCgpYCwgYC51cGRhdGUoKWAsIGAudXBzZXJ0KClgLCBhbmQgYC5kZWxldGUoKWAgZG8gbm90XG5cdCogcmV0dXJuIG1vZGlmaWVkIHJvd3MuIEJ5IGNhbGxpbmcgdGhpcyBtZXRob2QsIG1vZGlmaWVkIHJvd3MgYXJlIHJldHVybmVkIGluXG5cdCogYGRhdGFgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbnMgLSBUaGUgY29sdW1ucyB0byByZXRyaWV2ZSwgc2VwYXJhdGVkIGJ5IGNvbW1hc1xuXHQqL1xuXHRzZWxlY3QoY29sdW1ucykge1xuXHRcdGxldCBxdW90ZWQgPSBmYWxzZTtcblx0XHRjb25zdCBjbGVhbmVkQ29sdW1ucyA9IChjb2x1bW5zICE9PSBudWxsICYmIGNvbHVtbnMgIT09IHZvaWQgMCA/IGNvbHVtbnMgOiBcIipcIikuc3BsaXQoXCJcIikubWFwKChjKSA9PiB7XG5cdFx0XHRpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSByZXR1cm4gXCJcIjtcblx0XHRcdGlmIChjID09PSBcIlxcXCJcIikgcXVvdGVkID0gIXF1b3RlZDtcblx0XHRcdHJldHVybiBjO1xuXHRcdH0pLmpvaW4oXCJcIik7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChcInNlbGVjdFwiLCBjbGVhbmVkQ29sdW1ucyk7XG5cdFx0dGhpcy5oZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBcInJldHVybj1yZXByZXNlbnRhdGlvblwiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPcmRlciB0aGUgcXVlcnkgcmVzdWx0IGJ5IGBjb2x1bW5gLlxuXHQqXG5cdCogWW91IGNhbiBjYWxsIHRoaXMgbWV0aG9kIG11bHRpcGxlIHRpbWVzIHRvIG9yZGVyIGJ5IG11bHRpcGxlIGNvbHVtbnMuXG5cdCpcblx0KiBZb3UgY2FuIG9yZGVyIHJlZmVyZW5jZWQgdGFibGVzLCBidXQgaXQgb25seSBhZmZlY3RzIHRoZSBvcmRlcmluZyBvZiB0aGVcblx0KiBwYXJlbnQgdGFibGUgaWYgeW91IHVzZSBgIWlubmVyYCBpbiB0aGUgcXVlcnkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBvcmRlciBieVxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLmFzY2VuZGluZyAtIElmIGB0cnVlYCwgdGhlIHJlc3VsdCB3aWxsIGJlIGluIGFzY2VuZGluZyBvcmRlclxuXHQqIEBwYXJhbSBvcHRpb25zLm51bGxzRmlyc3QgLSBJZiBgdHJ1ZWAsIGBudWxsYHMgYXBwZWFyIGZpcnN0LiBJZiBgZmFsc2VgLFxuXHQqIGBudWxsYHMgYXBwZWFyIGxhc3QuXG5cdCogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gb3JkZXIgYSByZWZlcmVuY2VkIHRhYmxlIGJ5XG5cdCogaXRzIGNvbHVtbnNcblx0KiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuXHQqIGluc3RlYWRcblx0Ki9cblx0b3JkZXIoY29sdW1uLCB7IGFzY2VuZGluZyA9IHRydWUsIG51bGxzRmlyc3QsIGZvcmVpZ25UYWJsZSwgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlIH0gPSB7fSkge1xuXHRcdGNvbnN0IGtleSA9IHJlZmVyZW5jZWRUYWJsZSA/IGAke3JlZmVyZW5jZWRUYWJsZX0ub3JkZXJgIDogXCJvcmRlclwiO1xuXHRcdGNvbnN0IGV4aXN0aW5nT3JkZXIgPSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuZ2V0KGtleSk7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIGAke2V4aXN0aW5nT3JkZXIgPyBgJHtleGlzdGluZ09yZGVyfSxgIDogXCJcIn0ke2NvbHVtbn0uJHthc2NlbmRpbmcgPyBcImFzY1wiIDogXCJkZXNjXCJ9JHtudWxsc0ZpcnN0ID09PSB2b2lkIDAgPyBcIlwiIDogbnVsbHNGaXJzdCA/IFwiLm51bGxzZmlyc3RcIiA6IFwiLm51bGxzbGFzdFwifWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIExpbWl0IHRoZSBxdWVyeSByZXN1bHQgYnkgYGNvdW50YC5cblx0KlxuXHQqIEBwYXJhbSBjb3VudCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIHJldHVyblxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGxpbWl0IHJvd3Mgb2YgcmVmZXJlbmNlZFxuXHQqIHRhYmxlcyBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgdGFibGVcblx0KiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuXHQqIGluc3RlYWRcblx0Ki9cblx0bGltaXQoY291bnQsIHsgZm9yZWlnblRhYmxlLCByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUgfSA9IHt9KSB7XG5cdFx0Y29uc3Qga2V5ID0gdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwibGltaXRcIiA6IGAke3JlZmVyZW5jZWRUYWJsZX0ubGltaXRgO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCBgJHtjb3VudH1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBMaW1pdCB0aGUgcXVlcnkgcmVzdWx0IGJ5IHN0YXJ0aW5nIGF0IGFuIG9mZnNldCBgZnJvbWAgYW5kIGVuZGluZyBhdCB0aGUgb2Zmc2V0IGB0b2AuXG5cdCogT25seSByZWNvcmRzIHdpdGhpbiB0aGlzIHJhbmdlIGFyZSByZXR1cm5lZC5cblx0KiBUaGlzIHJlc3BlY3RzIHRoZSBxdWVyeSBvcmRlciBhbmQgaWYgdGhlcmUgaXMgbm8gb3JkZXIgY2xhdXNlIHRoZSByYW5nZSBjb3VsZCBiZWhhdmUgdW5leHBlY3RlZGx5LlxuXHQqIFRoZSBgZnJvbWAgYW5kIGB0b2AgdmFsdWVzIGFyZSAwLWJhc2VkIGFuZCBpbmNsdXNpdmU6IGByYW5nZSgxLCAzKWAgd2lsbCBpbmNsdWRlIHRoZSBzZWNvbmQsIHRoaXJkXG5cdCogYW5kIGZvdXJ0aCByb3dzIG9mIHRoZSBxdWVyeS5cblx0KlxuXHQqIEBwYXJhbSBmcm9tIC0gVGhlIHN0YXJ0aW5nIGluZGV4IGZyb20gd2hpY2ggdG8gbGltaXQgdGhlIHJlc3VsdFxuXHQqIEBwYXJhbSB0byAtIFRoZSBsYXN0IGluZGV4IHRvIHdoaWNoIHRvIGxpbWl0IHRoZSByZXN1bHRcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBsaW1pdCByb3dzIG9mIHJlZmVyZW5jZWRcblx0KiB0YWJsZXMgaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG5cdCogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcblx0KiBpbnN0ZWFkXG5cdCovXG5cdHJhbmdlKGZyb20sIHRvLCB7IGZvcmVpZ25UYWJsZSwgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlIH0gPSB7fSkge1xuXHRcdGNvbnN0IGtleU9mZnNldCA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09IFwidW5kZWZpbmVkXCIgPyBcIm9mZnNldFwiIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5vZmZzZXRgO1xuXHRcdGNvbnN0IGtleUxpbWl0ID0gdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwibGltaXRcIiA6IGAke3JlZmVyZW5jZWRUYWJsZX0ubGltaXRgO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5T2Zmc2V0LCBgJHtmcm9tfWApO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5TGltaXQsIGAke3RvIC0gZnJvbSArIDF9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogU2V0IHRoZSBBYm9ydFNpZ25hbCBmb3IgdGhlIGZldGNoIHJlcXVlc3QuXG5cdCpcblx0KiBAcGFyYW0gc2lnbmFsIC0gVGhlIEFib3J0U2lnbmFsIHRvIHVzZSBmb3IgdGhlIGZldGNoIHJlcXVlc3Rcblx0Ki9cblx0YWJvcnRTaWduYWwoc2lnbmFsKSB7XG5cdFx0dGhpcy5zaWduYWwgPSBzaWduYWw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogUmV0dXJuIGBkYXRhYCBhcyBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheSBvZiBvYmplY3RzLlxuXHQqXG5cdCogUXVlcnkgcmVzdWx0IG11c3QgYmUgb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZSB0aGlzXG5cdCogcmV0dXJucyBhbiBlcnJvci5cblx0Ki9cblx0c2luZ2xlKCkge1xuXHRcdHRoaXMuaGVhZGVycy5zZXQoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb25cIik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogUmV0dXJuIGBkYXRhYCBhcyBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheSBvZiBvYmplY3RzLlxuXHQqXG5cdCogUXVlcnkgcmVzdWx0IG11c3QgYmUgemVybyBvciBvbmUgcm93IChlLmcuIHVzaW5nIGAubGltaXQoMSlgKSwgb3RoZXJ3aXNlXG5cdCogdGhpcyByZXR1cm5zIGFuIGVycm9yLlxuXHQqL1xuXHRtYXliZVNpbmdsZSgpIHtcblx0XHRpZiAodGhpcy5tZXRob2QgPT09IFwiR0VUXCIpIHRoaXMuaGVhZGVycy5zZXQoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHRcdGVsc2UgdGhpcy5oZWFkZXJzLnNldChcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5vYmplY3QranNvblwiKTtcblx0XHR0aGlzLmlzTWF5YmVTaW5nbGUgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFJldHVybiBgZGF0YWAgYXMgYSBzdHJpbmcgaW4gQ1NWIGZvcm1hdC5cblx0Ki9cblx0Y3N2KCkge1xuXHRcdHRoaXMuaGVhZGVycy5zZXQoXCJBY2NlcHRcIiwgXCJ0ZXh0L2NzdlwiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBSZXR1cm4gYGRhdGFgIGFzIGFuIG9iamVjdCBpbiBbR2VvSlNPTl0oaHR0cHM6Ly9nZW9qc29uLm9yZykgZm9ybWF0LlxuXHQqL1xuXHRnZW9qc29uKCkge1xuXHRcdHRoaXMuaGVhZGVycy5zZXQoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi9nZW8ranNvblwiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBSZXR1cm4gYGRhdGFgIGFzIHRoZSBFWFBMQUlOIHBsYW4gZm9yIHRoZSBxdWVyeS5cblx0KlxuXHQqIFlvdSBuZWVkIHRvIGVuYWJsZSB0aGVcblx0KiBbZGJfcGxhbl9lbmFibGVkXShodHRwczovL3N1cGFiYXNlLmNvbS9kb2NzL2d1aWRlcy9kYXRhYmFzZS9kZWJ1Z2dpbmctcGVyZm9ybWFuY2UjZW5hYmxpbmctZXhwbGFpbilcblx0KiBzZXR0aW5nIGJlZm9yZSB1c2luZyB0aGlzIG1ldGhvZC5cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuYW5hbHl6ZSAtIElmIGB0cnVlYCwgdGhlIHF1ZXJ5IHdpbGwgYmUgZXhlY3V0ZWQgYW5kIHRoZVxuXHQqIGFjdHVhbCBydW4gdGltZSB3aWxsIGJlIHJldHVybmVkXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy52ZXJib3NlIC0gSWYgYHRydWVgLCB0aGUgcXVlcnkgaWRlbnRpZmllciB3aWxsIGJlIHJldHVybmVkXG5cdCogYW5kIGBkYXRhYCB3aWxsIGluY2x1ZGUgdGhlIG91dHB1dCBjb2x1bW5zIG9mIHRoZSBxdWVyeVxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuc2V0dGluZ3MgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gY29uZmlndXJhdGlvblxuXHQqIHBhcmFtZXRlcnMgdGhhdCBhZmZlY3QgcXVlcnkgcGxhbm5pbmdcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmJ1ZmZlcnMgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gYnVmZmVyIHVzYWdlXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy53YWwgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gV0FMIHJlY29yZCBnZW5lcmF0aW9uXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5mb3JtYXQgLSBUaGUgZm9ybWF0IG9mIHRoZSBvdXRwdXQsIGNhbiBiZSBgXCJ0ZXh0XCJgIChkZWZhdWx0KVxuXHQqIG9yIGBcImpzb25cImBcblx0Ki9cblx0ZXhwbGFpbih7IGFuYWx5emUgPSBmYWxzZSwgdmVyYm9zZSA9IGZhbHNlLCBzZXR0aW5ncyA9IGZhbHNlLCBidWZmZXJzID0gZmFsc2UsIHdhbCA9IGZhbHNlLCBmb3JtYXQgPSBcInRleHRcIiB9ID0ge30pIHtcblx0XHR2YXIgX3RoaXMkaGVhZGVycyRnZXQ7XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IFtcblx0XHRcdGFuYWx5emUgPyBcImFuYWx5emVcIiA6IG51bGwsXG5cdFx0XHR2ZXJib3NlID8gXCJ2ZXJib3NlXCIgOiBudWxsLFxuXHRcdFx0c2V0dGluZ3MgPyBcInNldHRpbmdzXCIgOiBudWxsLFxuXHRcdFx0YnVmZmVycyA/IFwiYnVmZmVyc1wiIDogbnVsbCxcblx0XHRcdHdhbCA/IFwid2FsXCIgOiBudWxsXG5cdFx0XS5maWx0ZXIoQm9vbGVhbikuam9pbihcInxcIik7XG5cdFx0Y29uc3QgZm9yTWVkaWF0eXBlID0gKF90aGlzJGhlYWRlcnMkZ2V0ID0gdGhpcy5oZWFkZXJzLmdldChcIkFjY2VwdFwiKSkgIT09IG51bGwgJiYgX3RoaXMkaGVhZGVycyRnZXQgIT09IHZvaWQgMCA/IF90aGlzJGhlYWRlcnMkZ2V0IDogXCJhcHBsaWNhdGlvbi9qc29uXCI7XG5cdFx0dGhpcy5oZWFkZXJzLnNldChcIkFjY2VwdFwiLCBgYXBwbGljYXRpb24vdm5kLnBncnN0LnBsYW4rJHtmb3JtYXR9OyBmb3I9XCIke2Zvck1lZGlhdHlwZX1cIjsgb3B0aW9ucz0ke29wdGlvbnN9O2ApO1xuXHRcdGlmIChmb3JtYXQgPT09IFwianNvblwiKSByZXR1cm4gdGhpcztcblx0XHRlbHNlIHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFJvbGxiYWNrIHRoZSBxdWVyeS5cblx0KlxuXHQqIGBkYXRhYCB3aWxsIHN0aWxsIGJlIHJldHVybmVkLCBidXQgdGhlIHF1ZXJ5IGlzIG5vdCBjb21taXR0ZWQuXG5cdCovXG5cdHJvbGxiYWNrKCkge1xuXHRcdHRoaXMuaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgXCJ0eD1yb2xsYmFja1wiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPdmVycmlkZSB0aGUgdHlwZSBvZiB0aGUgcmV0dXJuZWQgYGRhdGFgLlxuXHQqXG5cdCogQHR5cGVQYXJhbSBOZXdSZXN1bHQgLSBUaGUgbmV3IHJlc3VsdCB0eXBlIHRvIG92ZXJyaWRlIHdpdGhcblx0KiBAZGVwcmVjYXRlZCBVc2Ugb3ZlcnJpZGVUeXBlczx5b3VyVHlwZSwgeyBtZXJnZTogZmFsc2UgfT4oKSBtZXRob2QgYXQgdGhlIGVuZCBvZiB5b3VyIGNhbGwgY2hhaW4gaW5zdGVhZFxuXHQqL1xuXHRyZXR1cm5zKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFNldCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0aGF0IGNhbiBiZSBhZmZlY3RlZCBieSB0aGUgcXVlcnkuXG5cdCogT25seSBhdmFpbGFibGUgaW4gUG9zdGdSRVNUIHYxMysgYW5kIG9ubHkgd29ya3Mgd2l0aCBQQVRDSCBhbmQgREVMRVRFIG1ldGhvZHMuXG5cdCpcblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0aGF0IGNhbiBiZSBhZmZlY3RlZFxuXHQqL1xuXHRtYXhBZmZlY3RlZCh2YWx1ZSkge1xuXHRcdHRoaXMuaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgXCJoYW5kbGluZz1zdHJpY3RcIik7XG5cdFx0dGhpcy5oZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgbWF4LWFmZmVjdGVkPSR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLnRzXG5jb25zdCBQb3N0Z3Jlc3RSZXNlcnZlZENoYXJzUmVnZXhwID0gLyogQF9fUFVSRV9fICovIG5ldyBSZWdFeHAoXCJbLCgpXVwiKTtcbnZhciBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyIHtcblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGVxdWFsIHRvIGB2YWx1ZWAuXG5cdCpcblx0KiBUbyBjaGVjayBpZiB0aGUgdmFsdWUgb2YgYGNvbHVtbmAgaXMgTlVMTCwgeW91IHNob3VsZCB1c2UgYC5pcygpYCBpbnN0ZWFkLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGVxKGNvbHVtbiwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIG5vdCBlcXVhbCB0byBgdmFsdWVgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdG5lcShjb2x1bW4sIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBuZXEuJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIGB2YWx1ZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0Z3QoY29sdW1uLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZ3QuJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0Z3RlKGNvbHVtbiwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGd0ZS4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBsZXNzIHRoYW4gYHZhbHVlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRsdChjb2x1bW4sIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsdC4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRsdGUoY29sdW1uLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbHRlLiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYHBhdHRlcm5gIGNhc2Utc2Vuc2l0aXZlbHkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcGF0dGVybiAtIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdpdGhcblx0Ki9cblx0bGlrZShjb2x1bW4sIHBhdHRlcm4pIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UuJHtwYXR0ZXJufWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFsbCBvZiBgcGF0dGVybnNgIGNhc2Utc2Vuc2l0aXZlbHkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRsaWtlQWxsT2YoY29sdW1uLCBwYXR0ZXJucykge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZShhbGwpLnske3BhdHRlcm5zLmpvaW4oXCIsXCIpfX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbnkgb2YgYHBhdHRlcm5zYCBjYXNlLXNlbnNpdGl2ZWx5LlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcblx0Ki9cblx0bGlrZUFueU9mKGNvbHVtbiwgcGF0dGVybnMpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UoYW55KS57JHtwYXR0ZXJucy5qb2luKFwiLFwiKX19YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYHBhdHRlcm5gIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRpbGlrZShjb2x1bW4sIHBhdHRlcm4pIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlLiR7cGF0dGVybn1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbGwgb2YgYHBhdHRlcm5zYCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRpbGlrZUFsbE9mKGNvbHVtbiwgcGF0dGVybnMpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlKGFsbCkueyR7cGF0dGVybnMuam9pbihcIixcIil9fWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFueSBvZiBgcGF0dGVybnNgIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG5cdCovXG5cdGlsaWtlQW55T2YoY29sdW1uLCBwYXR0ZXJucykge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UoYW55KS57JHtwYXR0ZXJucy5qb2luKFwiLFwiKX19YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgdGhlIFBvc3RncmVTUUwgcmVnZXggYHBhdHRlcm5gXG5cdCogY2FzZS1zZW5zaXRpdmVseSAodXNpbmcgdGhlIGB+YCBvcGVyYXRvcikuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcGF0dGVybiAtIFRoZSBQb3N0Z3JlU1FMIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIHRvIG1hdGNoIHdpdGhcblx0Ki9cblx0cmVnZXhNYXRjaChjb2x1bW4sIHBhdHRlcm4pIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG1hdGNoLiR7cGF0dGVybn1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyB0aGUgUG9zdGdyZVNRTCByZWdleCBgcGF0dGVybmBcblx0KiBjYXNlLWluc2Vuc2l0aXZlbHkgKHVzaW5nIHRoZSBgfipgIG9wZXJhdG9yKS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIFBvc3RncmVTUUwgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRyZWdleElNYXRjaChjb2x1bW4sIHBhdHRlcm4pIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGltYXRjaC4ke3BhdHRlcm59YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIElTIGB2YWx1ZWAuXG5cdCpcblx0KiBGb3Igbm9uLWJvb2xlYW4gY29sdW1ucywgdGhpcyBpcyBvbmx5IHJlbGV2YW50IGZvciBjaGVja2luZyBpZiB0aGUgdmFsdWUgb2Zcblx0KiBgY29sdW1uYCBpcyBOVUxMIGJ5IHNldHRpbmcgYHZhbHVlYCB0byBgbnVsbGAuXG5cdCpcblx0KiBGb3IgYm9vbGVhbiBjb2x1bW5zLCB5b3UgY2FuIGFsc28gc2V0IGB2YWx1ZWAgdG8gYHRydWVgIG9yIGBmYWxzZWAgYW5kIGl0XG5cdCogd2lsbCBiZWhhdmUgdGhlIHNhbWUgd2F5IGFzIGAuZXEoKWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0aXMoY29sdW1uLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaXMuJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgSVMgRElTVElOQ1QgRlJPTSBgdmFsdWVgLlxuXHQqXG5cdCogVW5saWtlIGAubmVxKClgLCB0aGlzIHRyZWF0cyBgTlVMTGAgYXMgYSBjb21wYXJhYmxlIHZhbHVlLiBUd28gYE5VTExgIHZhbHVlc1xuXHQqIGFyZSBjb25zaWRlcmVkIGVxdWFsIChub3QgZGlzdGluY3QpLCBhbmQgY29tcGFyaW5nIGBOVUxMYCB3aXRoIGFueSBub24tTlVMTFxuXHQqIHZhbHVlIHJldHVybnMgdHJ1ZSAoZGlzdGluY3QpLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGlzRGlzdGluY3QoY29sdW1uLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaXNkaXN0aW5jdC4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBpbmNsdWRlZCBpbiB0aGUgYHZhbHVlc2AgYXJyYXkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyBhcnJheSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRpbihjb2x1bW4sIHZhbHVlcykge1xuXHRcdGNvbnN0IGNsZWFuZWRWYWx1ZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodmFsdWVzKSkubWFwKChzKSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIHMgPT09IFwic3RyaW5nXCIgJiYgUG9zdGdyZXN0UmVzZXJ2ZWRDaGFyc1JlZ2V4cC50ZXN0KHMpKSByZXR1cm4gYFwiJHtzfVwiYDtcblx0XHRcdGVsc2UgcmV0dXJuIGAke3N9YDtcblx0XHR9KS5qb2luKFwiLFwiKTtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGluLigke2NsZWFuZWRWYWx1ZXN9KWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBOT1QgaW5jbHVkZWQgaW4gdGhlIGB2YWx1ZXNgIGFycmF5LlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgYXJyYXkgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0bm90SW4oY29sdW1uLCB2YWx1ZXMpIHtcblx0XHRjb25zdCBjbGVhbmVkVmFsdWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KHZhbHVlcykpLm1hcCgocykgPT4ge1xuXHRcdFx0aWYgKHR5cGVvZiBzID09PSBcInN0cmluZ1wiICYmIFBvc3RncmVzdFJlc2VydmVkQ2hhcnNSZWdleHAudGVzdChzKSkgcmV0dXJuIGBcIiR7c31cImA7XG5cdFx0XHRlbHNlIHJldHVybiBgJHtzfWA7XG5cdFx0fSkuam9pbihcIixcIik7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBub3QuaW4uKCR7Y2xlYW5lZFZhbHVlc30pYCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IganNvbmIsIGFycmF5LCBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG5cdCogYGNvbHVtbmAgY29udGFpbnMgZXZlcnkgZWxlbWVudCBhcHBlYXJpbmcgaW4gYHZhbHVlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0Y29udGFpbnMoY29sdW1uLCB2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MuJHt2YWx1ZX1gKTtcblx0XHRlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjcy57JHt2YWx1ZS5qb2luKFwiLFwiKX19YCk7XG5cdFx0ZWxzZSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNzLiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9ubHkgcmVsZXZhbnQgZm9yIGpzb25iLCBhcnJheSwgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuXHQqIGV2ZXJ5IGVsZW1lbnQgYXBwZWFyaW5nIGluIGBjb2x1bW5gIGlzIGNvbnRhaW5lZCBieSBgdmFsdWVgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRjb250YWluZWRCeShjb2x1bW4sIHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjZC4ke3ZhbHVlfWApO1xuXHRcdGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLnske3ZhbHVlLmpvaW4oXCIsXCIpfX1gKTtcblx0XHRlbHNlIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY2QuJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cblx0KiBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gYW55IGVsZW1lbnQgaW4gYHJhbmdlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRyYW5nZUd0KGNvbHVtbiwgcmFuZ2UpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYHNyLiR7cmFuZ2V9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cblx0KiBgY29sdW1uYCBpcyBlaXRoZXIgY29udGFpbmVkIGluIGByYW5nZWAgb3IgZ3JlYXRlciB0aGFuIGFueSBlbGVtZW50IGluXG5cdCogYHJhbmdlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRyYW5nZUd0ZShjb2x1bW4sIHJhbmdlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBueGwuJHtyYW5nZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuXHQqIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBhbnkgZWxlbWVudCBpbiBgcmFuZ2VgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdHJhbmdlTHQoY29sdW1uLCByYW5nZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgc2wuJHtyYW5nZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuXHQqIGBjb2x1bW5gIGlzIGVpdGhlciBjb250YWluZWQgaW4gYHJhbmdlYCBvciBsZXNzIHRoYW4gYW55IGVsZW1lbnQgaW5cblx0KiBgcmFuZ2VgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdHJhbmdlTHRlKGNvbHVtbiwgcmFuZ2UpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG54ci4ke3JhbmdlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpc1xuXHQqIG11dHVhbGx5IGV4Y2x1c2l2ZSB0byBgcmFuZ2VgIGFuZCB0aGVyZSBjYW4gYmUgbm8gZWxlbWVudCBiZXR3ZWVuIHRoZSB0d29cblx0KiByYW5nZXMuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0cmFuZ2VBZGphY2VudChjb2x1bW4sIHJhbmdlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBhZGouJHtyYW5nZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciBhcnJheSBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG5cdCogYGNvbHVtbmAgYW5kIGB2YWx1ZWAgaGF2ZSBhbiBlbGVtZW50IGluIGNvbW1vbi5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgYXJyYXkgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhcnJheSBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRvdmVybGFwcyhjb2x1bW4sIHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBvdi4ke3ZhbHVlfWApO1xuXHRcdGVsc2UgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBvdi57JHt2YWx1ZS5qb2luKFwiLFwiKX19YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IgdGV4dCBhbmQgdHN2ZWN0b3IgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG5cdCogYGNvbHVtbmAgbWF0Y2hlcyB0aGUgcXVlcnkgc3RyaW5nIGluIGBxdWVyeWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIHRleHQgb3IgdHN2ZWN0b3IgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0ZXh0IHRvIG1hdGNoIHdpdGhcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5jb25maWcgLSBUaGUgdGV4dCBzZWFyY2ggY29uZmlndXJhdGlvbiB0byB1c2Vcblx0KiBAcGFyYW0gb3B0aW9ucy50eXBlIC0gQ2hhbmdlIGhvdyB0aGUgYHF1ZXJ5YCB0ZXh0IGlzIGludGVycHJldGVkXG5cdCovXG5cdHRleHRTZWFyY2goY29sdW1uLCBxdWVyeSwgeyBjb25maWcsIHR5cGUgfSA9IHt9KSB7XG5cdFx0bGV0IHR5cGVQYXJ0ID0gXCJcIjtcblx0XHRpZiAodHlwZSA9PT0gXCJwbGFpblwiKSB0eXBlUGFydCA9IFwicGxcIjtcblx0XHRlbHNlIGlmICh0eXBlID09PSBcInBocmFzZVwiKSB0eXBlUGFydCA9IFwicGhcIjtcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIndlYnNlYXJjaFwiKSB0eXBlUGFydCA9IFwid1wiO1xuXHRcdGNvbnN0IGNvbmZpZ1BhcnQgPSBjb25maWcgPT09IHZvaWQgMCA/IFwiXCIgOiBgKCR7Y29uZmlnfSlgO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgJHt0eXBlUGFydH1mdHMke2NvbmZpZ1BhcnR9LiR7cXVlcnl9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGVhY2ggY29sdW1uIGluIGBxdWVyeWAga2V5cyBpcyBlcXVhbCB0byBpdHNcblx0KiBhc3NvY2lhdGVkIHZhbHVlLiBTaG9ydGhhbmQgZm9yIG11bHRpcGxlIGAuZXEoKWBzLlxuXHQqXG5cdCogQHBhcmFtIHF1ZXJ5IC0gVGhlIG9iamVjdCB0byBmaWx0ZXIgd2l0aCwgd2l0aCBjb2x1bW4gbmFtZXMgYXMga2V5cyBtYXBwZWRcblx0KiB0byB0aGVpciBmaWx0ZXIgdmFsdWVzXG5cdCovXG5cdG1hdGNoKHF1ZXJ5KSB7XG5cdFx0T2JqZWN0LmVudHJpZXMocXVlcnkpLmZvckVhY2goKFtjb2x1bW4sIHZhbHVlXSkgPT4ge1xuXHRcdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBlcS4ke3ZhbHVlfWApO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBkb2Vzbid0IHNhdGlzZnkgdGhlIGZpbHRlci5cblx0KlxuXHQqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBvcGVhcmF0b3JgIGFuZCBgdmFsdWVgIGFyZSB1c2VkIGFzLWlzIGFuZCBuZWVkIHRvXG5cdCogZm9sbG93IFtQb3N0Z1JFU1Rcblx0KiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuXHQqIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBwcm9wZXJseSBzYW5pdGl6ZWQuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gb3BlcmF0b3IgLSBUaGUgb3BlcmF0b3IgdG8gYmUgbmVnYXRlZCB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nXG5cdCogUG9zdGdSRVNUIHN5bnRheFxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcblx0Ki9cblx0bm90KGNvbHVtbiwgb3BlcmF0b3IsIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBub3QuJHtvcGVyYXRvcn0uJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggc2F0aXNmeSBhdCBsZWFzdCBvbmUgb2YgdGhlIGZpbHRlcnMuXG5cdCpcblx0KiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgZmlsdGVyc2AgaXMgdXNlZCBhcy1pcyBhbmQgbmVlZHMgdG8gZm9sbG93IFtQb3N0Z1JFU1Rcblx0KiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuXHQqIHRvIG1ha2Ugc3VyZSBpdCdzIHByb3Blcmx5IHNhbml0aXplZC5cblx0KlxuXHQqIEl0J3MgY3VycmVudGx5IG5vdCBwb3NzaWJsZSB0byBkbyBhbiBgLm9yKClgIGZpbHRlciBhY3Jvc3MgbXVsdGlwbGUgdGFibGVzLlxuXHQqXG5cdCogQHBhcmFtIGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byB1c2UsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gZmlsdGVyIG9uIHJlZmVyZW5jZWQgdGFibGVzXG5cdCogaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG5cdCogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGByZWZlcmVuY2VkVGFibGVgIGluc3RlYWRcblx0Ki9cblx0b3IoZmlsdGVycywgeyBmb3JlaWduVGFibGUsIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSB9ID0ge30pIHtcblx0XHRjb25zdCBrZXkgPSByZWZlcmVuY2VkVGFibGUgPyBgJHtyZWZlcmVuY2VkVGFibGV9Lm9yYCA6IFwib3JcIjtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgYCgke2ZpbHRlcnN9KWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBzYXRpc2Z5IHRoZSBmaWx0ZXIuIFRoaXMgaXMgYW4gZXNjYXBlIGhhdGNoIC0geW91XG5cdCogc2hvdWxkIHVzZSB0aGUgc3BlY2lmaWMgZmlsdGVyIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUuXG5cdCpcblx0KiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgb3BlYXJhdG9yYCBhbmQgYHZhbHVlYCBhcmUgdXNlZCBhcy1pcyBhbmQgbmVlZCB0b1xuXHQqIGZvbGxvdyBbUG9zdGdSRVNUXG5cdCogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcblx0KiB0byBtYWtlIHN1cmUgdGhleSBhcmUgcHJvcGVybHkgc2FuaXRpemVkLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIG9wZXJhdG9yIC0gVGhlIG9wZXJhdG9yIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcblx0Ki9cblx0ZmlsdGVyKGNvbHVtbiwgb3BlcmF0b3IsIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGAke29wZXJhdG9yfS4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvUG9zdGdyZXN0UXVlcnlCdWlsZGVyLnRzXG52YXIgUG9zdGdyZXN0UXVlcnlCdWlsZGVyID0gY2xhc3Mge1xuXHQvKipcblx0KiBDcmVhdGVzIGEgcXVlcnkgYnVpbGRlciBzY29wZWQgdG8gYSBQb3N0Z3JlcyB0YWJsZSBvciB2aWV3LlxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0c1xuXHQqIGltcG9ydCBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgZnJvbSAnQHN1cGFiYXNlL3Bvc3RncmVzdC1qcydcblx0KlxuXHQqIGNvbnN0IHF1ZXJ5ID0gbmV3IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcihcblx0KiAgIG5ldyBVUkwoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9yZXN0L3YxL3VzZXJzJyksXG5cdCogICB7IGhlYWRlcnM6IHsgYXBpa2V5OiAncHVibGljLWFub24ta2V5JyB9IH1cblx0KiApXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgeyBoZWFkZXJzID0ge30sIHNjaGVtYSwgZmV0Y2g6IGZldGNoJDEgfSkge1xuXHRcdHRoaXMudXJsID0gdXJsO1xuXHRcdHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMpO1xuXHRcdHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuXHRcdHRoaXMuZmV0Y2ggPSBmZXRjaCQxO1xuXHR9XG5cdC8qKlxuXHQqIENsb25lIFVSTCBhbmQgaGVhZGVycyB0byBwcmV2ZW50IHNoYXJlZCBzdGF0ZSBiZXR3ZWVuIG9wZXJhdGlvbnMuXG5cdCovXG5cdGNsb25lUmVxdWVzdFN0YXRlKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR1cmw6IG5ldyBVUkwodGhpcy51cmwudG9TdHJpbmcoKSksXG5cdFx0XHRoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpXG5cdFx0fTtcblx0fVxuXHQvKipcblx0KiBQZXJmb3JtIGEgU0VMRUNUIHF1ZXJ5IG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbnMgLSBUaGUgY29sdW1ucyB0byByZXRyaWV2ZSwgc2VwYXJhdGVkIGJ5IGNvbW1hcy4gQ29sdW1ucyBjYW4gYmUgcmVuYW1lZCB3aGVuIHJldHVybmVkIHdpdGggYGN1c3RvbU5hbWU6Y29sdW1uTmFtZWBcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuXHQqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIGluIHRoZSB0YWJsZSBvciB2aWV3LlxuXHQqXG5cdCogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuXHQqIGhvb2QuXG5cdCpcblx0KiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuXHQqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG5cdCpcblx0KiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG5cdCogbnVtYmVycy5cblx0Ki9cblx0c2VsZWN0KGNvbHVtbnMsIG9wdGlvbnMpIHtcblx0XHRjb25zdCB7IGhlYWQgPSBmYWxzZSwgY291bnQgfSA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuXHRcdGNvbnN0IG1ldGhvZCA9IGhlYWQgPyBcIkhFQURcIiA6IFwiR0VUXCI7XG5cdFx0bGV0IHF1b3RlZCA9IGZhbHNlO1xuXHRcdGNvbnN0IGNsZWFuZWRDb2x1bW5zID0gKGNvbHVtbnMgIT09IG51bGwgJiYgY29sdW1ucyAhPT0gdm9pZCAwID8gY29sdW1ucyA6IFwiKlwiKS5zcGxpdChcIlwiKS5tYXAoKGMpID0+IHtcblx0XHRcdGlmICgvXFxzLy50ZXN0KGMpICYmICFxdW90ZWQpIHJldHVybiBcIlwiO1xuXHRcdFx0aWYgKGMgPT09IFwiXFxcIlwiKSBxdW90ZWQgPSAhcXVvdGVkO1xuXHRcdFx0cmV0dXJuIGM7XG5cdFx0fSkuam9pbihcIlwiKTtcblx0XHRjb25zdCB7IHVybCwgaGVhZGVycyB9ID0gdGhpcy5jbG9uZVJlcXVlc3RTdGF0ZSgpO1xuXHRcdHVybC5zZWFyY2hQYXJhbXMuc2V0KFwic2VsZWN0XCIsIGNsZWFuZWRDb2x1bW5zKTtcblx0XHRpZiAoY291bnQpIGhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIGBjb3VudD0ke2NvdW50fWApO1xuXHRcdHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHR1cmwsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0c2NoZW1hOiB0aGlzLnNjaGVtYSxcblx0XHRcdGZldGNoOiB0aGlzLmZldGNoXG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhbiBJTlNFUlQgaW50byB0aGUgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIEJ5IGRlZmF1bHQsIGluc2VydGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuXHQqIHdpdGggYC5zZWxlY3QoKWAuXG5cdCpcblx0KiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBpbnNlcnQuIFBhc3MgYW4gb2JqZWN0IHRvIGluc2VydCBhIHNpbmdsZSByb3dcblx0KiBvciBhbiBhcnJheSB0byBpbnNlcnQgbXVsdGlwbGUgcm93cy5cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGluc2VydGVkIHJvd3MuXG5cdCpcblx0KiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG5cdCogaG9vZC5cblx0KlxuXHQqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG5cdCogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cblx0KlxuXHQqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcblx0KiBudW1iZXJzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdFRvTnVsbCAtIE1ha2UgbWlzc2luZyBmaWVsZHMgZGVmYXVsdCB0byBgbnVsbGAuXG5cdCogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIE9ubHkgYXBwbGllcyBmb3IgYnVsa1xuXHQqIGluc2VydHMuXG5cdCovXG5cdGluc2VydCh2YWx1ZXMsIHsgY291bnQsIGRlZmF1bHRUb051bGwgPSB0cnVlIH0gPSB7fSkge1xuXHRcdHZhciBfdGhpcyRmZXRjaDtcblx0XHRjb25zdCBtZXRob2QgPSBcIlBPU1RcIjtcblx0XHRjb25zdCB7IHVybCwgaGVhZGVycyB9ID0gdGhpcy5jbG9uZVJlcXVlc3RTdGF0ZSgpO1xuXHRcdGlmIChjb3VudCkgaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgYGNvdW50PSR7Y291bnR9YCk7XG5cdFx0aWYgKCFkZWZhdWx0VG9OdWxsKSBoZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgbWlzc2luZz1kZWZhdWx0YCk7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuXHRcdFx0Y29uc3QgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdChPYmplY3Qua2V5cyh4KSksIFtdKTtcblx0XHRcdGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKTtcblx0XHRcdFx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJjb2x1bW5zXCIsIHVuaXF1ZUNvbHVtbnMuam9pbihcIixcIikpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0dXJsLFxuXHRcdFx0aGVhZGVycyxcblx0XHRcdHNjaGVtYTogdGhpcy5zY2hlbWEsXG5cdFx0XHRib2R5OiB2YWx1ZXMsXG5cdFx0XHRmZXRjaDogKF90aGlzJGZldGNoID0gdGhpcy5mZXRjaCkgIT09IG51bGwgJiYgX3RoaXMkZmV0Y2ggIT09IHZvaWQgMCA/IF90aGlzJGZldGNoIDogZmV0Y2hcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBQZXJmb3JtIGFuIFVQU0VSVCBvbiB0aGUgdGFibGUgb3Igdmlldy4gRGVwZW5kaW5nIG9uIHRoZSBjb2x1bW4ocykgcGFzc2VkXG5cdCogdG8gYG9uQ29uZmxpY3RgLCBgLnVwc2VydCgpYCBhbGxvd3MgeW91IHRvIHBlcmZvcm0gdGhlIGVxdWl2YWxlbnQgb2Zcblx0KiBgLmluc2VydCgpYCBpZiBhIHJvdyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGRvZXNuJ3Rcblx0KiBleGlzdCwgb3IgaWYgaXQgZG9lcyBleGlzdCwgcGVyZm9ybSBhbiBhbHRlcm5hdGl2ZSBhY3Rpb24gZGVwZW5kaW5nIG9uXG5cdCogYGlnbm9yZUR1cGxpY2F0ZXNgLlxuXHQqXG5cdCogQnkgZGVmYXVsdCwgdXBzZXJ0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG5cdCogd2l0aCBgLnNlbGVjdCgpYC5cblx0KlxuXHQqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIHVwc2VydCB3aXRoLiBQYXNzIGFuIG9iamVjdCB0byB1cHNlcnQgYVxuXHQqIHNpbmdsZSByb3cgb3IgYW4gYXJyYXkgdG8gdXBzZXJ0IG11bHRpcGxlIHJvd3MuXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLm9uQ29uZmxpY3QgLSBDb21tYS1zZXBhcmF0ZWQgVU5JUVVFIGNvbHVtbihzKSB0byBzcGVjaWZ5IGhvd1xuXHQqIGR1cGxpY2F0ZSByb3dzIGFyZSBkZXRlcm1pbmVkLiBUd28gcm93cyBhcmUgZHVwbGljYXRlcyBpZiBhbGwgdGhlXG5cdCogYG9uQ29uZmxpY3RgIGNvbHVtbnMgYXJlIGVxdWFsLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyAtIElmIGB0cnVlYCwgZHVwbGljYXRlIHJvd3MgYXJlIGlnbm9yZWQuIElmXG5cdCogYGZhbHNlYCwgZHVwbGljYXRlIHJvd3MgYXJlIG1lcmdlZCB3aXRoIGV4aXN0aW5nIHJvd3MuXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgdXBzZXJ0ZWQgcm93cy5cblx0KlxuXHQqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcblx0KiBob29kLlxuXHQqXG5cdCogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcblx0KiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuXHQqXG5cdCogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuXHQqIG51bWJlcnMuXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cblx0KiBPdGhlcndpc2UsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbHVtbi4gVGhpcyBvbmx5IGFwcGxpZXMgd2hlblxuXHQqIGluc2VydGluZyBuZXcgcm93cywgbm90IHdoZW4gbWVyZ2luZyB3aXRoIGV4aXN0aW5nIHJvd3MgdW5kZXJcblx0KiBgaWdub3JlRHVwbGljYXRlczogZmFsc2VgLiBUaGlzIGFsc28gb25seSBhcHBsaWVzIHdoZW4gZG9pbmcgYnVsayB1cHNlcnRzLlxuXHQqXG5cdCogQGV4YW1wbGUgVXBzZXJ0IGEgc2luZ2xlIHJvdyB1c2luZyBhIHVuaXF1ZSBrZXlcblx0KiBgYGB0c1xuXHQqIC8vIFVwc2VydGluZyBhIHNpbmdsZSByb3csIG92ZXJ3cml0aW5nIGJhc2VkIG9uIHRoZSAndXNlcm5hbWUnIHVuaXF1ZSBjb2x1bW5cblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLmZyb20oJ3VzZXJzJylcblx0KiAgIC51cHNlcnQoeyB1c2VybmFtZTogJ3N1cGFib3QnIH0sIHsgb25Db25mbGljdDogJ3VzZXJuYW1lJyB9KVxuXHQqXG5cdCogLy8gRXhhbXBsZSByZXNwb25zZTpcblx0KiAvLyB7XG5cdCogLy8gICBkYXRhOiBbXG5cdCogLy8gICAgIHsgaWQ6IDQsIG1lc3NhZ2U6ICdiYXInLCB1c2VybmFtZTogJ3N1cGFib3QnIH1cblx0KiAvLyAgIF0sXG5cdCogLy8gICBlcnJvcjogbnVsbFxuXHQqIC8vIH1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFVwc2VydCB3aXRoIGNvbmZsaWN0IHJlc29sdXRpb24gYW5kIGV4YWN0IHJvdyBjb3VudGluZ1xuXHQqIGBgYHRzXG5cdCogLy8gVXBzZXJ0aW5nIGFuZCByZXR1cm5pbmcgZXhhY3QgY291bnRcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yLCBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5mcm9tKCd1c2VycycpXG5cdCogICAudXBzZXJ0KFxuXHQqICAgICB7XG5cdCogICAgICAgaWQ6IDMsXG5cdCogICAgICAgbWVzc2FnZTogJ2ZvbycsXG5cdCogICAgICAgdXNlcm5hbWU6ICdzdXBhYm90J1xuXHQqICAgICB9LFxuXHQqICAgICB7XG5cdCogICAgICAgb25Db25mbGljdDogJ3VzZXJuYW1lJyxcblx0KiAgICAgICBjb3VudDogJ2V4YWN0J1xuXHQqICAgICB9XG5cdCogICApXG5cdCpcblx0KiAvLyBFeGFtcGxlIHJlc3BvbnNlOlxuXHQqIC8vIHtcblx0KiAvLyAgIGRhdGE6IFtcblx0KiAvLyAgICAge1xuXHQqIC8vICAgICAgIGlkOiA0Mixcblx0KiAvLyAgICAgICBoYW5kbGU6IFwic2FvaXJzZVwiLFxuXHQqIC8vICAgICAgIGRpc3BsYXlfbmFtZTogXCJTYW9pcnNlXCJcblx0KiAvLyAgICAgfVxuXHQqIC8vICAgXSxcblx0KiAvLyAgIGNvdW50OiAxLFxuXHQqIC8vICAgZXJyb3I6IG51bGxcblx0KiAvLyB9XG5cdCogYGBgXG5cdCovXG5cdHVwc2VydCh2YWx1ZXMsIHsgb25Db25mbGljdCwgaWdub3JlRHVwbGljYXRlcyA9IGZhbHNlLCBjb3VudCwgZGVmYXVsdFRvTnVsbCA9IHRydWUgfSA9IHt9KSB7XG5cdFx0dmFyIF90aGlzJGZldGNoMjtcblx0XHRjb25zdCBtZXRob2QgPSBcIlBPU1RcIjtcblx0XHRjb25zdCB7IHVybCwgaGVhZGVycyB9ID0gdGhpcy5jbG9uZVJlcXVlc3RTdGF0ZSgpO1xuXHRcdGhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIGByZXNvbHV0aW9uPSR7aWdub3JlRHVwbGljYXRlcyA/IFwiaWdub3JlXCIgOiBcIm1lcmdlXCJ9LWR1cGxpY2F0ZXNgKTtcblx0XHRpZiAob25Db25mbGljdCAhPT0gdm9pZCAwKSB1cmwuc2VhcmNoUGFyYW1zLnNldChcIm9uX2NvbmZsaWN0XCIsIG9uQ29uZmxpY3QpO1xuXHRcdGlmIChjb3VudCkgaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgYGNvdW50PSR7Y291bnR9YCk7XG5cdFx0aWYgKCFkZWZhdWx0VG9OdWxsKSBoZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBcIm1pc3Npbmc9ZGVmYXVsdFwiKTtcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG5cdFx0XHRjb25zdCBjb2x1bW5zID0gdmFsdWVzLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MuY29uY2F0KE9iamVjdC5rZXlzKHgpKSwgW10pO1xuXHRcdFx0aWYgKGNvbHVtbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjb25zdCB1bmlxdWVDb2x1bW5zID0gWy4uLm5ldyBTZXQoY29sdW1ucyldLm1hcCgoY29sdW1uKSA9PiBgXCIke2NvbHVtbn1cImApO1xuXHRcdFx0XHR1cmwuc2VhcmNoUGFyYW1zLnNldChcImNvbHVtbnNcIiwgdW5pcXVlQ29sdW1ucy5qb2luKFwiLFwiKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHR1cmwsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0c2NoZW1hOiB0aGlzLnNjaGVtYSxcblx0XHRcdGJvZHk6IHZhbHVlcyxcblx0XHRcdGZldGNoOiAoX3RoaXMkZmV0Y2gyID0gdGhpcy5mZXRjaCkgIT09IG51bGwgJiYgX3RoaXMkZmV0Y2gyICE9PSB2b2lkIDAgPyBfdGhpcyRmZXRjaDIgOiBmZXRjaFxuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIFBlcmZvcm0gYW4gVVBEQVRFIG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuXHQqXG5cdCogQnkgZGVmYXVsdCwgdXBkYXRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcblx0KiB3aXRoIGAuc2VsZWN0KClgIGFmdGVyIGZpbHRlcnMuXG5cdCpcblx0KiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cGRhdGUgd2l0aFxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgdXBkYXRlZCByb3dzLlxuXHQqXG5cdCogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuXHQqIGhvb2QuXG5cdCpcblx0KiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuXHQqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG5cdCpcblx0KiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG5cdCogbnVtYmVycy5cblx0Ki9cblx0dXBkYXRlKHZhbHVlcywgeyBjb3VudCB9ID0ge30pIHtcblx0XHR2YXIgX3RoaXMkZmV0Y2gzO1xuXHRcdGNvbnN0IG1ldGhvZCA9IFwiUEFUQ0hcIjtcblx0XHRjb25zdCB7IHVybCwgaGVhZGVycyB9ID0gdGhpcy5jbG9uZVJlcXVlc3RTdGF0ZSgpO1xuXHRcdGlmIChjb3VudCkgaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgYGNvdW50PSR7Y291bnR9YCk7XG5cdFx0cmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcblx0XHRcdG1ldGhvZCxcblx0XHRcdHVybCxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRzY2hlbWE6IHRoaXMuc2NoZW1hLFxuXHRcdFx0Ym9keTogdmFsdWVzLFxuXHRcdFx0ZmV0Y2g6IChfdGhpcyRmZXRjaDMgPSB0aGlzLmZldGNoKSAhPT0gbnVsbCAmJiBfdGhpcyRmZXRjaDMgIT09IHZvaWQgMCA/IF90aGlzJGZldGNoMyA6IGZldGNoXG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIERFTEVURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIEJ5IGRlZmF1bHQsIGRlbGV0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG5cdCogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgZGVsZXRlZCByb3dzLlxuXHQqXG5cdCogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuXHQqIGhvb2QuXG5cdCpcblx0KiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuXHQqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG5cdCpcblx0KiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG5cdCogbnVtYmVycy5cblx0Ki9cblx0ZGVsZXRlKHsgY291bnQgfSA9IHt9KSB7XG5cdFx0dmFyIF90aGlzJGZldGNoNDtcblx0XHRjb25zdCBtZXRob2QgPSBcIkRFTEVURVwiO1xuXHRcdGNvbnN0IHsgdXJsLCBoZWFkZXJzIH0gPSB0aGlzLmNsb25lUmVxdWVzdFN0YXRlKCk7XG5cdFx0aWYgKGNvdW50KSBoZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgY291bnQ9JHtjb3VudH1gKTtcblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0dXJsLFxuXHRcdFx0aGVhZGVycyxcblx0XHRcdHNjaGVtYTogdGhpcy5zY2hlbWEsXG5cdFx0XHRmZXRjaDogKF90aGlzJGZldGNoNCA9IHRoaXMuZmV0Y2gpICE9PSBudWxsICYmIF90aGlzJGZldGNoNCAhPT0gdm9pZCAwID8gX3RoaXMkZmV0Y2g0IDogZmV0Y2hcblx0XHR9KTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1Bvc3RncmVzdENsaWVudC50c1xuLyoqXG4qIFBvc3RnUkVTVCBjbGllbnQuXG4qXG4qIEB0eXBlUGFyYW0gRGF0YWJhc2UgLSBUeXBlcyBmb3IgdGhlIHNjaGVtYSBmcm9tIHRoZSBbdHlwZVxuKiBnZW5lcmF0b3JdKGh0dHBzOi8vc3VwYWJhc2UuY29tL2RvY3MvcmVmZXJlbmNlL2phdmFzY3JpcHQvbmV4dC90eXBlc2NyaXB0LXN1cHBvcnQpXG4qXG4qIEB0eXBlUGFyYW0gU2NoZW1hTmFtZSAtIFBvc3RncmVzIHNjaGVtYSB0byBzd2l0Y2ggdG8uIE11c3QgYmUgYSBzdHJpbmdcbiogbGl0ZXJhbCwgdGhlIHNhbWUgb25lIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuIElmIHRoZSBzY2hlbWEgaXMgbm90XG4qIGBcInB1YmxpY1wiYCwgdGhpcyBtdXN0IGJlIHN1cHBsaWVkIG1hbnVhbGx5LlxuKi9cbnZhciBQb3N0Z3Jlc3RDbGllbnQgPSBjbGFzcyBQb3N0Z3Jlc3RDbGllbnQge1xuXHQvKipcblx0KiBDcmVhdGVzIGEgUG9zdGdSRVNUIGNsaWVudC5cblx0KlxuXHQqIEBwYXJhbSB1cmwgLSBVUkwgb2YgdGhlIFBvc3RnUkVTVCBlbmRwb2ludFxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgLSBDdXN0b20gaGVhZGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLnNjaGVtYSAtIFBvc3RncmVzIHNjaGVtYSB0byBzd2l0Y2ggdG9cblx0KiBAcGFyYW0gb3B0aW9ucy5mZXRjaCAtIEN1c3RvbSBmZXRjaFxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHNcblx0KiBpbXBvcnQgUG9zdGdyZXN0Q2xpZW50IGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnXG5cdCpcblx0KiBjb25zdCBwb3N0Z3Jlc3QgPSBuZXcgUG9zdGdyZXN0Q2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vcmVzdC92MScsIHtcblx0KiAgIGhlYWRlcnM6IHsgYXBpa2V5OiAncHVibGljLWFub24ta2V5JyB9LFxuXHQqICAgc2NoZW1hOiAncHVibGljJyxcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIHsgaGVhZGVycyA9IHt9LCBzY2hlbWEsIGZldGNoOiBmZXRjaCQxIH0gPSB7fSkge1xuXHRcdHRoaXMudXJsID0gdXJsO1xuXHRcdHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMpO1xuXHRcdHRoaXMuc2NoZW1hTmFtZSA9IHNjaGVtYTtcblx0XHR0aGlzLmZldGNoID0gZmV0Y2gkMTtcblx0fVxuXHQvKipcblx0KiBQZXJmb3JtIGEgcXVlcnkgb24gYSB0YWJsZSBvciBhIHZpZXcuXG5cdCpcblx0KiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgdGFibGUgb3IgdmlldyBuYW1lIHRvIHF1ZXJ5XG5cdCovXG5cdGZyb20ocmVsYXRpb24pIHtcblx0XHRpZiAoIXJlbGF0aW9uIHx8IHR5cGVvZiByZWxhdGlvbiAhPT0gXCJzdHJpbmdcIiB8fCByZWxhdGlvbi50cmltKCkgPT09IFwiXCIpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVsYXRpb24gbmFtZTogcmVsYXRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuXCIpO1xuXHRcdHJldHVybiBuZXcgUG9zdGdyZXN0UXVlcnlCdWlsZGVyKG5ldyBVUkwoYCR7dGhpcy51cmx9LyR7cmVsYXRpb259YCksIHtcblx0XHRcdGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG5cdFx0XHRzY2hlbWE6IHRoaXMuc2NoZW1hTmFtZSxcblx0XHRcdGZldGNoOiB0aGlzLmZldGNoXG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cblx0KlxuXHQqIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cblx0KlxuXHQqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHF1ZXJ5XG5cdCovXG5cdHNjaGVtYShzY2hlbWEpIHtcblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdENsaWVudCh0aGlzLnVybCwge1xuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0c2NoZW1hLFxuXHRcdFx0ZmV0Y2g6IHRoaXMuZmV0Y2hcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBQZXJmb3JtIGEgZnVuY3Rpb24gY2FsbC5cblx0KlxuXHQqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiBuYW1lIHRvIGNhbGxcblx0KiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24gY2FsbFxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLmhlYWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGBkYXRhYCB3aWxsIG5vdCBiZSByZXR1cm5lZC5cblx0KiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG5cdCogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuXHQqIHJlYWQtb25seSBhY2Nlc3MgbW9kZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyByZXR1cm5lZCBieSB0aGVcblx0KiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuXHQqIGZ1bmN0aW9uc10oaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L2Z1bmN0aW9ucy1zcmYuaHRtbCkuXG5cdCpcblx0KiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG5cdCogaG9vZC5cblx0KlxuXHQqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG5cdCogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cblx0KlxuXHQqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcblx0KiBudW1iZXJzLlxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0c1xuXHQqIC8vIEZvciBjcm9zcy1zY2hlbWEgZnVuY3Rpb25zIHdoZXJlIHR5cGUgaW5mZXJlbmNlIGZhaWxzLCB1c2Ugb3ZlcnJpZGVUeXBlczpcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc2NoZW1hKCdzY2hlbWFfYicpXG5cdCogICAucnBjKCdmdW5jdGlvbl9hJywge30pXG5cdCogICAub3ZlcnJpZGVUeXBlczx7IGlkOiBzdHJpbmc7IHVzZXJfaWQ6IHN0cmluZyB9W10+KClcblx0KiBgYGBcblx0Ki9cblx0cnBjKGZuLCBhcmdzID0ge30sIHsgaGVhZCA9IGZhbHNlLCBnZXQgPSBmYWxzZSwgY291bnQgfSA9IHt9KSB7XG5cdFx0dmFyIF90aGlzJGZldGNoO1xuXHRcdGxldCBtZXRob2Q7XG5cdFx0Y29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLnVybH0vcnBjLyR7Zm59YCk7XG5cdFx0bGV0IGJvZHk7XG5cdFx0Y29uc3QgX2lzT2JqZWN0ID0gKHYpID0+IHYgIT09IG51bGwgJiYgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgKCFBcnJheS5pc0FycmF5KHYpIHx8IHYuc29tZShfaXNPYmplY3QpKTtcblx0XHRjb25zdCBfaGFzT2JqZWN0QXJnID0gaGVhZCAmJiBPYmplY3QudmFsdWVzKGFyZ3MpLnNvbWUoX2lzT2JqZWN0KTtcblx0XHRpZiAoX2hhc09iamVjdEFyZykge1xuXHRcdFx0bWV0aG9kID0gXCJQT1NUXCI7XG5cdFx0XHRib2R5ID0gYXJncztcblx0XHR9IGVsc2UgaWYgKGhlYWQgfHwgZ2V0KSB7XG5cdFx0XHRtZXRob2QgPSBoZWFkID8gXCJIRUFEXCIgOiBcIkdFVFwiO1xuXHRcdFx0T2JqZWN0LmVudHJpZXMoYXJncykuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdm9pZCAwKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IFtuYW1lLCBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGB7JHt2YWx1ZS5qb2luKFwiLFwiKX19YCA6IGAke3ZhbHVlfWBdKS5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiB7XG5cdFx0XHRcdHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZXRob2QgPSBcIlBPU1RcIjtcblx0XHRcdGJvZHkgPSBhcmdzO1xuXHRcdH1cblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKTtcblx0XHRpZiAoX2hhc09iamVjdEFyZykgaGVhZGVycy5zZXQoXCJQcmVmZXJcIiwgY291bnQgPyBgY291bnQ9JHtjb3VudH0scmV0dXJuPW1pbmltYWxgIDogXCJyZXR1cm49bWluaW1hbFwiKTtcblx0XHRlbHNlIGlmIChjb3VudCkgaGVhZGVycy5zZXQoXCJQcmVmZXJcIiwgYGNvdW50PSR7Y291bnR9YCk7XG5cdFx0cmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcblx0XHRcdG1ldGhvZCxcblx0XHRcdHVybCxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRzY2hlbWE6IHRoaXMuc2NoZW1hTmFtZSxcblx0XHRcdGJvZHksXG5cdFx0XHRmZXRjaDogKF90aGlzJGZldGNoID0gdGhpcy5mZXRjaCkgIT09IG51bGwgJiYgX3RoaXMkZmV0Y2ggIT09IHZvaWQgMCA/IF90aGlzJGZldGNoIDogZmV0Y2hcblx0XHR9KTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2luZGV4LnRzXG52YXIgc3JjX2RlZmF1bHQgPSB7XG5cdFBvc3RncmVzdENsaWVudCxcblx0UG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuXHRQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuXHRQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuXHRQb3N0Z3Jlc3RCdWlsZGVyLFxuXHRQb3N0Z3Jlc3RFcnJvclxufTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnRzLlBvc3RncmVzdEJ1aWxkZXIgPSBQb3N0Z3Jlc3RCdWlsZGVyO1xuZXhwb3J0cy5Qb3N0Z3Jlc3RDbGllbnQgPSBQb3N0Z3Jlc3RDbGllbnQ7XG5leHBvcnRzLlBvc3RncmVzdEVycm9yID0gUG9zdGdyZXN0RXJyb3I7XG5leHBvcnRzLlBvc3RncmVzdEZpbHRlckJ1aWxkZXIgPSBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyO1xuZXhwb3J0cy5Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgPSBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI7XG5leHBvcnRzLlBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIgPSBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gc3JjX2RlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUG9zdGdyZXN0RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY29udGV4dCIsIm1lc3NhZ2UiLCJuYW1lIiwiZGV0YWlscyIsImhpbnQiLCJjb2RlIiwiUG9zdGdyZXN0QnVpbGRlciIsImJ1aWxkZXIiLCJfYnVpbGRlciRzaG91bGRUaHJvd08iLCJfYnVpbGRlciRpc01heWJlU2luZ2wiLCJzaG91bGRUaHJvd09uRXJyb3IiLCJtZXRob2QiLCJ1cmwiLCJoZWFkZXJzIiwiSGVhZGVycyIsInNjaGVtYSIsImJvZHkiLCJzaWduYWwiLCJpc01heWJlU2luZ2xlIiwiZmV0Y2giLCJ0aHJvd09uRXJyb3IiLCJzZXRIZWFkZXIiLCJzZXQiLCJ0aGVuIiwib25mdWxmaWxsZWQiLCJvbnJlamVjdGVkIiwiX3RoaXMiLCJpbmNsdWRlcyIsIl9mZXRjaCIsInJlcyIsInRvU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlcyQxIiwiZXJyb3IiLCJkYXRhIiwiY291bnQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0Iiwib2siLCJfdGhpcyRoZWFkZXJzJGdldDIiLCJfcmVzJGhlYWRlcnMkZ2V0IiwiX3RoaXMkaGVhZGVycyRnZXQiLCJ0ZXh0IiwiZ2V0IiwicGFyc2UiLCJjb3VudEhlYWRlciIsIm1hdGNoIiwiY29udGVudFJhbmdlIiwic3BsaXQiLCJsZW5ndGgiLCJwYXJzZUludCIsIkFycmF5IiwiaXNBcnJheSIsIl9lcnJvciRkZXRhaWxzIiwiX3VudXNlZCIsImNhdGNoIiwiZmV0Y2hFcnJvciIsIl9mZXRjaEVycm9yJG5hbWUyIiwiZXJyb3JEZXRhaWxzIiwiY2F1c2UiLCJfY2F1c2UkbWVzc2FnZSIsIl9jYXVzZSRjb2RlIiwiX2ZldGNoRXJyb3IkbmFtZSIsIl9jYXVzZSRuYW1lIiwiY2F1c2VNZXNzYWdlIiwiY2F1c2VDb2RlIiwic3RhY2siLCJfZmV0Y2hFcnJvciRzdGFjayIsInJldHVybnMiLCJvdmVycmlkZVR5cGVzIiwiUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciIsInNlbGVjdCIsImNvbHVtbnMiLCJxdW90ZWQiLCJjbGVhbmVkQ29sdW1ucyIsIm1hcCIsImMiLCJ0ZXN0Iiwiam9pbiIsInNlYXJjaFBhcmFtcyIsImFwcGVuZCIsIm9yZGVyIiwiY29sdW1uIiwiYXNjZW5kaW5nIiwibnVsbHNGaXJzdCIsImZvcmVpZ25UYWJsZSIsInJlZmVyZW5jZWRUYWJsZSIsImtleSIsImV4aXN0aW5nT3JkZXIiLCJsaW1pdCIsInJhbmdlIiwiZnJvbSIsInRvIiwia2V5T2Zmc2V0Iiwia2V5TGltaXQiLCJhYm9ydFNpZ25hbCIsInNpbmdsZSIsIm1heWJlU2luZ2xlIiwiY3N2IiwiZ2VvanNvbiIsImV4cGxhaW4iLCJhbmFseXplIiwidmVyYm9zZSIsInNldHRpbmdzIiwiYnVmZmVycyIsIndhbCIsImZvcm1hdCIsIm9wdGlvbnMiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZm9yTWVkaWF0eXBlIiwicm9sbGJhY2siLCJtYXhBZmZlY3RlZCIsIlBvc3RncmVzdFJlc2VydmVkQ2hhcnNSZWdleHAiLCJSZWdFeHAiLCJQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyIiwiZXEiLCJuZXEiLCJndCIsImd0ZSIsImx0IiwibHRlIiwibGlrZSIsInBhdHRlcm4iLCJsaWtlQWxsT2YiLCJwYXR0ZXJucyIsImxpa2VBbnlPZiIsImlsaWtlIiwiaWxpa2VBbGxPZiIsImlsaWtlQW55T2YiLCJyZWdleE1hdGNoIiwicmVnZXhJTWF0Y2giLCJpcyIsImlzRGlzdGluY3QiLCJpbiIsInZhbHVlcyIsImNsZWFuZWRWYWx1ZXMiLCJTZXQiLCJzIiwibm90SW4iLCJjb250YWlucyIsImNvbnRhaW5lZEJ5IiwicmFuZ2VHdCIsInJhbmdlR3RlIiwicmFuZ2VMdCIsInJhbmdlTHRlIiwicmFuZ2VBZGphY2VudCIsIm92ZXJsYXBzIiwidGV4dFNlYXJjaCIsInF1ZXJ5IiwiY29uZmlnIiwidHlwZSIsInR5cGVQYXJ0IiwiY29uZmlnUGFydCIsImVudHJpZXMiLCJmb3JFYWNoIiwibm90Iiwib3BlcmF0b3IiLCJvciIsImZpbHRlcnMiLCJQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIiLCJmZXRjaCQxIiwiY2xvbmVSZXF1ZXN0U3RhdGUiLCJVUkwiLCJoZWFkIiwiaW5zZXJ0IiwiZGVmYXVsdFRvTnVsbCIsIl90aGlzJGZldGNoIiwicmVkdWNlIiwiYWNjIiwieCIsImNvbmNhdCIsImtleXMiLCJ1bmlxdWVDb2x1bW5zIiwidXBzZXJ0Iiwib25Db25mbGljdCIsImlnbm9yZUR1cGxpY2F0ZXMiLCJfdGhpcyRmZXRjaDIiLCJ1cGRhdGUiLCJfdGhpcyRmZXRjaDMiLCJkZWxldGUiLCJfdGhpcyRmZXRjaDQiLCJQb3N0Z3Jlc3RDbGllbnQiLCJzY2hlbWFOYW1lIiwicmVsYXRpb24iLCJ0cmltIiwicnBjIiwiZm4iLCJhcmdzIiwiX2lzT2JqZWN0IiwidiIsInNvbWUiLCJfaGFzT2JqZWN0QXJnIiwiXyIsInNyY19kZWZhdWx0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/postgrest-js/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/storage-js/dist/index.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/index.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("let iceberg_js = __webpack_require__(/*! iceberg-js */ \"(rsc)/./node_modules/iceberg-js/dist/index.cjs\");\n//#region src/lib/errors.ts\nvar StorageError = class extends Error {\n    constructor(message){\n        super(message);\n        this.__isStorageError = true;\n        this.name = \"StorageError\";\n    }\n};\nfunction isStorageError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageError\" in error;\n}\nvar StorageApiError = class extends StorageError {\n    constructor(message, status, statusCode){\n        super(message);\n        this.name = \"StorageApiError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode\n        };\n    }\n};\nvar StorageUnknownError = class extends StorageError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"StorageUnknownError\";\n        this.originalError = originalError;\n    }\n};\n//#endregion\n//#region src/lib/helpers.ts\nconst resolveFetch$1 = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\nconst resolveResponse$1 = ()=>{\n    return Response;\n};\nconst recursiveToCamel = (item)=>{\n    if (Array.isArray(item)) return item.map((el)=>recursiveToCamel(el));\n    else if (typeof item === \"function\" || item !== Object(item)) return item;\n    const result = {};\n    Object.entries(item).forEach(([key, value])=>{\n        const newKey = key.replace(/([-_][a-z])/gi, (c)=>c.toUpperCase().replace(/[-_]/g, \"\"));\n        result[newKey] = recursiveToCamel(value);\n    });\n    return result;\n};\n/**\n* Determine if input is a plain object\n* An object is plain if it's created by either {}, new Object(), or Object.create(null)\n* source: https://github.com/sindresorhus/is-plain-obj\n*/ const isPlainObject$1 = (value)=>{\n    if (typeof value !== \"object\" || value === null) return false;\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};\n/**\n* Validates if a given bucket name is valid according to Supabase Storage API rules\n* Mirrors backend validation from: storage/src/storage/limits.ts:isValidBucketName()\n*\n* Rules:\n* - Length: 1-100 characters\n* - Allowed characters: alphanumeric (a-z, A-Z, 0-9), underscore (_), and safe special characters\n* - Safe special characters: ! - . * ' ( ) space & $ @ = ; : + , ?\n* - Forbidden: path separators (/, \\), path traversal (..), leading/trailing whitespace\n*\n* AWS S3 Reference: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html\n*\n* @param bucketName - The bucket name to validate\n* @returns true if valid, false otherwise\n*/ const isValidBucketName = (bucketName)=>{\n    if (!bucketName || typeof bucketName !== \"string\") return false;\n    if (bucketName.length === 0 || bucketName.length > 100) return false;\n    if (bucketName.trim() !== bucketName) return false;\n    if (bucketName.includes(\"/\") || bucketName.includes(\"\\\\\")) return false;\n    return /^[\\w!.\\*'() &$@=;:+,?-]+$/.test(bucketName);\n};\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n        return typeof o$1;\n    } : function(o$1) {\n        return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, _typeof(o);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n    var i = toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r$1) {\n            return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n            _defineProperty(e, r$1, t[r$1]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n            Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n        });\n    }\n    return e;\n}\n//#endregion\n//#region src/lib/fetch.ts\nconst _getErrorMessage$1 = (err)=>{\n    var _err$error;\n    return err.msg || err.message || err.error_description || (typeof err.error === \"string\" ? err.error : (_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.message) || JSON.stringify(err);\n};\nconst handleError$1 = async (error, reject, options)=>{\n    if (error instanceof await resolveResponse$1() && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) error.json().then((err)=>{\n        const status = error.status || 500;\n        const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || status + \"\";\n        reject(new StorageApiError(_getErrorMessage$1(err), status, statusCode));\n    }).catch((err)=>{\n        reject(new StorageUnknownError(_getErrorMessage$1(err), err));\n    });\n    else reject(new StorageUnknownError(_getErrorMessage$1(error), error));\n};\nconst _getRequestParams$1 = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\" || !body) return params;\n    if (isPlainObject$1(body)) {\n        params.headers = _objectSpread2({\n            \"Content-Type\": \"application/json\"\n        }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    } else params.body = body;\n    if (options === null || options === void 0 ? void 0 : options.duplex) params.duplex = options.duplex;\n    return _objectSpread2(_objectSpread2({}, params), parameters);\n};\nasync function _handleRequest$1(fetcher, method, url, options, parameters, body) {\n    return new Promise((resolve, reject)=>{\n        fetcher(url, _getRequestParams$1(method, options, parameters, body)).then((result)=>{\n            if (!result.ok) throw result;\n            if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n            return result.json();\n        }).then((data)=>resolve(data)).catch((error)=>handleError$1(error, reject, options));\n    });\n}\nasync function get(fetcher, url, options, parameters) {\n    return _handleRequest$1(fetcher, \"GET\", url, options, parameters);\n}\nasync function post$1(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"POST\", url, options, parameters, body);\n}\nasync function put(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"PUT\", url, options, parameters, body);\n}\nasync function head(fetcher, url, options, parameters) {\n    return _handleRequest$1(fetcher, \"HEAD\", url, _objectSpread2(_objectSpread2({}, options), {}, {\n        noResolveJson: true\n    }), parameters);\n}\nasync function remove(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"DELETE\", url, options, parameters, body);\n}\n//#endregion\n//#region src/packages/StreamDownloadBuilder.ts\nvar StreamDownloadBuilder = class {\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n    }\n    then(onfulfilled, onrejected) {\n        return this.execute().then(onfulfilled, onrejected);\n    }\n    async execute() {\n        var _this = this;\n        try {\n            return {\n                data: (await _this.downloadFn()).body,\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/packages/BlobDownloadBuilder.ts\nlet _Symbol$toStringTag;\n_Symbol$toStringTag = Symbol.toStringTag;\nvar BlobDownloadBuilder = class {\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n        this[_Symbol$toStringTag] = \"BlobDownloadBuilder\";\n        this.promise = null;\n    }\n    asStream() {\n        return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);\n    }\n    then(onfulfilled, onrejected) {\n        return this.getPromise().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.getPromise().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.getPromise().finally(onfinally);\n    }\n    getPromise() {\n        if (!this.promise) this.promise = this.execute();\n        return this.promise;\n    }\n    async execute() {\n        var _this = this;\n        try {\n            return {\n                data: await (await _this.downloadFn()).blob(),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/packages/StorageFileApi.ts\nconst DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: \"name\",\n        order: \"asc\"\n    }\n};\nconst DEFAULT_FILE_OPTIONS = {\n    cacheControl: \"3600\",\n    contentType: \"text/plain;charset=UTF-8\",\n    upsert: false\n};\nvar StorageFileApi = class {\n    constructor(url, headers = {}, bucketId, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url;\n        this.headers = headers;\n        this.bucketId = bucketId;\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* Enable throwing errors instead of returning them.\n\t*\n\t* @category File Buckets\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n\t*\n\t* @param method HTTP method.\n\t* @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t*/ async uploadOrUpdate(method, path, fileBody, fileOptions) {\n        var _this = this;\n        try {\n            let body;\n            const options = _objectSpread2(_objectSpread2({}, DEFAULT_FILE_OPTIONS), fileOptions);\n            let headers = _objectSpread2(_objectSpread2({}, _this.headers), method === \"POST\" && {\n                \"x-upsert\": String(options.upsert)\n            });\n            const metadata = options.metadata;\n            if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                body = new FormData();\n                body.append(\"cacheControl\", options.cacheControl);\n                if (metadata) body.append(\"metadata\", _this.encodeMetadata(metadata));\n                body.append(\"\", fileBody);\n            } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                body = fileBody;\n                if (!body.has(\"cacheControl\")) body.append(\"cacheControl\", options.cacheControl);\n                if (metadata && !body.has(\"metadata\")) body.append(\"metadata\", _this.encodeMetadata(metadata));\n            } else {\n                body = fileBody;\n                headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                headers[\"content-type\"] = options.contentType;\n                if (metadata) headers[\"x-metadata\"] = _this.toBase64(_this.encodeMetadata(metadata));\n                if ((typeof ReadableStream !== \"undefined\" && body instanceof ReadableStream || body && typeof body === \"object\" && \"pipe\" in body && typeof body.pipe === \"function\") && !options.duplex) options.duplex = \"half\";\n            }\n            if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) headers = _objectSpread2(_objectSpread2({}, headers), fileOptions.headers);\n            const cleanPath = _this._removeEmptyFolders(path);\n            const _path = _this._getFinalPath(cleanPath);\n            const data = await (method == \"PUT\" ? put : post$1)(_this.fetch, `${_this.url}/object/${_path}`, body, _objectSpread2({\n                headers\n            }, (options === null || options === void 0 ? void 0 : options.duplex) ? {\n                duplex: options.duplex\n            } : {}));\n            return {\n                data: {\n                    path: cleanPath,\n                    id: data.Id,\n                    fullPath: data.Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Uploads a file to an existing bucket.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n\t* @returns Promise with response containing file path, id, and fullPath or error\n\t*\n\t* @example Upload file\n\t* ```js\n\t* const avatarFile = event.target.files[0]\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .upload('public/avatar1.png', avatarFile, {\n\t*     cacheControl: '3600',\n\t*     upsert: false\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"public/avatar1.png\",\n\t*     \"fullPath\": \"avatars/public/avatar1.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Upload file using `ArrayBuffer` from base64 file data\n\t* ```js\n\t* import { decode } from 'base64-arraybuffer'\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .upload('public/avatar1.png', decode('base64FileData'), {\n\t*     contentType: 'image/png'\n\t*   })\n\t* ```\n\t*/ async upload(path, fileBody, fileOptions) {\n        return this.uploadOrUpdate(\"POST\", path, fileBody, fileOptions);\n    }\n    /**\n\t* Upload a file with a token generated from `createSignedUploadUrl`.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param token The token generated from `createSignedUploadUrl`\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions HTTP headers (cacheControl, contentType, etc.).\n\t* **Note:** The `upsert` option has no effect here. To enable upsert behavior,\n\t* pass `{ upsert: true }` when calling `createSignedUploadUrl()` instead.\n\t* @returns Promise with response containing file path and fullPath or error\n\t*\n\t* @example Upload to a signed URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"folder/cat.jpg\",\n\t*     \"fullPath\": \"avatars/folder/cat.jpg\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async uploadToSignedUrl(path, token, fileBody, fileOptions) {\n        var _this3 = this;\n        const cleanPath = _this3._removeEmptyFolders(path);\n        const _path = _this3._getFinalPath(cleanPath);\n        const url = new URL(_this3.url + `/object/upload/sign/${_path}`);\n        url.searchParams.set(\"token\", token);\n        try {\n            let body;\n            const options = _objectSpread2({\n                upsert: DEFAULT_FILE_OPTIONS.upsert\n            }, fileOptions);\n            const headers = _objectSpread2(_objectSpread2({}, _this3.headers), {\n                \"x-upsert\": String(options.upsert)\n            });\n            if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                body = new FormData();\n                body.append(\"cacheControl\", options.cacheControl);\n                body.append(\"\", fileBody);\n            } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                body = fileBody;\n                body.append(\"cacheControl\", options.cacheControl);\n            } else {\n                body = fileBody;\n                headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                headers[\"content-type\"] = options.contentType;\n            }\n            return {\n                data: {\n                    path: cleanPath,\n                    fullPath: (await put(_this3.fetch, url.toString(), body, {\n                        headers\n                    })).Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a signed upload URL.\n\t* Signed upload URLs can be used to upload files to the bucket without further authentication.\n\t* They are valid for 2 hours.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the current file name. For example `folder/image.png`.\n\t* @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n\t* @returns Promise with response containing signed upload URL, token, and path or error\n\t*\n\t* @example Create Signed Upload URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUploadUrl('folder/cat.jpg')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/upload/sign/avatars/folder/cat.jpg?token=<TOKEN>\",\n\t*     \"path\": \"folder/cat.jpg\",\n\t*     \"token\": \"<TOKEN>\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createSignedUploadUrl(path, options) {\n        var _this4 = this;\n        try {\n            let _path = _this4._getFinalPath(path);\n            const headers = _objectSpread2({}, _this4.headers);\n            if (options === null || options === void 0 ? void 0 : options.upsert) headers[\"x-upsert\"] = \"true\";\n            const data = await post$1(_this4.fetch, `${_this4.url}/object/upload/sign/${_path}`, {}, {\n                headers\n            });\n            const url = new URL(_this4.url + data.url);\n            const token = url.searchParams.get(\"token\");\n            if (!token) throw new StorageError(\"No token returned by API\");\n            return {\n                data: {\n                    signedUrl: url.toString(),\n                    path,\n                    token\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Replaces an existing file at the specified path with a new one.\n\t*\n\t* @category File Buckets\n\t* @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n\t* @returns Promise with response containing file path, id, and fullPath or error\n\t*\n\t* @example Update file\n\t* ```js\n\t* const avatarFile = event.target.files[0]\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .update('public/avatar1.png', avatarFile, {\n\t*     cacheControl: '3600',\n\t*     upsert: true\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"public/avatar1.png\",\n\t*     \"fullPath\": \"avatars/public/avatar1.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Update file using `ArrayBuffer` from base64 file data\n\t* ```js\n\t* import {decode} from 'base64-arraybuffer'\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .update('public/avatar1.png', decode('base64FileData'), {\n\t*     contentType: 'image/png'\n\t*   })\n\t* ```\n\t*/ async update(path, fileBody, fileOptions) {\n        return this.uploadOrUpdate(\"PUT\", path, fileBody, fileOptions);\n    }\n    /**\n\t* Moves an existing file to a new path in the same bucket.\n\t*\n\t* @category File Buckets\n\t* @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n\t* @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n\t* @param options The destination options.\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Move file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .move('public/avatar1.png', 'private/avatar2.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully moved\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async move(fromPath, toPath, options) {\n        var _this6 = this;\n        try {\n            return {\n                data: await post$1(_this6.fetch, `${_this6.url}/object/move`, {\n                    bucketId: _this6.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                }, {\n                    headers: _this6.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this6.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Copies an existing file to a new path in the same bucket.\n\t*\n\t* @category File Buckets\n\t* @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n\t* @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n\t* @param options The destination options.\n\t* @returns Promise with response containing copied file path or error\n\t*\n\t* @example Copy file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .copy('public/avatar1.png', 'private/avatar2.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"avatars/private/avatar2.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async copy(fromPath, toPath, options) {\n        var _this7 = this;\n        try {\n            return {\n                data: {\n                    path: (await post$1(_this7.fetch, `${_this7.url}/object/copy`, {\n                        bucketId: _this7.bucketId,\n                        sourceKey: fromPath,\n                        destinationKey: toPath,\n                        destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                    }, {\n                        headers: _this7.headers\n                    })).Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this7.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the current file name. For example `folder/image.png`.\n\t* @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n\t* @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns Promise with response containing signed URL or error\n\t*\n\t* @example Create Signed URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Create a signed URL for an asset with transformations\n\t* ```js\n\t* const { data } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60, {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Create a signed URL which triggers the download of the asset\n\t* ```js\n\t* const { data } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60, {\n\t*     download: true,\n\t*   })\n\t* ```\n\t*/ async createSignedUrl(path, expiresIn, options) {\n        var _this8 = this;\n        try {\n            let _path = _this8._getFinalPath(path);\n            let data = await post$1(_this8.fetch, `${_this8.url}/object/sign/${_path}`, _objectSpread2({\n                expiresIn\n            }, (options === null || options === void 0 ? void 0 : options.transform) ? {\n                transform: options.transform\n            } : {}), {\n                headers: _this8.headers\n            });\n            const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n            data = {\n                signedUrl: encodeURI(`${_this8.url}${data.signedURL}${downloadQueryParam}`)\n            };\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            if (_this8.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n\t*\n\t* @category File Buckets\n\t* @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n\t* @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n\t* @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @returns Promise with response containing array of objects with signedUrl, path, and error or error\n\t*\n\t* @example Create Signed URLs\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"error\": null,\n\t*       \"path\": \"folder/avatar1.png\",\n\t*       \"signedURL\": \"/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\",\n\t*       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n\t*     },\n\t*     {\n\t*       \"error\": null,\n\t*       \"path\": \"folder/avatar2.png\",\n\t*       \"signedURL\": \"/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\",\n\t*       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\"\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createSignedUrls(paths, expiresIn, options) {\n        var _this9 = this;\n        try {\n            const data = await post$1(_this9.fetch, `${_this9.url}/object/sign/${_this9.bucketId}`, {\n                expiresIn,\n                paths\n            }, {\n                headers: _this9.headers\n            });\n            const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n            return {\n                data: data.map((datum)=>_objectSpread2(_objectSpread2({}, datum), {}, {\n                        signedUrl: datum.signedURL ? encodeURI(`${_this9.url}${datum.signedURL}${downloadQueryParam}`) : null\n                    })),\n                error: null\n            };\n        } catch (error) {\n            if (_this9.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n\t*\n\t* @category File Buckets\n\t* @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns BlobDownloadBuilder instance for downloading the file\n\t*\n\t* @example Download file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": <BLOB>,\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Download file with transformations\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png', {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*       quality: 80\n\t*     }\n\t*   })\n\t* ```\n\t*/ download(path, options) {\n        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\" ? \"render/image/authenticated\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        const queryString = transformationQuery ? `?${transformationQuery}` : \"\";\n        const _path = this._getFinalPath(path);\n        const downloadFn = ()=>get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n                headers: this.headers,\n                noResolveJson: true\n            });\n        return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError);\n    }\n    /**\n\t* Retrieves the details of an existing file.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. For example `folder/image.png`.\n\t* @returns Promise with response containing file metadata or error\n\t*\n\t* @example Get file info\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .info('folder/avatar1.png')\n\t* ```\n\t*/ async info(path) {\n        var _this10 = this;\n        const _path = _this10._getFinalPath(path);\n        try {\n            return {\n                data: recursiveToCamel(await get(_this10.fetch, `${_this10.url}/object/info/${_path}`, {\n                    headers: _this10.headers\n                })),\n                error: null\n            };\n        } catch (error) {\n            if (_this10.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Checks the existence of a file.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. For example `folder/image.png`.\n\t* @returns Promise with response containing boolean indicating file existence or error\n\t*\n\t* @example Check file existence\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .exists('folder/avatar1.png')\n\t* ```\n\t*/ async exists(path) {\n        var _this11 = this;\n        const _path = _this11._getFinalPath(path);\n        try {\n            await head(_this11.fetch, `${_this11.url}/object/${_path}`, {\n                headers: _this11.headers\n            });\n            return {\n                data: true,\n                error: null\n            };\n        } catch (error) {\n            if (_this11.shouldThrowOnError) throw error;\n            if (isStorageError(error) && error instanceof StorageUnknownError) {\n                const originalError = error.originalError;\n                if ([\n                    400,\n                    404\n                ].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) return {\n                    data: false,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n\t* A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n\t* This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n\t*\n\t* @category File Buckets\n\t* @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n\t* @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns Object with public URL\n\t*\n\t* @example Returns the URL for an asset in a public bucket\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"publicUrl\": \"https://example.supabase.co/storage/v1/object/public/public-bucket/folder/avatar1.png\"\n\t*   }\n\t* }\n\t* ```\n\t*\n\t* @example Returns the URL for an asset in a public bucket with transformations\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png', {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Returns the URL which triggers the download of an asset in a public bucket\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png', {\n\t*     download: true,\n\t*   })\n\t* ```\n\t*/ getPublicUrl(path, options) {\n        const _path = this._getFinalPath(path);\n        const _queryString = [];\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? \"\" : options.download}` : \"\";\n        if (downloadQueryParam !== \"\") _queryString.push(downloadQueryParam);\n        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\" ? \"render/image\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        if (transformationQuery !== \"\") _queryString.push(transformationQuery);\n        let queryString = _queryString.join(\"&\");\n        if (queryString !== \"\") queryString = `?${queryString}`;\n        return {\n            data: {\n                publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`)\n            }\n        };\n    }\n    /**\n\t* Deletes files within the same bucket\n\t*\n\t* @category File Buckets\n\t* @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n\t* @returns Promise with response containing array of deleted file objects or error\n\t*\n\t* @example Delete file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .remove(['folder/avatar1.png'])\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async remove(paths) {\n        var _this12 = this;\n        try {\n            return {\n                data: await remove(_this12.fetch, `${_this12.url}/object/${_this12.bucketId}`, {\n                    prefixes: paths\n                }, {\n                    headers: _this12.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this12.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Get file metadata\n\t* @param id the file id to retrieve metadata\n\t*/ /**\n\t* Update file metadata\n\t* @param id the file id to update metadata\n\t* @param meta the new file metadata\n\t*/ /**\n\t* Lists all the files and folders within a path of the bucket.\n\t*\n\t* @category File Buckets\n\t* @param path The folder path.\n\t* @param options Search options including limit (defaults to 100), offset, sortBy, and search\n\t* @param parameters Optional fetch parameters including signal for cancellation\n\t* @returns Promise with response containing array of files or error\n\t*\n\t* @example List files in a bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .list('folder', {\n\t*     limit: 100,\n\t*     offset: 0,\n\t*     sortBy: { column: 'name', order: 'asc' },\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"name\": \"avatar1.png\",\n\t*       \"id\": \"e668cf7f-821b-4a2f-9dce-7dfa5dd1cfd2\",\n\t*       \"updated_at\": \"2024-05-22T23:06:05.580Z\",\n\t*       \"created_at\": \"2024-05-22T23:04:34.443Z\",\n\t*       \"last_accessed_at\": \"2024-05-22T23:04:34.443Z\",\n\t*       \"metadata\": {\n\t*         \"eTag\": \"\\\"c5e8c553235d9af30ef4f6e280790b92\\\"\",\n\t*         \"size\": 32175,\n\t*         \"mimetype\": \"image/png\",\n\t*         \"cacheControl\": \"max-age=3600\",\n\t*         \"lastModified\": \"2024-05-22T23:06:05.574Z\",\n\t*         \"contentLength\": 32175,\n\t*         \"httpStatusCode\": 200\n\t*       }\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Search files in a bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .list('folder', {\n\t*     limit: 100,\n\t*     offset: 0,\n\t*     sortBy: { column: 'name', order: 'asc' },\n\t*     search: 'jon'\n\t*   })\n\t* ```\n\t*/ async list(path, options, parameters) {\n        var _this13 = this;\n        try {\n            const body = _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_SEARCH_OPTIONS), options), {}, {\n                prefix: path || \"\"\n            });\n            return {\n                data: await post$1(_this13.fetch, `${_this13.url}/object/list/${_this13.bucketId}`, body, {\n                    headers: _this13.headers\n                }, parameters),\n                error: null\n            };\n        } catch (error) {\n            if (_this13.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @experimental this method signature might change in the future\n\t*\n\t* @category File Buckets\n\t* @param options search options\n\t* @param parameters\n\t*/ async listV2(options, parameters) {\n        var _this14 = this;\n        try {\n            const body = _objectSpread2({}, options);\n            return {\n                data: await post$1(_this14.fetch, `${_this14.url}/object/list-v2/${_this14.bucketId}`, body, {\n                    headers: _this14.headers\n                }, parameters),\n                error: null\n            };\n        } catch (error) {\n            if (_this14.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    encodeMetadata(metadata) {\n        return JSON.stringify(metadata);\n    }\n    toBase64(data) {\n        if (typeof Buffer !== \"undefined\") return Buffer.from(data).toString(\"base64\");\n        return btoa(data);\n    }\n    _getFinalPath(path) {\n        return `${this.bucketId}/${path.replace(/^\\/+/, \"\")}`;\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, \"\").replace(/\\/+/g, \"/\");\n    }\n    transformOptsToQueryString(transform) {\n        const params = [];\n        if (transform.width) params.push(`width=${transform.width}`);\n        if (transform.height) params.push(`height=${transform.height}`);\n        if (transform.resize) params.push(`resize=${transform.resize}`);\n        if (transform.format) params.push(`format=${transform.format}`);\n        if (transform.quality) params.push(`quality=${transform.quality}`);\n        return params.join(\"&\");\n    }\n};\n//#endregion\n//#region src/lib/version.ts\nconst version = \"2.91.0\";\n//#endregion\n//#region src/lib/constants.ts\nconst DEFAULT_HEADERS$1 = {\n    \"X-Client-Info\": `storage-js/${version}`\n};\n//#endregion\n//#region src/packages/StorageBucketApi.ts\nvar StorageBucketApi = class {\n    constructor(url, headers = {}, fetch$1, opts){\n        this.shouldThrowOnError = false;\n        const baseUrl = new URL(url);\n        if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {\n            if (/supabase\\.(co|in|red)$/.test(baseUrl.hostname) && !baseUrl.hostname.includes(\"storage.supabase.\")) baseUrl.hostname = baseUrl.hostname.replace(\"supabase.\", \"storage.supabase.\");\n        }\n        this.url = baseUrl.href.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS$1), headers);\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* Enable throwing errors instead of returning them.\n\t*\n\t* @category File Buckets\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Retrieves the details of all Storage buckets within an existing project.\n\t*\n\t* @category File Buckets\n\t* @param options Query parameters for listing buckets\n\t* @param options.limit Maximum number of buckets to return\n\t* @param options.offset Number of buckets to skip\n\t* @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')\n\t* @param options.sortOrder Sort order ('asc' or 'desc')\n\t* @param options.search Search term to filter bucket names\n\t* @returns Promise with response containing array of buckets or error\n\t*\n\t* @example List buckets\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .listBuckets()\n\t* ```\n\t*\n\t* @example List buckets with options\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .listBuckets({\n\t*     limit: 10,\n\t*     offset: 0,\n\t*     sortColumn: 'created_at',\n\t*     sortOrder: 'desc',\n\t*     search: 'prod'\n\t*   })\n\t* ```\n\t*/ async listBuckets(options) {\n        var _this = this;\n        try {\n            const queryString = _this.listBucketOptionsToQueryString(options);\n            return {\n                data: await get(_this.fetch, `${_this.url}/bucket${queryString}`, {\n                    headers: _this.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Retrieves the details of an existing Storage bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to retrieve.\n\t* @returns Promise with response containing bucket details or error\n\t*\n\t* @example Get bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .getBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"id\": \"avatars\",\n\t*     \"name\": \"avatars\",\n\t*     \"owner\": \"\",\n\t*     \"public\": false,\n\t*     \"file_size_limit\": 1024,\n\t*     \"allowed_mime_types\": [\n\t*       \"image/png\"\n\t*     ],\n\t*     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async getBucket(id) {\n        var _this2 = this;\n        try {\n            return {\n                data: await get(_this2.fetch, `${_this2.url}/bucket/${id}`, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a new Storage bucket\n\t*\n\t* @category File Buckets\n\t* @param id A unique identifier for the bucket you are creating.\n\t* @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n\t* @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n\t* The global file size limit takes precedence over this value.\n\t* The default value is null, which doesn't set a per bucket file size limit.\n\t* @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n\t* The default value is null, which allows files with all mime types to be uploaded.\n\t* Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n\t* @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.\n\t*   - default bucket type is `STANDARD`\n\t* @returns Promise with response containing newly created bucket name or error\n\t*\n\t* @example Create bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .createBucket('avatars', {\n\t*     public: false,\n\t*     allowedMimeTypes: ['image/png'],\n\t*     fileSizeLimit: 1024\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"name\": \"avatars\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createBucket(id, options = {\n        public: false\n    }) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post$1(_this3.fetch, `${_this3.url}/bucket`, {\n                    id,\n                    name: id,\n                    type: options.type,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes\n                }, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Updates a Storage bucket\n\t*\n\t* @category File Buckets\n\t* @param id A unique identifier for the bucket you are updating.\n\t* @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n\t* @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n\t* The global file size limit takes precedence over this value.\n\t* The default value is null, which doesn't set a per bucket file size limit.\n\t* @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n\t* The default value is null, which allows files with all mime types to be uploaded.\n\t* Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Update bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .updateBucket('avatars', {\n\t*     public: false,\n\t*     allowedMimeTypes: ['image/png'],\n\t*     fileSizeLimit: 1024\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully updated\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async updateBucket(id, options) {\n        var _this4 = this;\n        try {\n            return {\n                data: await put(_this4.fetch, `${_this4.url}/bucket/${id}`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes\n                }, {\n                    headers: _this4.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Removes all objects inside a single bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to empty.\n\t* @returns Promise with success message or error\n\t*\n\t* @example Empty bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .emptyBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully emptied\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async emptyBucket(id) {\n        var _this5 = this;\n        try {\n            return {\n                data: await post$1(_this5.fetch, `${_this5.url}/bucket/${id}/empty`, {}, {\n                    headers: _this5.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this5.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n\t* You must first `empty()` the bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to delete.\n\t* @returns Promise with success message or error\n\t*\n\t* @example Delete bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .deleteBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully deleted\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async deleteBucket(id) {\n        var _this6 = this;\n        try {\n            return {\n                data: await remove(_this6.fetch, `${_this6.url}/bucket/${id}`, {}, {\n                    headers: _this6.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this6.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    listBucketOptionsToQueryString(options) {\n        const params = {};\n        if (options) {\n            if (\"limit\" in options) params.limit = String(options.limit);\n            if (\"offset\" in options) params.offset = String(options.offset);\n            if (options.search) params.search = options.search;\n            if (options.sortColumn) params.sortColumn = options.sortColumn;\n            if (options.sortOrder) params.sortOrder = options.sortOrder;\n        }\n        return Object.keys(params).length > 0 ? \"?\" + new URLSearchParams(params).toString() : \"\";\n    }\n};\n//#endregion\n//#region src/packages/StorageAnalyticsClient.ts\n/**\n* Client class for managing Analytics Buckets using Iceberg tables\n* Provides methods for creating, listing, and deleting analytics buckets\n*/ var StorageAnalyticsClient = class {\n    /**\n\t* @alpha\n\t*\n\t* Creates a new StorageAnalyticsClient instance\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param url - The base URL for the storage API\n\t* @param headers - HTTP headers to include in requests\n\t* @param fetch - Optional custom fetch implementation\n\t*\n\t* @example\n\t* ```typescript\n\t* const client = new StorageAnalyticsClient(url, headers)\n\t* ```\n\t*/ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS$1), headers);\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* @alpha\n\t*\n\t* Enable throwing errors instead of returning them in the response\n\t* When enabled, failed operations will throw instead of returning { data: null, error }\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @returns This instance for method chaining\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* @alpha\n\t*\n\t* Creates a new analytics bucket using Iceberg tables\n\t* Analytics buckets are optimized for analytical queries and data processing\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param name A unique name for the bucket you are creating\n\t* @returns Promise with response containing newly created analytics bucket or error\n\t*\n\t* @example Create analytics bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .createBucket('analytics-data')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"name\": \"analytics-data\",\n\t*     \"type\": \"ANALYTICS\",\n\t*     \"format\": \"iceberg\",\n\t*     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createBucket(name) {\n        var _this = this;\n        try {\n            return {\n                data: await post$1(_this.fetch, `${_this.url}/bucket`, {\n                    name\n                }, {\n                    headers: _this.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Retrieves the details of all Analytics Storage buckets within an existing project\n\t* Only returns buckets of type 'ANALYTICS'\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param options Query parameters for listing buckets\n\t* @param options.limit Maximum number of buckets to return\n\t* @param options.offset Number of buckets to skip\n\t* @param options.sortColumn Column to sort by ('name', 'created_at', 'updated_at')\n\t* @param options.sortOrder Sort order ('asc' or 'desc')\n\t* @param options.search Search term to filter bucket names\n\t* @returns Promise with response containing array of analytics buckets or error\n\t*\n\t* @example List analytics buckets\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .listBuckets({\n\t*     limit: 10,\n\t*     offset: 0,\n\t*     sortColumn: 'created_at',\n\t*     sortOrder: 'desc'\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"name\": \"analytics-data\",\n\t*       \"type\": \"ANALYTICS\",\n\t*       \"format\": \"iceberg\",\n\t*       \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*       \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async listBuckets(options) {\n        var _this2 = this;\n        try {\n            const queryParams = new URLSearchParams();\n            if ((options === null || options === void 0 ? void 0 : options.limit) !== void 0) queryParams.set(\"limit\", options.limit.toString());\n            if ((options === null || options === void 0 ? void 0 : options.offset) !== void 0) queryParams.set(\"offset\", options.offset.toString());\n            if (options === null || options === void 0 ? void 0 : options.sortColumn) queryParams.set(\"sortColumn\", options.sortColumn);\n            if (options === null || options === void 0 ? void 0 : options.sortOrder) queryParams.set(\"sortOrder\", options.sortOrder);\n            if (options === null || options === void 0 ? void 0 : options.search) queryParams.set(\"search\", options.search);\n            const queryString = queryParams.toString();\n            const url = queryString ? `${_this2.url}/bucket?${queryString}` : `${_this2.url}/bucket`;\n            return {\n                data: await get(_this2.fetch, url, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Deletes an existing analytics bucket\n\t* A bucket can't be deleted with existing objects inside it\n\t* You must first empty the bucket before deletion\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param bucketName The unique identifier of the bucket you would like to delete\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Delete analytics bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .deleteBucket('analytics-data')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully deleted\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async deleteBucket(bucketName) {\n        var _this3 = this;\n        try {\n            return {\n                data: await remove(_this3.fetch, `${_this3.url}/bucket/${bucketName}`, {}, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Get an Iceberg REST Catalog client configured for a specific analytics bucket\n\t* Use this to perform advanced table and namespace operations within the bucket\n\t* The returned client provides full access to the Apache Iceberg REST Catalog API\n\t* with the Supabase `{ data, error }` pattern for consistent error handling on all operations.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param bucketName - The name of the analytics bucket (warehouse) to connect to\n\t* @returns The wrapped Iceberg catalog client\n\t* @throws {StorageError} If the bucket name is invalid\n\t*\n\t* @example Get catalog and create table\n\t* ```js\n\t* // First, create an analytics bucket\n\t* const { data: bucket, error: bucketError } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .createBucket('analytics-data')\n\t*\n\t* // Get the Iceberg catalog for that bucket\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // Create a namespace\n\t* const { error: nsError } = await catalog.createNamespace({ namespace: ['default'] })\n\t*\n\t* // Create a table with schema\n\t* const { data: tableMetadata, error: tableError } = await catalog.createTable(\n\t*   { namespace: ['default'] },\n\t*   {\n\t*     name: 'events',\n\t*     schema: {\n\t*       type: 'struct',\n\t*       fields: [\n\t*         { id: 1, name: 'id', type: 'long', required: true },\n\t*         { id: 2, name: 'timestamp', type: 'timestamp', required: true },\n\t*         { id: 3, name: 'user_id', type: 'string', required: false }\n\t*       ],\n\t*       'schema-id': 0,\n\t*       'identifier-field-ids': [1]\n\t*     },\n\t*     'partition-spec': {\n\t*       'spec-id': 0,\n\t*       fields: []\n\t*     },\n\t*     'write-order': {\n\t*       'order-id': 0,\n\t*       fields: []\n\t*     },\n\t*     properties: {\n\t*       'write.format.default': 'parquet'\n\t*     }\n\t*   }\n\t* )\n\t* ```\n\t*\n\t* @example List tables in namespace\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // List all tables in the default namespace\n\t* const { data: tables, error: listError } = await catalog.listTables({ namespace: ['default'] })\n\t* if (listError) {\n\t*   if (listError.isNotFound()) {\n\t*     console.log('Namespace not found')\n\t*   }\n\t*   return\n\t* }\n\t* console.log(tables) // [{ namespace: ['default'], name: 'events' }]\n\t* ```\n\t*\n\t* @example Working with namespaces\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // List all namespaces\n\t* const { data: namespaces } = await catalog.listNamespaces()\n\t*\n\t* // Create namespace with properties\n\t* await catalog.createNamespace(\n\t*   { namespace: ['production'] },\n\t*   { properties: { owner: 'data-team', env: 'prod' } }\n\t* )\n\t* ```\n\t*\n\t* @example Cleanup operations\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // Drop table with purge option (removes all data)\n\t* const { error: dropError } = await catalog.dropTable(\n\t*   { namespace: ['default'], name: 'events' },\n\t*   { purge: true }\n\t* )\n\t*\n\t* if (dropError?.isNotFound()) {\n\t*   console.log('Table does not exist')\n\t* }\n\t*\n\t* // Drop namespace (must be empty)\n\t* await catalog.dropNamespace({ namespace: ['default'] })\n\t* ```\n\t*\n\t* @remarks\n\t* This method provides a bridge between Supabase's bucket management and the standard\n\t* Apache Iceberg REST Catalog API. The bucket name maps to the Iceberg warehouse parameter.\n\t* All authentication and configuration is handled automatically using your Supabase credentials.\n\t*\n\t* **Error Handling**: Invalid bucket names throw immediately. All catalog\n\t* operations return `{ data, error }` where errors are `IcebergError` instances from iceberg-js.\n\t* Use helper methods like `error.isNotFound()` or check `error.status` for specific error handling.\n\t* Use `.throwOnError()` on the analytics client if you prefer exceptions for catalog operations.\n\t*\n\t* **Cleanup Operations**: When using `dropTable`, the `purge: true` option permanently\n\t* deletes all table data. Without it, the table is marked as deleted but data remains.\n\t*\n\t* **Library Dependency**: The returned catalog wraps `IcebergRestCatalog` from iceberg-js.\n\t* For complete API documentation and advanced usage, refer to the\n\t* [iceberg-js documentation](https://supabase.github.io/iceberg-js/).\n\t*/ from(bucketName) {\n        var _this4 = this;\n        if (!isValidBucketName(bucketName)) throw new StorageError(\"Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.\");\n        const catalog = new iceberg_js.IcebergRestCatalog({\n            baseUrl: this.url,\n            catalogName: bucketName,\n            auth: {\n                type: \"custom\",\n                getHeaders: async ()=>_this4.headers\n            },\n            fetch: this.fetch\n        });\n        const shouldThrowOnError = this.shouldThrowOnError;\n        return new Proxy(catalog, {\n            get (target, prop) {\n                const value = target[prop];\n                if (typeof value !== \"function\") return value;\n                return async (...args)=>{\n                    try {\n                        return {\n                            data: await value.apply(target, args),\n                            error: null\n                        };\n                    } catch (error) {\n                        if (shouldThrowOnError) throw error;\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                };\n            }\n        });\n    }\n};\n//#endregion\n//#region src/lib/vectors/constants.ts\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `storage-js/${version}`,\n    \"Content-Type\": \"application/json\"\n};\n//#endregion\n//#region src/lib/vectors/errors.ts\n/**\n* Base error class for all Storage Vectors errors\n*/ var StorageVectorsError = class extends Error {\n    constructor(message){\n        super(message);\n        this.__isStorageVectorsError = true;\n        this.name = \"StorageVectorsError\";\n    }\n};\n/**\n* Type guard to check if an error is a StorageVectorsError\n* @param error - The error to check\n* @returns True if the error is a StorageVectorsError\n*/ function isStorageVectorsError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageVectorsError\" in error;\n}\n/**\n* API error returned from S3 Vectors service\n* Includes HTTP status code and service-specific error code\n*/ var StorageVectorsApiError = class extends StorageVectorsError {\n    constructor(message, status, statusCode){\n        super(message);\n        this.name = \"StorageVectorsApiError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode\n        };\n    }\n};\n/**\n* Unknown error that doesn't match expected error patterns\n* Wraps the original error for debugging\n*/ var StorageVectorsUnknownError = class extends StorageVectorsError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"StorageVectorsUnknownError\";\n        this.originalError = originalError;\n    }\n};\n/**\n* Error codes specific to S3 Vectors API\n* Maps AWS service errors to application-friendly error codes\n*/ let StorageVectorsErrorCode = /* @__PURE__ */ function(StorageVectorsErrorCode$1) {\n    /** Internal server fault (HTTP 500) */ StorageVectorsErrorCode$1[\"InternalError\"] = \"InternalError\";\n    /** Resource already exists / conflict (HTTP 409) */ StorageVectorsErrorCode$1[\"S3VectorConflictException\"] = \"S3VectorConflictException\";\n    /** Resource not found (HTTP 404) */ StorageVectorsErrorCode$1[\"S3VectorNotFoundException\"] = \"S3VectorNotFoundException\";\n    /** Delete bucket while not empty (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorBucketNotEmpty\"] = \"S3VectorBucketNotEmpty\";\n    /** Exceeds bucket quota/limit (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorMaxBucketsExceeded\"] = \"S3VectorMaxBucketsExceeded\";\n    /** Exceeds index quota/limit (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorMaxIndexesExceeded\"] = \"S3VectorMaxIndexesExceeded\";\n    return StorageVectorsErrorCode$1;\n}({});\n//#endregion\n//#region src/lib/vectors/helpers.ts\n/**\n* Resolves the fetch implementation to use\n* Uses custom fetch if provided, otherwise uses native fetch\n*\n* @param customFetch - Optional custom fetch implementation\n* @returns Resolved fetch function\n*/ const resolveFetch = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\n/**\n* Resolves the Response constructor to use\n* Returns native Response constructor\n*\n* @returns Response constructor\n*/ const resolveResponse = ()=>{\n    return Response;\n};\n/**\n* Determine if input is a plain object\n* An object is plain if it's created by either {}, new Object(), or Object.create(null)\n*\n* @param value - Value to check\n* @returns True if value is a plain object\n* @source https://github.com/sindresorhus/is-plain-obj\n*/ const isPlainObject = (value)=>{\n    if (typeof value !== \"object\" || value === null) return false;\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};\n/**\n* Normalizes a number array to float32 format\n* Ensures all vector values are valid 32-bit floats\n*\n* @param values - Array of numbers to normalize\n* @returns Normalized float32 array\n*/ const normalizeToFloat32 = (values)=>{\n    return Array.from(new Float32Array(values));\n};\n/**\n* Validates vector dimensions match expected dimension\n* Throws error if dimensions don't match\n*\n* @param vector - Vector data to validate\n* @param expectedDimension - Expected vector dimension\n* @throws Error if dimensions don't match\n*/ const validateVectorDimension = (vector, expectedDimension)=>{\n    if (expectedDimension !== void 0 && vector.float32.length !== expectedDimension) throw new Error(`Vector dimension mismatch: expected ${expectedDimension}, got ${vector.float32.length}`);\n};\n//#endregion\n//#region src/lib/vectors/fetch.ts\n/**\n* Extracts error message from various error response formats\n* @param err - Error object from API\n* @returns Human-readable error message\n*/ const _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\n/**\n* Handles fetch errors and converts them to StorageVectors error types\n* @param error - The error caught from fetch\n* @param reject - Promise rejection function\n* @param options - Fetch options that may affect error handling\n*/ const handleError = async (error, reject, options)=>{\n    if (error && typeof error === \"object\" && \"status\" in error && \"ok\" in error && typeof error.status === \"number\" && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {\n        const status = error.status || 500;\n        const responseError = error;\n        if (typeof responseError.json === \"function\") responseError.json().then((err)=>{\n            const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + \"\";\n            reject(new StorageVectorsApiError(_getErrorMessage(err), status, statusCode));\n        }).catch(()=>{\n            const statusCode = status + \"\";\n            reject(new StorageVectorsApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode));\n        });\n        else {\n            const statusCode = status + \"\";\n            reject(new StorageVectorsApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode));\n        }\n    } else reject(new StorageVectorsUnknownError(_getErrorMessage(error), error));\n};\n/**\n* Builds request parameters for fetch calls\n* @param method - HTTP method\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters like AbortSignal\n* @param body - Request body (will be JSON stringified if plain object)\n* @returns Complete fetch request parameters\n*/ const _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\" || !body) return params;\n    if (isPlainObject(body)) {\n        params.headers = _objectSpread2({\n            \"Content-Type\": \"application/json\"\n        }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    } else params.body = body;\n    return _objectSpread2(_objectSpread2({}, params), parameters);\n};\n/**\n* Internal request handler that wraps fetch with error handling\n* @param fetcher - Fetch function to use\n* @param method - HTTP method\n* @param url - Request URL\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters\n* @param body - Request body\n* @returns Promise with parsed response or error\n*/ async function _handleRequest(fetcher, method, url, options, parameters, body) {\n    return new Promise((resolve, reject)=>{\n        fetcher(url, _getRequestParams(method, options, parameters, body)).then((result)=>{\n            if (!result.ok) throw result;\n            if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n            const contentType = result.headers.get(\"content-type\");\n            if (!contentType || !contentType.includes(\"application/json\")) return {};\n            return result.json();\n        }).then((data)=>resolve(data)).catch((error)=>handleError(error, reject, options));\n    });\n}\n/**\n* Performs a POST request\n* @param fetcher - Fetch function to use\n* @param url - Request URL\n* @param body - Request body to be JSON stringified\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters\n* @returns Promise with parsed response\n*/ async function post(fetcher, url, body, options, parameters) {\n    return _handleRequest(fetcher, \"POST\", url, options, parameters, body);\n}\n//#endregion\n//#region src/lib/vectors/VectorIndexApi.ts\n/**\n* @hidden\n* Base implementation for vector index operations.\n* Use {@link VectorBucketScope} via `supabase.storage.vectors.from('bucket')` instead.\n*/ var VectorIndexApi = class {\n    /** Creates a new VectorIndexApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Creates a new vector index within a bucket */ async createIndex(options) {\n        var _this = this;\n        try {\n            return {\n                data: await post(_this.fetch, `${_this.url}/CreateIndex`, options, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves metadata for a specific vector index */ async getIndex(vectorBucketName, indexName) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetIndex`, {\n                    vectorBucketName,\n                    indexName\n                }, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vector indexes within a bucket with optional filtering and pagination */ async listIndexes(options) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListIndexes`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes a vector index and all its data */ async deleteIndex(vectorBucketName, indexName) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/DeleteIndex`, {\n                    vectorBucketName,\n                    indexName\n                }, {\n                    headers: _this4.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/VectorDataApi.ts\n/**\n* @hidden\n* Base implementation for vector data operations.\n* Use {@link VectorIndexScope} via `supabase.storage.vectors.from('bucket').index('idx')` instead.\n*/ var VectorDataApi = class {\n    /** Creates a new VectorDataApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Inserts or updates vectors in batch (1-500 per request) */ async putVectors(options) {\n        var _this = this;\n        try {\n            if (options.vectors.length < 1 || options.vectors.length > 500) throw new Error(\"Vector batch size must be between 1 and 500 items\");\n            return {\n                data: await post(_this.fetch, `${_this.url}/PutVectors`, options, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves vectors by their keys in batch */ async getVectors(options) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetVectors`, options, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vectors in an index with pagination */ async listVectors(options) {\n        var _this3 = this;\n        try {\n            if (options.segmentCount !== void 0) {\n                if (options.segmentCount < 1 || options.segmentCount > 16) throw new Error(\"segmentCount must be between 1 and 16\");\n                if (options.segmentIndex !== void 0) {\n                    if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);\n                }\n            }\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListVectors`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Queries for similar vectors using approximate nearest neighbor search */ async queryVectors(options) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/QueryVectors`, options, {\n                    headers: _this4.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes vectors by their keys in batch (1-500 per request) */ async deleteVectors(options) {\n        var _this5 = this;\n        try {\n            if (options.keys.length < 1 || options.keys.length > 500) throw new Error(\"Keys batch size must be between 1 and 500 items\");\n            return {\n                data: await post(_this5.fetch, `${_this5.url}/DeleteVectors`, options, {\n                    headers: _this5.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this5.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/VectorBucketApi.ts\n/**\n* @hidden\n* Base implementation for vector bucket operations.\n* Use {@link StorageVectorsClient} via `supabase.storage.vectors` instead.\n*/ var VectorBucketApi = class {\n    /** Creates a new VectorBucketApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Creates a new vector bucket */ async createBucket(vectorBucketName) {\n        var _this = this;\n        try {\n            return {\n                data: await post(_this.fetch, `${_this.url}/CreateVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves metadata for a specific vector bucket */ async getBucket(vectorBucketName) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vector buckets with optional filtering and pagination */ async listBuckets(options = {}) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListVectorBuckets`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes a vector bucket (must be empty first) */ async deleteBucket(vectorBucketName) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/DeleteVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this4.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/StorageVectorsClient.ts\n/**\n*\n* @alpha\n*\n* Main client for interacting with S3 Vectors API\n* Provides access to bucket, index, and vector data operations\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*\n* **Usage Patterns:**\n*\n* ```typescript\n* const { data, error } = await supabase\n*  .storage\n*  .vectors\n*  .createBucket('embeddings-prod')\n*\n* // Access index operations via buckets\n* const bucket = supabase.storage.vectors.from('embeddings-prod')\n* await bucket.createIndex({\n*   indexName: 'documents',\n*   dataType: 'float32',\n*   dimension: 1536,\n*   distanceMetric: 'cosine'\n* })\n*\n* // Access vector operations via index\n* const index = bucket.index('documents')\n* await index.putVectors({\n*   vectors: [\n*     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n*   ]\n* })\n*\n* // Query similar vectors\n* const { data } = await index.queryVectors({\n*   queryVector: { float32: [...] },\n*   topK: 5,\n*   returnDistance: true\n* })\n* ```\n*/ var StorageVectorsClient = class extends VectorBucketApi {\n    /**\n\t* @alpha\n\t*\n\t* Creates a StorageVectorsClient that can manage buckets, indexes, and vectors.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param url - Base URL of the Storage Vectors REST API.\n\t* @param options.headers - Optional headers (for example `Authorization`) applied to every request.\n\t* @param options.fetch - Optional custom `fetch` implementation for non-browser runtimes.\n\t*\n\t* @example\n\t* ```typescript\n\t* const client = new StorageVectorsClient(url, options)\n\t* ```\n\t*/ constructor(url, options = {}){\n        super(url, options.headers || {}, options.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access operations for a specific vector bucket\n\t* Returns a scoped client for index and vector operations within the bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket\n\t* @returns Bucket-scoped client with index and vector operations\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* ```\n\t*/ from(vectorBucketName) {\n        return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a new vector bucket\n\t* Vector buckets are containers for vector indexes and their data\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Unique name for the vector bucket\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .createBucket('embeddings-prod')\n\t* ```\n\t*/ async createBucket(vectorBucketName) {\n        var _superprop_getCreateBucket = ()=>super.createBucket, _this = this;\n        return _superprop_getCreateBucket().call(_this, vectorBucketName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves metadata for a specific vector bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket\n\t* @returns Promise with bucket metadata or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .getBucket('embeddings-prod')\n\t*\n\t* console.log('Bucket created:', data?.vectorBucket.creationTime)\n\t* ```\n\t*/ async getBucket(vectorBucketName) {\n        var _superprop_getGetBucket = ()=>super.getBucket, _this2 = this;\n        return _superprop_getGetBucket().call(_this2, vectorBucketName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists all vector buckets with optional filtering and pagination\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Optional filters (prefix, maxResults, nextToken)\n\t* @returns Promise with list of buckets or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .listBuckets({ prefix: 'embeddings-' })\n\t*\n\t* data?.vectorBuckets.forEach(bucket => {\n\t*   console.log(bucket.vectorBucketName)\n\t* })\n\t* ```\n\t*/ async listBuckets(options = {}) {\n        var _superprop_getListBuckets = ()=>super.listBuckets, _this3 = this;\n        return _superprop_getListBuckets().call(_this3, options);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes a vector bucket (bucket must be empty)\n\t* All indexes must be deleted before deleting the bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket to delete\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .deleteBucket('embeddings-old')\n\t* ```\n\t*/ async deleteBucket(vectorBucketName) {\n        var _superprop_getDeleteBucket = ()=>super.deleteBucket, _this4 = this;\n        return _superprop_getDeleteBucket().call(_this4, vectorBucketName);\n    }\n};\n/**\n*\n* @alpha\n*\n* Scoped client for operations within a specific vector bucket\n* Provides index management and access to vector operations\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*/ var VectorBucketScope = class extends VectorIndexApi {\n    /**\n\t* @alpha\n\t*\n\t* Creates a helper that automatically scopes all index operations to the provided bucket.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* ```\n\t*/ constructor(url, headers, vectorBucketName, fetch$1){\n        super(url, headers, fetch$1);\n        this.vectorBucketName = vectorBucketName;\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a new vector index in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Index configuration (vectorBucketName is automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* await bucket.createIndex({\n\t*   indexName: 'documents-openai',\n\t*   dataType: 'float32',\n\t*   dimension: 1536,\n\t*   distanceMetric: 'cosine',\n\t*   metadataConfiguration: {\n\t*     nonFilterableMetadataKeys: ['raw_text']\n\t*   }\n\t* })\n\t* ```\n\t*/ async createIndex(options) {\n        var _superprop_getCreateIndex = ()=>super.createIndex, _this5 = this;\n        return _superprop_getCreateIndex().call(_this5, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this5.vectorBucketName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists indexes in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Listing options (vectorBucketName is automatically set)\n\t* @returns Promise with response containing indexes array and pagination token or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* const { data } = await bucket.listIndexes({ prefix: 'documents-' })\n\t* ```\n\t*/ async listIndexes(options = {}) {\n        var _superprop_getListIndexes = ()=>super.listIndexes, _this6 = this;\n        return _superprop_getListIndexes().call(_this6, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this6.vectorBucketName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves metadata for a specific index in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index to retrieve\n\t* @returns Promise with index metadata or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* const { data } = await bucket.getIndex('documents-openai')\n\t* console.log('Dimension:', data?.index.dimension)\n\t* ```\n\t*/ async getIndex(indexName) {\n        var _superprop_getGetIndex = ()=>super.getIndex, _this7 = this;\n        return _superprop_getGetIndex().call(_this7, _this7.vectorBucketName, indexName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes an index from this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index to delete\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* await bucket.deleteIndex('old-index')\n\t* ```\n\t*/ async deleteIndex(indexName) {\n        var _superprop_getDeleteIndex = ()=>super.deleteIndex, _this8 = this;\n        return _superprop_getDeleteIndex().call(_this8, _this8.vectorBucketName, indexName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access operations for a specific index within this bucket\n\t* Returns a scoped client for vector data operations\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index\n\t* @returns Index-scoped client with vector data operations\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t*\n\t* // Insert vectors\n\t* await index.putVectors({\n\t*   vectors: [\n\t*     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n\t*   ]\n\t* })\n\t*\n\t* // Query similar vectors\n\t* const { data } = await index.queryVectors({\n\t*   queryVector: { float32: [...] },\n\t*   topK: 5\n\t* })\n\t* ```\n\t*/ index(indexName) {\n        return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);\n    }\n};\n/**\n*\n* @alpha\n*\n* Scoped client for operations within a specific vector index\n* Provides vector data operations (put, get, list, query, delete)\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*/ var VectorIndexScope = class extends VectorDataApi {\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a helper that automatically scopes all vector operations to the provided bucket/index names.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* ```\n\t*/ constructor(url, headers, vectorBucketName, indexName, fetch$1){\n        super(url, headers, fetch$1);\n        this.vectorBucketName = vectorBucketName;\n        this.indexName = indexName;\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Inserts or updates vectors in this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Vector insertion options (bucket and index names automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* await index.putVectors({\n\t*   vectors: [\n\t*     {\n\t*       key: 'doc-1',\n\t*       data: { float32: [0.1, 0.2, ...] },\n\t*       metadata: { title: 'Introduction', page: 1 }\n\t*     }\n\t*   ]\n\t* })\n\t* ```\n\t*/ async putVectors(options) {\n        var _superprop_getPutVectors = ()=>super.putVectors, _this9 = this;\n        return _superprop_getPutVectors().call(_this9, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this9.vectorBucketName,\n            indexName: _this9.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves vectors by keys from this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Vector retrieval options (bucket and index names automatically set)\n\t* @returns Promise with response containing vectors array or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.getVectors({\n\t*   keys: ['doc-1', 'doc-2'],\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async getVectors(options) {\n        var _superprop_getGetVectors = ()=>super.getVectors, _this10 = this;\n        return _superprop_getGetVectors().call(_this10, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this10.vectorBucketName,\n            indexName: _this10.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists vectors in this index with pagination\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Listing options (bucket and index names automatically set)\n\t* @returns Promise with response containing vectors array and pagination token or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.listVectors({\n\t*   maxResults: 500,\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async listVectors(options = {}) {\n        var _superprop_getListVectors = ()=>super.listVectors, _this11 = this;\n        return _superprop_getListVectors().call(_this11, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this11.vectorBucketName,\n            indexName: _this11.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Queries for similar vectors in this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Query options (bucket and index names automatically set)\n\t* @returns Promise with response containing matches array of similar vectors ordered by distance or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.queryVectors({\n\t*   queryVector: { float32: [0.1, 0.2, ...] },\n\t*   topK: 5,\n\t*   filter: { category: 'technical' },\n\t*   returnDistance: true,\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async queryVectors(options) {\n        var _superprop_getQueryVectors = ()=>super.queryVectors, _this12 = this;\n        return _superprop_getQueryVectors().call(_this12, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this12.vectorBucketName,\n            indexName: _this12.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes vectors by keys from this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Deletion options (bucket and index names automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* await index.deleteVectors({\n\t*   keys: ['doc-1', 'doc-2', 'doc-3']\n\t* })\n\t* ```\n\t*/ async deleteVectors(options) {\n        var _superprop_getDeleteVectors = ()=>super.deleteVectors, _this13 = this;\n        return _superprop_getDeleteVectors().call(_this13, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this13.vectorBucketName,\n            indexName: _this13.indexName\n        }));\n    }\n};\n//#endregion\n//#region src/StorageClient.ts\nvar StorageClient = class extends StorageBucketApi {\n    /**\n\t* Creates a client for Storage buckets, files, analytics, and vectors.\n\t*\n\t* @category File Buckets\n\t* @example\n\t* ```ts\n\t* import { StorageClient } from '@supabase/storage-js'\n\t*\n\t* const storage = new StorageClient('https://xyzcompany.supabase.co/storage/v1', {\n\t*   apikey: 'public-anon-key',\n\t* })\n\t* const avatars = storage.from('avatars')\n\t* ```\n\t*/ constructor(url, headers = {}, fetch$1, opts){\n        super(url, headers, fetch$1, opts);\n    }\n    /**\n\t* Perform file operation in a bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The bucket id to operate on.\n\t*\n\t* @example\n\t* ```typescript\n\t* const avatars = supabase.storage.from('avatars')\n\t* ```\n\t*/ from(id) {\n        return new StorageFileApi(this.url, this.headers, id, this.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access vector storage operations.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @returns A StorageVectorsClient instance configured with the current storage settings.\n\t*/ get vectors() {\n        return new StorageVectorsClient(this.url + \"/vector\", {\n            headers: this.headers,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access analytics storage operations using Iceberg tables.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @returns A StorageAnalyticsClient instance configured with the current storage settings.\n\t*/ get analytics() {\n        return new StorageAnalyticsClient(this.url + \"/iceberg\", this.headers, this.fetch);\n    }\n};\n//#endregion\nexports.StorageAnalyticsClient = StorageAnalyticsClient;\nexports.StorageApiError = StorageApiError;\nexports.StorageClient = StorageClient;\nexports.StorageError = StorageError;\nexports.StorageUnknownError = StorageUnknownError;\nexports.StorageVectorsApiError = StorageVectorsApiError;\nexports.StorageVectorsClient = StorageVectorsClient;\nexports.StorageVectorsError = StorageVectorsError;\nexports.StorageVectorsErrorCode = StorageVectorsErrorCode;\nexports.StorageVectorsUnknownError = StorageVectorsUnknownError;\nexports.VectorBucketApi = VectorBucketApi;\nexports.VectorBucketScope = VectorBucketScope;\nexports.VectorDataApi = VectorDataApi;\nexports.VectorIndexApi = VectorIndexApi;\nexports.VectorIndexScope = VectorIndexScope;\nexports.isPlainObject = isPlainObject;\nexports.isStorageError = isStorageError;\nexports.isStorageVectorsError = isStorageVectorsError;\nexports.normalizeToFloat32 = normalizeToFloat32;\nexports.resolveFetch = resolveFetch;\nexports.resolveResponse = resolveResponse;\nexports.validateVectorDimension = validateVectorDimension; //# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsYUFBYUMsbUJBQU9BLENBQUMsa0VBQVk7QUFFckMsMkJBQTJCO0FBQzNCLElBQUlDLGVBQWUsY0FBY0M7SUFDaENDLFlBQVlDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNDLElBQUksR0FBRztJQUNiO0FBQ0Q7QUFDQSxTQUFTQyxlQUFlQyxLQUFLO0lBQzVCLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsc0JBQXNCQTtBQUM3RTtBQUNBLElBQUlDLGtCQUFrQixjQUFjUjtJQUNuQ0UsWUFBWUMsT0FBTyxFQUFFTSxNQUFNLEVBQUVDLFVBQVUsQ0FBRTtRQUN4QyxLQUFLLENBQUNQO1FBQ04sSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNJLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFVBQVUsR0FBR0E7SUFDbkI7SUFDQUMsU0FBUztRQUNSLE9BQU87WUFDTk4sTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkYsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJNLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CQyxZQUFZLElBQUksQ0FBQ0EsVUFBVTtRQUM1QjtJQUNEO0FBQ0Q7QUFDQSxJQUFJRSxzQkFBc0IsY0FBY1o7SUFDdkNFLFlBQVlDLE9BQU8sRUFBRVUsYUFBYSxDQUFFO1FBQ25DLEtBQUssQ0FBQ1Y7UUFDTixJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ1EsYUFBYSxHQUFHQTtJQUN0QjtBQUNEO0FBRUEsWUFBWTtBQUNaLDRCQUE0QjtBQUM1QixNQUFNQyxpQkFBaUIsQ0FBQ0M7SUFDdkIsSUFBSUEsYUFBYSxPQUFPLENBQUMsR0FBR0MsT0FBU0QsZUFBZUM7SUFDcEQsT0FB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QUE4QixHQUFHMUQ7QUFDakMwRCw0QkFBNEIsR0FBR25CO0FBQy9CbUIsMkJBQTJCLEdBQUc3RDtBQUM5QjZELCtCQUErQixHQUFHeEQ7QUFDbEN3RCxrQ0FBa0MsR0FBR3pEO0FBQ3JDeUQsdUJBQXVCLEdBQUdwQjtBQUMxQm9CLHlCQUF5QixHQUFHbEI7QUFDNUJrQixxQkFBcUIsR0FBRzdCO0FBQ3hCNkIsc0JBQXNCLEdBQUdwQztBQUN6Qm9DLHdCQUF3QixHQUFHUjtBQUMzQlEscUJBQXFCLEdBQUdwRDtBQUN4Qm9ELHNCQUFzQixHQUFHMVQ7QUFDekIwVCw2QkFBNkIsR0FBRzNEO0FBQ2hDMkQsMEJBQTBCLEdBQUduRDtBQUM3Qm1ELG9CQUFvQixHQUFHdEQ7QUFDdkJzRCx1QkFBdUIsR0FBR3JEO0FBQzFCcUQsK0JBQStCLEdBQUdoRCx5QkFDbEMsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvaW5kZXguY2pzPzFjMjYiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGljZWJlcmdfanMgPSByZXF1aXJlKFwiaWNlYmVyZy1qc1wiKTtcblxuLy8jcmVnaW9uIHNyYy9saWIvZXJyb3JzLnRzXG52YXIgU3RvcmFnZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLl9faXNTdG9yYWdlRXJyb3IgPSB0cnVlO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZUVycm9yXCI7XG5cdH1cbn07XG5mdW5jdGlvbiBpc1N0b3JhZ2VFcnJvcihlcnJvcikge1xuXHRyZXR1cm4gdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIGVycm9yICE9PSBudWxsICYmIFwiX19pc1N0b3JhZ2VFcnJvclwiIGluIGVycm9yO1xufVxudmFyIFN0b3JhZ2VBcGlFcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBzdGF0dXNDb2RlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gXCJTdG9yYWdlQXBpRXJyb3JcIjtcblx0XHR0aGlzLnN0YXR1cyA9IHN0YXR1cztcblx0XHR0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuXHR9XG5cdHRvSlNPTigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXHRcdFx0bWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuXHRcdFx0c3RhdHVzOiB0aGlzLnN0YXR1cyxcblx0XHRcdHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZVxuXHRcdH07XG5cdH1cbn07XG52YXIgU3RvcmFnZVVua25vd25FcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZVVua25vd25FcnJvclwiO1xuXHRcdHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvaGVscGVycy50c1xuY29uc3QgcmVzb2x2ZUZldGNoJDEgPSAoY3VzdG9tRmV0Y2gpID0+IHtcblx0aWYgKGN1c3RvbUZldGNoKSByZXR1cm4gKC4uLmFyZ3MpID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpO1xuXHRyZXR1cm4gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xufTtcbmNvbnN0IHJlc29sdmVSZXNwb25zZSQxID0gKCkgPT4ge1xuXHRyZXR1cm4gUmVzcG9uc2U7XG59O1xuY29uc3QgcmVjdXJzaXZlVG9DYW1lbCA9IChpdGVtKSA9PiB7XG5cdGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSByZXR1cm4gaXRlbS5tYXAoKGVsKSA9PiByZWN1cnNpdmVUb0NhbWVsKGVsKSk7XG5cdGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIgfHwgaXRlbSAhPT0gT2JqZWN0KGl0ZW0pKSByZXR1cm4gaXRlbTtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuXHRcdGNvbnN0IG5ld0tleSA9IGtleS5yZXBsYWNlKC8oWy1fXVthLXpdKS9naSwgKGMpID0+IGMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9bLV9dL2csIFwiXCIpKTtcblx0XHRyZXN1bHRbbmV3S2V5XSA9IHJlY3Vyc2l2ZVRvQ2FtZWwodmFsdWUpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiogRGV0ZXJtaW5lIGlmIGlucHV0IGlzIGEgcGxhaW4gb2JqZWN0XG4qIEFuIG9iamVjdCBpcyBwbGFpbiBpZiBpdCdzIGNyZWF0ZWQgYnkgZWl0aGVyIHt9LCBuZXcgT2JqZWN0KCksIG9yIE9iamVjdC5jcmVhdGUobnVsbClcbiogc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2lzLXBsYWluLW9ialxuKi9cbmNvbnN0IGlzUGxhaW5PYmplY3QkMSA9ICh2YWx1ZSkgPT4ge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG5cdHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKTtcbn07XG4vKipcbiogVmFsaWRhdGVzIGlmIGEgZ2l2ZW4gYnVja2V0IG5hbWUgaXMgdmFsaWQgYWNjb3JkaW5nIHRvIFN1cGFiYXNlIFN0b3JhZ2UgQVBJIHJ1bGVzXG4qIE1pcnJvcnMgYmFja2VuZCB2YWxpZGF0aW9uIGZyb206IHN0b3JhZ2Uvc3JjL3N0b3JhZ2UvbGltaXRzLnRzOmlzVmFsaWRCdWNrZXROYW1lKClcbipcbiogUnVsZXM6XG4qIC0gTGVuZ3RoOiAxLTEwMCBjaGFyYWN0ZXJzXG4qIC0gQWxsb3dlZCBjaGFyYWN0ZXJzOiBhbHBoYW51bWVyaWMgKGEteiwgQS1aLCAwLTkpLCB1bmRlcnNjb3JlIChfKSwgYW5kIHNhZmUgc3BlY2lhbCBjaGFyYWN0ZXJzXG4qIC0gU2FmZSBzcGVjaWFsIGNoYXJhY3RlcnM6ICEgLSAuICogJyAoICkgc3BhY2UgJiAkIEAgPSA7IDogKyAsID9cbiogLSBGb3JiaWRkZW46IHBhdGggc2VwYXJhdG9ycyAoLywgXFwpLCBwYXRoIHRyYXZlcnNhbCAoLi4pLCBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2VcbipcbiogQVdTIFMzIFJlZmVyZW5jZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblMzL2xhdGVzdC91c2VyZ3VpZGUvb2JqZWN0LWtleXMuaHRtbFxuKlxuKiBAcGFyYW0gYnVja2V0TmFtZSAtIFRoZSBidWNrZXQgbmFtZSB0byB2YWxpZGF0ZVxuKiBAcmV0dXJucyB0cnVlIGlmIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiovXG5jb25zdCBpc1ZhbGlkQnVja2V0TmFtZSA9IChidWNrZXROYW1lKSA9PiB7XG5cdGlmICghYnVja2V0TmFtZSB8fCB0eXBlb2YgYnVja2V0TmFtZSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuXHRpZiAoYnVja2V0TmFtZS5sZW5ndGggPT09IDAgfHwgYnVja2V0TmFtZS5sZW5ndGggPiAxMDApIHJldHVybiBmYWxzZTtcblx0aWYgKGJ1Y2tldE5hbWUudHJpbSgpICE9PSBidWNrZXROYW1lKSByZXR1cm4gZmFsc2U7XG5cdGlmIChidWNrZXROYW1lLmluY2x1ZGVzKFwiL1wiKSB8fCBidWNrZXROYW1lLmluY2x1ZGVzKFwiXFxcXFwiKSkgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gL15bXFx3IS5cXConKCkgJiRAPTs6Kyw/LV0rJC8udGVzdChidWNrZXROYW1lKTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90eXBlb2YuanNcbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuXHRcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cdHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24obyQxKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBvJDE7XG5cdH0gOiBmdW5jdGlvbihvJDEpIHtcblx0XHRyZXR1cm4gbyQxICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8kMS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8kMSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbyQxO1xuXHR9LCBfdHlwZW9mKG8pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdG9QcmltaXRpdmUuanNcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcblx0aWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7XG5cdHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXHRpZiAodm9pZCAwICE9PSBlKSB7XG5cdFx0dmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG5cdFx0aWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuXHR9XG5cdHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzXG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcblx0dmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcblx0cmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuXHRyZXR1cm4gKHIgPSB0b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcblx0XHR2YWx1ZTogdCxcblx0XHRlbnVtZXJhYmxlOiAhMCxcblx0XHRjb25maWd1cmFibGU6ICEwLFxuXHRcdHdyaXRhYmxlOiAhMFxuXHR9KSA6IGVbcl0gPSB0LCBlO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvb2JqZWN0U3ByZWFkMi5qc1xuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG5cdHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG5cdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0dmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuXHRcdHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbihyJDEpIHtcblx0XHRcdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIkMSkuZW51bWVyYWJsZTtcblx0XHR9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcblx0fVxuXHRyZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcblx0Zm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcblx0XHR2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG5cdFx0ciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRfZGVmaW5lUHJvcGVydHkoZSwgciQxLCB0W3IkMV0pO1xuXHRcdH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbihyJDEpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByJDEsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgciQxKSk7XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIGU7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvZmV0Y2gudHNcbmNvbnN0IF9nZXRFcnJvck1lc3NhZ2UkMSA9IChlcnIpID0+IHtcblx0dmFyIF9lcnIkZXJyb3I7XG5cdHJldHVybiBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCAodHlwZW9mIGVyci5lcnJvciA9PT0gXCJzdHJpbmdcIiA/IGVyci5lcnJvciA6IChfZXJyJGVycm9yID0gZXJyLmVycm9yKSA9PT0gbnVsbCB8fCBfZXJyJGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyJGVycm9yLm1lc3NhZ2UpIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG59O1xuY29uc3QgaGFuZGxlRXJyb3IkMSA9IGFzeW5jIChlcnJvciwgcmVqZWN0LCBvcHRpb25zKSA9PiB7XG5cdGlmIChlcnJvciBpbnN0YW5jZW9mIGF3YWl0IHJlc29sdmVSZXNwb25zZSQxKCkgJiYgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikpIGVycm9yLmpzb24oKS50aGVuKChlcnIpID0+IHtcblx0XHRjb25zdCBzdGF0dXMgPSBlcnJvci5zdGF0dXMgfHwgNTAwO1xuXHRcdGNvbnN0IHN0YXR1c0NvZGUgPSAoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLnN0YXR1c0NvZGUpIHx8IHN0YXR1cyArIFwiXCI7XG5cdFx0cmVqZWN0KG5ldyBTdG9yYWdlQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZSQxKGVyciksIHN0YXR1cywgc3RhdHVzQ29kZSkpO1xuXHR9KS5jYXRjaCgoZXJyKSA9PiB7XG5cdFx0cmVqZWN0KG5ldyBTdG9yYWdlVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UkMShlcnIpLCBlcnIpKTtcblx0fSk7XG5cdGVsc2UgcmVqZWN0KG5ldyBTdG9yYWdlVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UkMShlcnJvciksIGVycm9yKSk7XG59O1xuY29uc3QgX2dldFJlcXVlc3RQYXJhbXMkMSA9IChtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpID0+IHtcblx0Y29uc3QgcGFyYW1zID0ge1xuXHRcdG1ldGhvZCxcblx0XHRoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9XG5cdH07XG5cdGlmIChtZXRob2QgPT09IFwiR0VUXCIgfHwgIWJvZHkpIHJldHVybiBwYXJhbXM7XG5cdGlmIChpc1BsYWluT2JqZWN0JDEoYm9keSkpIHtcblx0XHRwYXJhbXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuXHRcdHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG5cdH0gZWxzZSBwYXJhbXMuYm9keSA9IGJvZHk7XG5cdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZHVwbGV4KSBwYXJhbXMuZHVwbGV4ID0gb3B0aW9ucy5kdXBsZXg7XG5cdHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcGFyYW1zKSwgcGFyYW1ldGVycyk7XG59O1xuYXN5bmMgZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QkMShmZXRjaGVyLCBtZXRob2QsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGZldGNoZXIodXJsLCBfZ2V0UmVxdWVzdFBhcmFtcyQxKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuXHRcdFx0aWYgKCFyZXN1bHQub2spIHRocm93IHJlc3VsdDtcblx0XHRcdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikgcmV0dXJuIHJlc3VsdDtcblx0XHRcdHJldHVybiByZXN1bHQuanNvbigpO1xuXHRcdH0pLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlRXJyb3IkMShlcnJvciwgcmVqZWN0LCBvcHRpb25zKSk7XG5cdH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0KGZldGNoZXIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QkMShmZXRjaGVyLCBcIkdFVFwiLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9zdCQxKGZldGNoZXIsIHVybCwgYm9keSwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QkMShmZXRjaGVyLCBcIlBPU1RcIiwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHB1dChmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcblx0cmV0dXJuIF9oYW5kbGVSZXF1ZXN0JDEoZmV0Y2hlciwgXCJQVVRcIiwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhlYWQoZmV0Y2hlciwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBfaGFuZGxlUmVxdWVzdCQxKGZldGNoZXIsIFwiSEVBRFwiLCB1cmwsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHsgbm9SZXNvbHZlSnNvbjogdHJ1ZSB9KSwgcGFyYW1ldGVycyk7XG59XG5hc3luYyBmdW5jdGlvbiByZW1vdmUoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBfaGFuZGxlUmVxdWVzdCQxKGZldGNoZXIsIFwiREVMRVRFXCIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9wYWNrYWdlcy9TdHJlYW1Eb3dubG9hZEJ1aWxkZXIudHNcbnZhciBTdHJlYW1Eb3dubG9hZEJ1aWxkZXIgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKGRvd25sb2FkRm4sIHNob3VsZFRocm93T25FcnJvcikge1xuXHRcdHRoaXMuZG93bmxvYWRGbiA9IGRvd25sb2FkRm47XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBzaG91bGRUaHJvd09uRXJyb3I7XG5cdH1cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdHJldHVybiB0aGlzLmV4ZWN1dGUoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcblx0fVxuXHRhc3luYyBleGVjdXRlKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IChhd2FpdCBfdGhpcy5kb3dubG9hZEZuKCkpLmJvZHksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvQmxvYkRvd25sb2FkQnVpbGRlci50c1xubGV0IF9TeW1ib2wkdG9TdHJpbmdUYWc7XG5fU3ltYm9sJHRvU3RyaW5nVGFnID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xudmFyIEJsb2JEb3dubG9hZEJ1aWxkZXIgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKGRvd25sb2FkRm4sIHNob3VsZFRocm93T25FcnJvcikge1xuXHRcdHRoaXMuZG93bmxvYWRGbiA9IGRvd25sb2FkRm47XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBzaG91bGRUaHJvd09uRXJyb3I7XG5cdFx0dGhpc1tfU3ltYm9sJHRvU3RyaW5nVGFnXSA9IFwiQmxvYkRvd25sb2FkQnVpbGRlclwiO1xuXHRcdHRoaXMucHJvbWlzZSA9IG51bGw7XG5cdH1cblx0YXNTdHJlYW0oKSB7XG5cdFx0cmV0dXJuIG5ldyBTdHJlYW1Eb3dubG9hZEJ1aWxkZXIodGhpcy5kb3dubG9hZEZuLCB0aGlzLnNob3VsZFRocm93T25FcnJvcik7XG5cdH1cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdHJldHVybiB0aGlzLmdldFByb21pc2UoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcblx0fVxuXHRjYXRjaChvbnJlamVjdGVkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UHJvbWlzZSgpLmNhdGNoKG9ucmVqZWN0ZWQpO1xuXHR9XG5cdGZpbmFsbHkob25maW5hbGx5KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UHJvbWlzZSgpLmZpbmFsbHkob25maW5hbGx5KTtcblx0fVxuXHRnZXRQcm9taXNlKCkge1xuXHRcdGlmICghdGhpcy5wcm9taXNlKSB0aGlzLnByb21pc2UgPSB0aGlzLmV4ZWN1dGUoKTtcblx0XHRyZXR1cm4gdGhpcy5wcm9taXNlO1xuXHR9XG5cdGFzeW5jIGV4ZWN1dGUoKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgKGF3YWl0IF90aGlzLmRvd25sb2FkRm4oKSkuYmxvYigpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpLnRzXG5jb25zdCBERUZBVUxUX1NFQVJDSF9PUFRJT05TID0ge1xuXHRsaW1pdDogMTAwLFxuXHRvZmZzZXQ6IDAsXG5cdHNvcnRCeToge1xuXHRcdGNvbHVtbjogXCJuYW1lXCIsXG5cdFx0b3JkZXI6IFwiYXNjXCJcblx0fVxufTtcbmNvbnN0IERFRkFVTFRfRklMRV9PUFRJT05TID0ge1xuXHRjYWNoZUNvbnRyb2w6IFwiMzYwMFwiLFxuXHRjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIixcblx0dXBzZXJ0OiBmYWxzZVxufTtcbnZhciBTdG9yYWdlRmlsZUFwaSA9IGNsYXNzIHtcblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGJ1Y2tldElkLCBmZXRjaCQxKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHR0aGlzLnVybCA9IHVybDtcblx0XHR0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHRcdHRoaXMuYnVja2V0SWQgPSBidWNrZXRJZDtcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoJDEoZmV0Y2gkMSk7XG5cdH1cblx0LyoqXG5cdCogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqL1xuXHR0aHJvd09uRXJyb3IoKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFVwbG9hZHMgYSBmaWxlIHRvIGFuIGV4aXN0aW5nIGJ1Y2tldCBvciByZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cblx0KlxuXHQqIEBwYXJhbSBtZXRob2QgSFRUUCBtZXRob2QuXG5cdCogQHBhcmFtIHBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aC4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuXHQqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cblx0Ki9cblx0YXN5bmMgdXBsb2FkT3JVcGRhdGUobWV0aG9kLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRsZXQgYm9keTtcblx0XHRcdGNvbnN0IG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9GSUxFX09QVElPTlMpLCBmaWxlT3B0aW9ucyk7XG5cdFx0XHRsZXQgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpcy5oZWFkZXJzKSwgbWV0aG9kID09PSBcIlBPU1RcIiAmJiB7IFwieC11cHNlcnRcIjogU3RyaW5nKG9wdGlvbnMudXBzZXJ0KSB9KTtcblx0XHRcdGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YTtcblx0XHRcdGlmICh0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0Ym9keSA9IG5ldyBGb3JtRGF0YSgpO1xuXHRcdFx0XHRib2R5LmFwcGVuZChcImNhY2hlQ29udHJvbFwiLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG5cdFx0XHRcdGlmIChtZXRhZGF0YSkgYm9keS5hcHBlbmQoXCJtZXRhZGF0YVwiLCBfdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpO1xuXHRcdFx0XHRib2R5LmFwcGVuZChcIlwiLCBmaWxlQm9keSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0aWYgKCFib2R5LmhhcyhcImNhY2hlQ29udHJvbFwiKSkgYm9keS5hcHBlbmQoXCJjYWNoZUNvbnRyb2xcIiwgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuXHRcdFx0XHRpZiAobWV0YWRhdGEgJiYgIWJvZHkuaGFzKFwibWV0YWRhdGFcIikpIGJvZHkuYXBwZW5kKFwibWV0YWRhdGFcIiwgX3RoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0aGVhZGVyc1tcImNhY2hlLWNvbnRyb2xcIl0gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWA7XG5cdFx0XHRcdGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuXHRcdFx0XHRpZiAobWV0YWRhdGEpIGhlYWRlcnNbXCJ4LW1ldGFkYXRhXCJdID0gX3RoaXMudG9CYXNlNjQoX3RoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKTtcblx0XHRcdFx0aWYgKCh0eXBlb2YgUmVhZGFibGVTdHJlYW0gIT09IFwidW5kZWZpbmVkXCIgJiYgYm9keSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtIHx8IGJvZHkgJiYgdHlwZW9mIGJvZHkgPT09IFwib2JqZWN0XCIgJiYgXCJwaXBlXCIgaW4gYm9keSAmJiB0eXBlb2YgYm9keS5waXBlID09PSBcImZ1bmN0aW9uXCIpICYmICFvcHRpb25zLmR1cGxleCkgb3B0aW9ucy5kdXBsZXggPSBcImhhbGZcIjtcblx0XHRcdH1cblx0XHRcdGlmIChmaWxlT3B0aW9ucyA9PT0gbnVsbCB8fCBmaWxlT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsZU9wdGlvbnMuaGVhZGVycykgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBoZWFkZXJzKSwgZmlsZU9wdGlvbnMuaGVhZGVycyk7XG5cdFx0XHRjb25zdCBjbGVhblBhdGggPSBfdGhpcy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpO1xuXHRcdFx0Y29uc3QgX3BhdGggPSBfdGhpcy5fZ2V0RmluYWxQYXRoKGNsZWFuUGF0aCk7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgKG1ldGhvZCA9PSBcIlBVVFwiID8gcHV0IDogcG9zdCQxKShfdGhpcy5mZXRjaCwgYCR7X3RoaXMudXJsfS9vYmplY3QvJHtfcGF0aH1gLCBib2R5LCBfb2JqZWN0U3ByZWFkMih7IGhlYWRlcnMgfSwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kdXBsZXgpID8geyBkdXBsZXg6IG9wdGlvbnMuZHVwbGV4IH0gOiB7fSkpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YToge1xuXHRcdFx0XHRcdHBhdGg6IGNsZWFuUGF0aCxcblx0XHRcdFx0XHRpZDogZGF0YS5JZCxcblx0XHRcdFx0XHRmdWxsUGF0aDogZGF0YS5LZXlcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogVXBsb2FkcyBhIGZpbGUgdG8gYW4gZXhpc3RpbmcgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG5cdCogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuXHQqIEBwYXJhbSBmaWxlT3B0aW9ucyBPcHRpb25hbCBmaWxlIHVwbG9hZCBvcHRpb25zIGluY2x1ZGluZyBjYWNoZUNvbnRyb2wsIGNvbnRlbnRUeXBlLCB1cHNlcnQsIGFuZCBtZXRhZGF0YS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBmaWxlIHBhdGgsIGlkLCBhbmQgZnVsbFBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIFVwbG9hZCBmaWxlXG5cdCogYGBganNcblx0KiBjb25zdCBhdmF0YXJGaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzWzBdXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBsb2FkKCdwdWJsaWMvYXZhdGFyMS5wbmcnLCBhdmF0YXJGaWxlLCB7XG5cdCogICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuXHQqICAgICB1cHNlcnQ6IGZhbHNlXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwicGF0aFwiOiBcInB1YmxpYy9hdmF0YXIxLnBuZ1wiLFxuXHQqICAgICBcImZ1bGxQYXRoXCI6IFwiYXZhdGFycy9wdWJsaWMvYXZhdGFyMS5wbmdcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFVwbG9hZCBmaWxlIHVzaW5nIGBBcnJheUJ1ZmZlcmAgZnJvbSBiYXNlNjQgZmlsZSBkYXRhXG5cdCogYGBganNcblx0KiBpbXBvcnQgeyBkZWNvZGUgfSBmcm9tICdiYXNlNjQtYXJyYXlidWZmZXInXG5cdCpcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC51cGxvYWQoJ3B1YmxpYy9hdmF0YXIxLnBuZycsIGRlY29kZSgnYmFzZTY0RmlsZURhdGEnKSwge1xuXHQqICAgICBjb250ZW50VHlwZTogJ2ltYWdlL3BuZydcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHVwbG9hZChwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZShcIlBPU1RcIiwgcGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKTtcblx0fVxuXHQvKipcblx0KiBVcGxvYWQgYSBmaWxlIHdpdGggYSB0b2tlbiBnZW5lcmF0ZWQgZnJvbSBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsYC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuXHQqIEBwYXJhbSB0b2tlbiBUaGUgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGBcblx0KiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG5cdCogQHBhcmFtIGZpbGVPcHRpb25zIEhUVFAgaGVhZGVycyAoY2FjaGVDb250cm9sLCBjb250ZW50VHlwZSwgZXRjLikuXG5cdCogKipOb3RlOioqIFRoZSBgdXBzZXJ0YCBvcHRpb24gaGFzIG5vIGVmZmVjdCBoZXJlLiBUbyBlbmFibGUgdXBzZXJ0IGJlaGF2aW9yLFxuXHQqIHBhc3MgYHsgdXBzZXJ0OiB0cnVlIH1gIHdoZW4gY2FsbGluZyBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsKClgIGluc3RlYWQuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgZmlsZSBwYXRoIGFuZCBmdWxsUGF0aCBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgVXBsb2FkIHRvIGEgc2lnbmVkIFVSTFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBsb2FkVG9TaWduZWRVcmwoJ2ZvbGRlci9jYXQuanBnJywgJ3Rva2VuLWZyb20tY3JlYXRlU2lnbmVkVXBsb2FkVXJsJywgZmlsZSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInBhdGhcIjogXCJmb2xkZXIvY2F0LmpwZ1wiLFxuXHQqICAgICBcImZ1bGxQYXRoXCI6IFwiYXZhdGFycy9mb2xkZXIvY2F0LmpwZ1wiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyB1cGxvYWRUb1NpZ25lZFVybChwYXRoLCB0b2tlbiwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0Y29uc3QgY2xlYW5QYXRoID0gX3RoaXMzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCk7XG5cdFx0Y29uc3QgX3BhdGggPSBfdGhpczMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpO1xuXHRcdGNvbnN0IHVybCA9IG5ldyBVUkwoX3RoaXMzLnVybCArIGAvb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YCk7XG5cdFx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tlblwiLCB0b2tlbik7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBib2R5O1xuXHRcdFx0Y29uc3Qgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKHsgdXBzZXJ0OiBERUZBVUxUX0ZJTEVfT1BUSU9OUy51cHNlcnQgfSwgZmlsZU9wdGlvbnMpO1xuXHRcdFx0Y29uc3QgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpczMuaGVhZGVycyksIHsgXCJ4LXVwc2VydFwiOiBTdHJpbmcob3B0aW9ucy51cHNlcnQpIH0pO1xuXHRcdFx0aWYgKHR5cGVvZiBCbG9iICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRib2R5ID0gbmV3IEZvcm1EYXRhKCk7XG5cdFx0XHRcdGJvZHkuYXBwZW5kKFwiY2FjaGVDb250cm9sXCIsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcblx0XHRcdFx0Ym9keS5hcHBlbmQoXCJcIiwgZmlsZUJvZHkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0XHRib2R5ID0gZmlsZUJvZHk7XG5cdFx0XHRcdGJvZHkuYXBwZW5kKFwiY2FjaGVDb250cm9sXCIsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0aGVhZGVyc1tcImNhY2hlLWNvbnRyb2xcIl0gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWA7XG5cdFx0XHRcdGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YToge1xuXHRcdFx0XHRcdHBhdGg6IGNsZWFuUGF0aCxcblx0XHRcdFx0XHRmdWxsUGF0aDogKGF3YWl0IHB1dChfdGhpczMuZmV0Y2gsIHVybC50b1N0cmluZygpLCBib2R5LCB7IGhlYWRlcnMgfSkpLktleVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBhIHNpZ25lZCB1cGxvYWQgVVJMLlxuXHQqIFNpZ25lZCB1cGxvYWQgVVJMcyBjYW4gYmUgdXNlZCB0byB1cGxvYWQgZmlsZXMgdG8gdGhlIGJ1Y2tldCB3aXRob3V0IGZ1cnRoZXIgYXV0aGVudGljYXRpb24uXG5cdCogVGhleSBhcmUgdmFsaWQgZm9yIDIgaG91cnMuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBvcHRpb25zLnVwc2VydCBJZiBzZXQgdG8gdHJ1ZSwgYWxsb3dzIHRoZSBmaWxlIHRvIGJlIG92ZXJ3cml0dGVuIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHNpZ25lZCB1cGxvYWQgVVJMLCB0b2tlbiwgYW5kIHBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBTaWduZWQgVXBsb2FkIFVSTFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuY3JlYXRlU2lnbmVkVXBsb2FkVXJsKCdmb2xkZXIvY2F0LmpwZycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJzaWduZWRVcmxcIjogXCJodHRwczovL2V4YW1wbGUuc3VwYWJhc2UuY28vc3RvcmFnZS92MS9vYmplY3QvdXBsb2FkL3NpZ24vYXZhdGFycy9mb2xkZXIvY2F0LmpwZz90b2tlbj08VE9LRU4+XCIsXG5cdCogICAgIFwicGF0aFwiOiBcImZvbGRlci9jYXQuanBnXCIsXG5cdCogICAgIFwidG9rZW5cIjogXCI8VE9LRU4+XCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZVNpZ25lZFVwbG9hZFVybChwYXRoLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNCA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBfcGF0aCA9IF90aGlzNC5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdFx0Y29uc3QgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpczQuaGVhZGVycyk7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVwc2VydCkgaGVhZGVyc1tcIngtdXBzZXJ0XCJdID0gXCJ0cnVlXCI7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcG9zdCQxKF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YCwge30sIHsgaGVhZGVycyB9KTtcblx0XHRcdGNvbnN0IHVybCA9IG5ldyBVUkwoX3RoaXM0LnVybCArIGRhdGEudXJsKTtcblx0XHRcdGNvbnN0IHRva2VuID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ0b2tlblwiKTtcblx0XHRcdGlmICghdG9rZW4pIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXCJObyB0b2tlbiByZXR1cm5lZCBieSBBUElcIik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiB7XG5cdFx0XHRcdFx0c2lnbmVkVXJsOiB1cmwudG9TdHJpbmcoKSxcblx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdHRva2VuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM0LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBSZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgcmVsYXRpdmUgZmlsZSBwYXRoLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGRhdGUuXG5cdCogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuXHQqIEBwYXJhbSBmaWxlT3B0aW9ucyBPcHRpb25hbCBmaWxlIHVwbG9hZCBvcHRpb25zIGluY2x1ZGluZyBjYWNoZUNvbnRyb2wsIGNvbnRlbnRUeXBlLCB1cHNlcnQsIGFuZCBtZXRhZGF0YS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBmaWxlIHBhdGgsIGlkLCBhbmQgZnVsbFBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIFVwZGF0ZSBmaWxlXG5cdCogYGBganNcblx0KiBjb25zdCBhdmF0YXJGaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzWzBdXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBkYXRlKCdwdWJsaWMvYXZhdGFyMS5wbmcnLCBhdmF0YXJGaWxlLCB7XG5cdCogICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuXHQqICAgICB1cHNlcnQ6IHRydWVcblx0KiAgIH0pXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJwYXRoXCI6IFwicHVibGljL2F2YXRhcjEucG5nXCIsXG5cdCogICAgIFwiZnVsbFBhdGhcIjogXCJhdmF0YXJzL3B1YmxpYy9hdmF0YXIxLnBuZ1wiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgVXBkYXRlIGZpbGUgdXNpbmcgYEFycmF5QnVmZmVyYCBmcm9tIGJhc2U2NCBmaWxlIGRhdGFcblx0KiBgYGBqc1xuXHQqIGltcG9ydCB7ZGVjb2RlfSBmcm9tICdiYXNlNjQtYXJyYXlidWZmZXInXG5cdCpcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC51cGRhdGUoJ3B1YmxpYy9hdmF0YXIxLnBuZycsIGRlY29kZSgnYmFzZTY0RmlsZURhdGEnKSwge1xuXHQqICAgICBjb250ZW50VHlwZTogJ2ltYWdlL3BuZydcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHVwZGF0ZShwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZShcIlBVVFwiLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpO1xuXHR9XG5cdC8qKlxuXHQqIE1vdmVzIGFuIGV4aXN0aW5nIGZpbGUgdG8gYSBuZXcgcGF0aCBpbiB0aGUgc2FtZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cblx0KiBAcGFyYW0gdG9QYXRoIFRoZSBuZXcgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIG5ldyBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UtbmV3LnBuZ2AuXG5cdCogQHBhcmFtIG9wdGlvbnMgVGhlIGRlc3RpbmF0aW9uIG9wdGlvbnMuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBNb3ZlIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLm1vdmUoJ3B1YmxpYy9hdmF0YXIxLnBuZycsICdwcml2YXRlL2F2YXRhcjIucG5nJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgbW92ZWRcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbW92ZShmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNiA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczYuZmV0Y2gsIGAke190aGlzNi51cmx9L29iamVjdC9tb3ZlYCwge1xuXHRcdFx0XHRcdGJ1Y2tldElkOiBfdGhpczYuYnVja2V0SWQsXG5cdFx0XHRcdFx0c291cmNlS2V5OiBmcm9tUGF0aCxcblx0XHRcdFx0XHRkZXN0aW5hdGlvbktleTogdG9QYXRoLFxuXHRcdFx0XHRcdGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25CdWNrZXRcblx0XHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczYuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczYuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIENvcGllcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBmcm9tUGF0aCBUaGUgb3JpZ2luYWwgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLWNvcHkucG5nYC5cblx0KiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBjb3BpZWQgZmlsZSBwYXRoIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDb3B5IGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNvcHkoJ3B1YmxpYy9hdmF0YXIxLnBuZycsICdwcml2YXRlL2F2YXRhcjIucG5nJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInBhdGhcIjogXCJhdmF0YXJzL3ByaXZhdGUvYXZhdGFyMi5wbmdcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY29weShmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IHsgcGF0aDogKGF3YWl0IHBvc3QkMShfdGhpczcuZmV0Y2gsIGAke190aGlzNy51cmx9L29iamVjdC9jb3B5YCwge1xuXHRcdFx0XHRcdGJ1Y2tldElkOiBfdGhpczcuYnVja2V0SWQsXG5cdFx0XHRcdFx0c291cmNlS2V5OiBmcm9tUGF0aCxcblx0XHRcdFx0XHRkZXN0aW5hdGlvbktleTogdG9QYXRoLFxuXHRcdFx0XHRcdGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25CdWNrZXRcblx0XHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczcuaGVhZGVycyB9KSkuS2V5IH0sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM3LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBDcmVhdGVzIGEgc2lnbmVkIFVSTC4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMIGV4cGlyZXMuIEZvciBleGFtcGxlLCBgNjBgIGZvciBhIFVSTCB3aGljaCBpcyB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cblx0KiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHNpZ25lZCBVUkwgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBTaWduZWQgVVJMXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5jcmVhdGVTaWduZWRVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIDYwKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIGEgc2lnbmVkIFVSTCBmb3IgYW4gYXNzZXQgd2l0aCB0cmFuc2Zvcm1hdGlvbnNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuY3JlYXRlU2lnbmVkVXJsKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCA2MCwge1xuXHQqICAgICB0cmFuc2Zvcm06IHtcblx0KiAgICAgICB3aWR0aDogMTAwLFxuXHQqICAgICAgIGhlaWdodDogMTAwLFxuXHQqICAgICB9XG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIGEgc2lnbmVkIFVSTCB3aGljaCB0cmlnZ2VycyB0aGUgZG93bmxvYWQgb2YgdGhlIGFzc2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNyZWF0ZVNpZ25lZFVybCgnZm9sZGVyL2F2YXRhcjEucG5nJywgNjAsIHtcblx0KiAgICAgZG93bmxvYWQ6IHRydWUsXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjcmVhdGVTaWduZWRVcmwocGF0aCwgZXhwaXJlc0luLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzOCA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBfcGF0aCA9IF90aGlzOC5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdFx0bGV0IGRhdGEgPSBhd2FpdCBwb3N0JDEoX3RoaXM4LmZldGNoLCBgJHtfdGhpczgudXJsfS9vYmplY3Qvc2lnbi8ke19wYXRofWAsIF9vYmplY3RTcHJlYWQyKHsgZXhwaXJlc0luIH0sIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSA/IHsgdHJhbnNmb3JtOiBvcHRpb25zLnRyYW5zZm9ybSB9IDoge30pLCB7IGhlYWRlcnM6IF90aGlzOC5oZWFkZXJzIH0pO1xuXHRcdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/IFwiXCIgOiBvcHRpb25zLmRvd25sb2FkfWAgOiBcIlwiO1xuXHRcdFx0ZGF0YSA9IHsgc2lnbmVkVXJsOiBlbmNvZGVVUkkoYCR7X3RoaXM4LnVybH0ke2RhdGEuc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApIH07XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzOC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBtdWx0aXBsZSBzaWduZWQgVVJMcy4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGhzIFRoZSBmaWxlIHBhdGhzIHRvIGJlIGRvd25sb2FkZWQsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWVzLiBGb3IgZXhhbXBsZSBgWydmb2xkZXIvaW1hZ2UucG5nJywgJ2ZvbGRlcjIvaW1hZ2UyLnBuZyddYC5cblx0KiBAcGFyYW0gZXhwaXJlc0luIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCB0aGUgc2lnbmVkIFVSTHMgZXhwaXJlLiBGb3IgZXhhbXBsZSwgYDYwYCBmb3IgVVJMcyB3aGljaCBhcmUgdmFsaWQgZm9yIG9uZSBtaW51dGUuXG5cdCogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHNpZ25lZFVybCwgcGF0aCwgYW5kIGVycm9yIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDcmVhdGUgU2lnbmVkIFVSTHNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNyZWF0ZVNpZ25lZFVybHMoWydmb2xkZXIvYXZhdGFyMS5wbmcnLCAnZm9sZGVyL2F2YXRhcjIucG5nJ10sIDYwKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXG5cdCogICAgIHtcblx0KiAgICAgICBcImVycm9yXCI6IG51bGwsXG5cdCogICAgICAgXCJwYXRoXCI6IFwiZm9sZGVyL2F2YXRhcjEucG5nXCIsXG5cdCogICAgICAgXCJzaWduZWRVUkxcIjogXCIvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiLFxuXHQqICAgICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICAgIH0sXG5cdCogICAgIHtcblx0KiAgICAgICBcImVycm9yXCI6IG51bGwsXG5cdCogICAgICAgXCJwYXRoXCI6IFwiZm9sZGVyL2F2YXRhcjIucG5nXCIsXG5cdCogICAgICAgXCJzaWduZWRVUkxcIjogXCIvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMi5wbmc/dG9rZW49PFRPS0VOPlwiLFxuXHQqICAgICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMi5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICAgIH1cblx0KiAgIF0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZVNpZ25lZFVybHMocGF0aHMsIGV4cGlyZXNJbiwgb3B0aW9ucykge1xuXHRcdHZhciBfdGhpczkgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcG9zdCQxKF90aGlzOS5mZXRjaCwgYCR7X3RoaXM5LnVybH0vb2JqZWN0L3NpZ24vJHtfdGhpczkuYnVja2V0SWR9YCwge1xuXHRcdFx0XHRleHBpcmVzSW4sXG5cdFx0XHRcdHBhdGhzXG5cdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzOS5oZWFkZXJzIH0pO1xuXHRcdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/IFwiXCIgOiBvcHRpb25zLmRvd25sb2FkfWAgOiBcIlwiO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogZGF0YS5tYXAoKGRhdHVtKSA9PiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGF0dW0pLCB7fSwgeyBzaWduZWRVcmw6IGRhdHVtLnNpZ25lZFVSTCA/IGVuY29kZVVSSShgJHtfdGhpczkudXJsfSR7ZGF0dW0uc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApIDogbnVsbCB9KSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM5LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBEb3dubG9hZHMgYSBmaWxlIGZyb20gYSBwcml2YXRlIGJ1Y2tldC4gRm9yIHB1YmxpYyBidWNrZXRzLCBtYWtlIGEgcmVxdWVzdCB0byB0aGUgVVJMIHJldHVybmVkIGZyb20gYGdldFB1YmxpY1VybGAgaW5zdGVhZC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZnVsbCBwYXRoIGFuZCBmaWxlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYmUgZG93bmxvYWRlZC4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG5cdCogQHJldHVybnMgQmxvYkRvd25sb2FkQnVpbGRlciBpbnN0YW5jZSBmb3IgZG93bmxvYWRpbmcgdGhlIGZpbGVcblx0KlxuXHQqIEBleGFtcGxlIERvd25sb2FkIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmRvd25sb2FkKCdmb2xkZXIvYXZhdGFyMS5wbmcnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiA8QkxPQj4sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBEb3dubG9hZCBmaWxlIHdpdGggdHJhbnNmb3JtYXRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5kb3dubG9hZCgnZm9sZGVyL2F2YXRhcjEucG5nJywge1xuXHQqICAgICB0cmFuc2Zvcm06IHtcblx0KiAgICAgICB3aWR0aDogMTAwLFxuXHQqICAgICAgIGhlaWdodDogMTAwLFxuXHQqICAgICAgIHF1YWxpdHk6IDgwXG5cdCogICAgIH1cblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGRvd25sb2FkKHBhdGgsIG9wdGlvbnMpIHtcblx0XHRjb25zdCByZW5kZXJQYXRoID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gXCJ1bmRlZmluZWRcIiA/IFwicmVuZGVyL2ltYWdlL2F1dGhlbnRpY2F0ZWRcIiA6IFwib2JqZWN0XCI7XG5cdFx0Y29uc3QgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pIHx8IHt9KTtcblx0XHRjb25zdCBxdWVyeVN0cmluZyA9IHRyYW5zZm9ybWF0aW9uUXVlcnkgPyBgPyR7dHJhbnNmb3JtYXRpb25RdWVyeX1gIDogXCJcIjtcblx0XHRjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKTtcblx0XHRjb25zdCBkb3dubG9hZEZuID0gKCkgPT4gZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9LyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gLCB7XG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRub1Jlc29sdmVKc29uOiB0cnVlXG5cdFx0fSk7XG5cdFx0cmV0dXJuIG5ldyBCbG9iRG93bmxvYWRCdWlsZGVyKGRvd25sb2FkRm4sIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKTtcblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgZmlsZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGZpbGUgbWV0YWRhdGEgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIEdldCBmaWxlIGluZm9cblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmluZm8oJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGluZm8ocGF0aCkge1xuXHRcdHZhciBfdGhpczEwID0gdGhpcztcblx0XHRjb25zdCBfcGF0aCA9IF90aGlzMTAuX2dldEZpbmFsUGF0aChwYXRoKTtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogcmVjdXJzaXZlVG9DYW1lbChhd2FpdCBnZXQoX3RoaXMxMC5mZXRjaCwgYCR7X3RoaXMxMC51cmx9L29iamVjdC9pbmZvLyR7X3BhdGh9YCwgeyBoZWFkZXJzOiBfdGhpczEwLmhlYWRlcnMgfSkpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMTAuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIENoZWNrcyB0aGUgZXhpc3RlbmNlIG9mIGEgZmlsZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGJvb2xlYW4gaW5kaWNhdGluZyBmaWxlIGV4aXN0ZW5jZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgQ2hlY2sgZmlsZSBleGlzdGVuY2Vcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmV4aXN0cygnZm9sZGVyL2F2YXRhcjEucG5nJylcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZXhpc3RzKHBhdGgpIHtcblx0XHR2YXIgX3RoaXMxMSA9IHRoaXM7XG5cdFx0Y29uc3QgX3BhdGggPSBfdGhpczExLl9nZXRGaW5hbFBhdGgocGF0aCk7XG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IGhlYWQoX3RoaXMxMS5mZXRjaCwgYCR7X3RoaXMxMS51cmx9L29iamVjdC8ke19wYXRofWAsIHsgaGVhZGVyczogX3RoaXMxMS5oZWFkZXJzIH0pO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogdHJ1ZSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczExLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpICYmIGVycm9yIGluc3RhbmNlb2YgU3RvcmFnZVVua25vd25FcnJvcikge1xuXHRcdFx0XHRjb25zdCBvcmlnaW5hbEVycm9yID0gZXJyb3Iub3JpZ2luYWxFcnJvcjtcblx0XHRcdFx0aWYgKFs0MDAsIDQwNF0uaW5jbHVkZXMob3JpZ2luYWxFcnJvciA9PT0gbnVsbCB8fCBvcmlnaW5hbEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbEVycm9yLnN0YXR1cykpIHJldHVybiB7XG5cdFx0XHRcdFx0ZGF0YTogZmFsc2UsXG5cdFx0XHRcdFx0ZXJyb3Jcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBBIHNpbXBsZSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgdGhlIFVSTCBmb3IgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0LiBJZiB5b3UgZG8gbm90IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24sIHlvdSBjYW4gY29uc3RydWN0IHRoZSBwdWJsaWMgVVJMIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGJ1Y2tldCBVUkwgd2l0aCB0aGUgcGF0aCB0byB0aGUgYXNzZXQuXG5cdCogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB2ZXJpZnkgaWYgdGhlIGJ1Y2tldCBpcyBwdWJsaWMuIElmIGEgcHVibGljIFVSTCBpcyBjcmVhdGVkIGZvciBhIGJ1Y2tldCB3aGljaCBpcyBub3QgcHVibGljLCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZCB0aGUgYXNzZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIHBhdGggYW5kIG5hbWUgb2YgdGhlIGZpbGUgdG8gZ2VuZXJhdGUgdGhlIHB1YmxpYyBVUkwgZm9yLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgVHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG5cdCogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cblx0KiBAcmV0dXJucyBPYmplY3Qgd2l0aCBwdWJsaWMgVVJMXG5cdCpcblx0KiBAZXhhbXBsZSBSZXR1cm5zIHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhIH0gPSBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdwdWJsaWMtYnVja2V0Jylcblx0KiAgIC5nZXRQdWJsaWNVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJwdWJsaWNVcmxcIjogXCJodHRwczovL2V4YW1wbGUuc3VwYWJhc2UuY28vc3RvcmFnZS92MS9vYmplY3QvcHVibGljL3B1YmxpYy1idWNrZXQvZm9sZGVyL2F2YXRhcjEucG5nXCJcblx0KiAgIH1cblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBSZXR1cm5zIHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldCB3aXRoIHRyYW5zZm9ybWF0aW9uc1xuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhIH0gPSBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdwdWJsaWMtYnVja2V0Jylcblx0KiAgIC5nZXRQdWJsaWNVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIHtcblx0KiAgICAgdHJhbnNmb3JtOiB7XG5cdCogICAgICAgd2lkdGg6IDEwMCxcblx0KiAgICAgICBoZWlnaHQ6IDEwMCxcblx0KiAgICAgfVxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFJldHVybnMgdGhlIFVSTCB3aGljaCB0cmlnZ2VycyB0aGUgZG93bmxvYWQgb2YgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEgfSA9IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ3B1YmxpYy1idWNrZXQnKVxuXHQqICAgLmdldFB1YmxpY1VybCgnZm9sZGVyL2F2YXRhcjEucG5nJywge1xuXHQqICAgICBkb3dubG9hZDogdHJ1ZSxcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGdldFB1YmxpY1VybChwYXRoLCBvcHRpb25zKSB7XG5cdFx0Y29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG5cdFx0Y29uc3QgX3F1ZXJ5U3RyaW5nID0gW107XG5cdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gXCJcIiA6IG9wdGlvbnMuZG93bmxvYWR9YCA6IFwiXCI7XG5cdFx0aWYgKGRvd25sb2FkUXVlcnlQYXJhbSAhPT0gXCJcIikgX3F1ZXJ5U3RyaW5nLnB1c2goZG93bmxvYWRRdWVyeVBhcmFtKTtcblx0XHRjb25zdCByZW5kZXJQYXRoID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gXCJ1bmRlZmluZWRcIiA/IFwicmVuZGVyL2ltYWdlXCIgOiBcIm9iamVjdFwiO1xuXHRcdGNvbnN0IHRyYW5zZm9ybWF0aW9uUXVlcnkgPSB0aGlzLnRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSB8fCB7fSk7XG5cdFx0aWYgKHRyYW5zZm9ybWF0aW9uUXVlcnkgIT09IFwiXCIpIF9xdWVyeVN0cmluZy5wdXNoKHRyYW5zZm9ybWF0aW9uUXVlcnkpO1xuXHRcdGxldCBxdWVyeVN0cmluZyA9IF9xdWVyeVN0cmluZy5qb2luKFwiJlwiKTtcblx0XHRpZiAocXVlcnlTdHJpbmcgIT09IFwiXCIpIHF1ZXJ5U3RyaW5nID0gYD8ke3F1ZXJ5U3RyaW5nfWA7XG5cdFx0cmV0dXJuIHsgZGF0YTogeyBwdWJsaWNVcmw6IGVuY29kZVVSSShgJHt0aGlzLnVybH0vJHtyZW5kZXJQYXRofS9wdWJsaWMvJHtfcGF0aH0ke3F1ZXJ5U3RyaW5nfWApIH0gfTtcblx0fVxuXHQvKipcblx0KiBEZWxldGVzIGZpbGVzIHdpdGhpbiB0aGUgc2FtZSBidWNrZXRcblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aHMgQW4gYXJyYXkgb2YgZmlsZXMgdG8gZGVsZXRlLCBpbmNsdWRpbmcgdGhlIHBhdGggYW5kIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgW2AnZm9sZGVyL2ltYWdlLnBuZydgXS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBkZWxldGVkIGZpbGUgb2JqZWN0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgRGVsZXRlIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLnJlbW92ZShbJ2ZvbGRlci9hdmF0YXIxLnBuZyddKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgcmVtb3ZlKHBhdGhzKSB7XG5cdFx0dmFyIF90aGlzMTIgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCByZW1vdmUoX3RoaXMxMi5mZXRjaCwgYCR7X3RoaXMxMi51cmx9L29iamVjdC8ke190aGlzMTIuYnVja2V0SWR9YCwgeyBwcmVmaXhlczogcGF0aHMgfSwgeyBoZWFkZXJzOiBfdGhpczEyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMxMi5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogR2V0IGZpbGUgbWV0YWRhdGFcblx0KiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gcmV0cmlldmUgbWV0YWRhdGFcblx0Ki9cblx0LyoqXG5cdCogVXBkYXRlIGZpbGUgbWV0YWRhdGFcblx0KiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gdXBkYXRlIG1ldGFkYXRhXG5cdCogQHBhcmFtIG1ldGEgdGhlIG5ldyBmaWxlIG1ldGFkYXRhXG5cdCovXG5cdC8qKlxuXHQqIExpc3RzIGFsbCB0aGUgZmlsZXMgYW5kIGZvbGRlcnMgd2l0aGluIGEgcGF0aCBvZiB0aGUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmb2xkZXIgcGF0aC5cblx0KiBAcGFyYW0gb3B0aW9ucyBTZWFyY2ggb3B0aW9ucyBpbmNsdWRpbmcgbGltaXQgKGRlZmF1bHRzIHRvIDEwMCksIG9mZnNldCwgc29ydEJ5LCBhbmQgc2VhcmNoXG5cdCogQHBhcmFtIHBhcmFtZXRlcnMgT3B0aW9uYWwgZmV0Y2ggcGFyYW1ldGVycyBpbmNsdWRpbmcgc2lnbmFsIGZvciBjYW5jZWxsYXRpb25cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBmaWxlcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCBmaWxlcyBpbiBhIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAubGlzdCgnZm9sZGVyJywge1xuXHQqICAgICBsaW1pdDogMTAwLFxuXHQqICAgICBvZmZzZXQ6IDAsXG5cdCogICAgIHNvcnRCeTogeyBjb2x1bW46ICduYW1lJywgb3JkZXI6ICdhc2MnIH0sXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXG5cdCogICAgIHtcblx0KiAgICAgICBcIm5hbWVcIjogXCJhdmF0YXIxLnBuZ1wiLFxuXHQqICAgICAgIFwiaWRcIjogXCJlNjY4Y2Y3Zi04MjFiLTRhMmYtOWRjZS03ZGZhNWRkMWNmZDJcIixcblx0KiAgICAgICBcInVwZGF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIzOjA2OjA1LjU4MFpcIixcblx0KiAgICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIzOjA0OjM0LjQ0M1pcIixcblx0KiAgICAgICBcImxhc3RfYWNjZXNzZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIzOjA0OjM0LjQ0M1pcIixcblx0KiAgICAgICBcIm1ldGFkYXRhXCI6IHtcblx0KiAgICAgICAgIFwiZVRhZ1wiOiBcIlxcXCJjNWU4YzU1MzIzNWQ5YWYzMGVmNGY2ZTI4MDc5MGI5MlxcXCJcIixcblx0KiAgICAgICAgIFwic2l6ZVwiOiAzMjE3NSxcblx0KiAgICAgICAgIFwibWltZXR5cGVcIjogXCJpbWFnZS9wbmdcIixcblx0KiAgICAgICAgIFwiY2FjaGVDb250cm9sXCI6IFwibWF4LWFnZT0zNjAwXCIsXG5cdCogICAgICAgICBcImxhc3RNb2RpZmllZFwiOiBcIjIwMjQtMDUtMjJUMjM6MDY6MDUuNTc0WlwiLFxuXHQqICAgICAgICAgXCJjb250ZW50TGVuZ3RoXCI6IDMyMTc1LFxuXHQqICAgICAgICAgXCJodHRwU3RhdHVzQ29kZVwiOiAyMDBcblx0KiAgICAgICB9XG5cdCogICAgIH1cblx0KiAgIF0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBTZWFyY2ggZmlsZXMgaW4gYSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmxpc3QoJ2ZvbGRlcicsIHtcblx0KiAgICAgbGltaXQ6IDEwMCxcblx0KiAgICAgb2Zmc2V0OiAwLFxuXHQqICAgICBzb3J0Qnk6IHsgY29sdW1uOiAnbmFtZScsIG9yZGVyOiAnYXNjJyB9LFxuXHQqICAgICBzZWFyY2g6ICdqb24nXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0KHBhdGgsIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcblx0XHR2YXIgX3RoaXMxMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGJvZHkgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9TRUFSQ0hfT1BUSU9OUyksIG9wdGlvbnMpLCB7fSwgeyBwcmVmaXg6IHBhdGggfHwgXCJcIiB9KTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczEzLmZldGNoLCBgJHtfdGhpczEzLnVybH0vb2JqZWN0L2xpc3QvJHtfdGhpczEzLmJ1Y2tldElkfWAsIGJvZHksIHsgaGVhZGVyczogX3RoaXMxMy5oZWFkZXJzIH0sIHBhcmFtZXRlcnMpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMTMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEBleHBlcmltZW50YWwgdGhpcyBtZXRob2Qgc2lnbmF0dXJlIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgc2VhcmNoIG9wdGlvbnNcblx0KiBAcGFyYW0gcGFyYW1ldGVyc1xuXHQqL1xuXHRhc3luYyBsaXN0VjIob3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRcdHZhciBfdGhpczE0ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgYm9keSA9IF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczE0LmZldGNoLCBgJHtfdGhpczE0LnVybH0vb2JqZWN0L2xpc3QtdjIvJHtfdGhpczE0LmJ1Y2tldElkfWAsIGJvZHksIHsgaGVhZGVyczogX3RoaXMxNC5oZWFkZXJzIH0sIHBhcmFtZXRlcnMpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMTQuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdGVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKTtcblx0fVxuXHR0b0Jhc2U2NChkYXRhKSB7XG5cdFx0aWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZyhcImJhc2U2NFwiKTtcblx0XHRyZXR1cm4gYnRvYShkYXRhKTtcblx0fVxuXHRfZ2V0RmluYWxQYXRoKHBhdGgpIHtcblx0XHRyZXR1cm4gYCR7dGhpcy5idWNrZXRJZH0vJHtwYXRoLnJlcGxhY2UoL15cXC8rLywgXCJcIil9YDtcblx0fVxuXHRfcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpIHtcblx0XHRyZXR1cm4gcGF0aC5yZXBsYWNlKC9eXFwvfFxcLyQvZywgXCJcIikucmVwbGFjZSgvXFwvKy9nLCBcIi9cIik7XG5cdH1cblx0dHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcodHJhbnNmb3JtKSB7XG5cdFx0Y29uc3QgcGFyYW1zID0gW107XG5cdFx0aWYgKHRyYW5zZm9ybS53aWR0aCkgcGFyYW1zLnB1c2goYHdpZHRoPSR7dHJhbnNmb3JtLndpZHRofWApO1xuXHRcdGlmICh0cmFuc2Zvcm0uaGVpZ2h0KSBwYXJhbXMucHVzaChgaGVpZ2h0PSR7dHJhbnNmb3JtLmhlaWdodH1gKTtcblx0XHRpZiAodHJhbnNmb3JtLnJlc2l6ZSkgcGFyYW1zLnB1c2goYHJlc2l6ZT0ke3RyYW5zZm9ybS5yZXNpemV9YCk7XG5cdFx0aWYgKHRyYW5zZm9ybS5mb3JtYXQpIHBhcmFtcy5wdXNoKGBmb3JtYXQ9JHt0cmFuc2Zvcm0uZm9ybWF0fWApO1xuXHRcdGlmICh0cmFuc2Zvcm0ucXVhbGl0eSkgcGFyYW1zLnB1c2goYHF1YWxpdHk9JHt0cmFuc2Zvcm0ucXVhbGl0eX1gKTtcblx0XHRyZXR1cm4gcGFyYW1zLmpvaW4oXCImXCIpO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlcnNpb24udHNcbmNvbnN0IHZlcnNpb24gPSBcIjIuOTEuMFwiO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL2NvbnN0YW50cy50c1xuY29uc3QgREVGQVVMVF9IRUFERVJTJDEgPSB7IFwiWC1DbGllbnQtSW5mb1wiOiBgc3RvcmFnZS1qcy8ke3ZlcnNpb259YCB9O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaS50c1xudmFyIFN0b3JhZ2VCdWNrZXRBcGkgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxLCBvcHRzKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHRjb25zdCBiYXNlVXJsID0gbmV3IFVSTCh1cmwpO1xuXHRcdGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMudXNlTmV3SG9zdG5hbWUpIHtcblx0XHRcdGlmICgvc3VwYWJhc2VcXC4oY298aW58cmVkKSQvLnRlc3QoYmFzZVVybC5ob3N0bmFtZSkgJiYgIWJhc2VVcmwuaG9zdG5hbWUuaW5jbHVkZXMoXCJzdG9yYWdlLnN1cGFiYXNlLlwiKSkgYmFzZVVybC5ob3N0bmFtZSA9IGJhc2VVcmwuaG9zdG5hbWUucmVwbGFjZShcInN1cGFiYXNlLlwiLCBcInN0b3JhZ2Uuc3VwYWJhc2UuXCIpO1xuXHRcdH1cblx0XHR0aGlzLnVybCA9IGJhc2VVcmwuaHJlZi5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cdFx0dGhpcy5oZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfSEVBREVSUyQxKSwgaGVhZGVycyk7XG5cdFx0dGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaCQxKGZldGNoJDEpO1xuXHR9XG5cdC8qKlxuXHQqIEVuYWJsZSB0aHJvd2luZyBlcnJvcnMgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlbS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0Ki9cblx0dGhyb3dPbkVycm9yKCkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYWxsIFN0b3JhZ2UgYnVja2V0cyB3aXRoaW4gYW4gZXhpc3RpbmcgcHJvamVjdC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyBRdWVyeSBwYXJhbWV0ZXJzIGZvciBsaXN0aW5nIGJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucy5saW1pdCBNYXhpbXVtIG51bWJlciBvZiBidWNrZXRzIHRvIHJldHVyblxuXHQqIEBwYXJhbSBvcHRpb25zLm9mZnNldCBOdW1iZXIgb2YgYnVja2V0cyB0byBza2lwXG5cdCogQHBhcmFtIG9wdGlvbnMuc29ydENvbHVtbiBDb2x1bW4gdG8gc29ydCBieSAoJ2lkJywgJ25hbWUnLCAnY3JlYXRlZF9hdCcsICd1cGRhdGVkX2F0Jylcblx0KiBAcGFyYW0gb3B0aW9ucy5zb3J0T3JkZXIgU29ydCBvcmRlciAoJ2FzYycgb3IgJ2Rlc2MnKVxuXHQqIEBwYXJhbSBvcHRpb25zLnNlYXJjaCBTZWFyY2ggdGVybSB0byBmaWx0ZXIgYnVja2V0IG5hbWVzXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgYnVja2V0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCBidWNrZXRzXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5saXN0QnVja2V0cygpXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBMaXN0IGJ1Y2tldHMgd2l0aCBvcHRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5saXN0QnVja2V0cyh7XG5cdCogICAgIGxpbWl0OiAxMCxcblx0KiAgICAgb2Zmc2V0OiAwLFxuXHQqICAgICBzb3J0Q29sdW1uOiAnY3JlYXRlZF9hdCcsXG5cdCogICAgIHNvcnRPcmRlcjogJ2Rlc2MnLFxuXHQqICAgICBzZWFyY2g6ICdwcm9kJ1xuXHQqICAgfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdEJ1Y2tldHMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHF1ZXJ5U3RyaW5nID0gX3RoaXMubGlzdEJ1Y2tldE9wdGlvbnNUb1F1ZXJ5U3RyaW5nKG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgZ2V0KF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L2J1Y2tldCR7cXVlcnlTdHJpbmd9YCwgeyBoZWFkZXJzOiBfdGhpcy5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgU3RvcmFnZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIHJldHJpZXZlLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGJ1Y2tldCBkZXRhaWxzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBHZXQgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5nZXRCdWNrZXQoJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwiaWRcIjogXCJhdmF0YXJzXCIsXG5cdCogICAgIFwibmFtZVwiOiBcImF2YXRhcnNcIixcblx0KiAgICAgXCJvd25lclwiOiBcIlwiLFxuXHQqICAgICBcInB1YmxpY1wiOiBmYWxzZSxcblx0KiAgICAgXCJmaWxlX3NpemVfbGltaXRcIjogMTAyNCxcblx0KiAgICAgXCJhbGxvd2VkX21pbWVfdHlwZXNcIjogW1xuXHQqICAgICAgIFwiaW1hZ2UvcG5nXCJcblx0KiAgICAgXSxcblx0KiAgICAgXCJjcmVhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCIsXG5cdCogICAgIFwidXBkYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjI6MjY6MDUuMTAwWlwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBnZXRCdWNrZXQoaWQpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgZ2V0KF90aGlzMi5mZXRjaCwgYCR7X3RoaXMyLnVybH0vYnVja2V0LyR7aWR9YCwgeyBoZWFkZXJzOiBfdGhpczIuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczIuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBuZXcgU3RvcmFnZSBidWNrZXRcblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nLlxuXHQqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuIEJ5IGRlZmF1bHQsIGJ1Y2tldHMgYXJlIHByaXZhdGUuXG5cdCogQHBhcmFtIG9wdGlvbnMuZmlsZVNpemVMaW1pdCBzcGVjaWZpZXMgdGhlIG1heCBmaWxlIHNpemUgaW4gYnl0ZXMgdGhhdCBjYW4gYmUgdXBsb2FkZWQgdG8gdGhpcyBidWNrZXQuXG5cdCogVGhlIGdsb2JhbCBmaWxlIHNpemUgbGltaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgdmFsdWUuXG5cdCogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggZG9lc24ndCBzZXQgYSBwZXIgYnVja2V0IGZpbGUgc2l6ZSBsaW1pdC5cblx0KiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzIHNwZWNpZmllcyB0aGUgYWxsb3dlZCBtaW1lIHR5cGVzIHRoYXQgdGhpcyBidWNrZXQgY2FuIGFjY2VwdCBkdXJpbmcgdXBsb2FkLlxuXHQqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGFsbG93cyBmaWxlcyB3aXRoIGFsbCBtaW1lIHR5cGVzIHRvIGJlIHVwbG9hZGVkLlxuXHQqIEVhY2ggbWltZSB0eXBlIHNwZWNpZmllZCBjYW4gYmUgYSB3aWxkY2FyZCwgZS5nLiBpbWFnZS8qLCBvciBhIHNwZWNpZmljIG1pbWUgdHlwZSwgZS5nLiBpbWFnZS9wbmcuXG5cdCogQHBhcmFtIG9wdGlvbnMudHlwZSAocHJpdmF0ZS1iZXRhKSBzcGVjaWZpZXMgdGhlIGJ1Y2tldCB0eXBlLiBzZWUgYEJ1Y2tldFR5cGVgIGZvciBtb3JlIGRldGFpbHMuXG5cdCogICAtIGRlZmF1bHQgYnVja2V0IHR5cGUgaXMgYFNUQU5EQVJEYFxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIG5ld2x5IGNyZWF0ZWQgYnVja2V0IG5hbWUgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmNyZWF0ZUJ1Y2tldCgnYXZhdGFycycsIHtcblx0KiAgICAgcHVibGljOiBmYWxzZSxcblx0KiAgICAgYWxsb3dlZE1pbWVUeXBlczogWydpbWFnZS9wbmcnXSxcblx0KiAgICAgZmlsZVNpemVMaW1pdDogMTAyNFxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm5hbWVcIjogXCJhdmF0YXJzXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZUJ1Y2tldChpZCwgb3B0aW9ucyA9IHsgcHVibGljOiBmYWxzZSB9KSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczMuZmV0Y2gsIGAke190aGlzMy51cmx9L2J1Y2tldGAsIHtcblx0XHRcdFx0XHRpZCxcblx0XHRcdFx0XHRuYW1lOiBpZCxcblx0XHRcdFx0XHR0eXBlOiBvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0cHVibGljOiBvcHRpb25zLnB1YmxpYyxcblx0XHRcdFx0XHRmaWxlX3NpemVfbGltaXQ6IG9wdGlvbnMuZmlsZVNpemVMaW1pdCxcblx0XHRcdFx0XHRhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlc1xuXHRcdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzMy5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogVXBkYXRlcyBhIFN0b3JhZ2UgYnVja2V0XG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBidWNrZXQgeW91IGFyZSB1cGRhdGluZy5cblx0KiBAcGFyYW0gb3B0aW9ucy5wdWJsaWMgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGJ1Y2tldC4gUHVibGljIGJ1Y2tldHMgZG9uJ3QgcmVxdWlyZSBhbiBhdXRob3JpemF0aW9uIHRva2VuIHRvIGRvd25sb2FkIG9iamVjdHMsIGJ1dCBzdGlsbCByZXF1aXJlIGEgdmFsaWQgdG9rZW4gZm9yIGFsbCBvdGhlciBvcGVyYXRpb25zLlxuXHQqIEBwYXJhbSBvcHRpb25zLmZpbGVTaXplTGltaXQgc3BlY2lmaWVzIHRoZSBtYXggZmlsZSBzaXplIGluIGJ5dGVzIHRoYXQgY2FuIGJlIHVwbG9hZGVkIHRvIHRoaXMgYnVja2V0LlxuXHQqIFRoZSBnbG9iYWwgZmlsZSBzaXplIGxpbWl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHZhbHVlLlxuXHQqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGRvZXNuJ3Qgc2V0IGEgcGVyIGJ1Y2tldCBmaWxlIHNpemUgbGltaXQuXG5cdCogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyBzcGVjaWZpZXMgdGhlIGFsbG93ZWQgbWltZSB0eXBlcyB0aGF0IHRoaXMgYnVja2V0IGNhbiBhY2NlcHQgZHVyaW5nIHVwbG9hZC5cblx0KiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBhbGxvd3MgZmlsZXMgd2l0aCBhbGwgbWltZSB0eXBlcyB0byBiZSB1cGxvYWRlZC5cblx0KiBFYWNoIG1pbWUgdHlwZSBzcGVjaWZpZWQgY2FuIGJlIGEgd2lsZGNhcmQsIGUuZy4gaW1hZ2UvKiwgb3IgYSBzcGVjaWZpYyBtaW1lIHR5cGUsIGUuZy4gaW1hZ2UvcG5nLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHN1Y2Nlc3MgbWVzc2FnZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgVXBkYXRlIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAudXBkYXRlQnVja2V0KCdhdmF0YXJzJywge1xuXHQqICAgICBwdWJsaWM6IGZhbHNlLFxuXHQqICAgICBhbGxvd2VkTWltZVR5cGVzOiBbJ2ltYWdlL3BuZyddLFxuXHQqICAgICBmaWxlU2l6ZUxpbWl0OiAxMDI0XG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibWVzc2FnZVwiOiBcIlN1Y2Nlc3NmdWxseSB1cGRhdGVkXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHVwZGF0ZUJ1Y2tldChpZCwgb3B0aW9ucykge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwdXQoX3RoaXM0LmZldGNoLCBgJHtfdGhpczQudXJsfS9idWNrZXQvJHtpZH1gLCB7XG5cdFx0XHRcdFx0aWQsXG5cdFx0XHRcdFx0bmFtZTogaWQsXG5cdFx0XHRcdFx0cHVibGljOiBvcHRpb25zLnB1YmxpYyxcblx0XHRcdFx0XHRmaWxlX3NpemVfbGltaXQ6IG9wdGlvbnMuZmlsZVNpemVMaW1pdCxcblx0XHRcdFx0XHRhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlc1xuXHRcdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzNC5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogUmVtb3ZlcyBhbGwgb2JqZWN0cyBpbnNpZGUgYSBzaW5nbGUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byBlbXB0eS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBFbXB0eSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmVtcHR5QnVja2V0KCdhdmF0YXJzJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgZW1wdGllZFwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBlbXB0eUJ1Y2tldChpZCkge1xuXHRcdHZhciBfdGhpczUgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0JDEoX3RoaXM1LmZldGNoLCBgJHtfdGhpczUudXJsfS9idWNrZXQvJHtpZH0vZW1wdHlgLCB7fSwgeyBoZWFkZXJzOiBfdGhpczUuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczUuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIERlbGV0ZXMgYW4gZXhpc3RpbmcgYnVja2V0LiBBIGJ1Y2tldCBjYW4ndCBiZSBkZWxldGVkIHdpdGggZXhpc3Rpbmcgb2JqZWN0cyBpbnNpZGUgaXQuXG5cdCogWW91IG11c3QgZmlyc3QgYGVtcHR5KClgIHRoZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGRlbGV0ZS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBEZWxldGUgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5kZWxldGVCdWNrZXQoJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibWVzc2FnZVwiOiBcIlN1Y2Nlc3NmdWxseSBkZWxldGVkXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGRlbGV0ZUJ1Y2tldChpZCkge1xuXHRcdHZhciBfdGhpczYgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCByZW1vdmUoX3RoaXM2LmZldGNoLCBgJHtfdGhpczYudXJsfS9idWNrZXQvJHtpZH1gLCB7fSwgeyBoZWFkZXJzOiBfdGhpczYuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczYuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdGxpc3RCdWNrZXRPcHRpb25zVG9RdWVyeVN0cmluZyhvcHRpb25zKSB7XG5cdFx0Y29uc3QgcGFyYW1zID0ge307XG5cdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdGlmIChcImxpbWl0XCIgaW4gb3B0aW9ucykgcGFyYW1zLmxpbWl0ID0gU3RyaW5nKG9wdGlvbnMubGltaXQpO1xuXHRcdFx0aWYgKFwib2Zmc2V0XCIgaW4gb3B0aW9ucykgcGFyYW1zLm9mZnNldCA9IFN0cmluZyhvcHRpb25zLm9mZnNldCk7XG5cdFx0XHRpZiAob3B0aW9ucy5zZWFyY2gpIHBhcmFtcy5zZWFyY2ggPSBvcHRpb25zLnNlYXJjaDtcblx0XHRcdGlmIChvcHRpb25zLnNvcnRDb2x1bW4pIHBhcmFtcy5zb3J0Q29sdW1uID0gb3B0aW9ucy5zb3J0Q29sdW1uO1xuXHRcdFx0aWYgKG9wdGlvbnMuc29ydE9yZGVyKSBwYXJhbXMuc29ydE9yZGVyID0gb3B0aW9ucy5zb3J0T3JkZXI7XG5cdFx0fVxuXHRcdHJldHVybiBPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA+IDAgPyBcIj9cIiArIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKS50b1N0cmluZygpIDogXCJcIjtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1N0b3JhZ2VBbmFseXRpY3NDbGllbnQudHNcbi8qKlxuKiBDbGllbnQgY2xhc3MgZm9yIG1hbmFnaW5nIEFuYWx5dGljcyBCdWNrZXRzIHVzaW5nIEljZWJlcmcgdGFibGVzXG4qIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBsaXN0aW5nLCBhbmQgZGVsZXRpbmcgYW5hbHl0aWNzIGJ1Y2tldHNcbiovXG52YXIgU3RvcmFnZUFuYWx5dGljc0NsaWVudCA9IGNsYXNzIHtcblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgbmV3IFN0b3JhZ2VBbmFseXRpY3NDbGllbnQgaW5zdGFuY2Vcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcGFyYW0gdXJsIC0gVGhlIGJhc2UgVVJMIGZvciB0aGUgc3RvcmFnZSBBUElcblx0KiBAcGFyYW0gaGVhZGVycyAtIEhUVFAgaGVhZGVycyB0byBpbmNsdWRlIGluIHJlcXVlc3RzXG5cdCogQHBhcmFtIGZldGNoIC0gT3B0aW9uYWwgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBjbGllbnQgPSBuZXcgU3RvcmFnZUFuYWx5dGljc0NsaWVudCh1cmwsIGhlYWRlcnMpXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHR0aGlzLnVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cdFx0dGhpcy5oZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfSEVBREVSUyQxKSwgaGVhZGVycyk7XG5cdFx0dGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaCQxKGZldGNoJDEpO1xuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtIGluIHRoZSByZXNwb25zZVxuXHQqIFdoZW4gZW5hYmxlZCwgZmFpbGVkIG9wZXJhdGlvbnMgd2lsbCB0aHJvdyBpbnN0ZWFkIG9mIHJldHVybmluZyB7IGRhdGE6IG51bGwsIGVycm9yIH1cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcmV0dXJucyBUaGlzIGluc3RhbmNlIGZvciBtZXRob2QgY2hhaW5pbmdcblx0Ki9cblx0dGhyb3dPbkVycm9yKCkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBuZXcgYW5hbHl0aWNzIGJ1Y2tldCB1c2luZyBJY2ViZXJnIHRhYmxlc1xuXHQqIEFuYWx5dGljcyBidWNrZXRzIGFyZSBvcHRpbWl6ZWQgZm9yIGFuYWx5dGljYWwgcXVlcmllcyBhbmQgZGF0YSBwcm9jZXNzaW5nXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHBhcmFtIG5hbWUgQSB1bmlxdWUgbmFtZSBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgbmV3bHkgY3JlYXRlZCBhbmFseXRpY3MgYnVja2V0IG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDcmVhdGUgYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuYW5hbHl0aWNzXG5cdCogICAuY3JlYXRlQnVja2V0KCdhbmFseXRpY3MtZGF0YScpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJuYW1lXCI6IFwiYW5hbHl0aWNzLWRhdGFcIixcblx0KiAgICAgXCJ0eXBlXCI6IFwiQU5BTFlUSUNTXCIsXG5cdCogICAgIFwiZm9ybWF0XCI6IFwiaWNlYmVyZ1wiLFxuXHQqICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIixcblx0KiAgICAgXCJ1cGRhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZUJ1Y2tldChuYW1lKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdCQxKF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L2J1Y2tldGAsIHsgbmFtZSB9LCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFsbCBBbmFseXRpY3MgU3RvcmFnZSBidWNrZXRzIHdpdGhpbiBhbiBleGlzdGluZyBwcm9qZWN0XG5cdCogT25seSByZXR1cm5zIGJ1Y2tldHMgb2YgdHlwZSAnQU5BTFlUSUNTJ1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIFF1ZXJ5IHBhcmFtZXRlcnMgZm9yIGxpc3RpbmcgYnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zLmxpbWl0IE1heGltdW0gbnVtYmVyIG9mIGJ1Y2tldHMgdG8gcmV0dXJuXG5cdCogQHBhcmFtIG9wdGlvbnMub2Zmc2V0IE51bWJlciBvZiBidWNrZXRzIHRvIHNraXBcblx0KiBAcGFyYW0gb3B0aW9ucy5zb3J0Q29sdW1uIENvbHVtbiB0byBzb3J0IGJ5ICgnbmFtZScsICdjcmVhdGVkX2F0JywgJ3VwZGF0ZWRfYXQnKVxuXHQqIEBwYXJhbSBvcHRpb25zLnNvcnRPcmRlciBTb3J0IG9yZGVyICgnYXNjJyBvciAnZGVzYycpXG5cdCogQHBhcmFtIG9wdGlvbnMuc2VhcmNoIFNlYXJjaCB0ZXJtIHRvIGZpbHRlciBidWNrZXQgbmFtZXNcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBhbmFseXRpY3MgYnVja2V0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCBhbmFseXRpY3MgYnVja2V0c1xuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuYW5hbHl0aWNzXG5cdCogICAubGlzdEJ1Y2tldHMoe1xuXHQqICAgICBsaW1pdDogMTAsXG5cdCogICAgIG9mZnNldDogMCxcblx0KiAgICAgc29ydENvbHVtbjogJ2NyZWF0ZWRfYXQnLFxuXHQqICAgICBzb3J0T3JkZXI6ICdkZXNjJ1xuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjogW1xuXHQqICAgICB7XG5cdCogICAgICAgXCJuYW1lXCI6IFwiYW5hbHl0aWNzLWRhdGFcIixcblx0KiAgICAgICBcInR5cGVcIjogXCJBTkFMWVRJQ1NcIixcblx0KiAgICAgICBcImZvcm1hdFwiOiBcImljZWJlcmdcIixcblx0KiAgICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIixcblx0KiAgICAgICBcInVwZGF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIlxuXHQqICAgICB9XG5cdCogICBdLFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0QnVja2V0cyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXHRcdFx0aWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubGltaXQpICE9PSB2b2lkIDApIHF1ZXJ5UGFyYW1zLnNldChcImxpbWl0XCIsIG9wdGlvbnMubGltaXQudG9TdHJpbmcoKSk7XG5cdFx0XHRpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpICE9PSB2b2lkIDApIHF1ZXJ5UGFyYW1zLnNldChcIm9mZnNldFwiLCBvcHRpb25zLm9mZnNldC50b1N0cmluZygpKTtcblx0XHRcdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc29ydENvbHVtbikgcXVlcnlQYXJhbXMuc2V0KFwic29ydENvbHVtblwiLCBvcHRpb25zLnNvcnRDb2x1bW4pO1xuXHRcdFx0aWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zb3J0T3JkZXIpIHF1ZXJ5UGFyYW1zLnNldChcInNvcnRPcmRlclwiLCBvcHRpb25zLnNvcnRPcmRlcik7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNlYXJjaCkgcXVlcnlQYXJhbXMuc2V0KFwic2VhcmNoXCIsIG9wdGlvbnMuc2VhcmNoKTtcblx0XHRcdGNvbnN0IHF1ZXJ5U3RyaW5nID0gcXVlcnlQYXJhbXMudG9TdHJpbmcoKTtcblx0XHRcdGNvbnN0IHVybCA9IHF1ZXJ5U3RyaW5nID8gYCR7X3RoaXMyLnVybH0vYnVja2V0PyR7cXVlcnlTdHJpbmd9YCA6IGAke190aGlzMi51cmx9L2J1Y2tldGA7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBnZXQoX3RoaXMyLmZldGNoLCB1cmwsIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMyLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIERlbGV0ZXMgYW4gZXhpc3RpbmcgYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIEEgYnVja2V0IGNhbid0IGJlIGRlbGV0ZWQgd2l0aCBleGlzdGluZyBvYmplY3RzIGluc2lkZSBpdFxuXHQqIFlvdSBtdXN0IGZpcnN0IGVtcHR5IHRoZSBidWNrZXQgYmVmb3JlIGRlbGV0aW9uXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHBhcmFtIGJ1Y2tldE5hbWUgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gZGVsZXRlXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBEZWxldGUgYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuYW5hbHl0aWNzXG5cdCogICAuZGVsZXRlQnVja2V0KCdhbmFseXRpY3MtZGF0YScpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJtZXNzYWdlXCI6IFwiU3VjY2Vzc2Z1bGx5IGRlbGV0ZWRcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZGVsZXRlQnVja2V0KGJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3RoaXMzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcmVtb3ZlKF90aGlzMy5mZXRjaCwgYCR7X3RoaXMzLnVybH0vYnVja2V0LyR7YnVja2V0TmFtZX1gLCB7fSwgeyBoZWFkZXJzOiBfdGhpczMuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogR2V0IGFuIEljZWJlcmcgUkVTVCBDYXRhbG9nIGNsaWVudCBjb25maWd1cmVkIGZvciBhIHNwZWNpZmljIGFuYWx5dGljcyBidWNrZXRcblx0KiBVc2UgdGhpcyB0byBwZXJmb3JtIGFkdmFuY2VkIHRhYmxlIGFuZCBuYW1lc3BhY2Ugb3BlcmF0aW9ucyB3aXRoaW4gdGhlIGJ1Y2tldFxuXHQqIFRoZSByZXR1cm5lZCBjbGllbnQgcHJvdmlkZXMgZnVsbCBhY2Nlc3MgdG8gdGhlIEFwYWNoZSBJY2ViZXJnIFJFU1QgQ2F0YWxvZyBBUElcblx0KiB3aXRoIHRoZSBTdXBhYmFzZSBgeyBkYXRhLCBlcnJvciB9YCBwYXR0ZXJuIGZvciBjb25zaXN0ZW50IGVycm9yIGhhbmRsaW5nIG9uIGFsbCBvcGVyYXRpb25zLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEBwYXJhbSBidWNrZXROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGFuYWx5dGljcyBidWNrZXQgKHdhcmVob3VzZSkgdG8gY29ubmVjdCB0b1xuXHQqIEByZXR1cm5zIFRoZSB3cmFwcGVkIEljZWJlcmcgY2F0YWxvZyBjbGllbnRcblx0KiBAdGhyb3dzIHtTdG9yYWdlRXJyb3J9IElmIHRoZSBidWNrZXQgbmFtZSBpcyBpbnZhbGlkXG5cdCpcblx0KiBAZXhhbXBsZSBHZXQgY2F0YWxvZyBhbmQgY3JlYXRlIHRhYmxlXG5cdCogYGBganNcblx0KiAvLyBGaXJzdCwgY3JlYXRlIGFuIGFuYWx5dGljcyBidWNrZXRcblx0KiBjb25zdCB7IGRhdGE6IGJ1Y2tldCwgZXJyb3I6IGJ1Y2tldEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5hbmFseXRpY3Ncblx0KiAgIC5jcmVhdGVCdWNrZXQoJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIEdldCB0aGUgSWNlYmVyZyBjYXRhbG9nIGZvciB0aGF0IGJ1Y2tldFxuXHQqIGNvbnN0IGNhdGFsb2cgPSBzdXBhYmFzZS5zdG9yYWdlLmFuYWx5dGljcy5mcm9tKCdhbmFseXRpY3MtZGF0YScpXG5cdCpcblx0KiAvLyBDcmVhdGUgYSBuYW1lc3BhY2Vcblx0KiBjb25zdCB7IGVycm9yOiBuc0Vycm9yIH0gPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZSh7IG5hbWVzcGFjZTogWydkZWZhdWx0J10gfSlcblx0KlxuXHQqIC8vIENyZWF0ZSBhIHRhYmxlIHdpdGggc2NoZW1hXG5cdCogY29uc3QgeyBkYXRhOiB0YWJsZU1ldGFkYXRhLCBlcnJvcjogdGFibGVFcnJvciB9ID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVUYWJsZShcblx0KiAgIHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSB9LFxuXHQqICAge1xuXHQqICAgICBuYW1lOiAnZXZlbnRzJyxcblx0KiAgICAgc2NoZW1hOiB7XG5cdCogICAgICAgdHlwZTogJ3N0cnVjdCcsXG5cdCogICAgICAgZmllbGRzOiBbXG5cdCogICAgICAgICB7IGlkOiAxLCBuYW1lOiAnaWQnLCB0eXBlOiAnbG9uZycsIHJlcXVpcmVkOiB0cnVlIH0sXG5cdCogICAgICAgICB7IGlkOiAyLCBuYW1lOiAndGltZXN0YW1wJywgdHlwZTogJ3RpbWVzdGFtcCcsIHJlcXVpcmVkOiB0cnVlIH0sXG5cdCogICAgICAgICB7IGlkOiAzLCBuYW1lOiAndXNlcl9pZCcsIHR5cGU6ICdzdHJpbmcnLCByZXF1aXJlZDogZmFsc2UgfVxuXHQqICAgICAgIF0sXG5cdCogICAgICAgJ3NjaGVtYS1pZCc6IDAsXG5cdCogICAgICAgJ2lkZW50aWZpZXItZmllbGQtaWRzJzogWzFdXG5cdCogICAgIH0sXG5cdCogICAgICdwYXJ0aXRpb24tc3BlYyc6IHtcblx0KiAgICAgICAnc3BlYy1pZCc6IDAsXG5cdCogICAgICAgZmllbGRzOiBbXVxuXHQqICAgICB9LFxuXHQqICAgICAnd3JpdGUtb3JkZXInOiB7XG5cdCogICAgICAgJ29yZGVyLWlkJzogMCxcblx0KiAgICAgICBmaWVsZHM6IFtdXG5cdCogICAgIH0sXG5cdCogICAgIHByb3BlcnRpZXM6IHtcblx0KiAgICAgICAnd3JpdGUuZm9ybWF0LmRlZmF1bHQnOiAncGFycXVldCdcblx0KiAgICAgfVxuXHQqICAgfVxuXHQqIClcblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIExpc3QgdGFibGVzIGluIG5hbWVzcGFjZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgY2F0YWxvZyA9IHN1cGFiYXNlLnN0b3JhZ2UuYW5hbHl0aWNzLmZyb20oJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIExpc3QgYWxsIHRhYmxlcyBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2Vcblx0KiBjb25zdCB7IGRhdGE6IHRhYmxlcywgZXJyb3I6IGxpc3RFcnJvciB9ID0gYXdhaXQgY2F0YWxvZy5saXN0VGFibGVzKHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSB9KVxuXHQqIGlmIChsaXN0RXJyb3IpIHtcblx0KiAgIGlmIChsaXN0RXJyb3IuaXNOb3RGb3VuZCgpKSB7XG5cdCogICAgIGNvbnNvbGUubG9nKCdOYW1lc3BhY2Ugbm90IGZvdW5kJylcblx0KiAgIH1cblx0KiAgIHJldHVyblxuXHQqIH1cblx0KiBjb25zb2xlLmxvZyh0YWJsZXMpIC8vIFt7IG5hbWVzcGFjZTogWydkZWZhdWx0J10sIG5hbWU6ICdldmVudHMnIH1dXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBXb3JraW5nIHdpdGggbmFtZXNwYWNlc1xuXHQqIGBgYGpzXG5cdCogY29uc3QgY2F0YWxvZyA9IHN1cGFiYXNlLnN0b3JhZ2UuYW5hbHl0aWNzLmZyb20oJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIExpc3QgYWxsIG5hbWVzcGFjZXNcblx0KiBjb25zdCB7IGRhdGE6IG5hbWVzcGFjZXMgfSA9IGF3YWl0IGNhdGFsb2cubGlzdE5hbWVzcGFjZXMoKVxuXHQqXG5cdCogLy8gQ3JlYXRlIG5hbWVzcGFjZSB3aXRoIHByb3BlcnRpZXNcblx0KiBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZShcblx0KiAgIHsgbmFtZXNwYWNlOiBbJ3Byb2R1Y3Rpb24nXSB9LFxuXHQqICAgeyBwcm9wZXJ0aWVzOiB7IG93bmVyOiAnZGF0YS10ZWFtJywgZW52OiAncHJvZCcgfSB9XG5cdCogKVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ2xlYW51cCBvcGVyYXRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCBjYXRhbG9nID0gc3VwYWJhc2Uuc3RvcmFnZS5hbmFseXRpY3MuZnJvbSgnYW5hbHl0aWNzLWRhdGEnKVxuXHQqXG5cdCogLy8gRHJvcCB0YWJsZSB3aXRoIHB1cmdlIG9wdGlvbiAocmVtb3ZlcyBhbGwgZGF0YSlcblx0KiBjb25zdCB7IGVycm9yOiBkcm9wRXJyb3IgfSA9IGF3YWl0IGNhdGFsb2cuZHJvcFRhYmxlKFxuXHQqICAgeyBuYW1lc3BhY2U6IFsnZGVmYXVsdCddLCBuYW1lOiAnZXZlbnRzJyB9LFxuXHQqICAgeyBwdXJnZTogdHJ1ZSB9XG5cdCogKVxuXHQqXG5cdCogaWYgKGRyb3BFcnJvcj8uaXNOb3RGb3VuZCgpKSB7XG5cdCogICBjb25zb2xlLmxvZygnVGFibGUgZG9lcyBub3QgZXhpc3QnKVxuXHQqIH1cblx0KlxuXHQqIC8vIERyb3AgbmFtZXNwYWNlIChtdXN0IGJlIGVtcHR5KVxuXHQqIGF3YWl0IGNhdGFsb2cuZHJvcE5hbWVzcGFjZSh7IG5hbWVzcGFjZTogWydkZWZhdWx0J10gfSlcblx0KiBgYGBcblx0KlxuXHQqIEByZW1hcmtzXG5cdCogVGhpcyBtZXRob2QgcHJvdmlkZXMgYSBicmlkZ2UgYmV0d2VlbiBTdXBhYmFzZSdzIGJ1Y2tldCBtYW5hZ2VtZW50IGFuZCB0aGUgc3RhbmRhcmRcblx0KiBBcGFjaGUgSWNlYmVyZyBSRVNUIENhdGFsb2cgQVBJLiBUaGUgYnVja2V0IG5hbWUgbWFwcyB0byB0aGUgSWNlYmVyZyB3YXJlaG91c2UgcGFyYW1ldGVyLlxuXHQqIEFsbCBhdXRoZW50aWNhdGlvbiBhbmQgY29uZmlndXJhdGlvbiBpcyBoYW5kbGVkIGF1dG9tYXRpY2FsbHkgdXNpbmcgeW91ciBTdXBhYmFzZSBjcmVkZW50aWFscy5cblx0KlxuXHQqICoqRXJyb3IgSGFuZGxpbmcqKjogSW52YWxpZCBidWNrZXQgbmFtZXMgdGhyb3cgaW1tZWRpYXRlbHkuIEFsbCBjYXRhbG9nXG5cdCogb3BlcmF0aW9ucyByZXR1cm4gYHsgZGF0YSwgZXJyb3IgfWAgd2hlcmUgZXJyb3JzIGFyZSBgSWNlYmVyZ0Vycm9yYCBpbnN0YW5jZXMgZnJvbSBpY2ViZXJnLWpzLlxuXHQqIFVzZSBoZWxwZXIgbWV0aG9kcyBsaWtlIGBlcnJvci5pc05vdEZvdW5kKClgIG9yIGNoZWNrIGBlcnJvci5zdGF0dXNgIGZvciBzcGVjaWZpYyBlcnJvciBoYW5kbGluZy5cblx0KiBVc2UgYC50aHJvd09uRXJyb3IoKWAgb24gdGhlIGFuYWx5dGljcyBjbGllbnQgaWYgeW91IHByZWZlciBleGNlcHRpb25zIGZvciBjYXRhbG9nIG9wZXJhdGlvbnMuXG5cdCpcblx0KiAqKkNsZWFudXAgT3BlcmF0aW9ucyoqOiBXaGVuIHVzaW5nIGBkcm9wVGFibGVgLCB0aGUgYHB1cmdlOiB0cnVlYCBvcHRpb24gcGVybWFuZW50bHlcblx0KiBkZWxldGVzIGFsbCB0YWJsZSBkYXRhLiBXaXRob3V0IGl0LCB0aGUgdGFibGUgaXMgbWFya2VkIGFzIGRlbGV0ZWQgYnV0IGRhdGEgcmVtYWlucy5cblx0KlxuXHQqICoqTGlicmFyeSBEZXBlbmRlbmN5Kio6IFRoZSByZXR1cm5lZCBjYXRhbG9nIHdyYXBzIGBJY2ViZXJnUmVzdENhdGFsb2dgIGZyb20gaWNlYmVyZy1qcy5cblx0KiBGb3IgY29tcGxldGUgQVBJIGRvY3VtZW50YXRpb24gYW5kIGFkdmFuY2VkIHVzYWdlLCByZWZlciB0byB0aGVcblx0KiBbaWNlYmVyZy1qcyBkb2N1bWVudGF0aW9uXShodHRwczovL3N1cGFiYXNlLmdpdGh1Yi5pby9pY2ViZXJnLWpzLykuXG5cdCovXG5cdGZyb20oYnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdGlmICghaXNWYWxpZEJ1Y2tldE5hbWUoYnVja2V0TmFtZSkpIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXCJJbnZhbGlkIGJ1Y2tldCBuYW1lOiBGaWxlLCBmb2xkZXIsIGFuZCBidWNrZXQgbmFtZXMgbXVzdCBmb2xsb3cgQVdTIG9iamVjdCBrZXkgbmFtaW5nIGd1aWRlbGluZXMgYW5kIHNob3VsZCBhdm9pZCB0aGUgdXNlIG9mIGFueSBvdGhlciBjaGFyYWN0ZXJzLlwiKTtcblx0XHRjb25zdCBjYXRhbG9nID0gbmV3IGljZWJlcmdfanMuSWNlYmVyZ1Jlc3RDYXRhbG9nKHtcblx0XHRcdGJhc2VVcmw6IHRoaXMudXJsLFxuXHRcdFx0Y2F0YWxvZ05hbWU6IGJ1Y2tldE5hbWUsXG5cdFx0XHRhdXRoOiB7XG5cdFx0XHRcdHR5cGU6IFwiY3VzdG9tXCIsXG5cdFx0XHRcdGdldEhlYWRlcnM6IGFzeW5jICgpID0+IF90aGlzNC5oZWFkZXJzXG5cdFx0XHR9LFxuXHRcdFx0ZmV0Y2g6IHRoaXMuZmV0Y2hcblx0XHR9KTtcblx0XHRjb25zdCBzaG91bGRUaHJvd09uRXJyb3IgPSB0aGlzLnNob3VsZFRocm93T25FcnJvcjtcblx0XHRyZXR1cm4gbmV3IFByb3h5KGNhdGFsb2csIHsgZ2V0KHRhcmdldCwgcHJvcCkge1xuXHRcdFx0Y29uc3QgdmFsdWUgPSB0YXJnZXRbcHJvcF07XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiB2YWx1ZTtcblx0XHRcdHJldHVybiBhc3luYyAoLi4uYXJncykgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRkYXRhOiBhd2FpdCB2YWx1ZS5hcHBseSh0YXJnZXQsIGFyZ3MpLFxuXHRcdFx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGlmIChzaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRcdFx0ZXJyb3Jcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0gfSk7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9jb25zdGFudHMudHNcbmNvbnN0IERFRkFVTFRfSEVBREVSUyA9IHtcblx0XCJYLUNsaWVudC1JbmZvXCI6IGBzdG9yYWdlLWpzLyR7dmVyc2lvbn1gLFxuXHRcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi92ZWN0b3JzL2Vycm9ycy50c1xuLyoqXG4qIEJhc2UgZXJyb3IgY2xhc3MgZm9yIGFsbCBTdG9yYWdlIFZlY3RvcnMgZXJyb3JzXG4qL1xudmFyIFN0b3JhZ2VWZWN0b3JzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSkge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMuX19pc1N0b3JhZ2VWZWN0b3JzRXJyb3IgPSB0cnVlO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZVZlY3RvcnNFcnJvclwiO1xuXHR9XG59O1xuLyoqXG4qIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYW4gZXJyb3IgaXMgYSBTdG9yYWdlVmVjdG9yc0Vycm9yXG4qIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVja1xuKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBlcnJvciBpcyBhIFN0b3JhZ2VWZWN0b3JzRXJyb3JcbiovXG5mdW5jdGlvbiBpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpIHtcblx0cmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBlcnJvciAhPT0gbnVsbCAmJiBcIl9faXNTdG9yYWdlVmVjdG9yc0Vycm9yXCIgaW4gZXJyb3I7XG59XG4vKipcbiogQVBJIGVycm9yIHJldHVybmVkIGZyb20gUzMgVmVjdG9ycyBzZXJ2aWNlXG4qIEluY2x1ZGVzIEhUVFAgc3RhdHVzIGNvZGUgYW5kIHNlcnZpY2Utc3BlY2lmaWMgZXJyb3IgY29kZVxuKi9cbnZhciBTdG9yYWdlVmVjdG9yc0FwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBTdG9yYWdlVmVjdG9yc0Vycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBzdGF0dXNDb2RlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gXCJTdG9yYWdlVmVjdG9yc0FwaUVycm9yXCI7XG5cdFx0dGhpcy5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0dGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcblx0fVxuXHR0b0pTT04oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG5hbWU6IHRoaXMubmFtZSxcblx0XHRcdG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcblx0XHRcdHN0YXR1czogdGhpcy5zdGF0dXMsXG5cdFx0XHRzdGF0dXNDb2RlOiB0aGlzLnN0YXR1c0NvZGVcblx0XHR9O1xuXHR9XG59O1xuLyoqXG4qIFVua25vd24gZXJyb3IgdGhhdCBkb2Vzbid0IG1hdGNoIGV4cGVjdGVkIGVycm9yIHBhdHRlcm5zXG4qIFdyYXBzIHRoZSBvcmlnaW5hbCBlcnJvciBmb3IgZGVidWdnaW5nXG4qL1xudmFyIFN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yID0gY2xhc3MgZXh0ZW5kcyBTdG9yYWdlVmVjdG9yc0Vycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZVZlY3RvcnNVbmtub3duRXJyb3JcIjtcblx0XHR0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuXHR9XG59O1xuLyoqXG4qIEVycm9yIGNvZGVzIHNwZWNpZmljIHRvIFMzIFZlY3RvcnMgQVBJXG4qIE1hcHMgQVdTIHNlcnZpY2UgZXJyb3JzIHRvIGFwcGxpY2F0aW9uLWZyaWVuZGx5IGVycm9yIGNvZGVzXG4qL1xubGV0IFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDEpIHtcblx0LyoqIEludGVybmFsIHNlcnZlciBmYXVsdCAoSFRUUCA1MDApICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJJbnRlcm5hbEVycm9yXCJdID0gXCJJbnRlcm5hbEVycm9yXCI7XG5cdC8qKiBSZXNvdXJjZSBhbHJlYWR5IGV4aXN0cyAvIGNvbmZsaWN0IChIVFRQIDQwOSkgKi9cblx0U3RvcmFnZVZlY3RvcnNFcnJvckNvZGUkMVtcIlMzVmVjdG9yQ29uZmxpY3RFeGNlcHRpb25cIl0gPSBcIlMzVmVjdG9yQ29uZmxpY3RFeGNlcHRpb25cIjtcblx0LyoqIFJlc291cmNlIG5vdCBmb3VuZCAoSFRUUCA0MDQpICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJTM1ZlY3Rvck5vdEZvdW5kRXhjZXB0aW9uXCJdID0gXCJTM1ZlY3Rvck5vdEZvdW5kRXhjZXB0aW9uXCI7XG5cdC8qKiBEZWxldGUgYnVja2V0IHdoaWxlIG5vdCBlbXB0eSAoSFRUUCA0MDApICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJTM1ZlY3RvckJ1Y2tldE5vdEVtcHR5XCJdID0gXCJTM1ZlY3RvckJ1Y2tldE5vdEVtcHR5XCI7XG5cdC8qKiBFeGNlZWRzIGJ1Y2tldCBxdW90YS9saW1pdCAoSFRUUCA0MDApICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJTM1ZlY3Rvck1heEJ1Y2tldHNFeGNlZWRlZFwiXSA9IFwiUzNWZWN0b3JNYXhCdWNrZXRzRXhjZWVkZWRcIjtcblx0LyoqIEV4Y2VlZHMgaW5kZXggcXVvdGEvbGltaXQgKEhUVFAgNDAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JNYXhJbmRleGVzRXhjZWVkZWRcIl0gPSBcIlMzVmVjdG9yTWF4SW5kZXhlc0V4Y2VlZGVkXCI7XG5cdHJldHVybiBTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxO1xufSh7fSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9oZWxwZXJzLnRzXG4vKipcbiogUmVzb2x2ZXMgdGhlIGZldGNoIGltcGxlbWVudGF0aW9uIHRvIHVzZVxuKiBVc2VzIGN1c3RvbSBmZXRjaCBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIHVzZXMgbmF0aXZlIGZldGNoXG4qXG4qIEBwYXJhbSBjdXN0b21GZXRjaCAtIE9wdGlvbmFsIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvblxuKiBAcmV0dXJucyBSZXNvbHZlZCBmZXRjaCBmdW5jdGlvblxuKi9cbmNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuXHRpZiAoY3VzdG9tRmV0Y2gpIHJldHVybiAoLi4uYXJncykgPT4gY3VzdG9tRmV0Y2goLi4uYXJncyk7XG5cdHJldHVybiAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncyk7XG59O1xuLyoqXG4qIFJlc29sdmVzIHRoZSBSZXNwb25zZSBjb25zdHJ1Y3RvciB0byB1c2VcbiogUmV0dXJucyBuYXRpdmUgUmVzcG9uc2UgY29uc3RydWN0b3JcbipcbiogQHJldHVybnMgUmVzcG9uc2UgY29uc3RydWN0b3JcbiovXG5jb25zdCByZXNvbHZlUmVzcG9uc2UgPSAoKSA9PiB7XG5cdHJldHVybiBSZXNwb25zZTtcbn07XG4vKipcbiogRGV0ZXJtaW5lIGlmIGlucHV0IGlzIGEgcGxhaW4gb2JqZWN0XG4qIEFuIG9iamVjdCBpcyBwbGFpbiBpZiBpdCdzIGNyZWF0ZWQgYnkgZWl0aGVyIHt9LCBuZXcgT2JqZWN0KCksIG9yIE9iamVjdC5jcmVhdGUobnVsbClcbipcbiogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2tcbiogQHJldHVybnMgVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdFxuKiBAc291cmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvaXMtcGxhaW4tb2JqXG4qL1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWx1ZSkgPT4ge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG5cdHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKTtcbn07XG4vKipcbiogTm9ybWFsaXplcyBhIG51bWJlciBhcnJheSB0byBmbG9hdDMyIGZvcm1hdFxuKiBFbnN1cmVzIGFsbCB2ZWN0b3IgdmFsdWVzIGFyZSB2YWxpZCAzMi1iaXQgZmxvYXRzXG4qXG4qIEBwYXJhbSB2YWx1ZXMgLSBBcnJheSBvZiBudW1iZXJzIHRvIG5vcm1hbGl6ZVxuKiBAcmV0dXJucyBOb3JtYWxpemVkIGZsb2F0MzIgYXJyYXlcbiovXG5jb25zdCBub3JtYWxpemVUb0Zsb2F0MzIgPSAodmFsdWVzKSA9PiB7XG5cdHJldHVybiBBcnJheS5mcm9tKG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzKSk7XG59O1xuLyoqXG4qIFZhbGlkYXRlcyB2ZWN0b3IgZGltZW5zaW9ucyBtYXRjaCBleHBlY3RlZCBkaW1lbnNpb25cbiogVGhyb3dzIGVycm9yIGlmIGRpbWVuc2lvbnMgZG9uJ3QgbWF0Y2hcbipcbiogQHBhcmFtIHZlY3RvciAtIFZlY3RvciBkYXRhIHRvIHZhbGlkYXRlXG4qIEBwYXJhbSBleHBlY3RlZERpbWVuc2lvbiAtIEV4cGVjdGVkIHZlY3RvciBkaW1lbnNpb25cbiogQHRocm93cyBFcnJvciBpZiBkaW1lbnNpb25zIGRvbid0IG1hdGNoXG4qL1xuY29uc3QgdmFsaWRhdGVWZWN0b3JEaW1lbnNpb24gPSAodmVjdG9yLCBleHBlY3RlZERpbWVuc2lvbikgPT4ge1xuXHRpZiAoZXhwZWN0ZWREaW1lbnNpb24gIT09IHZvaWQgMCAmJiB2ZWN0b3IuZmxvYXQzMi5sZW5ndGggIT09IGV4cGVjdGVkRGltZW5zaW9uKSB0aHJvdyBuZXcgRXJyb3IoYFZlY3RvciBkaW1lbnNpb24gbWlzbWF0Y2g6IGV4cGVjdGVkICR7ZXhwZWN0ZWREaW1lbnNpb259LCBnb3QgJHt2ZWN0b3IuZmxvYXQzMi5sZW5ndGh9YCk7XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlY3RvcnMvZmV0Y2gudHNcbi8qKlxuKiBFeHRyYWN0cyBlcnJvciBtZXNzYWdlIGZyb20gdmFyaW91cyBlcnJvciByZXNwb25zZSBmb3JtYXRzXG4qIEBwYXJhbSBlcnIgLSBFcnJvciBvYmplY3QgZnJvbSBBUElcbiogQHJldHVybnMgSHVtYW4tcmVhZGFibGUgZXJyb3IgbWVzc2FnZVxuKi9cbmNvbnN0IF9nZXRFcnJvck1lc3NhZ2UgPSAoZXJyKSA9PiBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCBlcnIuZXJyb3IgfHwgSlNPTi5zdHJpbmdpZnkoZXJyKTtcbi8qKlxuKiBIYW5kbGVzIGZldGNoIGVycm9ycyBhbmQgY29udmVydHMgdGhlbSB0byBTdG9yYWdlVmVjdG9ycyBlcnJvciB0eXBlc1xuKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgY2F1Z2h0IGZyb20gZmV0Y2hcbiogQHBhcmFtIHJlamVjdCAtIFByb21pc2UgcmVqZWN0aW9uIGZ1bmN0aW9uXG4qIEBwYXJhbSBvcHRpb25zIC0gRmV0Y2ggb3B0aW9ucyB0aGF0IG1heSBhZmZlY3QgZXJyb3IgaGFuZGxpbmdcbiovXG5jb25zdCBoYW5kbGVFcnJvciA9IGFzeW5jIChlcnJvciwgcmVqZWN0LCBvcHRpb25zKSA9PiB7XG5cdGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJzdGF0dXNcIiBpbiBlcnJvciAmJiBcIm9rXCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLnN0YXR1cyA9PT0gXCJudW1iZXJcIiAmJiAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uKSkge1xuXHRcdGNvbnN0IHN0YXR1cyA9IGVycm9yLnN0YXR1cyB8fCA1MDA7XG5cdFx0Y29uc3QgcmVzcG9uc2VFcnJvciA9IGVycm9yO1xuXHRcdGlmICh0eXBlb2YgcmVzcG9uc2VFcnJvci5qc29uID09PSBcImZ1bmN0aW9uXCIpIHJlc3BvbnNlRXJyb3IuanNvbigpLnRoZW4oKGVycikgPT4ge1xuXHRcdFx0Y29uc3Qgc3RhdHVzQ29kZSA9IChlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIuc3RhdHVzQ29kZSkgfHwgKGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5jb2RlKSB8fCBzdGF0dXMgKyBcIlwiO1xuXHRcdFx0cmVqZWN0KG5ldyBTdG9yYWdlVmVjdG9yc0FwaUVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyKSwgc3RhdHVzLCBzdGF0dXNDb2RlKSk7XG5cdFx0fSkuY2F0Y2goKCkgPT4ge1xuXHRcdFx0Y29uc3Qgc3RhdHVzQ29kZSA9IHN0YXR1cyArIFwiXCI7XG5cdFx0XHRyZWplY3QobmV3IFN0b3JhZ2VWZWN0b3JzQXBpRXJyb3IocmVzcG9uc2VFcnJvci5zdGF0dXNUZXh0IHx8IGBIVFRQICR7c3RhdHVzfSBlcnJvcmAsIHN0YXR1cywgc3RhdHVzQ29kZSkpO1xuXHRcdH0pO1xuXHRcdGVsc2Uge1xuXHRcdFx0Y29uc3Qgc3RhdHVzQ29kZSA9IHN0YXR1cyArIFwiXCI7XG5cdFx0XHRyZWplY3QobmV3IFN0b3JhZ2VWZWN0b3JzQXBpRXJyb3IocmVzcG9uc2VFcnJvci5zdGF0dXNUZXh0IHx8IGBIVFRQICR7c3RhdHVzfSBlcnJvcmAsIHN0YXR1cywgc3RhdHVzQ29kZSkpO1xuXHRcdH1cblx0fSBlbHNlIHJlamVjdChuZXcgU3RvcmFnZVZlY3RvcnNVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yKSk7XG59O1xuLyoqXG4qIEJ1aWxkcyByZXF1ZXN0IHBhcmFtZXRlcnMgZm9yIGZldGNoIGNhbGxzXG4qIEBwYXJhbSBtZXRob2QgLSBIVFRQIG1ldGhvZFxuKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4qIEBwYXJhbSBwYXJhbWV0ZXJzIC0gQWRkaXRpb25hbCBmZXRjaCBwYXJhbWV0ZXJzIGxpa2UgQWJvcnRTaWduYWxcbiogQHBhcmFtIGJvZHkgLSBSZXF1ZXN0IGJvZHkgKHdpbGwgYmUgSlNPTiBzdHJpbmdpZmllZCBpZiBwbGFpbiBvYmplY3QpXG4qIEByZXR1cm5zIENvbXBsZXRlIGZldGNoIHJlcXVlc3QgcGFyYW1ldGVyc1xuKi9cbmNvbnN0IF9nZXRSZXF1ZXN0UGFyYW1zID0gKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkgPT4ge1xuXHRjb25zdCBwYXJhbXMgPSB7XG5cdFx0bWV0aG9kLFxuXHRcdGhlYWRlcnM6IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycykgfHwge31cblx0fTtcblx0aWYgKG1ldGhvZCA9PT0gXCJHRVRcIiB8fCAhYm9keSkgcmV0dXJuIHBhcmFtcztcblx0aWYgKGlzUGxhaW5PYmplY3QoYm9keSkpIHtcblx0XHRwYXJhbXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuXHRcdHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG5cdH0gZWxzZSBwYXJhbXMuYm9keSA9IGJvZHk7XG5cdHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcGFyYW1zKSwgcGFyYW1ldGVycyk7XG59O1xuLyoqXG4qIEludGVybmFsIHJlcXVlc3QgaGFuZGxlciB0aGF0IHdyYXBzIGZldGNoIHdpdGggZXJyb3IgaGFuZGxpbmdcbiogQHBhcmFtIGZldGNoZXIgLSBGZXRjaCBmdW5jdGlvbiB0byB1c2VcbiogQHBhcmFtIG1ldGhvZCAtIEhUVFAgbWV0aG9kXG4qIEBwYXJhbSB1cmwgLSBSZXF1ZXN0IFVSTFxuKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4qIEBwYXJhbSBwYXJhbWV0ZXJzIC0gQWRkaXRpb25hbCBmZXRjaCBwYXJhbWV0ZXJzXG4qIEBwYXJhbSBib2R5IC0gUmVxdWVzdCBib2R5XG4qIEByZXR1cm5zIFByb21pc2Ugd2l0aCBwYXJzZWQgcmVzcG9uc2Ugb3IgZXJyb3JcbiovXG5hc3luYyBmdW5jdGlvbiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGZldGNoZXIodXJsLCBfZ2V0UmVxdWVzdFBhcmFtcyhtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpKS50aGVuKChyZXN1bHQpID0+IHtcblx0XHRcdGlmICghcmVzdWx0Lm9rKSB0aHJvdyByZXN1bHQ7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vUmVzb2x2ZUpzb24pIHJldHVybiByZXN1bHQ7XG5cdFx0XHRjb25zdCBjb250ZW50VHlwZSA9IHJlc3VsdC5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcblx0XHRcdGlmICghY29udGVudFR5cGUgfHwgIWNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkgcmV0dXJuIHt9O1xuXHRcdFx0cmV0dXJuIHJlc3VsdC5qc29uKCk7XG5cdFx0fSkudGhlbigoZGF0YSkgPT4gcmVzb2x2ZShkYXRhKSkuY2F0Y2goKGVycm9yKSA9PiBoYW5kbGVFcnJvcihlcnJvciwgcmVqZWN0LCBvcHRpb25zKSk7XG5cdH0pO1xufVxuLyoqXG4qIFBlcmZvcm1zIGEgUE9TVCByZXF1ZXN0XG4qIEBwYXJhbSBmZXRjaGVyIC0gRmV0Y2ggZnVuY3Rpb24gdG8gdXNlXG4qIEBwYXJhbSB1cmwgLSBSZXF1ZXN0IFVSTFxuKiBAcGFyYW0gYm9keSAtIFJlcXVlc3QgYm9keSB0byBiZSBKU09OIHN0cmluZ2lmaWVkXG4qIEBwYXJhbSBvcHRpb25zIC0gQ3VzdG9tIGZldGNoIG9wdGlvbnNcbiogQHBhcmFtIHBhcmFtZXRlcnMgLSBBZGRpdGlvbmFsIGZldGNoIHBhcmFtZXRlcnNcbiogQHJldHVybnMgUHJvbWlzZSB3aXRoIHBhcnNlZCByZXNwb25zZVxuKi9cbmFzeW5jIGZ1bmN0aW9uIHBvc3QoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBcIlBPU1RcIiwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi92ZWN0b3JzL1ZlY3RvckluZGV4QXBpLnRzXG4vKipcbiogQGhpZGRlblxuKiBCYXNlIGltcGxlbWVudGF0aW9uIGZvciB2ZWN0b3IgaW5kZXggb3BlcmF0aW9ucy5cbiogVXNlIHtAbGluayBWZWN0b3JCdWNrZXRTY29wZX0gdmlhIGBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnYnVja2V0JylgIGluc3RlYWQuXG4qL1xudmFyIFZlY3RvckluZGV4QXBpID0gY2xhc3Mge1xuXHQvKiogQ3JlYXRlcyBhIG5ldyBWZWN0b3JJbmRleEFwaSBpbnN0YW5jZSAqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG5cdFx0dGhpcy51cmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXHRcdHRoaXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoJDEpO1xuXHR9XG5cdC8qKiBFbmFibGUgdGhyb3dpbmcgZXJyb3JzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0gaW4gdGhlIHJlc3BvbnNlICovXG5cdHRocm93T25FcnJvcigpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGluZGV4IHdpdGhpbiBhIGJ1Y2tldCAqL1xuXHRhc3luYyBjcmVhdGVJbmRleChvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpcy5mZXRjaCwgYCR7X3RoaXMudXJsfS9DcmVhdGVJbmRleGAsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMuaGVhZGVycyB9KSB8fCB7fSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBSZXRyaWV2ZXMgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgdmVjdG9yIGluZGV4ICovXG5cdGFzeW5jIGdldEluZGV4KHZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSkge1xuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzMi5mZXRjaCwgYCR7X3RoaXMyLnVybH0vR2V0SW5kZXhgLCB7XG5cdFx0XHRcdFx0dmVjdG9yQnVja2V0TmFtZSxcblx0XHRcdFx0XHRpbmRleE5hbWVcblx0XHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczIuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczIuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogTGlzdHMgdmVjdG9yIGluZGV4ZXMgd2l0aGluIGEgYnVja2V0IHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uICovXG5cdGFzeW5jIGxpc3RJbmRleGVzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczMuZmV0Y2gsIGAke190aGlzMy51cmx9L0xpc3RJbmRleGVzYCwgb3B0aW9ucywgeyBoZWFkZXJzOiBfdGhpczMuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogRGVsZXRlcyBhIHZlY3RvciBpbmRleCBhbmQgYWxsIGl0cyBkYXRhICovXG5cdGFzeW5jIGRlbGV0ZUluZGV4KHZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSkge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vRGVsZXRlSW5kZXhgLCB7XG5cdFx0XHRcdFx0dmVjdG9yQnVja2V0TmFtZSxcblx0XHRcdFx0XHRpbmRleE5hbWVcblx0XHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczQuaGVhZGVycyB9KSB8fCB7fSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczQuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi92ZWN0b3JzL1ZlY3RvckRhdGFBcGkudHNcbi8qKlxuKiBAaGlkZGVuXG4qIEJhc2UgaW1wbGVtZW50YXRpb24gZm9yIHZlY3RvciBkYXRhIG9wZXJhdGlvbnMuXG4qIFVzZSB7QGxpbmsgVmVjdG9ySW5kZXhTY29wZX0gdmlhIGBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnYnVja2V0JykuaW5kZXgoJ2lkeCcpYCBpbnN0ZWFkLlxuKi9cbnZhciBWZWN0b3JEYXRhQXBpID0gY2xhc3Mge1xuXHQvKiogQ3JlYXRlcyBhIG5ldyBWZWN0b3JEYXRhQXBpIGluc3RhbmNlICovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHR0aGlzLnVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cdFx0dGhpcy5oZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfSEVBREVSUyksIGhlYWRlcnMpO1xuXHRcdHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gkMSk7XG5cdH1cblx0LyoqIEVuYWJsZSB0aHJvd2luZyBlcnJvcnMgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlbSBpbiB0aGUgcmVzcG9uc2UgKi9cblx0dGhyb3dPbkVycm9yKCkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKiogSW5zZXJ0cyBvciB1cGRhdGVzIHZlY3RvcnMgaW4gYmF0Y2ggKDEtNTAwIHBlciByZXF1ZXN0KSAqL1xuXHRhc3luYyBwdXRWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAob3B0aW9ucy52ZWN0b3JzLmxlbmd0aCA8IDEgfHwgb3B0aW9ucy52ZWN0b3JzLmxlbmd0aCA+IDUwMCkgdGhyb3cgbmV3IEVycm9yKFwiVmVjdG9yIGJhdGNoIHNpemUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDUwMCBpdGVtc1wiKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vUHV0VmVjdG9yc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMuaGVhZGVycyB9KSB8fCB7fSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBSZXRyaWV2ZXMgdmVjdG9ycyBieSB0aGVpciBrZXlzIGluIGJhdGNoICovXG5cdGFzeW5jIGdldFZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzMi5mZXRjaCwgYCR7X3RoaXMyLnVybH0vR2V0VmVjdG9yc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMyLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIExpc3RzIHZlY3RvcnMgaW4gYW4gaW5kZXggd2l0aCBwYWdpbmF0aW9uICovXG5cdGFzeW5jIGxpc3RWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0aWYgKG9wdGlvbnMuc2VnbWVudENvdW50ICE9PSB2b2lkIDApIHtcblx0XHRcdFx0aWYgKG9wdGlvbnMuc2VnbWVudENvdW50IDwgMSB8fCBvcHRpb25zLnNlZ21lbnRDb3VudCA+IDE2KSB0aHJvdyBuZXcgRXJyb3IoXCJzZWdtZW50Q291bnQgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDE2XCIpO1xuXHRcdFx0XHRpZiAob3B0aW9ucy5zZWdtZW50SW5kZXggIT09IHZvaWQgMCkge1xuXHRcdFx0XHRcdGlmIChvcHRpb25zLnNlZ21lbnRJbmRleCA8IDAgfHwgb3B0aW9ucy5zZWdtZW50SW5kZXggPj0gb3B0aW9ucy5zZWdtZW50Q291bnQpIHRocm93IG5ldyBFcnJvcihgc2VnbWVudEluZGV4IG11c3QgYmUgYmV0d2VlbiAwIGFuZCAke29wdGlvbnMuc2VnbWVudENvdW50IC0gMX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczMuZmV0Y2gsIGAke190aGlzMy51cmx9L0xpc3RWZWN0b3JzYCwgb3B0aW9ucywgeyBoZWFkZXJzOiBfdGhpczMuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogUXVlcmllcyBmb3Igc2ltaWxhciB2ZWN0b3JzIHVzaW5nIGFwcHJveGltYXRlIG5lYXJlc3QgbmVpZ2hib3Igc2VhcmNoICovXG5cdGFzeW5jIHF1ZXJ5VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNCA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXM0LmZldGNoLCBgJHtfdGhpczQudXJsfS9RdWVyeVZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzNC5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBEZWxldGVzIHZlY3RvcnMgYnkgdGhlaXIga2V5cyBpbiBiYXRjaCAoMS01MDAgcGVyIHJlcXVlc3QpICovXG5cdGFzeW5jIGRlbGV0ZVZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpczUgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAob3B0aW9ucy5rZXlzLmxlbmd0aCA8IDEgfHwgb3B0aW9ucy5rZXlzLmxlbmd0aCA+IDUwMCkgdGhyb3cgbmV3IEVycm9yKFwiS2V5cyBiYXRjaCBzaXplIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA1MDAgaXRlbXNcIik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzNS5mZXRjaCwgYCR7X3RoaXM1LnVybH0vRGVsZXRlVmVjdG9yc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXM1LmhlYWRlcnMgfSkgfHwge30sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM1LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9WZWN0b3JCdWNrZXRBcGkudHNcbi8qKlxuKiBAaGlkZGVuXG4qIEJhc2UgaW1wbGVtZW50YXRpb24gZm9yIHZlY3RvciBidWNrZXQgb3BlcmF0aW9ucy5cbiogVXNlIHtAbGluayBTdG9yYWdlVmVjdG9yc0NsaWVudH0gdmlhIGBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnNgIGluc3RlYWQuXG4qL1xudmFyIFZlY3RvckJ1Y2tldEFwaSA9IGNsYXNzIHtcblx0LyoqIENyZWF0ZXMgYSBuZXcgVmVjdG9yQnVja2V0QXBpIGluc3RhbmNlICovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHR0aGlzLnVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cdFx0dGhpcy5oZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfSEVBREVSUyksIGhlYWRlcnMpO1xuXHRcdHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gkMSk7XG5cdH1cblx0LyoqIEVuYWJsZSB0aHJvd2luZyBlcnJvcnMgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlbSBpbiB0aGUgcmVzcG9uc2UgKi9cblx0dGhyb3dPbkVycm9yKCkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKiogQ3JlYXRlcyBhIG5ldyB2ZWN0b3IgYnVja2V0ICovXG5cdGFzeW5jIGNyZWF0ZUJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpcy5mZXRjaCwgYCR7X3RoaXMudXJsfS9DcmVhdGVWZWN0b3JCdWNrZXRgLCB7IHZlY3RvckJ1Y2tldE5hbWUgfSwgeyBoZWFkZXJzOiBfdGhpcy5oZWFkZXJzIH0pIHx8IHt9LFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIFJldHJpZXZlcyBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyB2ZWN0b3IgYnVja2V0ICovXG5cdGFzeW5jIGdldEJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMyLmZldGNoLCBgJHtfdGhpczIudXJsfS9HZXRWZWN0b3JCdWNrZXRgLCB7IHZlY3RvckJ1Y2tldE5hbWUgfSwgeyBoZWFkZXJzOiBfdGhpczIuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczIuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogTGlzdHMgdmVjdG9yIGJ1Y2tldHMgd2l0aCBvcHRpb25hbCBmaWx0ZXJpbmcgYW5kIHBhZ2luYXRpb24gKi9cblx0YXN5bmMgbGlzdEJ1Y2tldHMob3B0aW9ucyA9IHt9KSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMzLmZldGNoLCBgJHtfdGhpczMudXJsfS9MaXN0VmVjdG9yQnVja2V0c2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMzLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIERlbGV0ZXMgYSB2ZWN0b3IgYnVja2V0IChtdXN0IGJlIGVtcHR5IGZpcnN0KSAqL1xuXHRhc3luYyBkZWxldGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vRGVsZXRlVmVjdG9yQnVja2V0YCwgeyB2ZWN0b3JCdWNrZXROYW1lIH0sIHsgaGVhZGVyczogX3RoaXM0LmhlYWRlcnMgfSkgfHwge30sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM0LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9TdG9yYWdlVmVjdG9yc0NsaWVudC50c1xuLyoqXG4qXG4qIEBhbHBoYVxuKlxuKiBNYWluIGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBTMyBWZWN0b3JzIEFQSVxuKiBQcm92aWRlcyBhY2Nlc3MgdG8gYnVja2V0LCBpbmRleCwgYW5kIHZlY3RvciBkYXRhIG9wZXJhdGlvbnNcbipcbiogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbipcbiogKipVc2FnZSBQYXR0ZXJuczoqKlxuKlxuKiBgYGB0eXBlc2NyaXB0XG4qIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4qICAuc3RvcmFnZVxuKiAgLnZlY3RvcnNcbiogIC5jcmVhdGVCdWNrZXQoJ2VtYmVkZGluZ3MtcHJvZCcpXG4qXG4qIC8vIEFjY2VzcyBpbmRleCBvcGVyYXRpb25zIHZpYSBidWNrZXRzXG4qIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuKiBhd2FpdCBidWNrZXQuY3JlYXRlSW5kZXgoe1xuKiAgIGluZGV4TmFtZTogJ2RvY3VtZW50cycsXG4qICAgZGF0YVR5cGU6ICdmbG9hdDMyJyxcbiogICBkaW1lbnNpb246IDE1MzYsXG4qICAgZGlzdGFuY2VNZXRyaWM6ICdjb3NpbmUnXG4qIH0pXG4qXG4qIC8vIEFjY2VzcyB2ZWN0b3Igb3BlcmF0aW9ucyB2aWEgaW5kZXhcbiogY29uc3QgaW5kZXggPSBidWNrZXQuaW5kZXgoJ2RvY3VtZW50cycpXG4qIGF3YWl0IGluZGV4LnB1dFZlY3RvcnMoe1xuKiAgIHZlY3RvcnM6IFtcbiogICAgIHsga2V5OiAnZG9jLTEnLCBkYXRhOiB7IGZsb2F0MzI6IFsuLi5dIH0sIG1ldGFkYXRhOiB7IHRpdGxlOiAnSW50cm8nIH0gfVxuKiAgIF1cbiogfSlcbipcbiogLy8gUXVlcnkgc2ltaWxhciB2ZWN0b3JzXG4qIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXgucXVlcnlWZWN0b3JzKHtcbiogICBxdWVyeVZlY3RvcjogeyBmbG9hdDMyOiBbLi4uXSB9LFxuKiAgIHRvcEs6IDUsXG4qICAgcmV0dXJuRGlzdGFuY2U6IHRydWVcbiogfSlcbiogYGBgXG4qL1xudmFyIFN0b3JhZ2VWZWN0b3JzQ2xpZW50ID0gY2xhc3MgZXh0ZW5kcyBWZWN0b3JCdWNrZXRBcGkge1xuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBTdG9yYWdlVmVjdG9yc0NsaWVudCB0aGF0IGNhbiBtYW5hZ2UgYnVja2V0cywgaW5kZXhlcywgYW5kIHZlY3RvcnMuXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIHVybCAtIEJhc2UgVVJMIG9mIHRoZSBTdG9yYWdlIFZlY3RvcnMgUkVTVCBBUEkuXG5cdCogQHBhcmFtIG9wdGlvbnMuaGVhZGVycyAtIE9wdGlvbmFsIGhlYWRlcnMgKGZvciBleGFtcGxlIGBBdXRob3JpemF0aW9uYCkgYXBwbGllZCB0byBldmVyeSByZXF1ZXN0LlxuXHQqIEBwYXJhbSBvcHRpb25zLmZldGNoIC0gT3B0aW9uYWwgY3VzdG9tIGBmZXRjaGAgaW1wbGVtZW50YXRpb24gZm9yIG5vbi1icm93c2VyIHJ1bnRpbWVzLlxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgY2xpZW50ID0gbmV3IFN0b3JhZ2VWZWN0b3JzQ2xpZW50KHVybCwgb3B0aW9ucylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCBvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcih1cmwsIG9wdGlvbnMuaGVhZGVycyB8fCB7fSwgb3B0aW9ucy5mZXRjaCk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIEFjY2VzcyBvcGVyYXRpb25zIGZvciBhIHNwZWNpZmljIHZlY3RvciBidWNrZXRcblx0KiBSZXR1cm5zIGEgc2NvcGVkIGNsaWVudCBmb3IgaW5kZXggYW5kIHZlY3RvciBvcGVyYXRpb25zIHdpdGhpbiB0aGUgYnVja2V0XG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIHZlY3RvckJ1Y2tldE5hbWUgLSBOYW1lIG9mIHRoZSB2ZWN0b3IgYnVja2V0XG5cdCogQHJldHVybnMgQnVja2V0LXNjb3BlZCBjbGllbnQgd2l0aCBpbmRleCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGBgYFxuXHQqL1xuXHRmcm9tKHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHRyZXR1cm4gbmV3IFZlY3RvckJ1Y2tldFNjb3BlKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMsIHZlY3RvckJ1Y2tldE5hbWUsIHRoaXMuZmV0Y2gpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgbmV3IHZlY3RvciBidWNrZXRcblx0KiBWZWN0b3IgYnVja2V0cyBhcmUgY29udGFpbmVycyBmb3IgdmVjdG9yIGluZGV4ZXMgYW5kIHRoZWlyIGRhdGFcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gdmVjdG9yQnVja2V0TmFtZSAtIFVuaXF1ZSBuYW1lIGZvciB0aGUgdmVjdG9yIGJ1Y2tldFxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC52ZWN0b3JzXG5cdCogICAuY3JlYXRlQnVja2V0KCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjcmVhdGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldENyZWF0ZUJ1Y2tldCA9ICgpID0+IHN1cGVyLmNyZWF0ZUJ1Y2tldCwgX3RoaXMgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldENyZWF0ZUJ1Y2tldCgpLmNhbGwoX3RoaXMsIHZlY3RvckJ1Y2tldE5hbWUpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBSZXRyaWV2ZXMgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgdmVjdG9yIGJ1Y2tldFxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSB2ZWN0b3JCdWNrZXROYW1lIC0gTmFtZSBvZiB0aGUgdmVjdG9yIGJ1Y2tldFxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBidWNrZXQgbWV0YWRhdGEgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLnZlY3RvcnNcblx0KiAgIC5nZXRCdWNrZXQoJ2VtYmVkZGluZ3MtcHJvZCcpXG5cdCpcblx0KiBjb25zb2xlLmxvZygnQnVja2V0IGNyZWF0ZWQ6JywgZGF0YT8udmVjdG9yQnVja2V0LmNyZWF0aW9uVGltZSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZ2V0QnVja2V0KHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRHZXRCdWNrZXQgPSAoKSA9PiBzdXBlci5nZXRCdWNrZXQsIF90aGlzMiA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0R2V0QnVja2V0KCkuY2FsbChfdGhpczIsIHZlY3RvckJ1Y2tldE5hbWUpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBMaXN0cyBhbGwgdmVjdG9yIGJ1Y2tldHMgd2l0aCBvcHRpb25hbCBmaWx0ZXJpbmcgYW5kIHBhZ2luYXRpb25cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIGZpbHRlcnMgKHByZWZpeCwgbWF4UmVzdWx0cywgbmV4dFRva2VuKVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBsaXN0IG9mIGJ1Y2tldHMgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLnZlY3RvcnNcblx0KiAgIC5saXN0QnVja2V0cyh7IHByZWZpeDogJ2VtYmVkZGluZ3MtJyB9KVxuXHQqXG5cdCogZGF0YT8udmVjdG9yQnVja2V0cy5mb3JFYWNoKGJ1Y2tldCA9PiB7XG5cdCogICBjb25zb2xlLmxvZyhidWNrZXQudmVjdG9yQnVja2V0TmFtZSlcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0QnVja2V0cyhvcHRpb25zID0ge30pIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRMaXN0QnVja2V0cyA9ICgpID0+IHN1cGVyLmxpc3RCdWNrZXRzLCBfdGhpczMgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldExpc3RCdWNrZXRzKCkuY2FsbChfdGhpczMsIG9wdGlvbnMpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBEZWxldGVzIGEgdmVjdG9yIGJ1Y2tldCAoYnVja2V0IG11c3QgYmUgZW1wdHkpXG5cdCogQWxsIGluZGV4ZXMgbXVzdCBiZSBkZWxldGVkIGJlZm9yZSBkZWxldGluZyB0aGUgYnVja2V0XG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIHZlY3RvckJ1Y2tldE5hbWUgLSBOYW1lIG9mIHRoZSB2ZWN0b3IgYnVja2V0IHRvIGRlbGV0ZVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC52ZWN0b3JzXG5cdCogICAuZGVsZXRlQnVja2V0KCdlbWJlZGRpbmdzLW9sZCcpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGRlbGV0ZUJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0RGVsZXRlQnVja2V0ID0gKCkgPT4gc3VwZXIuZGVsZXRlQnVja2V0LCBfdGhpczQgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldERlbGV0ZUJ1Y2tldCgpLmNhbGwoX3RoaXM0LCB2ZWN0b3JCdWNrZXROYW1lKTtcblx0fVxufTtcbi8qKlxuKlxuKiBAYWxwaGFcbipcbiogU2NvcGVkIGNsaWVudCBmb3Igb3BlcmF0aW9ucyB3aXRoaW4gYSBzcGVjaWZpYyB2ZWN0b3IgYnVja2V0XG4qIFByb3ZpZGVzIGluZGV4IG1hbmFnZW1lbnQgYW5kIGFjY2VzcyB0byB2ZWN0b3Igb3BlcmF0aW9uc1xuKlxuKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuKi9cbnZhciBWZWN0b3JCdWNrZXRTY29wZSA9IGNsYXNzIGV4dGVuZHMgVmVjdG9ySW5kZXhBcGkge1xuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBoZWxwZXIgdGhhdCBhdXRvbWF0aWNhbGx5IHNjb3BlcyBhbGwgaW5kZXggb3BlcmF0aW9ucyB0byB0aGUgcHJvdmlkZWQgYnVja2V0LlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMsIHZlY3RvckJ1Y2tldE5hbWUsIGZldGNoJDEpIHtcblx0XHRzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoJDEpO1xuXHRcdHRoaXMudmVjdG9yQnVja2V0TmFtZSA9IHZlY3RvckJ1Y2tldE5hbWU7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGluZGV4IGluIHRoaXMgYnVja2V0XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIEluZGV4IGNvbmZpZ3VyYXRpb24gKHZlY3RvckJ1Y2tldE5hbWUgaXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGF3YWl0IGJ1Y2tldC5jcmVhdGVJbmRleCh7XG5cdCogICBpbmRleE5hbWU6ICdkb2N1bWVudHMtb3BlbmFpJyxcblx0KiAgIGRhdGFUeXBlOiAnZmxvYXQzMicsXG5cdCogICBkaW1lbnNpb246IDE1MzYsXG5cdCogICBkaXN0YW5jZU1ldHJpYzogJ2Nvc2luZScsXG5cdCogICBtZXRhZGF0YUNvbmZpZ3VyYXRpb246IHtcblx0KiAgICAgbm9uRmlsdGVyYWJsZU1ldGFkYXRhS2V5czogWydyYXdfdGV4dCddXG5cdCogICB9XG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY3JlYXRlSW5kZXgob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldENyZWF0ZUluZGV4ID0gKCkgPT4gc3VwZXIuY3JlYXRlSW5kZXgsIF90aGlzNSA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0Q3JlYXRlSW5kZXgoKS5jYWxsKF90aGlzNSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwgeyB2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczUudmVjdG9yQnVja2V0TmFtZSB9KSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIExpc3RzIGluZGV4ZXMgaW4gdGhpcyBidWNrZXRcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIHRoZSBidWNrZXQgbmFtZVxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIC0gTGlzdGluZyBvcHRpb25zICh2ZWN0b3JCdWNrZXROYW1lIGlzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGluZGV4ZXMgYXJyYXkgYW5kIHBhZ2luYXRpb24gdG9rZW4gb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYnVja2V0Lmxpc3RJbmRleGVzKHsgcHJlZml4OiAnZG9jdW1lbnRzLScgfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdEluZGV4ZXMob3B0aW9ucyA9IHt9KSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0TGlzdEluZGV4ZXMgPSAoKSA9PiBzdXBlci5saXN0SW5kZXhlcywgX3RoaXM2ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRMaXN0SW5kZXhlcygpLmNhbGwoX3RoaXM2LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7IHZlY3RvckJ1Y2tldE5hbWU6IF90aGlzNi52ZWN0b3JCdWNrZXROYW1lIH0pKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUmV0cmlldmVzIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIGluZGV4IGluIHRoaXMgYnVja2V0XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXggdG8gcmV0cmlldmVcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggaW5kZXggbWV0YWRhdGEgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYnVja2V0LmdldEluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBjb25zb2xlLmxvZygnRGltZW5zaW9uOicsIGRhdGE/LmluZGV4LmRpbWVuc2lvbilcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZ2V0SW5kZXgoaW5kZXhOYW1lKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0R2V0SW5kZXggPSAoKSA9PiBzdXBlci5nZXRJbmRleCwgX3RoaXM3ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRHZXRJbmRleCgpLmNhbGwoX3RoaXM3LCBfdGhpczcudmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRGVsZXRlcyBhbiBpbmRleCBmcm9tIHRoaXMgYnVja2V0XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXggdG8gZGVsZXRlXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGF3YWl0IGJ1Y2tldC5kZWxldGVJbmRleCgnb2xkLWluZGV4Jylcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZGVsZXRlSW5kZXgoaW5kZXhOYW1lKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0RGVsZXRlSW5kZXggPSAoKSA9PiBzdXBlci5kZWxldGVJbmRleCwgX3RoaXM4ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXREZWxldGVJbmRleCgpLmNhbGwoX3RoaXM4LCBfdGhpczgudmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQWNjZXNzIG9wZXJhdGlvbnMgZm9yIGEgc3BlY2lmaWMgaW5kZXggd2l0aGluIHRoaXMgYnVja2V0XG5cdCogUmV0dXJucyBhIHNjb3BlZCBjbGllbnQgZm9yIHZlY3RvciBkYXRhIG9wZXJhdGlvbnNcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXhcblx0KiBAcmV0dXJucyBJbmRleC1zY29wZWQgY2xpZW50IHdpdGggdmVjdG9yIGRhdGEgb3BlcmF0aW9uc1xuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqXG5cdCogLy8gSW5zZXJ0IHZlY3RvcnNcblx0KiBhd2FpdCBpbmRleC5wdXRWZWN0b3JzKHtcblx0KiAgIHZlY3RvcnM6IFtcblx0KiAgICAgeyBrZXk6ICdkb2MtMScsIGRhdGE6IHsgZmxvYXQzMjogWy4uLl0gfSwgbWV0YWRhdGE6IHsgdGl0bGU6ICdJbnRybycgfSB9XG5cdCogICBdXG5cdCogfSlcblx0KlxuXHQqIC8vIFF1ZXJ5IHNpbWlsYXIgdmVjdG9yc1xuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXgucXVlcnlWZWN0b3JzKHtcblx0KiAgIHF1ZXJ5VmVjdG9yOiB7IGZsb2F0MzI6IFsuLi5dIH0sXG5cdCogICB0b3BLOiA1XG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0aW5kZXgoaW5kZXhOYW1lKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWN0b3JJbmRleFNjb3BlKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMsIHRoaXMudmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lLCB0aGlzLmZldGNoKTtcblx0fVxufTtcbi8qKlxuKlxuKiBAYWxwaGFcbipcbiogU2NvcGVkIGNsaWVudCBmb3Igb3BlcmF0aW9ucyB3aXRoaW4gYSBzcGVjaWZpYyB2ZWN0b3IgaW5kZXhcbiogUHJvdmlkZXMgdmVjdG9yIGRhdGEgb3BlcmF0aW9ucyAocHV0LCBnZXQsIGxpc3QsIHF1ZXJ5LCBkZWxldGUpXG4qXG4qICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4qL1xudmFyIFZlY3RvckluZGV4U2NvcGUgPSBjbGFzcyBleHRlbmRzIFZlY3RvckRhdGFBcGkge1xuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQ3JlYXRlcyBhIGhlbHBlciB0aGF0IGF1dG9tYXRpY2FsbHkgc2NvcGVzIGFsbCB2ZWN0b3Igb3BlcmF0aW9ucyB0byB0aGUgcHJvdmlkZWQgYnVja2V0L2luZGV4IG5hbWVzLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzLCB2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUsIGZldGNoJDEpIHtcblx0XHRzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoJDEpO1xuXHRcdHRoaXMudmVjdG9yQnVja2V0TmFtZSA9IHZlY3RvckJ1Y2tldE5hbWU7XG5cdFx0dGhpcy5pbmRleE5hbWUgPSBpbmRleE5hbWU7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIEluc2VydHMgb3IgdXBkYXRlcyB2ZWN0b3JzIGluIHRoaXMgaW5kZXhcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIFZlY3RvciBpbnNlcnRpb24gb3B0aW9ucyAoYnVja2V0IGFuZCBpbmRleCBuYW1lcyBhdXRvbWF0aWNhbGx5IHNldClcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGF3YWl0IGluZGV4LnB1dFZlY3RvcnMoe1xuXHQqICAgdmVjdG9yczogW1xuXHQqICAgICB7XG5cdCogICAgICAga2V5OiAnZG9jLTEnLFxuXHQqICAgICAgIGRhdGE6IHsgZmxvYXQzMjogWzAuMSwgMC4yLCAuLi5dIH0sXG5cdCogICAgICAgbWV0YWRhdGE6IHsgdGl0bGU6ICdJbnRyb2R1Y3Rpb24nLCBwYWdlOiAxIH1cblx0KiAgICAgfVxuXHQqICAgXVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHB1dFZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldFB1dFZlY3RvcnMgPSAoKSA9PiBzdXBlci5wdXRWZWN0b3JzLCBfdGhpczkgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldFB1dFZlY3RvcnMoKS5jYWxsKF90aGlzOSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXM5LnZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRpbmRleE5hbWU6IF90aGlzOS5pbmRleE5hbWVcblx0XHR9KSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIFJldHJpZXZlcyB2ZWN0b3JzIGJ5IGtleXMgZnJvbSB0aGlzIGluZGV4XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBWZWN0b3IgcmV0cmlldmFsIG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgdmVjdG9ycyBhcnJheSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXguZ2V0VmVjdG9ycyh7XG5cdCogICBrZXlzOiBbJ2RvYy0xJywgJ2RvYy0yJ10sXG5cdCogICByZXR1cm5NZXRhZGF0YTogdHJ1ZVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGdldFZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldEdldFZlY3RvcnMgPSAoKSA9PiBzdXBlci5nZXRWZWN0b3JzLCBfdGhpczEwID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRHZXRWZWN0b3JzKCkuY2FsbChfdGhpczEwLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7XG5cdFx0XHR2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczEwLnZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRpbmRleE5hbWU6IF90aGlzMTAuaW5kZXhOYW1lXG5cdFx0fSkpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBMaXN0cyB2ZWN0b3JzIGluIHRoaXMgaW5kZXggd2l0aCBwYWdpbmF0aW9uXG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBMaXN0aW5nIG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgdmVjdG9ycyBhcnJheSBhbmQgcGFnaW5hdGlvbiB0b2tlbiBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXgubGlzdFZlY3RvcnMoe1xuXHQqICAgbWF4UmVzdWx0czogNTAwLFxuXHQqICAgcmV0dXJuTWV0YWRhdGE6IHRydWVcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0VmVjdG9ycyhvcHRpb25zID0ge30pIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRMaXN0VmVjdG9ycyA9ICgpID0+IHN1cGVyLmxpc3RWZWN0b3JzLCBfdGhpczExID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRMaXN0VmVjdG9ycygpLmNhbGwoX3RoaXMxMSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXMxMS52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczExLmluZGV4TmFtZVxuXHRcdH0pKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUXVlcmllcyBmb3Igc2ltaWxhciB2ZWN0b3JzIGluIHRoaXMgaW5kZXhcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIFF1ZXJ5IG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgbWF0Y2hlcyBhcnJheSBvZiBzaW1pbGFyIHZlY3RvcnMgb3JkZXJlZCBieSBkaXN0YW5jZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXgucXVlcnlWZWN0b3JzKHtcblx0KiAgIHF1ZXJ5VmVjdG9yOiB7IGZsb2F0MzI6IFswLjEsIDAuMiwgLi4uXSB9LFxuXHQqICAgdG9wSzogNSxcblx0KiAgIGZpbHRlcjogeyBjYXRlZ29yeTogJ3RlY2huaWNhbCcgfSxcblx0KiAgIHJldHVybkRpc3RhbmNlOiB0cnVlLFxuXHQqICAgcmV0dXJuTWV0YWRhdGE6IHRydWVcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBxdWVyeVZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldFF1ZXJ5VmVjdG9ycyA9ICgpID0+IHN1cGVyLnF1ZXJ5VmVjdG9ycywgX3RoaXMxMiA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0UXVlcnlWZWN0b3JzKCkuY2FsbChfdGhpczEyLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7XG5cdFx0XHR2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczEyLnZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRpbmRleE5hbWU6IF90aGlzMTIuaW5kZXhOYW1lXG5cdFx0fSkpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBEZWxldGVzIHZlY3RvcnMgYnkga2V5cyBmcm9tIHRoaXMgaW5kZXhcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIERlbGV0aW9uIG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBhd2FpdCBpbmRleC5kZWxldGVWZWN0b3JzKHtcblx0KiAgIGtleXM6IFsnZG9jLTEnLCAnZG9jLTInLCAnZG9jLTMnXVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGRlbGV0ZVZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldERlbGV0ZVZlY3RvcnMgPSAoKSA9PiBzdXBlci5kZWxldGVWZWN0b3JzLCBfdGhpczEzID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXREZWxldGVWZWN0b3JzKCkuY2FsbChfdGhpczEzLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7XG5cdFx0XHR2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczEzLnZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRpbmRleE5hbWU6IF90aGlzMTMuaW5kZXhOYW1lXG5cdFx0fSkpO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvU3RvcmFnZUNsaWVudC50c1xudmFyIFN0b3JhZ2VDbGllbnQgPSBjbGFzcyBleHRlbmRzIFN0b3JhZ2VCdWNrZXRBcGkge1xuXHQvKipcblx0KiBDcmVhdGVzIGEgY2xpZW50IGZvciBTdG9yYWdlIGJ1Y2tldHMsIGZpbGVzLCBhbmFseXRpY3MsIGFuZCB2ZWN0b3JzLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBleGFtcGxlXG5cdCogYGBgdHNcblx0KiBpbXBvcnQgeyBTdG9yYWdlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N0b3JhZ2UtanMnXG5cdCpcblx0KiBjb25zdCBzdG9yYWdlID0gbmV3IFN0b3JhZ2VDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9zdG9yYWdlL3YxJywge1xuXHQqICAgYXBpa2V5OiAncHVibGljLWFub24ta2V5Jyxcblx0KiB9KVxuXHQqIGNvbnN0IGF2YXRhcnMgPSBzdG9yYWdlLmZyb20oJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSwgb3B0cykge1xuXHRcdHN1cGVyKHVybCwgaGVhZGVycywgZmV0Y2gkMSwgb3B0cyk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBmaWxlIG9wZXJhdGlvbiBpbiBhIGJ1Y2tldC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gaWQgVGhlIGJ1Y2tldCBpZCB0byBvcGVyYXRlIG9uLlxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgYXZhdGFycyA9IHN1cGFiYXNlLnN0b3JhZ2UuZnJvbSgnYXZhdGFycycpXG5cdCogYGBgXG5cdCovXG5cdGZyb20oaWQpIHtcblx0XHRyZXR1cm4gbmV3IFN0b3JhZ2VGaWxlQXBpKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMsIGlkLCB0aGlzLmZldGNoKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQWNjZXNzIHZlY3RvciBzdG9yYWdlIG9wZXJhdGlvbnMuXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHJldHVybnMgQSBTdG9yYWdlVmVjdG9yc0NsaWVudCBpbnN0YW5jZSBjb25maWd1cmVkIHdpdGggdGhlIGN1cnJlbnQgc3RvcmFnZSBzZXR0aW5ncy5cblx0Ki9cblx0Z2V0IHZlY3RvcnMoKSB7XG5cdFx0cmV0dXJuIG5ldyBTdG9yYWdlVmVjdG9yc0NsaWVudCh0aGlzLnVybCArIFwiL3ZlY3RvclwiLCB7XG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRmZXRjaDogdGhpcy5mZXRjaFxuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBBY2Nlc3MgYW5hbHl0aWNzIHN0b3JhZ2Ugb3BlcmF0aW9ucyB1c2luZyBJY2ViZXJnIHRhYmxlcy5cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcmV0dXJucyBBIFN0b3JhZ2VBbmFseXRpY3NDbGllbnQgaW5zdGFuY2UgY29uZmlndXJlZCB3aXRoIHRoZSBjdXJyZW50IHN0b3JhZ2Ugc2V0dGluZ3MuXG5cdCovXG5cdGdldCBhbmFseXRpY3MoKSB7XG5cdFx0cmV0dXJuIG5ldyBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50KHRoaXMudXJsICsgXCIvaWNlYmVyZ1wiLCB0aGlzLmhlYWRlcnMsIHRoaXMuZmV0Y2gpO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydHMuU3RvcmFnZUFuYWx5dGljc0NsaWVudCA9IFN0b3JhZ2VBbmFseXRpY3NDbGllbnQ7XG5leHBvcnRzLlN0b3JhZ2VBcGlFcnJvciA9IFN0b3JhZ2VBcGlFcnJvcjtcbmV4cG9ydHMuU3RvcmFnZUNsaWVudCA9IFN0b3JhZ2VDbGllbnQ7XG5leHBvcnRzLlN0b3JhZ2VFcnJvciA9IFN0b3JhZ2VFcnJvcjtcbmV4cG9ydHMuU3RvcmFnZVVua25vd25FcnJvciA9IFN0b3JhZ2VVbmtub3duRXJyb3I7XG5leHBvcnRzLlN0b3JhZ2VWZWN0b3JzQXBpRXJyb3IgPSBTdG9yYWdlVmVjdG9yc0FwaUVycm9yO1xuZXhwb3J0cy5TdG9yYWdlVmVjdG9yc0NsaWVudCA9IFN0b3JhZ2VWZWN0b3JzQ2xpZW50O1xuZXhwb3J0cy5TdG9yYWdlVmVjdG9yc0Vycm9yID0gU3RvcmFnZVZlY3RvcnNFcnJvcjtcbmV4cG9ydHMuU3RvcmFnZVZlY3RvcnNFcnJvckNvZGUgPSBTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZTtcbmV4cG9ydHMuU3RvcmFnZVZlY3RvcnNVbmtub3duRXJyb3IgPSBTdG9yYWdlVmVjdG9yc1Vua25vd25FcnJvcjtcbmV4cG9ydHMuVmVjdG9yQnVja2V0QXBpID0gVmVjdG9yQnVja2V0QXBpO1xuZXhwb3J0cy5WZWN0b3JCdWNrZXRTY29wZSA9IFZlY3RvckJ1Y2tldFNjb3BlO1xuZXhwb3J0cy5WZWN0b3JEYXRhQXBpID0gVmVjdG9yRGF0YUFwaTtcbmV4cG9ydHMuVmVjdG9ySW5kZXhBcGkgPSBWZWN0b3JJbmRleEFwaTtcbmV4cG9ydHMuVmVjdG9ySW5kZXhTY29wZSA9IFZlY3RvckluZGV4U2NvcGU7XG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuZXhwb3J0cy5pc1N0b3JhZ2VFcnJvciA9IGlzU3RvcmFnZUVycm9yO1xuZXhwb3J0cy5pc1N0b3JhZ2VWZWN0b3JzRXJyb3IgPSBpc1N0b3JhZ2VWZWN0b3JzRXJyb3I7XG5leHBvcnRzLm5vcm1hbGl6ZVRvRmxvYXQzMiA9IG5vcm1hbGl6ZVRvRmxvYXQzMjtcbmV4cG9ydHMucmVzb2x2ZUZldGNoID0gcmVzb2x2ZUZldGNoO1xuZXhwb3J0cy5yZXNvbHZlUmVzcG9uc2UgPSByZXNvbHZlUmVzcG9uc2U7XG5leHBvcnRzLnZhbGlkYXRlVmVjdG9yRGltZW5zaW9uID0gdmFsaWRhdGVWZWN0b3JEaW1lbnNpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwIl0sIm5hbWVzIjpbImljZWJlcmdfanMiLCJyZXF1aXJlIiwiU3RvcmFnZUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJfX2lzU3RvcmFnZUVycm9yIiwibmFtZSIsImlzU3RvcmFnZUVycm9yIiwiZXJyb3IiLCJTdG9yYWdlQXBpRXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNDb2RlIiwidG9KU09OIiwiU3RvcmFnZVVua25vd25FcnJvciIsIm9yaWdpbmFsRXJyb3IiLCJyZXNvbHZlRmV0Y2gkMSIsImN1c3RvbUZldGNoIiwiYXJncyIsImZldGNoIiwicmVzb2x2ZVJlc3BvbnNlJDEiLCJSZXNwb25zZSIsInJlY3Vyc2l2ZVRvQ2FtZWwiLCJpdGVtIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiZWwiLCJPYmplY3QiLCJyZXN1bHQiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImtleSIsInZhbHVlIiwibmV3S2V5IiwicmVwbGFjZSIsImMiLCJ0b1VwcGVyQ2FzZSIsImlzUGxhaW5PYmplY3QkMSIsInByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJpdGVyYXRvciIsImlzVmFsaWRCdWNrZXROYW1lIiwiYnVja2V0TmFtZSIsImxlbmd0aCIsInRyaW0iLCJpbmNsdWRlcyIsInRlc3QiLCJfdHlwZW9mIiwibyIsIm8kMSIsInRvUHJpbWl0aXZlIiwidCIsInIiLCJlIiwiaSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJ0b1Byb3BlcnR5S2V5IiwiX2RlZmluZVByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsInIkMSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQyIiwiYXJndW1lbnRzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfZ2V0RXJyb3JNZXNzYWdlJDEiLCJlcnIiLCJfZXJyJGVycm9yIiwibXNnIiwiZXJyb3JfZGVzY3JpcHRpb24iLCJKU09OIiwic3RyaW5naWZ5IiwiaGFuZGxlRXJyb3IkMSIsInJlamVjdCIsIm9wdGlvbnMiLCJub1Jlc29sdmVKc29uIiwianNvbiIsInRoZW4iLCJjYXRjaCIsIl9nZXRSZXF1ZXN0UGFyYW1zJDEiLCJtZXRob2QiLCJwYXJhbWV0ZXJzIiwiYm9keSIsInBhcmFtcyIsImhlYWRlcnMiLCJkdXBsZXgiLCJfaGFuZGxlUmVxdWVzdCQxIiwiZmV0Y2hlciIsInVybCIsIlByb21pc2UiLCJyZXNvbHZlIiwib2siLCJkYXRhIiwiZ2V0IiwicG9zdCQxIiwicHV0IiwiaGVhZCIsInJlbW92ZSIsIlN0cmVhbURvd25sb2FkQnVpbGRlciIsImRvd25sb2FkRm4iLCJzaG91bGRUaHJvd09uRXJyb3IiLCJvbmZ1bGZpbGxlZCIsIm9ucmVqZWN0ZWQiLCJleGVjdXRlIiwiX3RoaXMiLCJfU3ltYm9sJHRvU3RyaW5nVGFnIiwiQmxvYkRvd25sb2FkQnVpbGRlciIsInByb21pc2UiLCJhc1N0cmVhbSIsImdldFByb21pc2UiLCJmaW5hbGx5Iiwib25maW5hbGx5IiwiYmxvYiIsIkRFRkFVTFRfU0VBUkNIX09QVElPTlMiLCJsaW1pdCIsIm9mZnNldCIsInNvcnRCeSIsImNvbHVtbiIsIm9yZGVyIiwiREVGQVVMVF9GSUxFX09QVElPTlMiLCJjYWNoZUNvbnRyb2wiLCJjb250ZW50VHlwZSIsInVwc2VydCIsIlN0b3JhZ2VGaWxlQXBpIiwiYnVja2V0SWQiLCJmZXRjaCQxIiwidGhyb3dPbkVycm9yIiwidXBsb2FkT3JVcGRhdGUiLCJwYXRoIiwiZmlsZUJvZHkiLCJmaWxlT3B0aW9ucyIsIm1ldGFkYXRhIiwiQmxvYiIsIkZvcm1EYXRhIiwiYXBwZW5kIiwiZW5jb2RlTWV0YWRhdGEiLCJoYXMiLCJ0b0Jhc2U2NCIsIlJlYWRhYmxlU3RyZWFtIiwicGlwZSIsImNsZWFuUGF0aCIsIl9yZW1vdmVFbXB0eUZvbGRlcnMiLCJfcGF0aCIsIl9nZXRGaW5hbFBhdGgiLCJpZCIsIklkIiwiZnVsbFBhdGgiLCJLZXkiLCJ1cGxvYWQiLCJ1cGxvYWRUb1NpZ25lZFVybCIsInRva2VuIiwiX3RoaXMzIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwic2V0IiwidG9TdHJpbmciLCJjcmVhdGVTaWduZWRVcGxvYWRVcmwiLCJfdGhpczQiLCJzaWduZWRVcmwiLCJ1cGRhdGUiLCJtb3ZlIiwiZnJvbVBhdGgiLCJ0b1BhdGgiLCJfdGhpczYiLCJzb3VyY2VLZXkiLCJkZXN0aW5hdGlvbktleSIsImRlc3RpbmF0aW9uQnVja2V0IiwiY29weSIsIl90aGlzNyIsImNyZWF0ZVNpZ25lZFVybCIsImV4cGlyZXNJbiIsIl90aGlzOCIsInRyYW5zZm9ybSIsImRvd25sb2FkUXVlcnlQYXJhbSIsImRvd25sb2FkIiwiZW5jb2RlVVJJIiwic2lnbmVkVVJMIiwiY3JlYXRlU2lnbmVkVXJscyIsInBhdGhzIiwiX3RoaXM5IiwiZGF0dW0iLCJyZW5kZXJQYXRoIiwidHJhbnNmb3JtYXRpb25RdWVyeSIsInRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nIiwicXVlcnlTdHJpbmciLCJpbmZvIiwiX3RoaXMxMCIsImV4aXN0cyIsIl90aGlzMTEiLCJnZXRQdWJsaWNVcmwiLCJfcXVlcnlTdHJpbmciLCJqb2luIiwicHVibGljVXJsIiwiX3RoaXMxMiIsInByZWZpeGVzIiwibGlzdCIsIl90aGlzMTMiLCJwcmVmaXgiLCJsaXN0VjIiLCJfdGhpczE0IiwiQnVmZmVyIiwiZnJvbSIsImJ0b2EiLCJ3aWR0aCIsImhlaWdodCIsInJlc2l6ZSIsImZvcm1hdCIsInF1YWxpdHkiLCJ2ZXJzaW9uIiwiREVGQVVMVF9IRUFERVJTJDEiLCJTdG9yYWdlQnVja2V0QXBpIiwib3B0cyIsImJhc2VVcmwiLCJ1c2VOZXdIb3N0bmFtZSIsImhvc3RuYW1lIiwiaHJlZiIsImxpc3RCdWNrZXRzIiwibGlzdEJ1Y2tldE9wdGlvbnNUb1F1ZXJ5U3RyaW5nIiwiZ2V0QnVja2V0IiwiX3RoaXMyIiwiY3JlYXRlQnVja2V0IiwicHVibGljIiwidHlwZSIsImZpbGVfc2l6ZV9saW1pdCIsImZpbGVTaXplTGltaXQiLCJhbGxvd2VkX21pbWVfdHlwZXMiLCJhbGxvd2VkTWltZVR5cGVzIiwidXBkYXRlQnVja2V0IiwiZW1wdHlCdWNrZXQiLCJfdGhpczUiLCJkZWxldGVCdWNrZXQiLCJzZWFyY2giLCJzb3J0Q29sdW1uIiwic29ydE9yZGVyIiwiVVJMU2VhcmNoUGFyYW1zIiwiU3RvcmFnZUFuYWx5dGljc0NsaWVudCIsInF1ZXJ5UGFyYW1zIiwiY2F0YWxvZyIsIkljZWJlcmdSZXN0Q2F0YWxvZyIsImNhdGFsb2dOYW1lIiwiYXV0aCIsImdldEhlYWRlcnMiLCJQcm94eSIsInRhcmdldCIsInByb3AiLCJERUZBVUxUX0hFQURFUlMiLCJTdG9yYWdlVmVjdG9yc0Vycm9yIiwiX19pc1N0b3JhZ2VWZWN0b3JzRXJyb3IiLCJpc1N0b3JhZ2VWZWN0b3JzRXJyb3IiLCJTdG9yYWdlVmVjdG9yc0FwaUVycm9yIiwiU3RvcmFnZVZlY3RvcnNVbmtub3duRXJyb3IiLCJTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSIsIlN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDEiLCJyZXNvbHZlRmV0Y2giLCJyZXNvbHZlUmVzcG9uc2UiLCJpc1BsYWluT2JqZWN0Iiwibm9ybWFsaXplVG9GbG9hdDMyIiwidmFsdWVzIiwiRmxvYXQzMkFycmF5IiwidmFsaWRhdGVWZWN0b3JEaW1lbnNpb24iLCJ2ZWN0b3IiLCJleHBlY3RlZERpbWVuc2lvbiIsImZsb2F0MzIiLCJfZ2V0RXJyb3JNZXNzYWdlIiwiaGFuZGxlRXJyb3IiLCJyZXNwb25zZUVycm9yIiwiY29kZSIsInN0YXR1c1RleHQiLCJfZ2V0UmVxdWVzdFBhcmFtcyIsIl9oYW5kbGVSZXF1ZXN0IiwicG9zdCIsIlZlY3RvckluZGV4QXBpIiwiY3JlYXRlSW5kZXgiLCJnZXRJbmRleCIsInZlY3RvckJ1Y2tldE5hbWUiLCJpbmRleE5hbWUiLCJsaXN0SW5kZXhlcyIsImRlbGV0ZUluZGV4IiwiVmVjdG9yRGF0YUFwaSIsInB1dFZlY3RvcnMiLCJ2ZWN0b3JzIiwiZ2V0VmVjdG9ycyIsImxpc3RWZWN0b3JzIiwic2VnbWVudENvdW50Iiwic2VnbWVudEluZGV4IiwicXVlcnlWZWN0b3JzIiwiZGVsZXRlVmVjdG9ycyIsIlZlY3RvckJ1Y2tldEFwaSIsIlN0b3JhZ2VWZWN0b3JzQ2xpZW50IiwiVmVjdG9yQnVja2V0U2NvcGUiLCJfc3VwZXJwcm9wX2dldENyZWF0ZUJ1Y2tldCIsIl9zdXBlcnByb3BfZ2V0R2V0QnVja2V0IiwiX3N1cGVycHJvcF9nZXRMaXN0QnVja2V0cyIsIl9zdXBlcnByb3BfZ2V0RGVsZXRlQnVja2V0IiwiX3N1cGVycHJvcF9nZXRDcmVhdGVJbmRleCIsIl9zdXBlcnByb3BfZ2V0TGlzdEluZGV4ZXMiLCJfc3VwZXJwcm9wX2dldEdldEluZGV4IiwiX3N1cGVycHJvcF9nZXREZWxldGVJbmRleCIsImluZGV4IiwiVmVjdG9ySW5kZXhTY29wZSIsIl9zdXBlcnByb3BfZ2V0UHV0VmVjdG9ycyIsIl9zdXBlcnByb3BfZ2V0R2V0VmVjdG9ycyIsIl9zdXBlcnByb3BfZ2V0TGlzdFZlY3RvcnMiLCJfc3VwZXJwcm9wX2dldFF1ZXJ5VmVjdG9ycyIsIl9zdXBlcnByb3BfZ2V0RGVsZXRlVmVjdG9ycyIsIlN0b3JhZ2VDbGllbnQiLCJhbmFseXRpY3MiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/storage-js/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/supabase-js/dist/index.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/index.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("let __supabase_functions_js = __webpack_require__(/*! @supabase/functions-js */ \"(rsc)/./node_modules/@supabase/functions-js/dist/main/index.js\");\nlet __supabase_postgrest_js = __webpack_require__(/*! @supabase/postgrest-js */ \"(rsc)/./node_modules/@supabase/postgrest-js/dist/index.cjs\");\nlet __supabase_realtime_js = __webpack_require__(/*! @supabase/realtime-js */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/index.js\");\nlet __supabase_storage_js = __webpack_require__(/*! @supabase/storage-js */ \"(rsc)/./node_modules/@supabase/storage-js/dist/index.cjs\");\nlet __supabase_auth_js = __webpack_require__(/*! @supabase/auth-js */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/index.js\");\n//#region src/lib/version.ts\nconst version = \"2.91.0\";\n//#endregion\n//#region src/lib/constants.ts\nlet JS_ENV = \"\";\nif (typeof Deno !== \"undefined\") JS_ENV = \"deno\";\nelse if (typeof document !== \"undefined\") JS_ENV = \"web\";\nelse if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") JS_ENV = \"react-native\";\nelse JS_ENV = \"node\";\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `supabase-js-${JS_ENV}/${version}`\n};\nconst DEFAULT_GLOBAL_OPTIONS = {\n    headers: DEFAULT_HEADERS\n};\nconst DEFAULT_DB_OPTIONS = {\n    schema: \"public\"\n};\nconst DEFAULT_AUTH_OPTIONS = {\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    flowType: \"implicit\"\n};\nconst DEFAULT_REALTIME_OPTIONS = {};\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n        return typeof o$1;\n    } : function(o$1) {\n        return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, _typeof(o);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n    var i = toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r$1) {\n            return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n            _defineProperty(e, r$1, t[r$1]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n            Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n        });\n    }\n    return e;\n}\n//#endregion\n//#region src/lib/fetch.ts\nconst resolveFetch = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\nconst resolveHeadersConstructor = ()=>{\n    return Headers;\n};\nconst fetchWithAuth = (supabaseKey, getAccessToken, customFetch)=>{\n    const fetch$1 = resolveFetch(customFetch);\n    const HeadersConstructor = resolveHeadersConstructor();\n    return async (input, init)=>{\n        var _await$getAccessToken;\n        const accessToken = (_await$getAccessToken = await getAccessToken()) !== null && _await$getAccessToken !== void 0 ? _await$getAccessToken : supabaseKey;\n        let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n        if (!headers.has(\"apikey\")) headers.set(\"apikey\", supabaseKey);\n        if (!headers.has(\"Authorization\")) headers.set(\"Authorization\", `Bearer ${accessToken}`);\n        return fetch$1(input, _objectSpread2(_objectSpread2({}, init), {}, {\n            headers\n        }));\n    };\n};\n//#endregion\n//#region src/lib/helpers.ts\nfunction ensureTrailingSlash(url) {\n    return url.endsWith(\"/\") ? url : url + \"/\";\n}\nfunction applySettingDefaults(options, defaults) {\n    var _DEFAULT_GLOBAL_OPTIO, _globalOptions$header;\n    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;\n    const { db: DEFAULT_DB_OPTIONS$1, auth: DEFAULT_AUTH_OPTIONS$1, realtime: DEFAULT_REALTIME_OPTIONS$1, global: DEFAULT_GLOBAL_OPTIONS$1 } = defaults;\n    const result = {\n        db: _objectSpread2(_objectSpread2({}, DEFAULT_DB_OPTIONS$1), dbOptions),\n        auth: _objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS$1), authOptions),\n        realtime: _objectSpread2(_objectSpread2({}, DEFAULT_REALTIME_OPTIONS$1), realtimeOptions),\n        storage: {},\n        global: _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_GLOBAL_OPTIONS$1), globalOptions), {}, {\n            headers: _objectSpread2(_objectSpread2({}, (_DEFAULT_GLOBAL_OPTIO = DEFAULT_GLOBAL_OPTIONS$1 === null || DEFAULT_GLOBAL_OPTIONS$1 === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS$1.headers) !== null && _DEFAULT_GLOBAL_OPTIO !== void 0 ? _DEFAULT_GLOBAL_OPTIO : {}), (_globalOptions$header = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _globalOptions$header !== void 0 ? _globalOptions$header : {})\n        }),\n        accessToken: async ()=>\"\"\n    };\n    if (options.accessToken) result.accessToken = options.accessToken;\n    else delete result.accessToken;\n    return result;\n}\n/**\n* Validates a Supabase client URL\n*\n* @param {string} supabaseUrl - The Supabase client URL string.\n* @returns {URL} - The validated base URL.\n* @throws {Error}\n*/ function validateSupabaseUrl(supabaseUrl) {\n    const trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();\n    if (!trimmedUrl) throw new Error(\"supabaseUrl is required.\");\n    if (!trimmedUrl.match(/^https?:\\/\\//i)) throw new Error(\"Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.\");\n    try {\n        return new URL(ensureTrailingSlash(trimmedUrl));\n    } catch (_unused) {\n        throw Error(\"Invalid supabaseUrl: Provided URL is malformed.\");\n    }\n}\n//#endregion\n//#region src/lib/SupabaseAuthClient.ts\nvar SupabaseAuthClient = class extends __supabase_auth_js.AuthClient {\n    constructor(options){\n        super(options);\n    }\n};\n//#endregion\n//#region src/SupabaseClient.ts\n/**\n* Supabase Client.\n*\n* An isomorphic Javascript client for interacting with Postgres.\n*/ var SupabaseClient = class {\n    /**\n\t* Create a new client for use in the browser.\n\t* @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n\t* @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n\t* @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n\t* @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n\t* @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n\t* @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n\t* @param options.realtime Options passed along to realtime-js constructor.\n\t* @param options.storage Options passed along to the storage-js constructor.\n\t* @param options.global.fetch A custom fetch implementation.\n\t* @param options.global.headers Any additional headers to send with each network request.\n\t* @example\n\t* ```ts\n\t* import { createClient } from '@supabase/supabase-js'\n\t*\n\t* const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')\n\t* const { data } = await supabase.from('profiles').select('*')\n\t* ```\n\t*/ constructor(supabaseUrl, supabaseKey, options){\n        var _settings$auth$storag, _settings$global$head;\n        this.supabaseUrl = supabaseUrl;\n        this.supabaseKey = supabaseKey;\n        const baseUrl = validateSupabaseUrl(supabaseUrl);\n        if (!supabaseKey) throw new Error(\"supabaseKey is required.\");\n        this.realtimeUrl = new URL(\"realtime/v1\", baseUrl);\n        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace(\"http\", \"ws\");\n        this.authUrl = new URL(\"auth/v1\", baseUrl);\n        this.storageUrl = new URL(\"storage/v1\", baseUrl);\n        this.functionsUrl = new URL(\"functions/v1\", baseUrl);\n        const defaultStorageKey = `sb-${baseUrl.hostname.split(\".\")[0]}-auth-token`;\n        const DEFAULTS = {\n            db: DEFAULT_DB_OPTIONS,\n            realtime: DEFAULT_REALTIME_OPTIONS,\n            auth: _objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS), {}, {\n                storageKey: defaultStorageKey\n            }),\n            global: DEFAULT_GLOBAL_OPTIONS\n        };\n        const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n        this.storageKey = (_settings$auth$storag = settings.auth.storageKey) !== null && _settings$auth$storag !== void 0 ? _settings$auth$storag : \"\";\n        this.headers = (_settings$global$head = settings.global.headers) !== null && _settings$global$head !== void 0 ? _settings$global$head : {};\n        if (!settings.accessToken) {\n            var _settings$auth;\n            this.auth = this._initSupabaseAuthClient((_settings$auth = settings.auth) !== null && _settings$auth !== void 0 ? _settings$auth : {}, this.headers, settings.global.fetch);\n        } else {\n            this.accessToken = settings.accessToken;\n            this.auth = new Proxy({}, {\n                get: (_, prop)=>{\n                    throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);\n                }\n            });\n        }\n        this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);\n        this.realtime = this._initRealtimeClient(_objectSpread2({\n            headers: this.headers,\n            accessToken: this._getAccessToken.bind(this)\n        }, settings.realtime));\n        if (this.accessToken) Promise.resolve(this.accessToken()).then((token)=>this.realtime.setAuth(token)).catch((e)=>console.warn(\"Failed to set initial Realtime auth token:\", e));\n        this.rest = new __supabase_postgrest_js.PostgrestClient(new URL(\"rest/v1\", baseUrl).href, {\n            headers: this.headers,\n            schema: settings.db.schema,\n            fetch: this.fetch\n        });\n        this.storage = new __supabase_storage_js.StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);\n        if (!settings.accessToken) this._listenForAuthEvents();\n    }\n    /**\n\t* Supabase Functions allows you to deploy and invoke edge functions.\n\t*/ get functions() {\n        return new __supabase_functions_js.FunctionsClient(this.functionsUrl.href, {\n            headers: this.headers,\n            customFetch: this.fetch\n        });\n    }\n    /**\n\t* Perform a query on a table or a view.\n\t*\n\t* @param relation - The table or view name to query\n\t*/ from(relation) {\n        return this.rest.from(relation);\n    }\n    /**\n\t* Select a schema to query or perform an function (rpc) call.\n\t*\n\t* The schema needs to be on the list of exposed schemas inside Supabase.\n\t*\n\t* @param schema - The schema to query\n\t*/ schema(schema) {\n        return this.rest.schema(schema);\n    }\n    /**\n\t* Perform a function call.\n\t*\n\t* @param fn - The function name to call\n\t* @param args - The arguments to pass to the function call\n\t* @param options - Named parameters\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t* @param options.get - When set to `true`, the function will be called with\n\t* read-only access mode.\n\t* @param options.count - Count algorithm to use to count rows returned by the\n\t* function. Only applicable for [set-returning\n\t* functions](https://www.postgresql.org/docs/current/functions-srf.html).\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ rpc(fn, args = {}, options = {\n        head: false,\n        get: false,\n        count: void 0\n    }) {\n        return this.rest.rpc(fn, args, options);\n    }\n    /**\n\t* Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n\t*\n\t* @param {string} name - The name of the Realtime channel.\n\t* @param {Object} opts - The options to pass to the Realtime channel.\n\t*\n\t*/ channel(name, opts = {\n        config: {}\n    }) {\n        return this.realtime.channel(name, opts);\n    }\n    /**\n\t* Returns all Realtime channels.\n\t*/ getChannels() {\n        return this.realtime.getChannels();\n    }\n    /**\n\t* Unsubscribes and removes Realtime channel from Realtime client.\n\t*\n\t* @param {RealtimeChannel} channel - The name of the Realtime channel.\n\t*\n\t*/ removeChannel(channel) {\n        return this.realtime.removeChannel(channel);\n    }\n    /**\n\t* Unsubscribes and removes all Realtime channels from Realtime client.\n\t*/ removeAllChannels() {\n        return this.realtime.removeAllChannels();\n    }\n    async _getAccessToken() {\n        var _this = this;\n        var _data$session$access_, _data$session;\n        if (_this.accessToken) return await _this.accessToken();\n        const { data } = await _this.auth.getSession();\n        return (_data$session$access_ = (_data$session = data.session) === null || _data$session === void 0 ? void 0 : _data$session.access_token) !== null && _data$session$access_ !== void 0 ? _data$session$access_ : _this.supabaseKey;\n    }\n    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug, throwOnError }, headers, fetch$1) {\n        const authHeaders = {\n            Authorization: `Bearer ${this.supabaseKey}`,\n            apikey: `${this.supabaseKey}`\n        };\n        return new SupabaseAuthClient({\n            url: this.authUrl.href,\n            headers: _objectSpread2(_objectSpread2({}, authHeaders), headers),\n            storageKey,\n            autoRefreshToken,\n            persistSession,\n            detectSessionInUrl,\n            storage,\n            userStorage,\n            flowType,\n            lock,\n            debug,\n            throwOnError,\n            fetch: fetch$1,\n            hasCustomAuthorizationHeader: Object.keys(this.headers).some((key)=>key.toLowerCase() === \"authorization\")\n        });\n    }\n    _initRealtimeClient(options) {\n        return new __supabase_realtime_js.RealtimeClient(this.realtimeUrl.href, _objectSpread2(_objectSpread2({}, options), {}, {\n            params: _objectSpread2(_objectSpread2({}, {\n                apikey: this.supabaseKey\n            }), options === null || options === void 0 ? void 0 : options.params)\n        }));\n    }\n    _listenForAuthEvents() {\n        return this.auth.onAuthStateChange((event, session)=>{\n            this._handleTokenChanged(event, \"CLIENT\", session === null || session === void 0 ? void 0 : session.access_token);\n        });\n    }\n    _handleTokenChanged(event, source, token) {\n        if ((event === \"TOKEN_REFRESHED\" || event === \"SIGNED_IN\") && this.changedAccessToken !== token) {\n            this.changedAccessToken = token;\n            this.realtime.setAuth(token);\n        } else if (event === \"SIGNED_OUT\") {\n            this.realtime.setAuth();\n            if (source == \"STORAGE\") this.auth.signOut();\n            this.changedAccessToken = void 0;\n        }\n    }\n};\n//#endregion\n//#region src/index.ts\n/**\n* Creates a new Supabase Client.\n*\n* @example\n* ```ts\n* import { createClient } from '@supabase/supabase-js'\n*\n* const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')\n* const { data, error } = await supabase.from('profiles').select('*')\n* ```\n*/ const createClient = (supabaseUrl, supabaseKey, options)=>{\n    return new SupabaseClient(supabaseUrl, supabaseKey, options);\n};\nfunction shouldShowDeprecationWarning() {\n    if (false) {}\n    const _process = globalThis[\"process\"];\n    if (!_process) return false;\n    const processVersion = _process[\"version\"];\n    if (processVersion === void 0 || processVersion === null) return false;\n    const versionMatch = processVersion.match(/^v(\\d+)\\./);\n    if (!versionMatch) return false;\n    return parseInt(versionMatch[1], 10) <= 18;\n}\nif (shouldShowDeprecationWarning()) console.warn(\"  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217\");\n//#endregion\nObject.defineProperty(exports, \"FunctionRegion\", ({\n    enumerable: true,\n    get: function() {\n        return __supabase_functions_js.FunctionRegion;\n    }\n}));\nObject.defineProperty(exports, \"FunctionsError\", ({\n    enumerable: true,\n    get: function() {\n        return __supabase_functions_js.FunctionsError;\n    }\n}));\nObject.defineProperty(exports, \"FunctionsFetchError\", ({\n    enumerable: true,\n    get: function() {\n        return __supabase_functions_js.FunctionsFetchError;\n    }\n}));\nObject.defineProperty(exports, \"FunctionsHttpError\", ({\n    enumerable: true,\n    get: function() {\n        return __supabase_functions_js.FunctionsHttpError;\n    }\n}));\nObject.defineProperty(exports, \"FunctionsRelayError\", ({\n    enumerable: true,\n    get: function() {\n        return __supabase_functions_js.FunctionsRelayError;\n    }\n}));\nObject.defineProperty(exports, \"PostgrestError\", ({\n    enumerable: true,\n    get: function() {\n        return __supabase_postgrest_js.PostgrestError;\n    }\n}));\nexports.SupabaseClient = SupabaseClient;\nexports.createClient = createClient;\nObject.keys(__supabase_auth_js).forEach(function(k) {\n    if (k !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {\n        enumerable: true,\n        get: function() {\n            return __supabase_auth_js[k];\n        }\n    });\n});\nObject.keys(__supabase_realtime_js).forEach(function(k) {\n    if (k !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {\n        enumerable: true,\n        get: function() {\n            return __supabase_realtime_js[k];\n        }\n    });\n}); //# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLDBCQUEwQkMsbUJBQU9BLENBQUMsOEZBQXdCO0FBQzlELElBQUlDLDBCQUEwQkQsbUJBQU9BLENBQUMsMEZBQXdCO0FBQzlELElBQUlFLHlCQUF5QkYsbUJBQU9BLENBQUMsNEZBQXVCO0FBQzVELElBQUlHLHdCQUF3QkgsbUJBQU9BLENBQUMsc0ZBQXNCO0FBQzFELElBQUlJLHFCQUFxQkosbUJBQU9BLENBQUMsb0ZBQW1CO0FBRXBELDRCQUE0QjtBQUM1QixNQUFNSyxVQUFVO0FBRWhCLFlBQVk7QUFDWiw4QkFBOEI7QUFDOUIsSUFBSUMsU0FBUztBQUNiLElBQUksT0FBT0MsU0FBUyxhQUFhRCxTQUFTO0tBQ3JDLElBQUksT0FBT0UsYUFBYSxhQUFhRixTQUFTO0tBQzlDLElBQUksT0FBT0csY0FBYyxlQUFlQSxVQUFVQyxPQUFPLEtBQUssZUFBZUosU0FBUztLQUN0RkEsU0FBUztBQUNkLE1BQU1LLGtCQUFrQjtJQUFFLGlCQUFpQixDQUFDLFlBQVksRUFBRUwsT0FBTyxDQUFDLEVBQUVELFFBQVEsQ0FBQztBQUFDO0FBQzlFLE1BQU1PLHlCQUF5QjtJQUFFQyxTQUFTRjtBQUFnQjtBQUMxRCxNQUFNRyxxQkFBcUI7SUFBRUMsUUFBUTtBQUFTO0FBQzlDLE1BQU1DLHVCQUF1QjtJQUM1QkMsa0JBQWtCO0lBQ2xCQyxnQkFBZ0I7SUFDaEJDLG9CQUFvQjtJQUNwQkMsVUFBVTtBQUNYO0FBQ0EsTUFBTUMsMkJBQTJCLENBQUM7QUFFbEMsWUFBWTtBQUNaLDBEQUEwRDtBQUMxRCxTQUFTQyxRQUFRQyxDQUFDO0lBQ2pCO0lBQ0EsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBU0MsR0FBRztRQUNoRyxPQUFPLE9BQU9BO0lBQ2YsSUFBSSxTQUFTQSxHQUFHO1FB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QUMxRy9KLFlBQVk7UUFDWnFGLEtBQUs7WUFBYyxPQUFPNUgsa0JBQWtCLENBQUNzTSxFQUFFO1FBQUU7SUFDbkQ7QUFDRjtBQUVBbEssT0FBT08sSUFBSSxDQUFDN0Msd0JBQXdCdUQsT0FBTyxDQUFDLFNBQVVpSixDQUFDO0lBQ3JELElBQUlBLE1BQU0sYUFBYSxDQUFDbEssT0FBT1osU0FBUyxDQUFDK0ssY0FBYyxDQUFDekssSUFBSSxDQUFDaUssU0FBU08sSUFBSWxLLE9BQU9DLGNBQWMsQ0FBQzBKLFNBQVNPLEdBQUc7UUFDMUcvSixZQUFZO1FBQ1pxRixLQUFLO1lBQWMsT0FBTzlILHNCQUFzQixDQUFDd00sRUFBRTtRQUFFO0lBQ3ZEO0FBQ0YsSUFFQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvaW5kZXguY2pzPzU3ZjkiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IF9fc3VwYWJhc2VfZnVuY3Rpb25zX2pzID0gcmVxdWlyZShcIkBzdXBhYmFzZS9mdW5jdGlvbnMtanNcIik7XG5sZXQgX19zdXBhYmFzZV9wb3N0Z3Jlc3RfanMgPSByZXF1aXJlKFwiQHN1cGFiYXNlL3Bvc3RncmVzdC1qc1wiKTtcbmxldCBfX3N1cGFiYXNlX3JlYWx0aW1lX2pzID0gcmVxdWlyZShcIkBzdXBhYmFzZS9yZWFsdGltZS1qc1wiKTtcbmxldCBfX3N1cGFiYXNlX3N0b3JhZ2VfanMgPSByZXF1aXJlKFwiQHN1cGFiYXNlL3N0b3JhZ2UtanNcIik7XG5sZXQgX19zdXBhYmFzZV9hdXRoX2pzID0gcmVxdWlyZShcIkBzdXBhYmFzZS9hdXRoLWpzXCIpO1xuXG4vLyNyZWdpb24gc3JjL2xpYi92ZXJzaW9uLnRzXG5jb25zdCB2ZXJzaW9uID0gXCIyLjkxLjBcIjtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi9jb25zdGFudHMudHNcbmxldCBKU19FTlYgPSBcIlwiO1xuaWYgKHR5cGVvZiBEZW5vICE9PSBcInVuZGVmaW5lZFwiKSBKU19FTlYgPSBcImRlbm9cIjtcbmVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikgSlNfRU5WID0gXCJ3ZWJcIjtcbmVsc2UgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIikgSlNfRU5WID0gXCJyZWFjdC1uYXRpdmVcIjtcbmVsc2UgSlNfRU5WID0gXCJub2RlXCI7XG5jb25zdCBERUZBVUxUX0hFQURFUlMgPSB7IFwiWC1DbGllbnQtSW5mb1wiOiBgc3VwYWJhc2UtanMtJHtKU19FTlZ9LyR7dmVyc2lvbn1gIH07XG5jb25zdCBERUZBVUxUX0dMT0JBTF9PUFRJT05TID0geyBoZWFkZXJzOiBERUZBVUxUX0hFQURFUlMgfTtcbmNvbnN0IERFRkFVTFRfREJfT1BUSU9OUyA9IHsgc2NoZW1hOiBcInB1YmxpY1wiIH07XG5jb25zdCBERUZBVUxUX0FVVEhfT1BUSU9OUyA9IHtcblx0YXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcblx0cGVyc2lzdFNlc3Npb246IHRydWUsXG5cdGRldGVjdFNlc3Npb25JblVybDogdHJ1ZSxcblx0Zmxvd1R5cGU6IFwiaW1wbGljaXRcIlxufTtcbmNvbnN0IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyA9IHt9O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdHlwZW9mLmpzXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcblx0XCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXHRyZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG8kMSkge1xuXHRcdHJldHVybiB0eXBlb2YgbyQxO1xuXHR9IDogZnVuY3Rpb24obyQxKSB7XG5cdFx0cmV0dXJuIG8kMSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvJDEuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvJDEgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG8kMTtcblx0fSwgX3R5cGVvZihvKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL3RvUHJpbWl0aXZlLmpzXG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh0LCByKSB7XG5cdGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0O1xuXHR2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcblx0aWYgKHZvaWQgMCAhPT0gZSkge1xuXHRcdHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuXHRcdGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpO1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcblx0fVxuXHRyZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdG9Qcm9wZXJ0eUtleS5qc1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG5cdHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG5cdHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qc1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcblx0cmV0dXJuIChyID0gdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG5cdFx0dmFsdWU6IHQsXG5cdFx0ZW51bWVyYWJsZTogITAsXG5cdFx0Y29uZmlndXJhYmxlOiAhMCxcblx0XHR3cml0YWJsZTogITBcblx0fSkgOiBlW3JdID0gdCwgZTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL29iamVjdFNwcmVhZDIuanNcbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuXHR2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuXHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcblx0XHRyICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByJDEpLmVudW1lcmFibGU7XG5cdFx0fSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG5cdH1cblx0cmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG5cdGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG5cdFx0dmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuXHRcdHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIkMSkge1xuXHRcdFx0X2RlZmluZVByb3BlcnR5KGUsIHIkMSwgdFtyJDFdKTtcblx0XHR9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciQxLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIkMSkpO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBlO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL2ZldGNoLnRzXG5jb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcblx0aWYgKGN1c3RvbUZldGNoKSByZXR1cm4gKC4uLmFyZ3MpID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpO1xuXHRyZXR1cm4gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xufTtcbmNvbnN0IHJlc29sdmVIZWFkZXJzQ29uc3RydWN0b3IgPSAoKSA9PiB7XG5cdHJldHVybiBIZWFkZXJzO1xufTtcbmNvbnN0IGZldGNoV2l0aEF1dGggPSAoc3VwYWJhc2VLZXksIGdldEFjY2Vzc1Rva2VuLCBjdXN0b21GZXRjaCkgPT4ge1xuXHRjb25zdCBmZXRjaCQxID0gcmVzb2x2ZUZldGNoKGN1c3RvbUZldGNoKTtcblx0Y29uc3QgSGVhZGVyc0NvbnN0cnVjdG9yID0gcmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvcigpO1xuXHRyZXR1cm4gYXN5bmMgKGlucHV0LCBpbml0KSA9PiB7XG5cdFx0dmFyIF9hd2FpdCRnZXRBY2Nlc3NUb2tlbjtcblx0XHRjb25zdCBhY2Nlc3NUb2tlbiA9IChfYXdhaXQkZ2V0QWNjZXNzVG9rZW4gPSBhd2FpdCBnZXRBY2Nlc3NUb2tlbigpKSAhPT0gbnVsbCAmJiBfYXdhaXQkZ2V0QWNjZXNzVG9rZW4gIT09IHZvaWQgMCA/IF9hd2FpdCRnZXRBY2Nlc3NUb2tlbiA6IHN1cGFiYXNlS2V5O1xuXHRcdGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnNDb25zdHJ1Y3Rvcihpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycyk7XG5cdFx0aWYgKCFoZWFkZXJzLmhhcyhcImFwaWtleVwiKSkgaGVhZGVycy5zZXQoXCJhcGlrZXlcIiwgc3VwYWJhc2VLZXkpO1xuXHRcdGlmICghaGVhZGVycy5oYXMoXCJBdXRob3JpemF0aW9uXCIpKSBoZWFkZXJzLnNldChcIkF1dGhvcml6YXRpb25cIiwgYEJlYXJlciAke2FjY2Vzc1Rva2VufWApO1xuXHRcdHJldHVybiBmZXRjaCQxKGlucHV0LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgaW5pdCksIHt9LCB7IGhlYWRlcnMgfSkpO1xuXHR9O1xufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi9oZWxwZXJzLnRzXG5mdW5jdGlvbiBlbnN1cmVUcmFpbGluZ1NsYXNoKHVybCkge1xuXHRyZXR1cm4gdXJsLmVuZHNXaXRoKFwiL1wiKSA/IHVybCA6IHVybCArIFwiL1wiO1xufVxuZnVuY3Rpb24gYXBwbHlTZXR0aW5nRGVmYXVsdHMob3B0aW9ucywgZGVmYXVsdHMpIHtcblx0dmFyIF9ERUZBVUxUX0dMT0JBTF9PUFRJTywgX2dsb2JhbE9wdGlvbnMkaGVhZGVyO1xuXHRjb25zdCB7IGRiOiBkYk9wdGlvbnMsIGF1dGg6IGF1dGhPcHRpb25zLCByZWFsdGltZTogcmVhbHRpbWVPcHRpb25zLCBnbG9iYWw6IGdsb2JhbE9wdGlvbnMgfSA9IG9wdGlvbnM7XG5cdGNvbnN0IHsgZGI6IERFRkFVTFRfREJfT1BUSU9OUyQxLCBhdXRoOiBERUZBVUxUX0FVVEhfT1BUSU9OUyQxLCByZWFsdGltZTogREVGQVVMVF9SRUFMVElNRV9PUFRJT05TJDEsIGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OUyQxIH0gPSBkZWZhdWx0cztcblx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdGRiOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9EQl9PUFRJT05TJDEpLCBkYk9wdGlvbnMpLFxuXHRcdGF1dGg6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0FVVEhfT1BUSU9OUyQxKSwgYXV0aE9wdGlvbnMpLFxuXHRcdHJlYWx0aW1lOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9SRUFMVElNRV9PUFRJT05TJDEpLCByZWFsdGltZU9wdGlvbnMpLFxuXHRcdHN0b3JhZ2U6IHt9LFxuXHRcdGdsb2JhbDogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfR0xPQkFMX09QVElPTlMkMSksIGdsb2JhbE9wdGlvbnMpLCB7fSwgeyBoZWFkZXJzOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgKF9ERUZBVUxUX0dMT0JBTF9PUFRJTyA9IERFRkFVTFRfR0xPQkFMX09QVElPTlMkMSA9PT0gbnVsbCB8fCBERUZBVUxUX0dMT0JBTF9PUFRJT05TJDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IERFRkFVTFRfR0xPQkFMX09QVElPTlMkMS5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfREVGQVVMVF9HTE9CQUxfT1BUSU8gIT09IHZvaWQgMCA/IF9ERUZBVUxUX0dMT0JBTF9PUFRJTyA6IHt9KSwgKF9nbG9iYWxPcHRpb25zJGhlYWRlciA9IGdsb2JhbE9wdGlvbnMgPT09IG51bGwgfHwgZ2xvYmFsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2xvYmFsT3B0aW9ucy5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfZ2xvYmFsT3B0aW9ucyRoZWFkZXIgIT09IHZvaWQgMCA/IF9nbG9iYWxPcHRpb25zJGhlYWRlciA6IHt9KSB9KSxcblx0XHRhY2Nlc3NUb2tlbjogYXN5bmMgKCkgPT4gXCJcIlxuXHR9O1xuXHRpZiAob3B0aW9ucy5hY2Nlc3NUb2tlbikgcmVzdWx0LmFjY2Vzc1Rva2VuID0gb3B0aW9ucy5hY2Nlc3NUb2tlbjtcblx0ZWxzZSBkZWxldGUgcmVzdWx0LmFjY2Vzc1Rva2VuO1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4qIFZhbGlkYXRlcyBhIFN1cGFiYXNlIGNsaWVudCBVUkxcbipcbiogQHBhcmFtIHtzdHJpbmd9IHN1cGFiYXNlVXJsIC0gVGhlIFN1cGFiYXNlIGNsaWVudCBVUkwgc3RyaW5nLlxuKiBAcmV0dXJucyB7VVJMfSAtIFRoZSB2YWxpZGF0ZWQgYmFzZSBVUkwuXG4qIEB0aHJvd3Mge0Vycm9yfVxuKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU3VwYWJhc2VVcmwoc3VwYWJhc2VVcmwpIHtcblx0Y29uc3QgdHJpbW1lZFVybCA9IHN1cGFiYXNlVXJsID09PSBudWxsIHx8IHN1cGFiYXNlVXJsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdXBhYmFzZVVybC50cmltKCk7XG5cdGlmICghdHJpbW1lZFVybCkgdGhyb3cgbmV3IEVycm9yKFwic3VwYWJhc2VVcmwgaXMgcmVxdWlyZWQuXCIpO1xuXHRpZiAoIXRyaW1tZWRVcmwubWF0Y2goL15odHRwcz86XFwvXFwvL2kpKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN1cGFiYXNlVXJsOiBNdXN0IGJlIGEgdmFsaWQgSFRUUCBvciBIVFRQUyBVUkwuXCIpO1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgVVJMKGVuc3VyZVRyYWlsaW5nU2xhc2godHJpbW1lZFVybCkpO1xuXHR9IGNhdGNoIChfdW51c2VkKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJJbnZhbGlkIHN1cGFiYXNlVXJsOiBQcm92aWRlZCBVUkwgaXMgbWFsZm9ybWVkLlwiKTtcblx0fVxufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL1N1cGFiYXNlQXV0aENsaWVudC50c1xudmFyIFN1cGFiYXNlQXV0aENsaWVudCA9IGNsYXNzIGV4dGVuZHMgX19zdXBhYmFzZV9hdXRoX2pzLkF1dGhDbGllbnQge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9TdXBhYmFzZUNsaWVudC50c1xuLyoqXG4qIFN1cGFiYXNlIENsaWVudC5cbipcbiogQW4gaXNvbW9ycGhpYyBKYXZhc2NyaXB0IGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBQb3N0Z3Jlcy5cbiovXG52YXIgU3VwYWJhc2VDbGllbnQgPSBjbGFzcyB7XG5cdC8qKlxuXHQqIENyZWF0ZSBhIG5ldyBjbGllbnQgZm9yIHVzZSBpbiB0aGUgYnJvd3Nlci5cblx0KiBAcGFyYW0gc3VwYWJhc2VVcmwgVGhlIHVuaXF1ZSBTdXBhYmFzZSBVUkwgd2hpY2ggaXMgc3VwcGxpZWQgd2hlbiB5b3UgY3JlYXRlIGEgbmV3IHByb2plY3QgaW4geW91ciBwcm9qZWN0IGRhc2hib2FyZC5cblx0KiBAcGFyYW0gc3VwYWJhc2VLZXkgVGhlIHVuaXF1ZSBTdXBhYmFzZSBLZXkgd2hpY2ggaXMgc3VwcGxpZWQgd2hlbiB5b3UgY3JlYXRlIGEgbmV3IHByb2plY3QgaW4geW91ciBwcm9qZWN0IGRhc2hib2FyZC5cblx0KiBAcGFyYW0gb3B0aW9ucy5kYi5zY2hlbWEgWW91IGNhbiBzd2l0Y2ggaW4gYmV0d2VlbiBzY2hlbWFzLiBUaGUgc2NoZW1hIG5lZWRzIHRvIGJlIG9uIHRoZSBsaXN0IG9mIGV4cG9zZWQgc2NoZW1hcyBpbnNpZGUgU3VwYWJhc2UuXG5cdCogQHBhcmFtIG9wdGlvbnMuYXV0aC5hdXRvUmVmcmVzaFRva2VuIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlZnJlc2ggdGhlIHRva2VuIGJlZm9yZSBleHBpcmluZy5cblx0KiBAcGFyYW0gb3B0aW9ucy5hdXRoLnBlcnNpc3RTZXNzaW9uIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHNhdmUgdGhlIHVzZXIgc2Vzc2lvbiBpbnRvIGxvY2FsIHN0b3JhZ2UuXG5cdCogQHBhcmFtIG9wdGlvbnMuYXV0aC5kZXRlY3RTZXNzaW9uSW5VcmwgU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyBPQXV0aCBncmFudHMgaW4gdGhlIFVSTCBhbmQgc2lnbnMgaW4gdGhlIHVzZXIuXG5cdCogQHBhcmFtIG9wdGlvbnMucmVhbHRpbWUgT3B0aW9ucyBwYXNzZWQgYWxvbmcgdG8gcmVhbHRpbWUtanMgY29uc3RydWN0b3IuXG5cdCogQHBhcmFtIG9wdGlvbnMuc3RvcmFnZSBPcHRpb25zIHBhc3NlZCBhbG9uZyB0byB0aGUgc3RvcmFnZS1qcyBjb25zdHJ1Y3Rvci5cblx0KiBAcGFyYW0gb3B0aW9ucy5nbG9iYWwuZmV0Y2ggQSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24uXG5cdCogQHBhcmFtIG9wdGlvbnMuZ2xvYmFsLmhlYWRlcnMgQW55IGFkZGl0aW9uYWwgaGVhZGVycyB0byBzZW5kIHdpdGggZWFjaCBuZXR3b3JrIHJlcXVlc3QuXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0c1xuXHQqIGltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcblx0KlxuXHQqIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28nLCAncHVibGljLWFub24ta2V5Jylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Byb2ZpbGVzJykuc2VsZWN0KCcqJylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3Ioc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5LCBvcHRpb25zKSB7XG5cdFx0dmFyIF9zZXR0aW5ncyRhdXRoJHN0b3JhZywgX3NldHRpbmdzJGdsb2JhbCRoZWFkO1xuXHRcdHRoaXMuc3VwYWJhc2VVcmwgPSBzdXBhYmFzZVVybDtcblx0XHR0aGlzLnN1cGFiYXNlS2V5ID0gc3VwYWJhc2VLZXk7XG5cdFx0Y29uc3QgYmFzZVVybCA9IHZhbGlkYXRlU3VwYWJhc2VVcmwoc3VwYWJhc2VVcmwpO1xuXHRcdGlmICghc3VwYWJhc2VLZXkpIHRocm93IG5ldyBFcnJvcihcInN1cGFiYXNlS2V5IGlzIHJlcXVpcmVkLlwiKTtcblx0XHR0aGlzLnJlYWx0aW1lVXJsID0gbmV3IFVSTChcInJlYWx0aW1lL3YxXCIsIGJhc2VVcmwpO1xuXHRcdHRoaXMucmVhbHRpbWVVcmwucHJvdG9jb2wgPSB0aGlzLnJlYWx0aW1lVXJsLnByb3RvY29sLnJlcGxhY2UoXCJodHRwXCIsIFwid3NcIik7XG5cdFx0dGhpcy5hdXRoVXJsID0gbmV3IFVSTChcImF1dGgvdjFcIiwgYmFzZVVybCk7XG5cdFx0dGhpcy5zdG9yYWdlVXJsID0gbmV3IFVSTChcInN0b3JhZ2UvdjFcIiwgYmFzZVVybCk7XG5cdFx0dGhpcy5mdW5jdGlvbnNVcmwgPSBuZXcgVVJMKFwiZnVuY3Rpb25zL3YxXCIsIGJhc2VVcmwpO1xuXHRcdGNvbnN0IGRlZmF1bHRTdG9yYWdlS2V5ID0gYHNiLSR7YmFzZVVybC5ob3N0bmFtZS5zcGxpdChcIi5cIilbMF19LWF1dGgtdG9rZW5gO1xuXHRcdGNvbnN0IERFRkFVTFRTID0ge1xuXHRcdFx0ZGI6IERFRkFVTFRfREJfT1BUSU9OUyxcblx0XHRcdHJlYWx0aW1lOiBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsXG5cdFx0XHRhdXRoOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9BVVRIX09QVElPTlMpLCB7fSwgeyBzdG9yYWdlS2V5OiBkZWZhdWx0U3RvcmFnZUtleSB9KSxcblx0XHRcdGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OU1xuXHRcdH07XG5cdFx0Y29uc3Qgc2V0dGluZ3MgPSBhcHBseVNldHRpbmdEZWZhdWx0cyhvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSwgREVGQVVMVFMpO1xuXHRcdHRoaXMuc3RvcmFnZUtleSA9IChfc2V0dGluZ3MkYXV0aCRzdG9yYWcgPSBzZXR0aW5ncy5hdXRoLnN0b3JhZ2VLZXkpICE9PSBudWxsICYmIF9zZXR0aW5ncyRhdXRoJHN0b3JhZyAhPT0gdm9pZCAwID8gX3NldHRpbmdzJGF1dGgkc3RvcmFnIDogXCJcIjtcblx0XHR0aGlzLmhlYWRlcnMgPSAoX3NldHRpbmdzJGdsb2JhbCRoZWFkID0gc2V0dGluZ3MuZ2xvYmFsLmhlYWRlcnMpICE9PSBudWxsICYmIF9zZXR0aW5ncyRnbG9iYWwkaGVhZCAhPT0gdm9pZCAwID8gX3NldHRpbmdzJGdsb2JhbCRoZWFkIDoge307XG5cdFx0aWYgKCFzZXR0aW5ncy5hY2Nlc3NUb2tlbikge1xuXHRcdFx0dmFyIF9zZXR0aW5ncyRhdXRoO1xuXHRcdFx0dGhpcy5hdXRoID0gdGhpcy5faW5pdFN1cGFiYXNlQXV0aENsaWVudCgoX3NldHRpbmdzJGF1dGggPSBzZXR0aW5ncy5hdXRoKSAhPT0gbnVsbCAmJiBfc2V0dGluZ3MkYXV0aCAhPT0gdm9pZCAwID8gX3NldHRpbmdzJGF1dGggOiB7fSwgdGhpcy5oZWFkZXJzLCBzZXR0aW5ncy5nbG9iYWwuZmV0Y2gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFjY2Vzc1Rva2VuID0gc2V0dGluZ3MuYWNjZXNzVG9rZW47XG5cdFx0XHR0aGlzLmF1dGggPSBuZXcgUHJveHkoe30sIHsgZ2V0OiAoXywgcHJvcCkgPT4ge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9zdXBhYmFzZS1qczogU3VwYWJhc2UgQ2xpZW50IGlzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgYWNjZXNzVG9rZW4gb3B0aW9uLCBhY2Nlc3Npbmcgc3VwYWJhc2UuYXV0aC4ke1N0cmluZyhwcm9wKX0gaXMgbm90IHBvc3NpYmxlYCk7XG5cdFx0XHR9IH0pO1xuXHRcdH1cblx0XHR0aGlzLmZldGNoID0gZmV0Y2hXaXRoQXV0aChzdXBhYmFzZUtleSwgdGhpcy5fZ2V0QWNjZXNzVG9rZW4uYmluZCh0aGlzKSwgc2V0dGluZ3MuZ2xvYmFsLmZldGNoKTtcblx0XHR0aGlzLnJlYWx0aW1lID0gdGhpcy5faW5pdFJlYWx0aW1lQ2xpZW50KF9vYmplY3RTcHJlYWQyKHtcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdGFjY2Vzc1Rva2VuOiB0aGlzLl9nZXRBY2Nlc3NUb2tlbi5iaW5kKHRoaXMpXG5cdFx0fSwgc2V0dGluZ3MucmVhbHRpbWUpKTtcblx0XHRpZiAodGhpcy5hY2Nlc3NUb2tlbikgUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWNjZXNzVG9rZW4oKSkudGhlbigodG9rZW4pID0+IHRoaXMucmVhbHRpbWUuc2V0QXV0aCh0b2tlbikpLmNhdGNoKChlKSA9PiBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gc2V0IGluaXRpYWwgUmVhbHRpbWUgYXV0aCB0b2tlbjpcIiwgZSkpO1xuXHRcdHRoaXMucmVzdCA9IG5ldyBfX3N1cGFiYXNlX3Bvc3RncmVzdF9qcy5Qb3N0Z3Jlc3RDbGllbnQobmV3IFVSTChcInJlc3QvdjFcIiwgYmFzZVVybCkuaHJlZiwge1xuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0c2NoZW1hOiBzZXR0aW5ncy5kYi5zY2hlbWEsXG5cdFx0XHRmZXRjaDogdGhpcy5mZXRjaFxuXHRcdH0pO1xuXHRcdHRoaXMuc3RvcmFnZSA9IG5ldyBfX3N1cGFiYXNlX3N0b3JhZ2VfanMuU3RvcmFnZUNsaWVudCh0aGlzLnN0b3JhZ2VVcmwuaHJlZiwgdGhpcy5oZWFkZXJzLCB0aGlzLmZldGNoLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RvcmFnZSk7XG5cdFx0aWYgKCFzZXR0aW5ncy5hY2Nlc3NUb2tlbikgdGhpcy5fbGlzdGVuRm9yQXV0aEV2ZW50cygpO1xuXHR9XG5cdC8qKlxuXHQqIFN1cGFiYXNlIEZ1bmN0aW9ucyBhbGxvd3MgeW91IHRvIGRlcGxveSBhbmQgaW52b2tlIGVkZ2UgZnVuY3Rpb25zLlxuXHQqL1xuXHRnZXQgZnVuY3Rpb25zKCkge1xuXHRcdHJldHVybiBuZXcgX19zdXBhYmFzZV9mdW5jdGlvbnNfanMuRnVuY3Rpb25zQ2xpZW50KHRoaXMuZnVuY3Rpb25zVXJsLmhyZWYsIHtcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdGN1c3RvbUZldGNoOiB0aGlzLmZldGNoXG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuXHQqXG5cdCogQHBhcmFtIHJlbGF0aW9uIC0gVGhlIHRhYmxlIG9yIHZpZXcgbmFtZSB0byBxdWVyeVxuXHQqL1xuXHRmcm9tKHJlbGF0aW9uKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVzdC5mcm9tKHJlbGF0aW9uKTtcblx0fVxuXHQvKipcblx0KiBTZWxlY3QgYSBzY2hlbWEgdG8gcXVlcnkgb3IgcGVyZm9ybSBhbiBmdW5jdGlvbiAocnBjKSBjYWxsLlxuXHQqXG5cdCogVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuXHQqXG5cdCogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgdG8gcXVlcnlcblx0Ki9cblx0c2NoZW1hKHNjaGVtYSkge1xuXHRcdHJldHVybiB0aGlzLnJlc3Quc2NoZW1hKHNjaGVtYSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIGZ1bmN0aW9uIGNhbGwuXG5cdCpcblx0KiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gbmFtZSB0byBjYWxsXG5cdCogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uIGNhbGxcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG5cdCogVXNlZnVsIGlmIHlvdSBvbmx5IG5lZWQgdGhlIGNvdW50LlxuXHQqIEBwYXJhbSBvcHRpb25zLmdldCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGhcblx0KiByZWFkLW9ubHkgYWNjZXNzIG1vZGUuXG5cdCogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHJvd3MgcmV0dXJuZWQgYnkgdGhlXG5cdCogZnVuY3Rpb24uIE9ubHkgYXBwbGljYWJsZSBmb3IgW3NldC1yZXR1cm5pbmdcblx0KiBmdW5jdGlvbnNdKGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9mdW5jdGlvbnMtc3JmLmh0bWwpLlxuXHQqXG5cdCogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuXHQqIGhvb2QuXG5cdCpcblx0KiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuXHQqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG5cdCpcblx0KiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG5cdCogbnVtYmVycy5cblx0Ki9cblx0cnBjKGZuLCBhcmdzID0ge30sIG9wdGlvbnMgPSB7XG5cdFx0aGVhZDogZmFsc2UsXG5cdFx0Z2V0OiBmYWxzZSxcblx0XHRjb3VudDogdm9pZCAwXG5cdH0pIHtcblx0XHRyZXR1cm4gdGhpcy5yZXN0LnJwYyhmbiwgYXJncywgb3B0aW9ucyk7XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBhIFJlYWx0aW1lIGNoYW5uZWwgd2l0aCBCcm9hZGNhc3QsIFByZXNlbmNlLCBhbmQgUG9zdGdyZXMgQ2hhbmdlcy5cblx0KlxuXHQqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG5cdCogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuXHQqXG5cdCovXG5cdGNoYW5uZWwobmFtZSwgb3B0cyA9IHsgY29uZmlnOiB7fSB9KSB7XG5cdFx0cmV0dXJuIHRoaXMucmVhbHRpbWUuY2hhbm5lbChuYW1lLCBvcHRzKTtcblx0fVxuXHQvKipcblx0KiBSZXR1cm5zIGFsbCBSZWFsdGltZSBjaGFubmVscy5cblx0Ki9cblx0Z2V0Q2hhbm5lbHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVhbHRpbWUuZ2V0Q2hhbm5lbHMoKTtcblx0fVxuXHQvKipcblx0KiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgUmVhbHRpbWUgY2hhbm5lbCBmcm9tIFJlYWx0aW1lIGNsaWVudC5cblx0KlxuXHQqIEBwYXJhbSB7UmVhbHRpbWVDaGFubmVsfSBjaGFubmVsIC0gVGhlIG5hbWUgb2YgdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG5cdCpcblx0Ki9cblx0cmVtb3ZlQ2hhbm5lbChjaGFubmVsKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVhbHRpbWUucmVtb3ZlQ2hhbm5lbChjaGFubmVsKTtcblx0fVxuXHQvKipcblx0KiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYWxsIFJlYWx0aW1lIGNoYW5uZWxzIGZyb20gUmVhbHRpbWUgY2xpZW50LlxuXHQqL1xuXHRyZW1vdmVBbGxDaGFubmVscygpIHtcblx0XHRyZXR1cm4gdGhpcy5yZWFsdGltZS5yZW1vdmVBbGxDaGFubmVscygpO1xuXHR9XG5cdGFzeW5jIF9nZXRBY2Nlc3NUb2tlbigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBfZGF0YSRzZXNzaW9uJGFjY2Vzc18sIF9kYXRhJHNlc3Npb247XG5cdFx0aWYgKF90aGlzLmFjY2Vzc1Rva2VuKSByZXR1cm4gYXdhaXQgX3RoaXMuYWNjZXNzVG9rZW4oKTtcblx0XHRjb25zdCB7IGRhdGEgfSA9IGF3YWl0IF90aGlzLmF1dGguZ2V0U2Vzc2lvbigpO1xuXHRcdHJldHVybiAoX2RhdGEkc2Vzc2lvbiRhY2Nlc3NfID0gKF9kYXRhJHNlc3Npb24gPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9kYXRhJHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kYXRhJHNlc3Npb24uYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfZGF0YSRzZXNzaW9uJGFjY2Vzc18gIT09IHZvaWQgMCA/IF9kYXRhJHNlc3Npb24kYWNjZXNzXyA6IF90aGlzLnN1cGFiYXNlS2V5O1xuXHR9XG5cdF9pbml0U3VwYWJhc2VBdXRoQ2xpZW50KHsgYXV0b1JlZnJlc2hUb2tlbiwgcGVyc2lzdFNlc3Npb24sIGRldGVjdFNlc3Npb25JblVybCwgc3RvcmFnZSwgdXNlclN0b3JhZ2UsIHN0b3JhZ2VLZXksIGZsb3dUeXBlLCBsb2NrLCBkZWJ1ZywgdGhyb3dPbkVycm9yIH0sIGhlYWRlcnMsIGZldGNoJDEpIHtcblx0XHRjb25zdCBhdXRoSGVhZGVycyA9IHtcblx0XHRcdEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLnN1cGFiYXNlS2V5fWAsXG5cdFx0XHRhcGlrZXk6IGAke3RoaXMuc3VwYWJhc2VLZXl9YFxuXHRcdH07XG5cdFx0cmV0dXJuIG5ldyBTdXBhYmFzZUF1dGhDbGllbnQoe1xuXHRcdFx0dXJsOiB0aGlzLmF1dGhVcmwuaHJlZixcblx0XHRcdGhlYWRlcnM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBhdXRoSGVhZGVycyksIGhlYWRlcnMpLFxuXHRcdFx0c3RvcmFnZUtleSxcblx0XHRcdGF1dG9SZWZyZXNoVG9rZW4sXG5cdFx0XHRwZXJzaXN0U2Vzc2lvbixcblx0XHRcdGRldGVjdFNlc3Npb25JblVybCxcblx0XHRcdHN0b3JhZ2UsXG5cdFx0XHR1c2VyU3RvcmFnZSxcblx0XHRcdGZsb3dUeXBlLFxuXHRcdFx0bG9jayxcblx0XHRcdGRlYnVnLFxuXHRcdFx0dGhyb3dPbkVycm9yLFxuXHRcdFx0ZmV0Y2g6IGZldGNoJDEsXG5cdFx0XHRoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyOiBPYmplY3Qua2V5cyh0aGlzLmhlYWRlcnMpLnNvbWUoKGtleSkgPT4ga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwiYXV0aG9yaXphdGlvblwiKVxuXHRcdH0pO1xuXHR9XG5cdF9pbml0UmVhbHRpbWVDbGllbnQob3B0aW9ucykge1xuXHRcdHJldHVybiBuZXcgX19zdXBhYmFzZV9yZWFsdGltZV9qcy5SZWFsdGltZUNsaWVudCh0aGlzLnJlYWx0aW1lVXJsLmhyZWYsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHsgcGFyYW1zOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgeyBhcGlrZXk6IHRoaXMuc3VwYWJhc2VLZXkgfSksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpIH0pKTtcblx0fVxuXHRfbGlzdGVuRm9yQXV0aEV2ZW50cygpIHtcblx0XHRyZXR1cm4gdGhpcy5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKChldmVudCwgc2Vzc2lvbikgPT4ge1xuXHRcdFx0dGhpcy5faGFuZGxlVG9rZW5DaGFuZ2VkKGV2ZW50LCBcIkNMSUVOVFwiLCBzZXNzaW9uID09PSBudWxsIHx8IHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb24uYWNjZXNzX3Rva2VuKTtcblx0XHR9KTtcblx0fVxuXHRfaGFuZGxlVG9rZW5DaGFuZ2VkKGV2ZW50LCBzb3VyY2UsIHRva2VuKSB7XG5cdFx0aWYgKChldmVudCA9PT0gXCJUT0tFTl9SRUZSRVNIRURcIiB8fCBldmVudCA9PT0gXCJTSUdORURfSU5cIikgJiYgdGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gIT09IHRva2VuKSB7XG5cdFx0XHR0aGlzLmNoYW5nZWRBY2Nlc3NUb2tlbiA9IHRva2VuO1xuXHRcdFx0dGhpcy5yZWFsdGltZS5zZXRBdXRoKHRva2VuKTtcblx0XHR9IGVsc2UgaWYgKGV2ZW50ID09PSBcIlNJR05FRF9PVVRcIikge1xuXHRcdFx0dGhpcy5yZWFsdGltZS5zZXRBdXRoKCk7XG5cdFx0XHRpZiAoc291cmNlID09IFwiU1RPUkFHRVwiKSB0aGlzLmF1dGguc2lnbk91dCgpO1xuXHRcdFx0dGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gPSB2b2lkIDA7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvaW5kZXgudHNcbi8qKlxuKiBDcmVhdGVzIGEgbmV3IFN1cGFiYXNlIENsaWVudC5cbipcbiogQGV4YW1wbGVcbiogYGBgdHNcbiogaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xuKlxuKiBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudCgnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvJywgJ3B1YmxpYy1hbm9uLWtleScpXG4qIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Byb2ZpbGVzJykuc2VsZWN0KCcqJylcbiogYGBgXG4qL1xuY29uc3QgY3JlYXRlQ2xpZW50ID0gKHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucykgPT4ge1xuXHRyZXR1cm4gbmV3IFN1cGFiYXNlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucyk7XG59O1xuZnVuY3Rpb24gc2hvdWxkU2hvd0RlcHJlY2F0aW9uV2FybmluZygpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcblx0Y29uc3QgX3Byb2Nlc3MgPSBnbG9iYWxUaGlzW1wicHJvY2Vzc1wiXTtcblx0aWYgKCFfcHJvY2VzcykgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCBwcm9jZXNzVmVyc2lvbiA9IF9wcm9jZXNzW1widmVyc2lvblwiXTtcblx0aWYgKHByb2Nlc3NWZXJzaW9uID09PSB2b2lkIDAgfHwgcHJvY2Vzc1ZlcnNpb24gPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0Y29uc3QgdmVyc2lvbk1hdGNoID0gcHJvY2Vzc1ZlcnNpb24ubWF0Y2goL152KFxcZCspXFwuLyk7XG5cdGlmICghdmVyc2lvbk1hdGNoKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiBwYXJzZUludCh2ZXJzaW9uTWF0Y2hbMV0sIDEwKSA8PSAxODtcbn1cbmlmIChzaG91bGRTaG93RGVwcmVjYXRpb25XYXJuaW5nKCkpIGNvbnNvbGUud2FybihcIuKaoO+4jyAgTm9kZS5qcyAxOCBhbmQgYmVsb3cgYXJlIGRlcHJlY2F0ZWQgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgQHN1cGFiYXNlL3N1cGFiYXNlLWpzLiBQbGVhc2UgdXBncmFkZSB0byBOb2RlLmpzIDIwIG9yIGxhdGVyLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgdmlzaXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9vcmdzL3N1cGFiYXNlL2Rpc2N1c3Npb25zLzM3MjE3XCIpO1xuXG4vLyNlbmRyZWdpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRnVuY3Rpb25SZWdpb24nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX3N1cGFiYXNlX2Z1bmN0aW9uc19qcy5GdW5jdGlvblJlZ2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Z1bmN0aW9uc0Vycm9yJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX19zdXBhYmFzZV9mdW5jdGlvbnNfanMuRnVuY3Rpb25zRXJyb3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdGdW5jdGlvbnNGZXRjaEVycm9yJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX19zdXBhYmFzZV9mdW5jdGlvbnNfanMuRnVuY3Rpb25zRmV0Y2hFcnJvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Z1bmN0aW9uc0h0dHBFcnJvcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fc3VwYWJhc2VfZnVuY3Rpb25zX2pzLkZ1bmN0aW9uc0h0dHBFcnJvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Z1bmN0aW9uc1JlbGF5RXJyb3InLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX3N1cGFiYXNlX2Z1bmN0aW9uc19qcy5GdW5jdGlvbnNSZWxheUVycm9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnUG9zdGdyZXN0RXJyb3InLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX3N1cGFiYXNlX3Bvc3RncmVzdF9qcy5Qb3N0Z3Jlc3RFcnJvcjtcbiAgfVxufSk7XG5leHBvcnRzLlN1cGFiYXNlQ2xpZW50ID0gU3VwYWJhc2VDbGllbnQ7XG5leHBvcnRzLmNyZWF0ZUNsaWVudCA9IGNyZWF0ZUNsaWVudDtcbk9iamVjdC5rZXlzKF9fc3VwYWJhc2VfYXV0aF9qcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICBpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgaykpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fc3VwYWJhc2VfYXV0aF9qc1trXTsgfVxuICB9KTtcbn0pO1xuXG5PYmplY3Qua2V5cyhfX3N1cGFiYXNlX3JlYWx0aW1lX2pzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gIGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX19zdXBhYmFzZV9yZWFsdGltZV9qc1trXTsgfVxuICB9KTtcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwIl0sIm5hbWVzIjpbIl9fc3VwYWJhc2VfZnVuY3Rpb25zX2pzIiwicmVxdWlyZSIsIl9fc3VwYWJhc2VfcG9zdGdyZXN0X2pzIiwiX19zdXBhYmFzZV9yZWFsdGltZV9qcyIsIl9fc3VwYWJhc2Vfc3RvcmFnZV9qcyIsIl9fc3VwYWJhc2VfYXV0aF9qcyIsInZlcnNpb24iLCJKU19FTlYiLCJEZW5vIiwiZG9jdW1lbnQiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwiREVGQVVMVF9IRUFERVJTIiwiREVGQVVMVF9HTE9CQUxfT1BUSU9OUyIsImhlYWRlcnMiLCJERUZBVUxUX0RCX09QVElPTlMiLCJzY2hlbWEiLCJERUZBVUxUX0FVVEhfT1BUSU9OUyIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsImRldGVjdFNlc3Npb25JblVybCIsImZsb3dUeXBlIiwiREVGQVVMVF9SRUFMVElNRV9PUFRJT05TIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsIm8kMSIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwidG9QcmltaXRpdmUiLCJ0IiwiciIsImUiLCJpIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsInRvUHJvcGVydHlLZXkiLCJfZGVmaW5lUHJvcGVydHkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJyJDEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsInJlc29sdmVGZXRjaCIsImN1c3RvbUZldGNoIiwiYXJncyIsImZldGNoIiwicmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvciIsIkhlYWRlcnMiLCJmZXRjaFdpdGhBdXRoIiwic3VwYWJhc2VLZXkiLCJnZXRBY2Nlc3NUb2tlbiIsImZldGNoJDEiLCJIZWFkZXJzQ29uc3RydWN0b3IiLCJpbnB1dCIsImluaXQiLCJfYXdhaXQkZ2V0QWNjZXNzVG9rZW4iLCJhY2Nlc3NUb2tlbiIsImhhcyIsInNldCIsImVuc3VyZVRyYWlsaW5nU2xhc2giLCJ1cmwiLCJlbmRzV2l0aCIsImFwcGx5U2V0dGluZ0RlZmF1bHRzIiwib3B0aW9ucyIsImRlZmF1bHRzIiwiX0RFRkFVTFRfR0xPQkFMX09QVElPIiwiX2dsb2JhbE9wdGlvbnMkaGVhZGVyIiwiZGIiLCJkYk9wdGlvbnMiLCJhdXRoIiwiYXV0aE9wdGlvbnMiLCJyZWFsdGltZSIsInJlYWx0aW1lT3B0aW9ucyIsImdsb2JhbCIsImdsb2JhbE9wdGlvbnMiLCJERUZBVUxUX0RCX09QVElPTlMkMSIsIkRFRkFVTFRfQVVUSF9PUFRJT05TJDEiLCJERUZBVUxUX1JFQUxUSU1FX09QVElPTlMkMSIsIkRFRkFVTFRfR0xPQkFMX09QVElPTlMkMSIsInJlc3VsdCIsInN0b3JhZ2UiLCJ2YWxpZGF0ZVN1cGFiYXNlVXJsIiwic3VwYWJhc2VVcmwiLCJ0cmltbWVkVXJsIiwidHJpbSIsIkVycm9yIiwibWF0Y2giLCJVUkwiLCJfdW51c2VkIiwiU3VwYWJhc2VBdXRoQ2xpZW50IiwiQXV0aENsaWVudCIsIlN1cGFiYXNlQ2xpZW50IiwiX3NldHRpbmdzJGF1dGgkc3RvcmFnIiwiX3NldHRpbmdzJGdsb2JhbCRoZWFkIiwiYmFzZVVybCIsInJlYWx0aW1lVXJsIiwicHJvdG9jb2wiLCJyZXBsYWNlIiwiYXV0aFVybCIsInN0b3JhZ2VVcmwiLCJmdW5jdGlvbnNVcmwiLCJkZWZhdWx0U3RvcmFnZUtleSIsImhvc3RuYW1lIiwic3BsaXQiLCJERUZBVUxUUyIsInN0b3JhZ2VLZXkiLCJzZXR0aW5ncyIsIl9zZXR0aW5ncyRhdXRoIiwiX2luaXRTdXBhYmFzZUF1dGhDbGllbnQiLCJQcm94eSIsImdldCIsIl8iLCJwcm9wIiwiX2dldEFjY2Vzc1Rva2VuIiwiYmluZCIsIl9pbml0UmVhbHRpbWVDbGllbnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJ0b2tlbiIsInNldEF1dGgiLCJjYXRjaCIsImNvbnNvbGUiLCJ3YXJuIiwicmVzdCIsIlBvc3RncmVzdENsaWVudCIsImhyZWYiLCJTdG9yYWdlQ2xpZW50IiwiX2xpc3RlbkZvckF1dGhFdmVudHMiLCJmdW5jdGlvbnMiLCJGdW5jdGlvbnNDbGllbnQiLCJmcm9tIiwicmVsYXRpb24iLCJycGMiLCJmbiIsImhlYWQiLCJjb3VudCIsImNoYW5uZWwiLCJuYW1lIiwib3B0cyIsImNvbmZpZyIsImdldENoYW5uZWxzIiwicmVtb3ZlQ2hhbm5lbCIsInJlbW92ZUFsbENoYW5uZWxzIiwiX3RoaXMiLCJfZGF0YSRzZXNzaW9uJGFjY2Vzc18iLCJfZGF0YSRzZXNzaW9uIiwiZGF0YSIsImdldFNlc3Npb24iLCJzZXNzaW9uIiwiYWNjZXNzX3Rva2VuIiwidXNlclN0b3JhZ2UiLCJsb2NrIiwiZGVidWciLCJ0aHJvd09uRXJyb3IiLCJhdXRoSGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJhcGlrZXkiLCJoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyIiwic29tZSIsImtleSIsInRvTG93ZXJDYXNlIiwiUmVhbHRpbWVDbGllbnQiLCJwYXJhbXMiLCJvbkF1dGhTdGF0ZUNoYW5nZSIsImV2ZW50IiwiX2hhbmRsZVRva2VuQ2hhbmdlZCIsInNvdXJjZSIsImNoYW5nZWRBY2Nlc3NUb2tlbiIsInNpZ25PdXQiLCJjcmVhdGVDbGllbnQiLCJzaG91bGRTaG93RGVwcmVjYXRpb25XYXJuaW5nIiwiX3Byb2Nlc3MiLCJnbG9iYWxUaGlzIiwicHJvY2Vzc1ZlcnNpb24iLCJ2ZXJzaW9uTWF0Y2giLCJwYXJzZUludCIsImV4cG9ydHMiLCJGdW5jdGlvblJlZ2lvbiIsIkZ1bmN0aW9uc0Vycm9yIiwiRnVuY3Rpb25zRmV0Y2hFcnJvciIsIkZ1bmN0aW9uc0h0dHBFcnJvciIsIkZ1bmN0aW9uc1JlbGF5RXJyb3IiLCJQb3N0Z3Jlc3RFcnJvciIsImsiLCJoYXNPd25Qcm9wZXJ0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/supabase-js/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/postgrest-js/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgrestBuilder: () => (/* binding */ PostgrestBuilder),\n/* harmony export */   PostgrestClient: () => (/* binding */ PostgrestClient),\n/* harmony export */   PostgrestError: () => (/* binding */ PostgrestError),\n/* harmony export */   PostgrestFilterBuilder: () => (/* binding */ PostgrestFilterBuilder),\n/* harmony export */   PostgrestQueryBuilder: () => (/* binding */ PostgrestQueryBuilder),\n/* harmony export */   PostgrestTransformBuilder: () => (/* binding */ PostgrestTransformBuilder),\n/* harmony export */   \"default\": () => (/* binding */ src_default)\n/* harmony export */ });\n//#region src/PostgrestError.ts\n/**\n* Error format\n*\n* {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n*/ var PostgrestError = class extends Error {\n    /**\n\t* @example\n\t* ```ts\n\t* import PostgrestError from '@supabase/postgrest-js'\n\t*\n\t* throw new PostgrestError({\n\t*   message: 'Row level security prevented the request',\n\t*   details: 'RLS denied the insert',\n\t*   hint: 'Check your policies',\n\t*   code: 'PGRST301',\n\t* })\n\t* ```\n\t*/ constructor(context){\n        super(context.message);\n        this.name = \"PostgrestError\";\n        this.details = context.details;\n        this.hint = context.hint;\n        this.code = context.code;\n    }\n};\n//#endregion\n//#region src/PostgrestBuilder.ts\nvar PostgrestBuilder = class {\n    /**\n\t* Creates a builder configured for a specific PostgREST request.\n\t*\n\t* @example\n\t* ```ts\n\t* import PostgrestQueryBuilder from '@supabase/postgrest-js'\n\t*\n\t* const builder = new PostgrestQueryBuilder(\n\t*   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n\t*   { headers: new Headers({ apikey: 'public-anon-key' }) }\n\t* )\n\t* ```\n\t*/ constructor(builder){\n        var _builder$shouldThrowO, _builder$isMaybeSingl;\n        this.shouldThrowOnError = false;\n        this.method = builder.method;\n        this.url = builder.url;\n        this.headers = new Headers(builder.headers);\n        this.schema = builder.schema;\n        this.body = builder.body;\n        this.shouldThrowOnError = (_builder$shouldThrowO = builder.shouldThrowOnError) !== null && _builder$shouldThrowO !== void 0 ? _builder$shouldThrowO : false;\n        this.signal = builder.signal;\n        this.isMaybeSingle = (_builder$isMaybeSingl = builder.isMaybeSingle) !== null && _builder$isMaybeSingl !== void 0 ? _builder$isMaybeSingl : false;\n        if (builder.fetch) this.fetch = builder.fetch;\n        else this.fetch = fetch;\n    }\n    /**\n\t* If there's an error with the query, throwOnError will reject the promise by\n\t* throwing the error instead of returning it as part of a successful response.\n\t*\n\t* {@link https://github.com/supabase/supabase-js/issues/92}\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Set an HTTP header for the request.\n\t*/ setHeader(name, value) {\n        this.headers = new Headers(this.headers);\n        this.headers.set(name, value);\n        return this;\n    }\n    then(onfulfilled, onrejected) {\n        var _this = this;\n        if (this.schema === void 0) {} else if ([\n            \"GET\",\n            \"HEAD\"\n        ].includes(this.method)) this.headers.set(\"Accept-Profile\", this.schema);\n        else this.headers.set(\"Content-Profile\", this.schema);\n        if (this.method !== \"GET\" && this.method !== \"HEAD\") this.headers.set(\"Content-Type\", \"application/json\");\n        const _fetch = this.fetch;\n        let res = _fetch(this.url.toString(), {\n            method: this.method,\n            headers: this.headers,\n            body: JSON.stringify(this.body),\n            signal: this.signal\n        }).then(async (res$1)=>{\n            let error = null;\n            let data = null;\n            let count = null;\n            let status = res$1.status;\n            let statusText = res$1.statusText;\n            if (res$1.ok) {\n                var _this$headers$get2, _res$headers$get;\n                if (_this.method !== \"HEAD\") {\n                    var _this$headers$get;\n                    const body = await res$1.text();\n                    if (body === \"\") {} else if (_this.headers.get(\"Accept\") === \"text/csv\") data = body;\n                    else if (_this.headers.get(\"Accept\") && ((_this$headers$get = _this.headers.get(\"Accept\")) === null || _this$headers$get === void 0 ? void 0 : _this$headers$get.includes(\"application/vnd.pgrst.plan+text\"))) data = body;\n                    else data = JSON.parse(body);\n                }\n                const countHeader = (_this$headers$get2 = _this.headers.get(\"Prefer\")) === null || _this$headers$get2 === void 0 ? void 0 : _this$headers$get2.match(/count=(exact|planned|estimated)/);\n                const contentRange = (_res$headers$get = res$1.headers.get(\"content-range\")) === null || _res$headers$get === void 0 ? void 0 : _res$headers$get.split(\"/\");\n                if (countHeader && contentRange && contentRange.length > 1) count = parseInt(contentRange[1]);\n                if (_this.isMaybeSingle && _this.method === \"GET\" && Array.isArray(data)) if (data.length > 1) {\n                    error = {\n                        code: \"PGRST116\",\n                        details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n                        hint: null,\n                        message: \"JSON object requested, multiple (or no) rows returned\"\n                    };\n                    data = null;\n                    count = null;\n                    status = 406;\n                    statusText = \"Not Acceptable\";\n                } else if (data.length === 1) data = data[0];\n                else data = null;\n            } else {\n                var _error$details;\n                const body = await res$1.text();\n                try {\n                    error = JSON.parse(body);\n                    if (Array.isArray(error) && res$1.status === 404) {\n                        data = [];\n                        error = null;\n                        status = 200;\n                        statusText = \"OK\";\n                    }\n                } catch (_unused) {\n                    if (res$1.status === 404 && body === \"\") {\n                        status = 204;\n                        statusText = \"No Content\";\n                    } else error = {\n                        message: body\n                    };\n                }\n                if (error && _this.isMaybeSingle && (error === null || error === void 0 || (_error$details = error.details) === null || _error$details === void 0 ? void 0 : _error$details.includes(\"0 rows\"))) {\n                    error = null;\n                    status = 200;\n                    statusText = \"OK\";\n                }\n                if (error && _this.shouldThrowOnError) throw new PostgrestError(error);\n            }\n            return {\n                error,\n                data,\n                count,\n                status,\n                statusText\n            };\n        });\n        if (!this.shouldThrowOnError) res = res.catch((fetchError)=>{\n            var _fetchError$name2;\n            let errorDetails = \"\";\n            const cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;\n            if (cause) {\n                var _cause$message, _cause$code, _fetchError$name, _cause$name;\n                const causeMessage = (_cause$message = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _cause$message !== void 0 ? _cause$message : \"\";\n                const causeCode = (_cause$code = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _cause$code !== void 0 ? _cause$code : \"\";\n                errorDetails = `${(_fetchError$name = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name !== void 0 ? _fetchError$name : \"FetchError\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`;\n                errorDetails += `\\n\\nCaused by: ${(_cause$name = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _cause$name !== void 0 ? _cause$name : \"Error\"}: ${causeMessage}`;\n                if (causeCode) errorDetails += ` (${causeCode})`;\n                if (cause === null || cause === void 0 ? void 0 : cause.stack) errorDetails += `\\n${cause.stack}`;\n            } else {\n                var _fetchError$stack;\n                errorDetails = (_fetchError$stack = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _fetchError$stack !== void 0 ? _fetchError$stack : \"\";\n            }\n            return {\n                error: {\n                    message: `${(_fetchError$name2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name2 !== void 0 ? _fetchError$name2 : \"FetchError\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,\n                    details: errorDetails,\n                    hint: \"\",\n                    code: \"\"\n                },\n                data: null,\n                count: null,\n                status: 0,\n                statusText: \"\"\n            };\n        });\n        return res.then(onfulfilled, onrejected);\n    }\n    /**\n\t* Override the type of the returned `data`.\n\t*\n\t* @typeParam NewResult - The new result type to override with\n\t* @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n\t*/ returns() {\n        /* istanbul ignore next */ return this;\n    }\n    /**\n\t* Override the type of the returned `data` field in the response.\n\t*\n\t* @typeParam NewResult - The new type to cast the response data to\n\t* @typeParam Options - Optional type configuration (defaults to { merge: true })\n\t* @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n\t* @example\n\t* ```typescript\n\t* // Merge with existing types (default behavior)\n\t* const query = supabase\n\t*   .from('users')\n\t*   .select()\n\t*   .overrideTypes<{ custom_field: string }>()\n\t*\n\t* // Replace existing types completely\n\t* const replaceQuery = supabase\n\t*   .from('users')\n\t*   .select()\n\t*   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n\t* ```\n\t* @returns A PostgrestBuilder instance with the new type\n\t*/ overrideTypes() {\n        return this;\n    }\n};\n//#endregion\n//#region src/PostgrestTransformBuilder.ts\nvar PostgrestTransformBuilder = class extends PostgrestBuilder {\n    /**\n\t* Perform a SELECT on the query result.\n\t*\n\t* By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n\t* return modified rows. By calling this method, modified rows are returned in\n\t* `data`.\n\t*\n\t* @param columns - The columns to retrieve, separated by commas\n\t*/ select(columns) {\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c)=>{\n            if (/\\s/.test(c) && !quoted) return \"\";\n            if (c === '\"') quoted = !quoted;\n            return c;\n        }).join(\"\");\n        this.url.searchParams.set(\"select\", cleanedColumns);\n        this.headers.append(\"Prefer\", \"return=representation\");\n        return this;\n    }\n    /**\n\t* Order the query result by `column`.\n\t*\n\t* You can call this method multiple times to order by multiple columns.\n\t*\n\t* You can order referenced tables, but it only affects the ordering of the\n\t* parent table if you use `!inner` in the query.\n\t*\n\t* @param column - The column to order by\n\t* @param options - Named parameters\n\t* @param options.ascending - If `true`, the result will be in ascending order\n\t* @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n\t* `null`s appear last.\n\t* @param options.referencedTable - Set this to order a referenced table by\n\t* its columns\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {\n        const key = referencedTable ? `${referencedTable}.order` : \"order\";\n        const existingOrder = this.url.searchParams.get(key);\n        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : \"\"}${column}.${ascending ? \"asc\" : \"desc\"}${nullsFirst === void 0 ? \"\" : nullsFirst ? \".nullsfirst\" : \".nullslast\"}`);\n        return this;\n    }\n    /**\n\t* Limit the query result by `count`.\n\t*\n\t* @param count - The maximum number of rows to return\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to limit rows of referenced\n\t* tables instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ limit(count, { foreignTable, referencedTable = foreignTable } = {}) {\n        const key = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n        this.url.searchParams.set(key, `${count}`);\n        return this;\n    }\n    /**\n\t* Limit the query result by starting at an offset `from` and ending at the offset `to`.\n\t* Only records within this range are returned.\n\t* This respects the query order and if there is no order clause the range could behave unexpectedly.\n\t* The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n\t* and fourth rows of the query.\n\t*\n\t* @param from - The starting index from which to limit the result\n\t* @param to - The last index to which to limit the result\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to limit rows of referenced\n\t* tables instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {\n        const keyOffset = typeof referencedTable === \"undefined\" ? \"offset\" : `${referencedTable}.offset`;\n        const keyLimit = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n        this.url.searchParams.set(keyOffset, `${from}`);\n        this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n        return this;\n    }\n    /**\n\t* Set the AbortSignal for the fetch request.\n\t*\n\t* @param signal - The AbortSignal to use for the fetch request\n\t*/ abortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    /**\n\t* Return `data` as a single object instead of an array of objects.\n\t*\n\t* Query result must be one row (e.g. using `.limit(1)`), otherwise this\n\t* returns an error.\n\t*/ single() {\n        this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n        return this;\n    }\n    /**\n\t* Return `data` as a single object instead of an array of objects.\n\t*\n\t* Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n\t* this returns an error.\n\t*/ maybeSingle() {\n        if (this.method === \"GET\") this.headers.set(\"Accept\", \"application/json\");\n        else this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n        this.isMaybeSingle = true;\n        return this;\n    }\n    /**\n\t* Return `data` as a string in CSV format.\n\t*/ csv() {\n        this.headers.set(\"Accept\", \"text/csv\");\n        return this;\n    }\n    /**\n\t* Return `data` as an object in [GeoJSON](https://geojson.org) format.\n\t*/ geojson() {\n        this.headers.set(\"Accept\", \"application/geo+json\");\n        return this;\n    }\n    /**\n\t* Return `data` as the EXPLAIN plan for the query.\n\t*\n\t* You need to enable the\n\t* [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n\t* setting before using this method.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.analyze - If `true`, the query will be executed and the\n\t* actual run time will be returned\n\t*\n\t* @param options.verbose - If `true`, the query identifier will be returned\n\t* and `data` will include the output columns of the query\n\t*\n\t* @param options.settings - If `true`, include information on configuration\n\t* parameters that affect query planning\n\t*\n\t* @param options.buffers - If `true`, include information on buffer usage\n\t*\n\t* @param options.wal - If `true`, include information on WAL record generation\n\t*\n\t* @param options.format - The format of the output, can be `\"text\"` (default)\n\t* or `\"json\"`\n\t*/ explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = \"text\" } = {}) {\n        var _this$headers$get;\n        const options = [\n            analyze ? \"analyze\" : null,\n            verbose ? \"verbose\" : null,\n            settings ? \"settings\" : null,\n            buffers ? \"buffers\" : null,\n            wal ? \"wal\" : null\n        ].filter(Boolean).join(\"|\");\n        const forMediatype = (_this$headers$get = this.headers.get(\"Accept\")) !== null && _this$headers$get !== void 0 ? _this$headers$get : \"application/json\";\n        this.headers.set(\"Accept\", `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`);\n        if (format === \"json\") return this;\n        else return this;\n    }\n    /**\n\t* Rollback the query.\n\t*\n\t* `data` will still be returned, but the query is not committed.\n\t*/ rollback() {\n        this.headers.append(\"Prefer\", \"tx=rollback\");\n        return this;\n    }\n    /**\n\t* Override the type of the returned `data`.\n\t*\n\t* @typeParam NewResult - The new result type to override with\n\t* @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n\t*/ returns() {\n        return this;\n    }\n    /**\n\t* Set the maximum number of rows that can be affected by the query.\n\t* Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n\t*\n\t* @param value - The maximum number of rows that can be affected\n\t*/ maxAffected(value) {\n        this.headers.append(\"Prefer\", \"handling=strict\");\n        this.headers.append(\"Prefer\", `max-affected=${value}`);\n        return this;\n    }\n};\n//#endregion\n//#region src/PostgrestFilterBuilder.ts\nconst PostgrestReservedCharsRegexp = /* @__PURE__ */ new RegExp(\"[,()]\");\nvar PostgrestFilterBuilder = class extends PostgrestTransformBuilder {\n    /**\n\t* Match only rows where `column` is equal to `value`.\n\t*\n\t* To check if the value of `column` is NULL, you should use `.is()` instead.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ eq(column, value) {\n        this.url.searchParams.append(column, `eq.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is not equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ neq(column, value) {\n        this.url.searchParams.append(column, `neq.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is greater than `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ gt(column, value) {\n        this.url.searchParams.append(column, `gt.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is greater than or equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ gte(column, value) {\n        this.url.searchParams.append(column, `gte.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is less than `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ lt(column, value) {\n        this.url.searchParams.append(column, `lt.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is less than or equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ lte(column, value) {\n        this.url.searchParams.append(column, `lte.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches `pattern` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The pattern to match with\n\t*/ like(column, pattern) {\n        this.url.searchParams.append(column, `like.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches all of `patterns` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ likeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `like(all).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches any of `patterns` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ likeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `like(any).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches `pattern` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The pattern to match with\n\t*/ ilike(column, pattern) {\n        this.url.searchParams.append(column, `ilike.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches all of `patterns` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ ilikeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(all).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches any of `patterns` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ ilikeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(any).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches the PostgreSQL regex `pattern`\n\t* case-sensitively (using the `~` operator).\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The PostgreSQL regular expression pattern to match with\n\t*/ regexMatch(column, pattern) {\n        this.url.searchParams.append(column, `match.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches the PostgreSQL regex `pattern`\n\t* case-insensitively (using the `~*` operator).\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The PostgreSQL regular expression pattern to match with\n\t*/ regexIMatch(column, pattern) {\n        this.url.searchParams.append(column, `imatch.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` IS `value`.\n\t*\n\t* For non-boolean columns, this is only relevant for checking if the value of\n\t* `column` is NULL by setting `value` to `null`.\n\t*\n\t* For boolean columns, you can also set `value` to `true` or `false` and it\n\t* will behave the same way as `.eq()`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ is(column, value) {\n        this.url.searchParams.append(column, `is.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` IS DISTINCT FROM `value`.\n\t*\n\t* Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values\n\t* are considered equal (not distinct), and comparing `NULL` with any non-NULL\n\t* value returns true (distinct).\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ isDistinct(column, value) {\n        this.url.searchParams.append(column, `isdistinct.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is included in the `values` array.\n\t*\n\t* @param column - The column to filter on\n\t* @param values - The values array to filter with\n\t*/ in(column, values) {\n        const cleanedValues = Array.from(new Set(values)).map((s)=>{\n            if (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`;\n            else return `${s}`;\n        }).join(\",\");\n        this.url.searchParams.append(column, `in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is NOT included in the `values` array.\n\t*\n\t* @param column - The column to filter on\n\t* @param values - The values array to filter with\n\t*/ notIn(column, values) {\n        const cleanedValues = Array.from(new Set(values)).map((s)=>{\n            if (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`;\n            else return `${s}`;\n        }).join(\",\");\n        this.url.searchParams.append(column, `not.in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n\t* Only relevant for jsonb, array, and range columns. Match only rows where\n\t* `column` contains every element appearing in `value`.\n\t*\n\t* @param column - The jsonb, array, or range column to filter on\n\t* @param value - The jsonb, array, or range value to filter with\n\t*/ contains(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, `cs.${value}`);\n        else if (Array.isArray(value)) this.url.searchParams.append(column, `cs.{${value.join(\",\")}}`);\n        else this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n        return this;\n    }\n    /**\n\t* Only relevant for jsonb, array, and range columns. Match only rows where\n\t* every element appearing in `column` is contained by `value`.\n\t*\n\t* @param column - The jsonb, array, or range column to filter on\n\t* @param value - The jsonb, array, or range value to filter with\n\t*/ containedBy(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, `cd.${value}`);\n        else if (Array.isArray(value)) this.url.searchParams.append(column, `cd.{${value.join(\",\")}}`);\n        else this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is greater than any element in `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeGt(column, range) {\n        this.url.searchParams.append(column, `sr.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is either contained in `range` or greater than any element in\n\t* `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeGte(column, range) {\n        this.url.searchParams.append(column, `nxl.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is less than any element in `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeLt(column, range) {\n        this.url.searchParams.append(column, `sl.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is either contained in `range` or less than any element in\n\t* `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeLte(column, range) {\n        this.url.searchParams.append(column, `nxr.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where `column` is\n\t* mutually exclusive to `range` and there can be no element between the two\n\t* ranges.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeAdjacent(column, range) {\n        this.url.searchParams.append(column, `adj.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for array and range columns. Match only rows where\n\t* `column` and `value` have an element in common.\n\t*\n\t* @param column - The array or range column to filter on\n\t* @param value - The array or range value to filter with\n\t*/ overlaps(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, `ov.${value}`);\n        else this.url.searchParams.append(column, `ov.{${value.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Only relevant for text and tsvector columns. Match only rows where\n\t* `column` matches the query string in `query`.\n\t*\n\t* @param column - The text or tsvector column to filter on\n\t* @param query - The query text to match with\n\t* @param options - Named parameters\n\t* @param options.config - The text search configuration to use\n\t* @param options.type - Change how the `query` text is interpreted\n\t*/ textSearch(column, query, { config, type } = {}) {\n        let typePart = \"\";\n        if (type === \"plain\") typePart = \"pl\";\n        else if (type === \"phrase\") typePart = \"ph\";\n        else if (type === \"websearch\") typePart = \"w\";\n        const configPart = config === void 0 ? \"\" : `(${config})`;\n        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n        return this;\n    }\n    /**\n\t* Match only rows where each column in `query` keys is equal to its\n\t* associated value. Shorthand for multiple `.eq()`s.\n\t*\n\t* @param query - The object to filter with, with column names as keys mapped\n\t* to their filter values\n\t*/ match(query) {\n        Object.entries(query).forEach(([column, value])=>{\n            this.url.searchParams.append(column, `eq.${value}`);\n        });\n        return this;\n    }\n    /**\n\t* Match only rows which doesn't satisfy the filter.\n\t*\n\t* Unlike most filters, `opearator` and `value` are used as-is and need to\n\t* follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure they are properly sanitized.\n\t*\n\t* @param column - The column to filter on\n\t* @param operator - The operator to be negated to filter with, following\n\t* PostgREST syntax\n\t* @param value - The value to filter with, following PostgREST syntax\n\t*/ not(column, operator, value) {\n        this.url.searchParams.append(column, `not.${operator}.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows which satisfy at least one of the filters.\n\t*\n\t* Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure it's properly sanitized.\n\t*\n\t* It's currently not possible to do an `.or()` filter across multiple tables.\n\t*\n\t* @param filters - The filters to use, following PostgREST syntax\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to filter on referenced tables\n\t* instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `referencedTable` instead\n\t*/ or(filters, { foreignTable, referencedTable = foreignTable } = {}) {\n        const key = referencedTable ? `${referencedTable}.or` : \"or\";\n        this.url.searchParams.append(key, `(${filters})`);\n        return this;\n    }\n    /**\n\t* Match only rows which satisfy the filter. This is an escape hatch - you\n\t* should use the specific filter methods wherever possible.\n\t*\n\t* Unlike most filters, `opearator` and `value` are used as-is and need to\n\t* follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure they are properly sanitized.\n\t*\n\t* @param column - The column to filter on\n\t* @param operator - The operator to filter with, following PostgREST syntax\n\t* @param value - The value to filter with, following PostgREST syntax\n\t*/ filter(column, operator, value) {\n        this.url.searchParams.append(column, `${operator}.${value}`);\n        return this;\n    }\n};\n//#endregion\n//#region src/PostgrestQueryBuilder.ts\nvar PostgrestQueryBuilder = class {\n    /**\n\t* Creates a query builder scoped to a Postgres table or view.\n\t*\n\t* @example\n\t* ```ts\n\t* import PostgrestQueryBuilder from '@supabase/postgrest-js'\n\t*\n\t* const query = new PostgrestQueryBuilder(\n\t*   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n\t*   { headers: { apikey: 'public-anon-key' } }\n\t* )\n\t* ```\n\t*/ constructor(url, { headers = {}, schema, fetch: fetch$1 }){\n        this.url = url;\n        this.headers = new Headers(headers);\n        this.schema = schema;\n        this.fetch = fetch$1;\n    }\n    /**\n\t* Clone URL and headers to prevent shared state between operations.\n\t*/ cloneRequestState() {\n        return {\n            url: new URL(this.url.toString()),\n            headers: new Headers(this.headers)\n        };\n    }\n    /**\n\t* Perform a SELECT query on the table or view.\n\t*\n\t* @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t*\n\t* @param options.count - Count algorithm to use to count rows in the table or view.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ select(columns, options) {\n        const { head = false, count } = options !== null && options !== void 0 ? options : {};\n        const method = head ? \"HEAD\" : \"GET\";\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c)=>{\n            if (/\\s/.test(c) && !quoted) return \"\";\n            if (c === '\"') quoted = !quoted;\n            return c;\n        }).join(\"\");\n        const { url, headers } = this.cloneRequestState();\n        url.searchParams.set(\"select\", cleanedColumns);\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t* Perform an INSERT into the table or view.\n\t*\n\t* By default, inserted rows are not returned. To return it, chain the call\n\t* with `.select()`.\n\t*\n\t* @param values - The values to insert. Pass an object to insert a single row\n\t* or an array to insert multiple rows.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count inserted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @param options.defaultToNull - Make missing fields default to `null`.\n\t* Otherwise, use the default value for the column. Only applies for bulk\n\t* inserts.\n\t*/ insert(values, { count, defaultToNull = true } = {}) {\n        var _this$fetch;\n        const method = \"POST\";\n        const { url, headers } = this.cloneRequestState();\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        if (!defaultToNull) headers.append(\"Prefer\", `missing=default`);\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>`\"${column}\"`);\n                url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch\n        });\n    }\n    /**\n\t* Perform an UPSERT on the table or view. Depending on the column(s) passed\n\t* to `onConflict`, `.upsert()` allows you to perform the equivalent of\n\t* `.insert()` if a row with the corresponding `onConflict` columns doesn't\n\t* exist, or if it does exist, perform an alternative action depending on\n\t* `ignoreDuplicates`.\n\t*\n\t* By default, upserted rows are not returned. To return it, chain the call\n\t* with `.select()`.\n\t*\n\t* @param values - The values to upsert with. Pass an object to upsert a\n\t* single row or an array to upsert multiple rows.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n\t* duplicate rows are determined. Two rows are duplicates if all the\n\t* `onConflict` columns are equal.\n\t*\n\t* @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n\t* `false`, duplicate rows are merged with existing rows.\n\t*\n\t* @param options.count - Count algorithm to use to count upserted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @param options.defaultToNull - Make missing fields default to `null`.\n\t* Otherwise, use the default value for the column. This only applies when\n\t* inserting new rows, not when merging with existing rows under\n\t* `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n\t*\n\t* @example Upsert a single row using a unique key\n\t* ```ts\n\t* // Upserting a single row, overwriting based on the 'username' unique column\n\t* const { data, error } = await supabase\n\t*   .from('users')\n\t*   .upsert({ username: 'supabot' }, { onConflict: 'username' })\n\t*\n\t* // Example response:\n\t* // {\n\t* //   data: [\n\t* //     { id: 4, message: 'bar', username: 'supabot' }\n\t* //   ],\n\t* //   error: null\n\t* // }\n\t* ```\n\t*\n\t* @example Upsert with conflict resolution and exact row counting\n\t* ```ts\n\t* // Upserting and returning exact count\n\t* const { data, error, count } = await supabase\n\t*   .from('users')\n\t*   .upsert(\n\t*     {\n\t*       id: 3,\n\t*       message: 'foo',\n\t*       username: 'supabot'\n\t*     },\n\t*     {\n\t*       onConflict: 'username',\n\t*       count: 'exact'\n\t*     }\n\t*   )\n\t*\n\t* // Example response:\n\t* // {\n\t* //   data: [\n\t* //     {\n\t* //       id: 42,\n\t* //       handle: \"saoirse\",\n\t* //       display_name: \"Saoirse\"\n\t* //     }\n\t* //   ],\n\t* //   count: 1,\n\t* //   error: null\n\t* // }\n\t* ```\n\t*/ upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {\n        var _this$fetch2;\n        const method = \"POST\";\n        const { url, headers } = this.cloneRequestState();\n        headers.append(\"Prefer\", `resolution=${ignoreDuplicates ? \"ignore\" : \"merge\"}-duplicates`);\n        if (onConflict !== void 0) url.searchParams.set(\"on_conflict\", onConflict);\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        if (!defaultToNull) headers.append(\"Prefer\", \"missing=default\");\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>`\"${column}\"`);\n                url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch2 = this.fetch) !== null && _this$fetch2 !== void 0 ? _this$fetch2 : fetch\n        });\n    }\n    /**\n\t* Perform an UPDATE on the table or view.\n\t*\n\t* By default, updated rows are not returned. To return it, chain the call\n\t* with `.select()` after filters.\n\t*\n\t* @param values - The values to update with\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count updated rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ update(values, { count } = {}) {\n        var _this$fetch3;\n        const method = \"PATCH\";\n        const { url, headers } = this.cloneRequestState();\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch3 = this.fetch) !== null && _this$fetch3 !== void 0 ? _this$fetch3 : fetch\n        });\n    }\n    /**\n\t* Perform a DELETE on the table or view.\n\t*\n\t* By default, deleted rows are not returned. To return it, chain the call\n\t* with `.select()` after filters.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count deleted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ delete({ count } = {}) {\n        var _this$fetch4;\n        const method = \"DELETE\";\n        const { url, headers } = this.cloneRequestState();\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            fetch: (_this$fetch4 = this.fetch) !== null && _this$fetch4 !== void 0 ? _this$fetch4 : fetch\n        });\n    }\n};\n//#endregion\n//#region src/PostgrestClient.ts\n/**\n* PostgREST client.\n*\n* @typeParam Database - Types for the schema from the [type\n* generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n*\n* @typeParam SchemaName - Postgres schema to switch to. Must be a string\n* literal, the same one passed to the constructor. If the schema is not\n* `\"public\"`, this must be supplied manually.\n*/ var PostgrestClient = class PostgrestClient {\n    /**\n\t* Creates a PostgREST client.\n\t*\n\t* @param url - URL of the PostgREST endpoint\n\t* @param options - Named parameters\n\t* @param options.headers - Custom headers\n\t* @param options.schema - Postgres schema to switch to\n\t* @param options.fetch - Custom fetch\n\t* @example\n\t* ```ts\n\t* import PostgrestClient from '@supabase/postgrest-js'\n\t*\n\t* const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {\n\t*   headers: { apikey: 'public-anon-key' },\n\t*   schema: 'public',\n\t* })\n\t* ```\n\t*/ constructor(url, { headers = {}, schema, fetch: fetch$1 } = {}){\n        this.url = url;\n        this.headers = new Headers(headers);\n        this.schemaName = schema;\n        this.fetch = fetch$1;\n    }\n    /**\n\t* Perform a query on a table or a view.\n\t*\n\t* @param relation - The table or view name to query\n\t*/ from(relation) {\n        if (!relation || typeof relation !== \"string\" || relation.trim() === \"\") throw new Error(\"Invalid relation name: relation must be a non-empty string.\");\n        return new PostgrestQueryBuilder(new URL(`${this.url}/${relation}`), {\n            headers: new Headers(this.headers),\n            schema: this.schemaName,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t* Select a schema to query or perform an function (rpc) call.\n\t*\n\t* The schema needs to be on the list of exposed schemas inside Supabase.\n\t*\n\t* @param schema - The schema to query\n\t*/ schema(schema) {\n        return new PostgrestClient(this.url, {\n            headers: this.headers,\n            schema,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t* Perform a function call.\n\t*\n\t* @param fn - The function name to call\n\t* @param args - The arguments to pass to the function call\n\t* @param options - Named parameters\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t* @param options.get - When set to `true`, the function will be called with\n\t* read-only access mode.\n\t* @param options.count - Count algorithm to use to count rows returned by the\n\t* function. Only applicable for [set-returning\n\t* functions](https://www.postgresql.org/docs/current/functions-srf.html).\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @example\n\t* ```ts\n\t* // For cross-schema functions where type inference fails, use overrideTypes:\n\t* const { data } = await supabase\n\t*   .schema('schema_b')\n\t*   .rpc('function_a', {})\n\t*   .overrideTypes<{ id: string; user_id: string }[]>()\n\t* ```\n\t*/ rpc(fn, args = {}, { head = false, get = false, count } = {}) {\n        var _this$fetch;\n        let method;\n        const url = new URL(`${this.url}/rpc/${fn}`);\n        let body;\n        const _isObject = (v)=>v !== null && typeof v === \"object\" && (!Array.isArray(v) || v.some(_isObject));\n        const _hasObjectArg = head && Object.values(args).some(_isObject);\n        if (_hasObjectArg) {\n            method = \"POST\";\n            body = args;\n        } else if (head || get) {\n            method = head ? \"HEAD\" : \"GET\";\n            Object.entries(args).filter(([_, value])=>value !== void 0).map(([name, value])=>[\n                    name,\n                    Array.isArray(value) ? `{${value.join(\",\")}}` : `${value}`\n                ]).forEach(([name, value])=>{\n                url.searchParams.append(name, value);\n            });\n        } else {\n            method = \"POST\";\n            body = args;\n        }\n        const headers = new Headers(this.headers);\n        if (_hasObjectArg) headers.set(\"Prefer\", count ? `count=${count},return=minimal` : \"return=minimal\");\n        else if (count) headers.set(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schemaName,\n            body,\n            fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch\n        });\n    }\n};\n//#endregion\n//#region src/index.ts\nvar src_default = {\n    PostgrestClient,\n    PostgrestQueryBuilder,\n    PostgrestFilterBuilder,\n    PostgrestTransformBuilder,\n    PostgrestBuilder,\n    PostgrestError\n};\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsK0JBQStCO0FBQy9COzs7O0FBSUEsR0FDQSxJQUFJQSxpQkFBaUIsY0FBY0M7SUFDbEM7Ozs7Ozs7Ozs7OztDQVlBLEdBQ0FDLFlBQVlDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBLFFBQVFDLE9BQU87UUFDckIsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE9BQU8sR0FBR0gsUUFBUUcsT0FBTztRQUM5QixJQUFJLENBQUNDLElBQUksR0FBR0osUUFBUUksSUFBSTtRQUN4QixJQUFJLENBQUNDLElBQUksR0FBR0wsUUFBUUssSUFBSTtJQUN6QjtBQUNEO0FBRUEsWUFBWTtBQUNaLGlDQUFpQztBQUNqQyxJQUFJQyxtQkFBbUI7SUFDdEI7Ozs7Ozs7Ozs7OztDQVlBLEdBQ0FQLFlBQVlRLE9BQU8sQ0FBRTtRQUNwQixJQUFJQyx1QkFBdUJDO1FBQzNCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDQyxNQUFNLEdBQUdKLFFBQVFJLE1BQU07UUFDNUIsSUFBSSxDQUFDQyxHQUFHLEdBQUdMLFFBQVFLLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUMsUUFBUVAsUUFBUU0sT0FBTztRQUMxQyxJQUFJLENBQUNFLE1BQU0sR0FBR1IsUUFBUVEsTUFBTTtRQUM1QixJQUFJLENBQUNDLElBQUksR0FBR1QsUUFBUVMsSUFBSTtRQUN4QixJQUFJLENBQUNOLGtCQUFrQixHQUFHLENBQUNGLHdCQUF3QkQsUUFBUUcsa0JBQWtCLE1BQU0sUUFBUUYsMEJBQTBCLEtBQUssSUFBSUEsd0JBQXdCO1FBQ3RKLElBQUksQ0FBQ1MsTUFBTSxHQUFHVixRQUFRVSxNQUFNO1FBQzVCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLENBQUNULHdCQUF3QkYsUUFBUVcsYUFBYSxNQUFNLFFBQVFULDBCQUEwQixLQUFLLElBQUlBLHdCQUF3QjtRQUM1SSxJQUFJRixRQUFRWSxLQUFLLEVBQUUsSUFBSSxDQUFDQSxLQUFLLEdBQUdaLFFBQVFZLEtBQUs7YUFDeEMsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO0lBQ25CO0lBQ0E7Ozs7O0NBS0EsR0FDQUMsZUFBZTtRQUNkLElBQUksQ0FBQ1Ysa0JBQWtCLEdBQUc7UUFDMUIsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Q0FFQSxHQUNBVyxVQUFVbkIsSUFBSSxFQUFFb0IsS0FBSyxFQUFFO1FBQ3RCLElBQUksQ0FBQ1QsT0FBTyxHQUFHLElBQUlDLFFBQVEsSUFBSSxDQUFDRCxPQUFPO1FBQ3ZDLElBQUksQ0FBQ0EsT0FBTyxDQUFDVSxHQUFHLENBQUNyQixNQUFNb0I7UUFDdkIsT0FBTyxJQUFJO0lBQ1o7SUFDQUUsS0FBS0MsV0FBVyxFQUFFQyxVQUFVLEVBQUU7UUFDN0IsSUFBSUMsUUFBUSxJQUFJO1FBQ2hCLElBQUksSUFBSSxDQUFDWixNQUFNLEtBQUssS0FBSyxHQUFHLENBQUMsT0FBTyxJQUFJO1lBQUM7WUFBTztTQUFPLENBQUNhLFFBQVEsQ0FBQyxJQUFJLENBQUNqQixNQUFNLEdBQUcsSUFBSSxDQUFDRSxPQUFPLENBQUNVLEdBQUcsQ0FBQyxrQkFBa0IsSUFBSSxDQUFDUixNQUFNO2FBQ3hILElBQUksQ0FBQ0YsT0FBTyxDQUFDVSxHQUFHLENBQUMsbUJBQW1CLElBQUksQ0FBQ1IsTUFBTTtRQUNwRCxJQUFJLElBQUksQ0FBQ0osTUFBTSxLQUFLLFNBQVMsSUFBSSxDQUFDQSxNQUFNLEtBQUssUUFBUSxJQUFJLENBQUNFLE9BQU8sQ0FBQ1UsR0FBRyxDQUFDLGdCQUFnQjtRQUN0RixNQUFNTSxTQUFTLElBQUksQ0FBQ1YsS0FBSztRQUN6QixJQUFJVyxNQUFNRCxPQUFPLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQ21CLFFBQVEsSUFBSTtZQUNyQ3BCLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CRSxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQkcsTUFBTWdCLEtBQUtDLFNBQVMsQ0FBQyxJQUFJLENBQUNqQixJQUFJO1lBQzlCQyxRQUFRLElBQUksQ0FBQ0EsTUFBTTtRQUNwQixHQUFHTyxJQUFJLENBQUMsT0FBT1U7WUFDZCxJQUFJQyxRQUFRO1lBQ1osSUFBSUMsT0FBTztZQUNYLElBQUlDLFFBQVE7WUFDWixJQUFJQyxTQUFTSixNQUFNSSxNQUFNO1lBQ3pCLElBQUlDLGFBQWFMLE1BQU1LLFVBQVU7WUFDakMsSUFBSUwsTUFBTU0sRUFBRSxFQUFFO2dCQUNiLElBQUlDLG9CQUFvQkM7Z0JBQ3hCLElBQUlmLE1BQU1oQixNQUFNLEtBQUssUUFBUTtvQkFDNUIsSUFBSWdDO29CQUNKLE1BQU0zQixPQUFPLE1BQU1rQixNQUFNVSxJQUFJO29CQUM3QixJQUFJNUIsU0FBUyxJQUFJLENBQUMsT0FBTyxJQUFJVyxNQUFNZCxPQUFPLENBQUNnQyxHQUFHLENBQUMsY0FBYyxZQUFZVCxPQUFPcEI7eUJBQzNFLElBQUlXLE1BQU1kLE9BQU8sQ0FBQ2dDLEdBQUcsQ0FBQyxhQUFjLEVBQUNGLG9CQUFvQmhCLE1BQU1kLE9BQU8sQ0FBQ2dDLEdBQUcsQ0FBQyxTQUFRLE1BQU8sUUFBUUYsc0JBQXNCLEtBQUssSUFBSSxLQUFLLElBQUlBLGtCQUFrQmYsUUFBUSxDQUFDLGtDQUFpQyxHQUFJUSxPQUFPcEI7eUJBQ2pOb0IsT0FBT0osS0FBS2MsS0FBSyxDQUFDOUI7Z0JBQ3hCO2dCQUNBLE1BQU0rQixjQUFjLENBQUNOLHFCQUFxQmQsTUFBTWQsT0FBTyxDQUFDZ0MsR0FBRyxDQUFDLFNBQVEsTUFBTyxRQUFRSix1QkFBdUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsbUJBQW1CTyxLQUFLLENBQUM7Z0JBQ3JKLE1BQU1DLGVBQWUsQ0FBQ1AsbUJBQW1CUixNQUFNckIsT0FBTyxDQUFDZ0MsR0FBRyxDQUFDLGdCQUFlLE1BQU8sUUFBUUgscUJBQXFCLEtBQUssSUFBSSxLQUFLLElBQUlBLGlCQUFpQlEsS0FBSyxDQUFDO2dCQUN2SixJQUFJSCxlQUFlRSxnQkFBZ0JBLGFBQWFFLE1BQU0sR0FBRyxHQUFHZCxRQUFRZSxTQUFTSCxZQUFZLENBQUMsRUFBRTtnQkFDNUYsSUFBSXRCLE1BQU1ULGFBQWEsSUFBSVMsTUFBTWhCLE1BQU0sS0FBSyxTQUFTMEMsTUFBTUMsT0FBTyxDQUFDbEIsT0FBTyxJQUFJQSxLQUFLZSxNQUFNLEdBQUcsR0FBRztvQkFDOUZoQixRQUFRO3dCQUNQOUIsTUFBTTt3QkFDTkYsU0FBUyxDQUFDLGdCQUFnQixFQUFFaUMsS0FBS2UsTUFBTSxDQUFDLHVEQUF1RCxDQUFDO3dCQUNoRy9DLE1BQU07d0JBQ05ILFNBQVM7b0JBQ1Y7b0JBQ0FtQyxPQUFPO29CQUNQQyxRQUFRO29CQUNSQyxTQUFTO29CQUNUQyxhQUFhO2dCQUNkLE9BQU8sSUFBSUgsS0FBS2UsTUFBTSxLQUFLLEdBQUdmLE9BQU9BLElBQUksQ0FBQyxFQUFFO3FCQUN2Q0EsT0FBTztZQUNiLE9BQU87Z0JBQ04sSUFBSW1CO2dCQUNKLE1BQU12QyxPQUFPLE1BQU1rQixNQUFNVSxJQUFJO2dCQUM3QixJQUFJO29CQUNIVCxRQUFRSCxLQUFLYyxLQUFLLENBQUM5QjtvQkFDbkIsSUFBSXFDLE1BQU1DLE9BQU8sQ0FBQ25CLFVBQVVELE1BQU1JLE1BQU0sS0FBSyxLQUFLO3dCQUNqREYsT0FBTyxFQUFFO3dCQUNURCxRQUFRO3dCQUNSRyxTQUFTO3dCQUNUQyxhQUFhO29CQUNkO2dCQUNELEVBQUUsT0FBT2lCLFNBQVM7b0JBQ2pCLElBQUl0QixNQUFNSSxNQUFNLEtBQUssT0FBT3RCLFNBQVMsSUFBSTt3QkFDeENzQixTQUFTO3dCQUNUQyxhQUFhO29CQUNkLE9BQU9KLFFBQVE7d0JBQUVsQyxTQUFTZTtvQkFBSztnQkFDaEM7Z0JBQ0EsSUFBSW1CLFNBQVNSLE1BQU1ULGFBQWEsSUFBS2lCLENBQUFBLFVBQVUsUUFBUUEsVUFBVSxLQUFLLEtBQUssQ0FBQ29CLGlCQUFpQnBCLE1BQU1oQyxPQUFPLE1BQU0sUUFBUW9ELG1CQUFtQixLQUFLLElBQUksS0FBSyxJQUFJQSxlQUFlM0IsUUFBUSxDQUFDLFNBQVEsR0FBSTtvQkFDaE1PLFFBQVE7b0JBQ1JHLFNBQVM7b0JBQ1RDLGFBQWE7Z0JBQ2Q7Z0JBQ0EsSUFBSUosU0FBU1IsTUFBTWpCLGtCQUFrQixFQUFFLE1BQU0sSUFBSWIsZUFBZXNDO1lBQ2pFO1lBQ0EsT0FBTztnQkFDTkE7Z0JBQ0FDO2dCQUNBQztnQkFDQUM7Z0JBQ0FDO1lBQ0Q7UUFDRDtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUM3QixrQkFBa0IsRUFBRW9CLE1BQU1BLElBQUkyQixLQUFLLENBQUMsQ0FBQ0M7WUFDOUMsSUFBSUM7WUFDSixJQUFJQyxlQUFlO1lBQ25CLE1BQU1DLFFBQVFILGVBQWUsUUFBUUEsZUFBZSxLQUFLLElBQUksS0FBSyxJQUFJQSxXQUFXRyxLQUFLO1lBQ3RGLElBQUlBLE9BQU87Z0JBQ1YsSUFBSUMsZ0JBQWdCQyxhQUFhQyxrQkFBa0JDO2dCQUNuRCxNQUFNQyxlQUFlLENBQUNKLGlCQUFpQkQsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU01RCxPQUFPLE1BQU0sUUFBUTZELG1CQUFtQixLQUFLLElBQUlBLGlCQUFpQjtnQkFDN0osTUFBTUssWUFBWSxDQUFDSixjQUFjRixVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSUEsTUFBTXhELElBQUksTUFBTSxRQUFRMEQsZ0JBQWdCLEtBQUssSUFBSUEsY0FBYztnQkFDOUlILGVBQWUsQ0FBQyxFQUFFLENBQUNJLG1CQUFtQk4sZUFBZSxRQUFRQSxlQUFlLEtBQUssSUFBSSxLQUFLLElBQUlBLFdBQVd4RCxJQUFJLE1BQU0sUUFBUThELHFCQUFxQixLQUFLLElBQUlBLG1CQUFtQixhQUFhLEVBQUUsRUFBRU4sZUFBZSxRQUFRQSxlQUFlLEtBQUssSUFBSSxLQUFLLElBQUlBLFdBQVd6RCxPQUFPLENBQUMsQ0FBQztnQkFDelEyRCxnQkFBZ0IsQ0FBQyxlQUFlLEVBQUUsQ0FBQ0ssY0FBY0osVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU0zRCxJQUFJLE1BQU0sUUFBUStELGdCQUFnQixLQUFLLElBQUlBLGNBQWMsUUFBUSxFQUFFLEVBQUVDLGFBQWEsQ0FBQztnQkFDeEwsSUFBSUMsV0FBV1AsZ0JBQWdCLENBQUMsRUFBRSxFQUFFTyxVQUFVLENBQUMsQ0FBQztnQkFDaEQsSUFBSU4sVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU1PLEtBQUssRUFBRVIsZ0JBQWdCLENBQUMsRUFBRSxFQUFFQyxNQUFNTyxLQUFLLENBQUMsQ0FBQztZQUNsRyxPQUFPO2dCQUNOLElBQUlDO2dCQUNKVCxlQUFlLENBQUNTLG9CQUFvQlgsZUFBZSxRQUFRQSxlQUFlLEtBQUssSUFBSSxLQUFLLElBQUlBLFdBQVdVLEtBQUssTUFBTSxRQUFRQyxzQkFBc0IsS0FBSyxJQUFJQSxvQkFBb0I7WUFDOUs7WUFDQSxPQUFPO2dCQUNObEMsT0FBTztvQkFDTmxDLFNBQVMsQ0FBQyxFQUFFLENBQUMwRCxvQkFBb0JELGVBQWUsUUFBUUEsZUFBZSxLQUFLLElBQUksS0FBSyxJQUFJQSxXQUFXeEQsSUFBSSxNQUFNLFFBQVF5RCxzQkFBc0IsS0FBSyxJQUFJQSxvQkFBb0IsYUFBYSxFQUFFLEVBQUVELGVBQWUsUUFBUUEsZUFBZSxLQUFLLElBQUksS0FBSyxJQUFJQSxXQUFXekQsT0FBTyxDQUFDLENBQUM7b0JBQ3RRRSxTQUFTeUQ7b0JBQ1R4RCxNQUFNO29CQUNOQyxNQUFNO2dCQUNQO2dCQUNBK0IsTUFBTTtnQkFDTkMsT0FBTztnQkFDUEMsUUFBUTtnQkFDUkMsWUFBWTtZQUNiO1FBQ0Q7UUFDQSxPQUFPVCxJQUFJTixJQUFJLENBQUNDLGFBQWFDO0lBQzlCO0lBQ0E7Ozs7O0NBS0EsR0FDQTRDLFVBQVU7UUFDVCx3QkFBd0IsR0FDeEIsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJBLEdBQ0FDLGdCQUFnQjtRQUNmLE9BQU8sSUFBSTtJQUNaO0FBQ0Q7QUFFQSxZQUFZO0FBQ1osMENBQTBDO0FBQzFDLElBQUlDLDRCQUE0QixjQUFjbEU7SUFDN0M7Ozs7Ozs7O0NBUUEsR0FDQW1FLE9BQU9DLE9BQU8sRUFBRTtRQUNmLElBQUlDLFNBQVM7UUFDYixNQUFNQyxpQkFBaUIsQ0FBQ0YsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSUEsVUFBVSxHQUFFLEVBQUd4QixLQUFLLENBQUMsSUFBSTJCLEdBQUcsQ0FBQyxDQUFDQztZQUM5RixJQUFJLEtBQUtDLElBQUksQ0FBQ0QsTUFBTSxDQUFDSCxRQUFRLE9BQU87WUFDcEMsSUFBSUcsTUFBTSxLQUFNSCxTQUFTLENBQUNBO1lBQzFCLE9BQU9HO1FBQ1IsR0FBR0UsSUFBSSxDQUFDO1FBQ1IsSUFBSSxDQUFDcEUsR0FBRyxDQUFDcUUsWUFBWSxDQUFDMUQsR0FBRyxDQUFDLFVBQVVxRDtRQUNwQyxJQUFJLENBQUMvRCxPQUFPLENBQUNxRSxNQUFNLENBQUMsVUFBVTtRQUM5QixPQUFPLElBQUk7SUFDWjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQSxHQUNBQyxNQUFNQyxNQUFNLEVBQUUsRUFBRUMsWUFBWSxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsWUFBWSxFQUFFQyxrQkFBa0JELFlBQVksRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ2xHLE1BQU1FLE1BQU1ELGtCQUFrQixDQUFDLEVBQUVBLGdCQUFnQixNQUFNLENBQUMsR0FBRztRQUMzRCxNQUFNRSxnQkFBZ0IsSUFBSSxDQUFDOUUsR0FBRyxDQUFDcUUsWUFBWSxDQUFDcEMsR0FBRyxDQUFDNEM7UUFDaEQsSUFBSSxDQUFDN0UsR0FBRyxDQUFDcUUsWUFBWSxDQUFDMUQsR0FBRyxDQUFDa0UsS0FBSyxDQUFDLEVBQUVDLGdCQUFnQixDQUFDLEVBQUVBLGNBQWMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxFQUFFTixPQUFPLENBQUMsRUFBRUMsWUFBWSxRQUFRLE9BQU8sRUFBRUMsZUFBZSxLQUFLLElBQUksS0FBS0EsYUFBYSxnQkFBZ0IsYUFBYSxDQUFDO1FBQzVMLE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7Ozs7OztDQVNBLEdBQ0FLLE1BQU10RCxLQUFLLEVBQUUsRUFBRWtELFlBQVksRUFBRUMsa0JBQWtCRCxZQUFZLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUNuRSxNQUFNRSxNQUFNLE9BQU9ELG9CQUFvQixjQUFjLFVBQVUsQ0FBQyxFQUFFQSxnQkFBZ0IsTUFBTSxDQUFDO1FBQ3pGLElBQUksQ0FBQzVFLEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQzFELEdBQUcsQ0FBQ2tFLEtBQUssQ0FBQyxFQUFFcEQsTUFBTSxDQUFDO1FBQ3pDLE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7Ozs7Ozs7Ozs7O0NBY0EsR0FDQXVELE1BQU1DLElBQUksRUFBRUMsRUFBRSxFQUFFLEVBQUVQLFlBQVksRUFBRUMsa0JBQWtCRCxZQUFZLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUN0RSxNQUFNUSxZQUFZLE9BQU9QLG9CQUFvQixjQUFjLFdBQVcsQ0FBQyxFQUFFQSxnQkFBZ0IsT0FBTyxDQUFDO1FBQ2pHLE1BQU1RLFdBQVcsT0FBT1Isb0JBQW9CLGNBQWMsVUFBVSxDQUFDLEVBQUVBLGdCQUFnQixNQUFNLENBQUM7UUFDOUYsSUFBSSxDQUFDNUUsR0FBRyxDQUFDcUUsWUFBWSxDQUFDMUQsR0FBRyxDQUFDd0UsV0FBVyxDQUFDLEVBQUVGLEtBQUssQ0FBQztRQUM5QyxJQUFJLENBQUNqRixHQUFHLENBQUNxRSxZQUFZLENBQUMxRCxHQUFHLENBQUN5RSxVQUFVLENBQUMsRUFBRUYsS0FBS0QsT0FBTyxFQUFFLENBQUM7UUFDdEQsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7OztDQUlBLEdBQ0FJLFlBQVloRixNQUFNLEVBQUU7UUFDbkIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Ozs7Q0FLQSxHQUNBaUYsU0FBUztRQUNSLElBQUksQ0FBQ3JGLE9BQU8sQ0FBQ1UsR0FBRyxDQUFDLFVBQVU7UUFDM0IsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Ozs7Q0FLQSxHQUNBNEUsY0FBYztRQUNiLElBQUksSUFBSSxDQUFDeEYsTUFBTSxLQUFLLE9BQU8sSUFBSSxDQUFDRSxPQUFPLENBQUNVLEdBQUcsQ0FBQyxVQUFVO2FBQ2pELElBQUksQ0FBQ1YsT0FBTyxDQUFDVSxHQUFHLENBQUMsVUFBVTtRQUNoQyxJQUFJLENBQUNMLGFBQWEsR0FBRztRQUNyQixPQUFPLElBQUk7SUFDWjtJQUNBOztDQUVBLEdBQ0FrRixNQUFNO1FBQ0wsSUFBSSxDQUFDdkYsT0FBTyxDQUFDVSxHQUFHLENBQUMsVUFBVTtRQUMzQixPQUFPLElBQUk7SUFDWjtJQUNBOztDQUVBLEdBQ0E4RSxVQUFVO1FBQ1QsSUFBSSxDQUFDeEYsT0FBTyxDQUFDVSxHQUFHLENBQUMsVUFBVTtRQUMzQixPQUFPLElBQUk7SUFDWjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QkEsR0FDQStFLFFBQVEsRUFBRUMsVUFBVSxLQUFLLEVBQUVDLFVBQVUsS0FBSyxFQUFFQyxXQUFXLEtBQUssRUFBRUMsVUFBVSxLQUFLLEVBQUVDLE1BQU0sS0FBSyxFQUFFQyxTQUFTLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ25ILElBQUlqRTtRQUNKLE1BQU1rRSxVQUFVO1lBQ2ZOLFVBQVUsWUFBWTtZQUN0QkMsVUFBVSxZQUFZO1lBQ3RCQyxXQUFXLGFBQWE7WUFDeEJDLFVBQVUsWUFBWTtZQUN0QkMsTUFBTSxRQUFRO1NBQ2QsQ0FBQ0csTUFBTSxDQUFDQyxTQUFTL0IsSUFBSSxDQUFDO1FBQ3ZCLE1BQU1nQyxlQUFlLENBQUNyRSxvQkFBb0IsSUFBSSxDQUFDOUIsT0FBTyxDQUFDZ0MsR0FBRyxDQUFDLFNBQVEsTUFBTyxRQUFRRixzQkFBc0IsS0FBSyxJQUFJQSxvQkFBb0I7UUFDckksSUFBSSxDQUFDOUIsT0FBTyxDQUFDVSxHQUFHLENBQUMsVUFBVSxDQUFDLDJCQUEyQixFQUFFcUYsT0FBTyxPQUFPLEVBQUVJLGFBQWEsV0FBVyxFQUFFSCxRQUFRLENBQUMsQ0FBQztRQUM3RyxJQUFJRCxXQUFXLFFBQVEsT0FBTyxJQUFJO2FBQzdCLE9BQU8sSUFBSTtJQUNqQjtJQUNBOzs7O0NBSUEsR0FDQUssV0FBVztRQUNWLElBQUksQ0FBQ3BHLE9BQU8sQ0FBQ3FFLE1BQU0sQ0FBQyxVQUFVO1FBQzlCLE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7O0NBS0EsR0FDQVosVUFBVTtRQUNULE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7O0NBS0EsR0FDQTRDLFlBQVk1RixLQUFLLEVBQUU7UUFDbEIsSUFBSSxDQUFDVCxPQUFPLENBQUNxRSxNQUFNLENBQUMsVUFBVTtRQUM5QixJQUFJLENBQUNyRSxPQUFPLENBQUNxRSxNQUFNLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRTVELE1BQU0sQ0FBQztRQUNyRCxPQUFPLElBQUk7SUFDWjtBQUNEO0FBRUEsWUFBWTtBQUNaLHVDQUF1QztBQUN2QyxNQUFNNkYsK0JBQStCLGFBQWEsR0FBRyxJQUFJQyxPQUFPO0FBQ2hFLElBQUlDLHlCQUF5QixjQUFjN0M7SUFDMUM7Ozs7Ozs7Q0FPQSxHQUNBOEMsR0FBR2xDLE1BQU0sRUFBRTlELEtBQUssRUFBRTtRQUNqQixJQUFJLENBQUNWLEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDRSxRQUFRLENBQUMsR0FBRyxFQUFFOUQsTUFBTSxDQUFDO1FBQ2xELE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7O0NBS0EsR0FDQWlHLElBQUluQyxNQUFNLEVBQUU5RCxLQUFLLEVBQUU7UUFDbEIsSUFBSSxDQUFDVixHQUFHLENBQUNxRSxZQUFZLENBQUNDLE1BQU0sQ0FBQ0UsUUFBUSxDQUFDLElBQUksRUFBRTlELE1BQU0sQ0FBQztRQUNuRCxPQUFPLElBQUk7SUFDWjtJQUNBOzs7OztDQUtBLEdBQ0FrRyxHQUFHcEMsTUFBTSxFQUFFOUQsS0FBSyxFQUFFO1FBQ2pCLElBQUksQ0FBQ1YsR0FBRyxDQUFDcUUsWUFBWSxDQUFDQyxNQUFNLENBQUNFLFFBQVEsQ0FBQyxHQUFHLEVBQUU5RCxNQUFNLENBQUM7UUFDbEQsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Ozs7Q0FLQSxHQUNBbUcsSUFBSXJDLE1BQU0sRUFBRTlELEtBQUssRUFBRTtRQUNsQixJQUFJLENBQUNWLEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDRSxRQUFRLENBQUMsSUFBSSxFQUFFOUQsTUFBTSxDQUFDO1FBQ25ELE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7O0NBS0EsR0FDQW9HLEdBQUd0QyxNQUFNLEVBQUU5RCxLQUFLLEVBQUU7UUFDakIsSUFBSSxDQUFDVixHQUFHLENBQUNxRSxZQUFZLENBQUNDLE1BQU0sQ0FBQ0UsUUFBUSxDQUFDLEdBQUcsRUFBRTlELE1BQU0sQ0FBQztRQUNsRCxPQUFPLElBQUk7SUFDWjtJQUNBOzs7OztDQUtBLEdBQ0FxRyxJQUFJdkMsTUFBTSxFQUFFOUQsS0FBSyxFQUFFO1FBQ2xCLElBQUksQ0FBQ1YsR0FBRyxDQUFDcUUsWUFBWSxDQUFDQyxNQUFNLENBQUNFLFFBQVEsQ0FBQyxJQUFJLEVBQUU5RCxNQUFNLENBQUM7UUFDbkQsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Ozs7Q0FLQSxHQUNBc0csS0FBS3hDLE1BQU0sRUFBRXlDLE9BQU8sRUFBRTtRQUNyQixJQUFJLENBQUNqSCxHQUFHLENBQUNxRSxZQUFZLENBQUNDLE1BQU0sQ0FBQ0UsUUFBUSxDQUFDLEtBQUssRUFBRXlDLFFBQVEsQ0FBQztRQUN0RCxPQUFPLElBQUk7SUFDWjtJQUNBOzs7OztDQUtBLEdBQ0FDLFVBQVUxQyxNQUFNLEVBQUUyQyxRQUFRLEVBQUU7UUFDM0IsSUFBSSxDQUFDbkgsR0FBRyxDQUFDcUUsWUFBWSxDQUFDQyxNQUFNLENBQUNFLFFBQVEsQ0FBQyxXQUFXLEVBQUUyQyxTQUFTL0MsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3hFLE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7O0NBS0EsR0FDQWdELFVBQVU1QyxNQUFNLEVBQUUyQyxRQUFRLEVBQUU7UUFDM0IsSUFBSSxDQUFDbkgsR0FBRyxDQUFDcUUsWUFBWSxDQUFDQyxNQUFNLENBQUNFLFFBQVEsQ0FBQyxXQUFXLEVBQUUyQyxTQUFTL0MsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3hFLE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7O0NBS0EsR0FDQWlELE1BQU03QyxNQUFNLEVBQUV5QyxPQUFPLEVBQUU7UUFDdEIsSUFBSSxDQUFDakgsR0FBRyxDQUFDcUUsWUFBWSxDQUFDQyxNQUFNLENBQUNFLFFBQVEsQ0FBQyxNQUFNLEVBQUV5QyxRQUFRLENBQUM7UUFDdkQsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Ozs7Q0FLQSxHQUNBSyxXQUFXOUMsTUFBTSxFQUFFMkMsUUFBUSxFQUFFO1FBQzVCLElBQUksQ0FBQ25ILEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDRSxRQUFRLENBQUMsWUFBWSxFQUFFMkMsU0FBUy9DLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN6RSxPQUFPLElBQUk7SUFDWjtJQUNBOzs7OztDQUtBLEdBQ0FtRCxXQUFXL0MsTUFBTSxFQUFFMkMsUUFBUSxFQUFFO1FBQzVCLElBQUksQ0FBQ25ILEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDRSxRQUFRLENBQUMsWUFBWSxFQUFFMkMsU0FBUy9DLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN6RSxPQUFPLElBQUk7SUFDWjtJQUNBOzs7Ozs7Q0FNQSxHQUNBb0QsV0FBV2hELE1BQU0sRUFBRXlDLE9BQU8sRUFBRTtRQUMzQixJQUFJLENBQUNqSCxHQUFHLENBQUNxRSxZQUFZLENBQUNDLE1BQU0sQ0FBQ0UsUUFBUSxDQUFDLE1BQU0sRUFBRXlDLFFBQVEsQ0FBQztRQUN2RCxPQUFPLElBQUk7SUFDWjtJQUNBOzs7Ozs7Q0FNQSxHQUNBUSxZQUFZakQsTUFBTSxFQUFFeUMsT0FBTyxFQUFFO1FBQzVCLElBQUksQ0FBQ2pILEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDRSxRQUFRLENBQUMsT0FBTyxFQUFFeUMsUUFBUSxDQUFDO1FBQ3hELE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7Ozs7Ozs7O0NBV0EsR0FDQVMsR0FBR2xELE1BQU0sRUFBRTlELEtBQUssRUFBRTtRQUNqQixJQUFJLENBQUNWLEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDRSxRQUFRLENBQUMsR0FBRyxFQUFFOUQsTUFBTSxDQUFDO1FBQ2xELE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7Ozs7OztDQVNBLEdBQ0FpSCxXQUFXbkQsTUFBTSxFQUFFOUQsS0FBSyxFQUFFO1FBQ3pCLElBQUksQ0FBQ1YsR0FBRyxDQUFDcUUsWUFBWSxDQUFDQyxNQUFNLENBQUNFLFFBQVEsQ0FBQyxXQUFXLEVBQUU5RCxNQUFNLENBQUM7UUFDMUQsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Ozs7Q0FLQSxHQUNBa0gsR0FBR3BELE1BQU0sRUFBRXFELE1BQU0sRUFBRTtRQUNsQixNQUFNQyxnQkFBZ0JyRixNQUFNd0MsSUFBSSxDQUFDLElBQUk4QyxJQUFJRixTQUFTNUQsR0FBRyxDQUFDLENBQUMrRDtZQUN0RCxJQUFJLE9BQU9BLE1BQU0sWUFBWXpCLDZCQUE2QnBDLElBQUksQ0FBQzZELElBQUksT0FBTyxDQUFDLENBQUMsRUFBRUEsRUFBRSxDQUFDLENBQUM7aUJBQzdFLE9BQU8sQ0FBQyxFQUFFQSxFQUFFLENBQUM7UUFDbkIsR0FBRzVELElBQUksQ0FBQztRQUNSLElBQUksQ0FBQ3BFLEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDRSxRQUFRLENBQUMsSUFBSSxFQUFFc0QsY0FBYyxDQUFDLENBQUM7UUFDNUQsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Ozs7Q0FLQSxHQUNBRyxNQUFNekQsTUFBTSxFQUFFcUQsTUFBTSxFQUFFO1FBQ3JCLE1BQU1DLGdCQUFnQnJGLE1BQU13QyxJQUFJLENBQUMsSUFBSThDLElBQUlGLFNBQVM1RCxHQUFHLENBQUMsQ0FBQytEO1lBQ3RELElBQUksT0FBT0EsTUFBTSxZQUFZekIsNkJBQTZCcEMsSUFBSSxDQUFDNkQsSUFBSSxPQUFPLENBQUMsQ0FBQyxFQUFFQSxFQUFFLENBQUMsQ0FBQztpQkFDN0UsT0FBTyxDQUFDLEVBQUVBLEVBQUUsQ0FBQztRQUNuQixHQUFHNUQsSUFBSSxDQUFDO1FBQ1IsSUFBSSxDQUFDcEUsR0FBRyxDQUFDcUUsWUFBWSxDQUFDQyxNQUFNLENBQUNFLFFBQVEsQ0FBQyxRQUFRLEVBQUVzRCxjQUFjLENBQUMsQ0FBQztRQUNoRSxPQUFPLElBQUk7SUFDWjtJQUNBOzs7Ozs7Q0FNQSxHQUNBSSxTQUFTMUQsTUFBTSxFQUFFOUQsS0FBSyxFQUFFO1FBQ3ZCLElBQUksT0FBT0EsVUFBVSxVQUFVLElBQUksQ0FBQ1YsR0FBRyxDQUFDcUUsWUFBWSxDQUFDQyxNQUFNLENBQUNFLFFBQVEsQ0FBQyxHQUFHLEVBQUU5RCxNQUFNLENBQUM7YUFDNUUsSUFBSStCLE1BQU1DLE9BQU8sQ0FBQ2hDLFFBQVEsSUFBSSxDQUFDVixHQUFHLENBQUNxRSxZQUFZLENBQUNDLE1BQU0sQ0FBQ0UsUUFBUSxDQUFDLElBQUksRUFBRTlELE1BQU0wRCxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDeEYsSUFBSSxDQUFDcEUsR0FBRyxDQUFDcUUsWUFBWSxDQUFDQyxNQUFNLENBQUNFLFFBQVEsQ0FBQyxHQUFHLEVBQUVwRCxLQUFLQyxTQUFTLENBQUNYLE9BQU8sQ0FBQztRQUN2RSxPQUFPLElBQUk7SUFDWjtJQUNBOzs7Ozs7Q0FNQSxHQUNBeUgsWUFBWTNELE1BQU0sRUFBRTlELEtBQUssRUFBRTtRQUMxQixJQUFJLE9BQU9BLFVBQVUsVUFBVSxJQUFJLENBQUNWLEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDRSxRQUFRLENBQUMsR0FBRyxFQUFFOUQsTUFBTSxDQUFDO2FBQzVFLElBQUkrQixNQUFNQyxPQUFPLENBQUNoQyxRQUFRLElBQUksQ0FBQ1YsR0FBRyxDQUFDcUUsWUFBWSxDQUFDQyxNQUFNLENBQUNFLFFBQVEsQ0FBQyxJQUFJLEVBQUU5RCxNQUFNMEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3hGLElBQUksQ0FBQ3BFLEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDRSxRQUFRLENBQUMsR0FBRyxFQUFFcEQsS0FBS0MsU0FBUyxDQUFDWCxPQUFPLENBQUM7UUFDdkUsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Ozs7O0NBTUEsR0FDQTBILFFBQVE1RCxNQUFNLEVBQUVRLEtBQUssRUFBRTtRQUN0QixJQUFJLENBQUNoRixHQUFHLENBQUNxRSxZQUFZLENBQUNDLE1BQU0sQ0FBQ0UsUUFBUSxDQUFDLEdBQUcsRUFBRVEsTUFBTSxDQUFDO1FBQ2xELE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7Ozs7Q0FPQSxHQUNBcUQsU0FBUzdELE1BQU0sRUFBRVEsS0FBSyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ2hGLEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDRSxRQUFRLENBQUMsSUFBSSxFQUFFUSxNQUFNLENBQUM7UUFDbkQsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Ozs7O0NBTUEsR0FDQXNELFFBQVE5RCxNQUFNLEVBQUVRLEtBQUssRUFBRTtRQUN0QixJQUFJLENBQUNoRixHQUFHLENBQUNxRSxZQUFZLENBQUNDLE1BQU0sQ0FBQ0UsUUFBUSxDQUFDLEdBQUcsRUFBRVEsTUFBTSxDQUFDO1FBQ2xELE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7Ozs7Q0FPQSxHQUNBdUQsU0FBUy9ELE1BQU0sRUFBRVEsS0FBSyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ2hGLEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDRSxRQUFRLENBQUMsSUFBSSxFQUFFUSxNQUFNLENBQUM7UUFDbkQsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Ozs7OztDQU9BLEdBQ0F3RCxjQUFjaEUsTUFBTSxFQUFFUSxLQUFLLEVBQUU7UUFDNUIsSUFBSSxDQUFDaEYsR0FBRyxDQUFDcUUsWUFBWSxDQUFDQyxNQUFNLENBQUNFLFFBQVEsQ0FBQyxJQUFJLEVBQUVRLE1BQU0sQ0FBQztRQUNuRCxPQUFPLElBQUk7SUFDWjtJQUNBOzs7Ozs7Q0FNQSxHQUNBeUQsU0FBU2pFLE1BQU0sRUFBRTlELEtBQUssRUFBRTtRQUN2QixJQUFJLE9BQU9BLFVBQVUsVUFBVSxJQUFJLENBQUNWLEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDRSxRQUFRLENBQUMsR0FBRyxFQUFFOUQsTUFBTSxDQUFDO2FBQzVFLElBQUksQ0FBQ1YsR0FBRyxDQUFDcUUsWUFBWSxDQUFDQyxNQUFNLENBQUNFLFFBQVEsQ0FBQyxJQUFJLEVBQUU5RCxNQUFNMEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ25FLE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7Ozs7OztDQVNBLEdBQ0FzRSxXQUFXbEUsTUFBTSxFQUFFbUUsS0FBSyxFQUFFLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDaEQsSUFBSUMsV0FBVztRQUNmLElBQUlELFNBQVMsU0FBU0MsV0FBVzthQUM1QixJQUFJRCxTQUFTLFVBQVVDLFdBQVc7YUFDbEMsSUFBSUQsU0FBUyxhQUFhQyxXQUFXO1FBQzFDLE1BQU1DLGFBQWFILFdBQVcsS0FBSyxJQUFJLEtBQUssQ0FBQyxDQUFDLEVBQUVBLE9BQU8sQ0FBQyxDQUFDO1FBQ3pELElBQUksQ0FBQzVJLEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDRSxRQUFRLENBQUMsRUFBRXNFLFNBQVMsR0FBRyxFQUFFQyxXQUFXLENBQUMsRUFBRUosTUFBTSxDQUFDO1FBQzNFLE9BQU8sSUFBSTtJQUNaO0lBQ0E7Ozs7OztDQU1BLEdBQ0F2RyxNQUFNdUcsS0FBSyxFQUFFO1FBQ1pLLE9BQU9DLE9BQU8sQ0FBQ04sT0FBT08sT0FBTyxDQUFDLENBQUMsQ0FBQzFFLFFBQVE5RCxNQUFNO1lBQzdDLElBQUksQ0FBQ1YsR0FBRyxDQUFDcUUsWUFBWSxDQUFDQyxNQUFNLENBQUNFLFFBQVEsQ0FBQyxHQUFHLEVBQUU5RCxNQUFNLENBQUM7UUFDbkQ7UUFDQSxPQUFPLElBQUk7SUFDWjtJQUNBOzs7Ozs7Ozs7Ozs7Q0FZQSxHQUNBeUksSUFBSTNFLE1BQU0sRUFBRTRFLFFBQVEsRUFBRTFJLEtBQUssRUFBRTtRQUM1QixJQUFJLENBQUNWLEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDRSxRQUFRLENBQUMsSUFBSSxFQUFFNEUsU0FBUyxDQUFDLEVBQUUxSSxNQUFNLENBQUM7UUFDL0QsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQSxHQUNBMkksR0FBR0MsT0FBTyxFQUFFLEVBQUUzRSxZQUFZLEVBQUVDLGtCQUFrQkQsWUFBWSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDbEUsTUFBTUUsTUFBTUQsa0JBQWtCLENBQUMsRUFBRUEsZ0JBQWdCLEdBQUcsQ0FBQyxHQUFHO1FBQ3hELElBQUksQ0FBQzVFLEdBQUcsQ0FBQ3FFLFlBQVksQ0FBQ0MsTUFBTSxDQUFDTyxLQUFLLENBQUMsQ0FBQyxFQUFFeUUsUUFBUSxDQUFDLENBQUM7UUFDaEQsT0FBTyxJQUFJO0lBQ1o7SUFDQTs7Ozs7Ozs7Ozs7O0NBWUEsR0FDQXBELE9BQU8xQixNQUFNLEVBQUU0RSxRQUFRLEVBQUUxSSxLQUFLLEVBQUU7UUFDL0IsSUFBSSxDQUFDVixHQUFHLENBQUNxRSxZQUFZLENBQUNDLE1BQU0sQ0FBQ0UsUUFBUSxDQUFDLEVBQUU0RSxTQUFTLENBQUMsRUFBRTFJLE1BQU0sQ0FBQztRQUMzRCxPQUFPLElBQUk7SUFDWjtBQUNEO0FBRUEsWUFBWTtBQUNaLHNDQUFzQztBQUN0QyxJQUFJNkksd0JBQXdCO0lBQzNCOzs7Ozs7Ozs7Ozs7Q0FZQSxHQUNBcEssWUFBWWEsR0FBRyxFQUFFLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUVFLE1BQU0sRUFBRUksT0FBT2lKLE9BQU8sRUFBRSxDQUFFO1FBQzFELElBQUksQ0FBQ3hKLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJQyxRQUFRRDtRQUMzQixJQUFJLENBQUNFLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNJLEtBQUssR0FBR2lKO0lBQ2Q7SUFDQTs7Q0FFQSxHQUNBQyxvQkFBb0I7UUFDbkIsT0FBTztZQUNOekosS0FBSyxJQUFJMEosSUFBSSxJQUFJLENBQUMxSixHQUFHLENBQUNtQixRQUFRO1lBQzlCbEIsU0FBUyxJQUFJQyxRQUFRLElBQUksQ0FBQ0QsT0FBTztRQUNsQztJQUNEO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JBLEdBQ0E0RCxPQUFPQyxPQUFPLEVBQUVtQyxPQUFPLEVBQUU7UUFDeEIsTUFBTSxFQUFFMEQsT0FBTyxLQUFLLEVBQUVsSSxLQUFLLEVBQUUsR0FBR3dFLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUlBLFVBQVUsQ0FBQztRQUNwRixNQUFNbEcsU0FBUzRKLE9BQU8sU0FBUztRQUMvQixJQUFJNUYsU0FBUztRQUNiLE1BQU1DLGlCQUFpQixDQUFDRixZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJQSxVQUFVLEdBQUUsRUFBR3hCLEtBQUssQ0FBQyxJQUFJMkIsR0FBRyxDQUFDLENBQUNDO1lBQzlGLElBQUksS0FBS0MsSUFBSSxDQUFDRCxNQUFNLENBQUNILFFBQVEsT0FBTztZQUNwQyxJQUFJRyxNQUFNLEtBQU1ILFNBQVMsQ0FBQ0E7WUFDMUIsT0FBT0c7UUFDUixHQUFHRSxJQUFJLENBQUM7UUFDUixNQUFNLEVBQUVwRSxHQUFHLEVBQUVDLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQ3dKLGlCQUFpQjtRQUMvQ3pKLElBQUlxRSxZQUFZLENBQUMxRCxHQUFHLENBQUMsVUFBVXFEO1FBQy9CLElBQUl2QyxPQUFPeEIsUUFBUXFFLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFN0MsTUFBTSxDQUFDO1FBQ3BELE9BQU8sSUFBSWdGLHVCQUF1QjtZQUNqQzFHO1lBQ0FDO1lBQ0FDO1lBQ0FFLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CSSxPQUFPLElBQUksQ0FBQ0EsS0FBSztRQUNsQjtJQUNEO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkEsR0FDQXFKLE9BQU8vQixNQUFNLEVBQUUsRUFBRXBHLEtBQUssRUFBRW9JLGdCQUFnQixJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUNwRCxJQUFJQztRQUNKLE1BQU0vSixTQUFTO1FBQ2YsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQ3dKLGlCQUFpQjtRQUMvQyxJQUFJaEksT0FBT3hCLFFBQVFxRSxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRTdDLE1BQU0sQ0FBQztRQUNwRCxJQUFJLENBQUNvSSxlQUFlNUosUUFBUXFFLE1BQU0sQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDO1FBQzlELElBQUk3QixNQUFNQyxPQUFPLENBQUNtRixTQUFTO1lBQzFCLE1BQU0vRCxVQUFVK0QsT0FBT2tDLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxJQUFNRCxJQUFJRSxNQUFNLENBQUNsQixPQUFPbUIsSUFBSSxDQUFDRixLQUFLLEVBQUU7WUFDeEUsSUFBSW5HLFFBQVF2QixNQUFNLEdBQUcsR0FBRztnQkFDdkIsTUFBTTZILGdCQUFnQjt1QkFBSSxJQUFJckMsSUFBSWpFO2lCQUFTLENBQUNHLEdBQUcsQ0FBQyxDQUFDTyxTQUFXLENBQUMsQ0FBQyxFQUFFQSxPQUFPLENBQUMsQ0FBQztnQkFDekV4RSxJQUFJcUUsWUFBWSxDQUFDMUQsR0FBRyxDQUFDLFdBQVd5SixjQUFjaEcsSUFBSSxDQUFDO1lBQ3BEO1FBQ0Q7UUFDQSxPQUFPLElBQUlxQyx1QkFBdUI7WUFDakMxRztZQUNBQztZQUNBQztZQUNBRSxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQkMsTUFBTXlIO1lBQ050SCxPQUFPLENBQUN1SixjQUFjLElBQUksQ0FBQ3ZKLEtBQUssTUFBTSxRQUFRdUosZ0JBQWdCLEtBQUssSUFBSUEsY0FBY3ZKO1FBQ3RGO0lBQ0Q7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0ZBLEdBQ0E4SixPQUFPeEMsTUFBTSxFQUFFLEVBQUV5QyxVQUFVLEVBQUVDLG1CQUFtQixLQUFLLEVBQUU5SSxLQUFLLEVBQUVvSSxnQkFBZ0IsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDMUYsSUFBSVc7UUFDSixNQUFNekssU0FBUztRQUNmLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUN3SixpQkFBaUI7UUFDL0N4SixRQUFRcUUsTUFBTSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUVpRyxtQkFBbUIsV0FBVyxRQUFRLFdBQVcsQ0FBQztRQUN6RixJQUFJRCxlQUFlLEtBQUssR0FBR3RLLElBQUlxRSxZQUFZLENBQUMxRCxHQUFHLENBQUMsZUFBZTJKO1FBQy9ELElBQUk3SSxPQUFPeEIsUUFBUXFFLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFN0MsTUFBTSxDQUFDO1FBQ3BELElBQUksQ0FBQ29JLGVBQWU1SixRQUFRcUUsTUFBTSxDQUFDLFVBQVU7UUFDN0MsSUFBSTdCLE1BQU1DLE9BQU8sQ0FBQ21GLFNBQVM7WUFDMUIsTUFBTS9ELFVBQVUrRCxPQUFPa0MsTUFBTSxDQUFDLENBQUNDLEtBQUtDLElBQU1ELElBQUlFLE1BQU0sQ0FBQ2xCLE9BQU9tQixJQUFJLENBQUNGLEtBQUssRUFBRTtZQUN4RSxJQUFJbkcsUUFBUXZCLE1BQU0sR0FBRyxHQUFHO2dCQUN2QixNQUFNNkgsZ0JBQWdCO3VCQUFJLElBQUlyQyxJQUFJakU7aUJBQVMsQ0FBQ0csR0FBRyxDQUFDLENBQUNPLFNBQVcsQ0FBQyxDQUFDLEVBQUVBLE9BQU8sQ0FBQyxDQUFDO2dCQUN6RXhFLElBQUlxRSxZQUFZLENBQUMxRCxHQUFHLENBQUMsV0FBV3lKLGNBQWNoRyxJQUFJLENBQUM7WUFDcEQ7UUFDRDtRQUNBLE9BQU8sSUFBSXFDLHVCQUF1QjtZQUNqQzFHO1lBQ0FDO1lBQ0FDO1lBQ0FFLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CQyxNQUFNeUg7WUFDTnRILE9BQU8sQ0FBQ2lLLGVBQWUsSUFBSSxDQUFDakssS0FBSyxNQUFNLFFBQVFpSyxpQkFBaUIsS0FBSyxJQUFJQSxlQUFlaks7UUFDekY7SUFDRDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQSxHQUNBa0ssT0FBTzVDLE1BQU0sRUFBRSxFQUFFcEcsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDOUIsSUFBSWlKO1FBQ0osTUFBTTNLLFNBQVM7UUFDZixNQUFNLEVBQUVDLEdBQUcsRUFBRUMsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDd0osaUJBQWlCO1FBQy9DLElBQUloSSxPQUFPeEIsUUFBUXFFLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFN0MsTUFBTSxDQUFDO1FBQ3BELE9BQU8sSUFBSWdGLHVCQUF1QjtZQUNqQzFHO1lBQ0FDO1lBQ0FDO1lBQ0FFLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CQyxNQUFNeUg7WUFDTnRILE9BQU8sQ0FBQ21LLGVBQWUsSUFBSSxDQUFDbkssS0FBSyxNQUFNLFFBQVFtSyxpQkFBaUIsS0FBSyxJQUFJQSxlQUFlbks7UUFDekY7SUFDRDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkEsR0FDQW9LLE9BQU8sRUFBRWxKLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ3RCLElBQUltSjtRQUNKLE1BQU03SyxTQUFTO1FBQ2YsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQ3dKLGlCQUFpQjtRQUMvQyxJQUFJaEksT0FBT3hCLFFBQVFxRSxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRTdDLE1BQU0sQ0FBQztRQUNwRCxPQUFPLElBQUlnRix1QkFBdUI7WUFDakMxRztZQUNBQztZQUNBQztZQUNBRSxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQkksT0FBTyxDQUFDcUssZUFBZSxJQUFJLENBQUNySyxLQUFLLE1BQU0sUUFBUXFLLGlCQUFpQixLQUFLLElBQUlBLGVBQWVySztRQUN6RjtJQUNEO0FBQ0Q7QUFFQSxZQUFZO0FBQ1osZ0NBQWdDO0FBQ2hDOzs7Ozs7Ozs7QUFTQSxHQUNBLElBQUlzSyxrQkFBa0IsTUFBTUE7SUFDM0I7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJBLEdBQ0ExTCxZQUFZYSxHQUFHLEVBQUUsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRUUsTUFBTSxFQUFFSSxPQUFPaUosT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDL0QsSUFBSSxDQUFDeEosR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlDLFFBQVFEO1FBQzNCLElBQUksQ0FBQzZLLFVBQVUsR0FBRzNLO1FBQ2xCLElBQUksQ0FBQ0ksS0FBSyxHQUFHaUo7SUFDZDtJQUNBOzs7O0NBSUEsR0FDQXZFLEtBQUs4RixRQUFRLEVBQUU7UUFDZCxJQUFJLENBQUNBLFlBQVksT0FBT0EsYUFBYSxZQUFZQSxTQUFTQyxJQUFJLE9BQU8sSUFBSSxNQUFNLElBQUk5TCxNQUFNO1FBQ3pGLE9BQU8sSUFBSXFLLHNCQUFzQixJQUFJRyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMxSixHQUFHLENBQUMsQ0FBQyxFQUFFK0ssU0FBUyxDQUFDLEdBQUc7WUFDcEU5SyxTQUFTLElBQUlDLFFBQVEsSUFBSSxDQUFDRCxPQUFPO1lBQ2pDRSxRQUFRLElBQUksQ0FBQzJLLFVBQVU7WUFDdkJ2SyxPQUFPLElBQUksQ0FBQ0EsS0FBSztRQUNsQjtJQUNEO0lBQ0E7Ozs7OztDQU1BLEdBQ0FKLE9BQU9BLE1BQU0sRUFBRTtRQUNkLE9BQU8sSUFBSTBLLGdCQUFnQixJQUFJLENBQUM3SyxHQUFHLEVBQUU7WUFDcENDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCRTtZQUNBSSxPQUFPLElBQUksQ0FBQ0EsS0FBSztRQUNsQjtJQUNEO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0ErQkEsR0FDQTBLLElBQUlDLEVBQUUsRUFBRUMsT0FBTyxDQUFDLENBQUMsRUFBRSxFQUFFeEIsT0FBTyxLQUFLLEVBQUUxSCxNQUFNLEtBQUssRUFBRVIsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDN0QsSUFBSXFJO1FBQ0osSUFBSS9KO1FBQ0osTUFBTUMsTUFBTSxJQUFJMEosSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDMUosR0FBRyxDQUFDLEtBQUssRUFBRWtMLEdBQUcsQ0FBQztRQUMzQyxJQUFJOUs7UUFDSixNQUFNZ0wsWUFBWSxDQUFDQyxJQUFNQSxNQUFNLFFBQVEsT0FBT0EsTUFBTSxZQUFhLEVBQUM1SSxNQUFNQyxPQUFPLENBQUMySSxNQUFNQSxFQUFFQyxJQUFJLENBQUNGLFVBQVM7UUFDdEcsTUFBTUcsZ0JBQWdCNUIsUUFBUVgsT0FBT25CLE1BQU0sQ0FBQ3NELE1BQU1HLElBQUksQ0FBQ0Y7UUFDdkQsSUFBSUcsZUFBZTtZQUNsQnhMLFNBQVM7WUFDVEssT0FBTytLO1FBQ1IsT0FBTyxJQUFJeEIsUUFBUTFILEtBQUs7WUFDdkJsQyxTQUFTNEosT0FBTyxTQUFTO1lBQ3pCWCxPQUFPQyxPQUFPLENBQUNrQyxNQUFNakYsTUFBTSxDQUFDLENBQUMsQ0FBQ3NGLEdBQUc5SyxNQUFNLEdBQUtBLFVBQVUsS0FBSyxHQUFHdUQsR0FBRyxDQUFDLENBQUMsQ0FBQzNFLE1BQU1vQixNQUFNLEdBQUs7b0JBQUNwQjtvQkFBTW1ELE1BQU1DLE9BQU8sQ0FBQ2hDLFNBQVMsQ0FBQyxDQUFDLEVBQUVBLE1BQU0wRCxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUxRCxNQUFNLENBQUM7aUJBQUMsRUFBRXdJLE9BQU8sQ0FBQyxDQUFDLENBQUM1SixNQUFNb0IsTUFBTTtnQkFDOUtWLElBQUlxRSxZQUFZLENBQUNDLE1BQU0sQ0FBQ2hGLE1BQU1vQjtZQUMvQjtRQUNELE9BQU87WUFDTlgsU0FBUztZQUNUSyxPQUFPK0s7UUFDUjtRQUNBLE1BQU1sTCxVQUFVLElBQUlDLFFBQVEsSUFBSSxDQUFDRCxPQUFPO1FBQ3hDLElBQUlzTCxlQUFldEwsUUFBUVUsR0FBRyxDQUFDLFVBQVVjLFFBQVEsQ0FBQyxNQUFNLEVBQUVBLE1BQU0sZUFBZSxDQUFDLEdBQUc7YUFDOUUsSUFBSUEsT0FBT3hCLFFBQVFVLEdBQUcsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFYyxNQUFNLENBQUM7UUFDdEQsT0FBTyxJQUFJZ0YsdUJBQXVCO1lBQ2pDMUc7WUFDQUM7WUFDQUM7WUFDQUUsUUFBUSxJQUFJLENBQUMySyxVQUFVO1lBQ3ZCMUs7WUFDQUcsT0FBTyxDQUFDdUosY0FBYyxJQUFJLENBQUN2SixLQUFLLE1BQU0sUUFBUXVKLGdCQUFnQixLQUFLLElBQUlBLGNBQWN2SjtRQUN0RjtJQUNEO0FBQ0Q7QUFFQSxZQUFZO0FBQ1osc0JBQXNCO0FBQ3RCLElBQUlrTCxjQUFjO0lBQ2pCWjtJQUNBdEI7SUFDQTlDO0lBQ0E3QztJQUNBbEU7SUFDQVQ7QUFDRDtBQUVBLFlBQVk7QUFDbUosQ0FDL0osa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9pbmRleC5tanM/N2FjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gc3JjL1Bvc3RncmVzdEVycm9yLnRzXG4vKipcbiogRXJyb3IgZm9ybWF0XG4qXG4qIHtAbGluayBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sP2hpZ2hsaWdodD1vcHRpb25zI2Vycm9ycy1hbmQtaHR0cC1zdGF0dXMtY29kZXN9XG4qL1xudmFyIFBvc3RncmVzdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdC8qKlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHNcblx0KiBpbXBvcnQgUG9zdGdyZXN0RXJyb3IgZnJvbSAnQHN1cGFiYXNlL3Bvc3RncmVzdC1qcydcblx0KlxuXHQqIHRocm93IG5ldyBQb3N0Z3Jlc3RFcnJvcih7XG5cdCogICBtZXNzYWdlOiAnUm93IGxldmVsIHNlY3VyaXR5IHByZXZlbnRlZCB0aGUgcmVxdWVzdCcsXG5cdCogICBkZXRhaWxzOiAnUkxTIGRlbmllZCB0aGUgaW5zZXJ0Jyxcblx0KiAgIGhpbnQ6ICdDaGVjayB5b3VyIHBvbGljaWVzJyxcblx0KiAgIGNvZGU6ICdQR1JTVDMwMScsXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IoY29udGV4dCkge1xuXHRcdHN1cGVyKGNvbnRleHQubWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gXCJQb3N0Z3Jlc3RFcnJvclwiO1xuXHRcdHRoaXMuZGV0YWlscyA9IGNvbnRleHQuZGV0YWlscztcblx0XHR0aGlzLmhpbnQgPSBjb250ZXh0LmhpbnQ7XG5cdFx0dGhpcy5jb2RlID0gY29udGV4dC5jb2RlO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvUG9zdGdyZXN0QnVpbGRlci50c1xudmFyIFBvc3RncmVzdEJ1aWxkZXIgPSBjbGFzcyB7XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBidWlsZGVyIGNvbmZpZ3VyZWQgZm9yIGEgc3BlY2lmaWMgUG9zdGdSRVNUIHJlcXVlc3QuXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHRzXG5cdCogaW1wb3J0IFBvc3RncmVzdFF1ZXJ5QnVpbGRlciBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuXHQqXG5cdCogY29uc3QgYnVpbGRlciA9IG5ldyBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIoXG5cdCogICBuZXcgVVJMKCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vcmVzdC92MS91c2VycycpLFxuXHQqICAgeyBoZWFkZXJzOiBuZXcgSGVhZGVycyh7IGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScgfSkgfVxuXHQqIClcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IoYnVpbGRlcikge1xuXHRcdHZhciBfYnVpbGRlciRzaG91bGRUaHJvd08sIF9idWlsZGVyJGlzTWF5YmVTaW5nbDtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuXHRcdHRoaXMubWV0aG9kID0gYnVpbGRlci5tZXRob2Q7XG5cdFx0dGhpcy51cmwgPSBidWlsZGVyLnVybDtcblx0XHR0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhidWlsZGVyLmhlYWRlcnMpO1xuXHRcdHRoaXMuc2NoZW1hID0gYnVpbGRlci5zY2hlbWE7XG5cdFx0dGhpcy5ib2R5ID0gYnVpbGRlci5ib2R5O1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gKF9idWlsZGVyJHNob3VsZFRocm93TyA9IGJ1aWxkZXIuc2hvdWxkVGhyb3dPbkVycm9yKSAhPT0gbnVsbCAmJiBfYnVpbGRlciRzaG91bGRUaHJvd08gIT09IHZvaWQgMCA/IF9idWlsZGVyJHNob3VsZFRocm93TyA6IGZhbHNlO1xuXHRcdHRoaXMuc2lnbmFsID0gYnVpbGRlci5zaWduYWw7XG5cdFx0dGhpcy5pc01heWJlU2luZ2xlID0gKF9idWlsZGVyJGlzTWF5YmVTaW5nbCA9IGJ1aWxkZXIuaXNNYXliZVNpbmdsZSkgIT09IG51bGwgJiYgX2J1aWxkZXIkaXNNYXliZVNpbmdsICE9PSB2b2lkIDAgPyBfYnVpbGRlciRpc01heWJlU2luZ2wgOiBmYWxzZTtcblx0XHRpZiAoYnVpbGRlci5mZXRjaCkgdGhpcy5mZXRjaCA9IGJ1aWxkZXIuZmV0Y2g7XG5cdFx0ZWxzZSB0aGlzLmZldGNoID0gZmV0Y2g7XG5cdH1cblx0LyoqXG5cdCogSWYgdGhlcmUncyBhbiBlcnJvciB3aXRoIHRoZSBxdWVyeSwgdGhyb3dPbkVycm9yIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlIGJ5XG5cdCogdGhyb3dpbmcgdGhlIGVycm9yIGluc3RlYWQgb2YgcmV0dXJuaW5nIGl0IGFzIHBhcnQgb2YgYSBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuXHQqXG5cdCoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9zdXBhYmFzZS1qcy9pc3N1ZXMvOTJ9XG5cdCovXG5cdHRocm93T25FcnJvcigpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogU2V0IGFuIEhUVFAgaGVhZGVyIGZvciB0aGUgcmVxdWVzdC5cblx0Ki9cblx0c2V0SGVhZGVyKG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKTtcblx0XHR0aGlzLmhlYWRlcnMuc2V0KG5hbWUsIHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRpZiAodGhpcy5zY2hlbWEgPT09IHZvaWQgMCkge30gZWxzZSBpZiAoW1wiR0VUXCIsIFwiSEVBRFwiXS5pbmNsdWRlcyh0aGlzLm1ldGhvZCkpIHRoaXMuaGVhZGVycy5zZXQoXCJBY2NlcHQtUHJvZmlsZVwiLCB0aGlzLnNjaGVtYSk7XG5cdFx0ZWxzZSB0aGlzLmhlYWRlcnMuc2V0KFwiQ29udGVudC1Qcm9maWxlXCIsIHRoaXMuc2NoZW1hKTtcblx0XHRpZiAodGhpcy5tZXRob2QgIT09IFwiR0VUXCIgJiYgdGhpcy5tZXRob2QgIT09IFwiSEVBRFwiKSB0aGlzLmhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcblx0XHRjb25zdCBfZmV0Y2ggPSB0aGlzLmZldGNoO1xuXHRcdGxldCByZXMgPSBfZmV0Y2godGhpcy51cmwudG9TdHJpbmcoKSwge1xuXHRcdFx0bWV0aG9kOiB0aGlzLm1ldGhvZCxcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdGJvZHk6IEpTT04uc3RyaW5naWZ5KHRoaXMuYm9keSksXG5cdFx0XHRzaWduYWw6IHRoaXMuc2lnbmFsXG5cdFx0fSkudGhlbihhc3luYyAocmVzJDEpID0+IHtcblx0XHRcdGxldCBlcnJvciA9IG51bGw7XG5cdFx0XHRsZXQgZGF0YSA9IG51bGw7XG5cdFx0XHRsZXQgY291bnQgPSBudWxsO1xuXHRcdFx0bGV0IHN0YXR1cyA9IHJlcyQxLnN0YXR1cztcblx0XHRcdGxldCBzdGF0dXNUZXh0ID0gcmVzJDEuc3RhdHVzVGV4dDtcblx0XHRcdGlmIChyZXMkMS5vaykge1xuXHRcdFx0XHR2YXIgX3RoaXMkaGVhZGVycyRnZXQyLCBfcmVzJGhlYWRlcnMkZ2V0O1xuXHRcdFx0XHRpZiAoX3RoaXMubWV0aG9kICE9PSBcIkhFQURcIikge1xuXHRcdFx0XHRcdHZhciBfdGhpcyRoZWFkZXJzJGdldDtcblx0XHRcdFx0XHRjb25zdCBib2R5ID0gYXdhaXQgcmVzJDEudGV4dCgpO1xuXHRcdFx0XHRcdGlmIChib2R5ID09PSBcIlwiKSB7fSBlbHNlIGlmIChfdGhpcy5oZWFkZXJzLmdldChcIkFjY2VwdFwiKSA9PT0gXCJ0ZXh0L2NzdlwiKSBkYXRhID0gYm9keTtcblx0XHRcdFx0XHRlbHNlIGlmIChfdGhpcy5oZWFkZXJzLmdldChcIkFjY2VwdFwiKSAmJiAoKF90aGlzJGhlYWRlcnMkZ2V0ID0gX3RoaXMuaGVhZGVycy5nZXQoXCJBY2NlcHRcIikpID09PSBudWxsIHx8IF90aGlzJGhlYWRlcnMkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRoZWFkZXJzJGdldC5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5wbGFuK3RleHRcIikpKSBkYXRhID0gYm9keTtcblx0XHRcdFx0XHRlbHNlIGRhdGEgPSBKU09OLnBhcnNlKGJvZHkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IGNvdW50SGVhZGVyID0gKF90aGlzJGhlYWRlcnMkZ2V0MiA9IF90aGlzLmhlYWRlcnMuZ2V0KFwiUHJlZmVyXCIpKSA9PT0gbnVsbCB8fCBfdGhpcyRoZWFkZXJzJGdldDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGhlYWRlcnMkZ2V0Mi5tYXRjaCgvY291bnQ9KGV4YWN0fHBsYW5uZWR8ZXN0aW1hdGVkKS8pO1xuXHRcdFx0XHRjb25zdCBjb250ZW50UmFuZ2UgPSAoX3JlcyRoZWFkZXJzJGdldCA9IHJlcyQxLmhlYWRlcnMuZ2V0KFwiY29udGVudC1yYW5nZVwiKSkgPT09IG51bGwgfHwgX3JlcyRoZWFkZXJzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRoZWFkZXJzJGdldC5zcGxpdChcIi9cIik7XG5cdFx0XHRcdGlmIChjb3VudEhlYWRlciAmJiBjb250ZW50UmFuZ2UgJiYgY29udGVudFJhbmdlLmxlbmd0aCA+IDEpIGNvdW50ID0gcGFyc2VJbnQoY29udGVudFJhbmdlWzFdKTtcblx0XHRcdFx0aWYgKF90aGlzLmlzTWF5YmVTaW5nbGUgJiYgX3RoaXMubWV0aG9kID09PSBcIkdFVFwiICYmIEFycmF5LmlzQXJyYXkoZGF0YSkpIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRlcnJvciA9IHtcblx0XHRcdFx0XHRcdGNvZGU6IFwiUEdSU1QxMTZcIixcblx0XHRcdFx0XHRcdGRldGFpbHM6IGBSZXN1bHRzIGNvbnRhaW4gJHtkYXRhLmxlbmd0aH0gcm93cywgYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uIHJlcXVpcmVzIDEgcm93YCxcblx0XHRcdFx0XHRcdGhpbnQ6IG51bGwsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiBcIkpTT04gb2JqZWN0IHJlcXVlc3RlZCwgbXVsdGlwbGUgKG9yIG5vKSByb3dzIHJldHVybmVkXCJcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGRhdGEgPSBudWxsO1xuXHRcdFx0XHRcdGNvdW50ID0gbnVsbDtcblx0XHRcdFx0XHRzdGF0dXMgPSA0MDY7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiTm90IEFjY2VwdGFibGVcIjtcblx0XHRcdFx0fSBlbHNlIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkgZGF0YSA9IGRhdGFbMF07XG5cdFx0XHRcdGVsc2UgZGF0YSA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgX2Vycm9yJGRldGFpbHM7XG5cdFx0XHRcdGNvbnN0IGJvZHkgPSBhd2FpdCByZXMkMS50ZXh0KCk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZXJyb3IgPSBKU09OLnBhcnNlKGJvZHkpO1xuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGVycm9yKSAmJiByZXMkMS5zdGF0dXMgPT09IDQwNCkge1xuXHRcdFx0XHRcdFx0ZGF0YSA9IFtdO1xuXHRcdFx0XHRcdFx0ZXJyb3IgPSBudWxsO1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMjAwO1xuXHRcdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiT0tcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKF91bnVzZWQpIHtcblx0XHRcdFx0XHRpZiAocmVzJDEuc3RhdHVzID09PSA0MDQgJiYgYm9keSA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMjA0O1xuXHRcdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiTm8gQ29udGVudFwiO1xuXHRcdFx0XHRcdH0gZWxzZSBlcnJvciA9IHsgbWVzc2FnZTogYm9keSB9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlcnJvciAmJiBfdGhpcy5pc01heWJlU2luZ2xlICYmIChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwIHx8IChfZXJyb3IkZGV0YWlscyA9IGVycm9yLmRldGFpbHMpID09PSBudWxsIHx8IF9lcnJvciRkZXRhaWxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyb3IkZGV0YWlscy5pbmNsdWRlcyhcIjAgcm93c1wiKSkpIHtcblx0XHRcdFx0XHRlcnJvciA9IG51bGw7XG5cdFx0XHRcdFx0c3RhdHVzID0gMjAwO1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIk9LXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVycm9yICYmIF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgbmV3IFBvc3RncmVzdEVycm9yKGVycm9yKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRkYXRhLFxuXHRcdFx0XHRjb3VudCxcblx0XHRcdFx0c3RhdHVzLFxuXHRcdFx0XHRzdGF0dXNUZXh0XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdGlmICghdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHJlcyA9IHJlcy5jYXRjaCgoZmV0Y2hFcnJvcikgPT4ge1xuXHRcdFx0dmFyIF9mZXRjaEVycm9yJG5hbWUyO1xuXHRcdFx0bGV0IGVycm9yRGV0YWlscyA9IFwiXCI7XG5cdFx0XHRjb25zdCBjYXVzZSA9IGZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5jYXVzZTtcblx0XHRcdGlmIChjYXVzZSkge1xuXHRcdFx0XHR2YXIgX2NhdXNlJG1lc3NhZ2UsIF9jYXVzZSRjb2RlLCBfZmV0Y2hFcnJvciRuYW1lLCBfY2F1c2UkbmFtZTtcblx0XHRcdFx0Y29uc3QgY2F1c2VNZXNzYWdlID0gKF9jYXVzZSRtZXNzYWdlID0gY2F1c2UgPT09IG51bGwgfHwgY2F1c2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhdXNlLm1lc3NhZ2UpICE9PSBudWxsICYmIF9jYXVzZSRtZXNzYWdlICE9PSB2b2lkIDAgPyBfY2F1c2UkbWVzc2FnZSA6IFwiXCI7XG5cdFx0XHRcdGNvbnN0IGNhdXNlQ29kZSA9IChfY2F1c2UkY29kZSA9IGNhdXNlID09PSBudWxsIHx8IGNhdXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXVzZS5jb2RlKSAhPT0gbnVsbCAmJiBfY2F1c2UkY29kZSAhPT0gdm9pZCAwID8gX2NhdXNlJGNvZGUgOiBcIlwiO1xuXHRcdFx0XHRlcnJvckRldGFpbHMgPSBgJHsoX2ZldGNoRXJyb3IkbmFtZSA9IGZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5uYW1lKSAhPT0gbnVsbCAmJiBfZmV0Y2hFcnJvciRuYW1lICE9PSB2b2lkIDAgPyBfZmV0Y2hFcnJvciRuYW1lIDogXCJGZXRjaEVycm9yXCJ9OiAke2ZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5tZXNzYWdlfWA7XG5cdFx0XHRcdGVycm9yRGV0YWlscyArPSBgXFxuXFxuQ2F1c2VkIGJ5OiAkeyhfY2F1c2UkbmFtZSA9IGNhdXNlID09PSBudWxsIHx8IGNhdXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXVzZS5uYW1lKSAhPT0gbnVsbCAmJiBfY2F1c2UkbmFtZSAhPT0gdm9pZCAwID8gX2NhdXNlJG5hbWUgOiBcIkVycm9yXCJ9OiAke2NhdXNlTWVzc2FnZX1gO1xuXHRcdFx0XHRpZiAoY2F1c2VDb2RlKSBlcnJvckRldGFpbHMgKz0gYCAoJHtjYXVzZUNvZGV9KWA7XG5cdFx0XHRcdGlmIChjYXVzZSA9PT0gbnVsbCB8fCBjYXVzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2F1c2Uuc3RhY2spIGVycm9yRGV0YWlscyArPSBgXFxuJHtjYXVzZS5zdGFja31gO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIF9mZXRjaEVycm9yJHN0YWNrO1xuXHRcdFx0XHRlcnJvckRldGFpbHMgPSAoX2ZldGNoRXJyb3Ikc3RhY2sgPSBmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3Iuc3RhY2spICE9PSBudWxsICYmIF9mZXRjaEVycm9yJHN0YWNrICE9PSB2b2lkIDAgPyBfZmV0Y2hFcnJvciRzdGFjayA6IFwiXCI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRlcnJvcjoge1xuXHRcdFx0XHRcdG1lc3NhZ2U6IGAkeyhfZmV0Y2hFcnJvciRuYW1lMiA9IGZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5uYW1lKSAhPT0gbnVsbCAmJiBfZmV0Y2hFcnJvciRuYW1lMiAhPT0gdm9pZCAwID8gX2ZldGNoRXJyb3IkbmFtZTIgOiBcIkZldGNoRXJyb3JcIn06ICR7ZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLm1lc3NhZ2V9YCxcblx0XHRcdFx0XHRkZXRhaWxzOiBlcnJvckRldGFpbHMsXG5cdFx0XHRcdFx0aGludDogXCJcIixcblx0XHRcdFx0XHRjb2RlOiBcIlwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGNvdW50OiBudWxsLFxuXHRcdFx0XHRzdGF0dXM6IDAsXG5cdFx0XHRcdHN0YXR1c1RleHQ6IFwiXCJcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHJlcy50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcblx0fVxuXHQvKipcblx0KiBPdmVycmlkZSB0aGUgdHlwZSBvZiB0aGUgcmV0dXJuZWQgYGRhdGFgLlxuXHQqXG5cdCogQHR5cGVQYXJhbSBOZXdSZXN1bHQgLSBUaGUgbmV3IHJlc3VsdCB0eXBlIHRvIG92ZXJyaWRlIHdpdGhcblx0KiBAZGVwcmVjYXRlZCBVc2Ugb3ZlcnJpZGVUeXBlczx5b3VyVHlwZSwgeyBtZXJnZTogZmFsc2UgfT4oKSBtZXRob2QgYXQgdGhlIGVuZCBvZiB5b3VyIGNhbGwgY2hhaW4gaW5zdGVhZFxuXHQqL1xuXHRyZXR1cm5zKCkge1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGBkYXRhYCBmaWVsZCBpbiB0aGUgcmVzcG9uc2UuXG5cdCpcblx0KiBAdHlwZVBhcmFtIE5ld1Jlc3VsdCAtIFRoZSBuZXcgdHlwZSB0byBjYXN0IHRoZSByZXNwb25zZSBkYXRhIHRvXG5cdCogQHR5cGVQYXJhbSBPcHRpb25zIC0gT3B0aW9uYWwgdHlwZSBjb25maWd1cmF0aW9uIChkZWZhdWx0cyB0byB7IG1lcmdlOiB0cnVlIH0pXG5cdCogQHR5cGVQYXJhbSBPcHRpb25zLm1lcmdlIC0gV2hlbiB0cnVlLCBtZXJnZXMgdGhlIG5ldyB0eXBlIHdpdGggZXhpc3RpbmcgcmV0dXJuIHR5cGUuIFdoZW4gZmFsc2UsIHJlcGxhY2VzIHRoZSBleGlzdGluZyB0eXBlcyBlbnRpcmVseSAoZGVmYXVsdHMgdG8gdHJ1ZSlcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiAvLyBNZXJnZSB3aXRoIGV4aXN0aW5nIHR5cGVzIChkZWZhdWx0IGJlaGF2aW9yKVxuXHQqIGNvbnN0IHF1ZXJ5ID0gc3VwYWJhc2Vcblx0KiAgIC5mcm9tKCd1c2VycycpXG5cdCogICAuc2VsZWN0KClcblx0KiAgIC5vdmVycmlkZVR5cGVzPHsgY3VzdG9tX2ZpZWxkOiBzdHJpbmcgfT4oKVxuXHQqXG5cdCogLy8gUmVwbGFjZSBleGlzdGluZyB0eXBlcyBjb21wbGV0ZWx5XG5cdCogY29uc3QgcmVwbGFjZVF1ZXJ5ID0gc3VwYWJhc2Vcblx0KiAgIC5mcm9tKCd1c2VycycpXG5cdCogICAuc2VsZWN0KClcblx0KiAgIC5vdmVycmlkZVR5cGVzPHsgaWQ6IG51bWJlcjsgbmFtZTogc3RyaW5nIH0sIHsgbWVyZ2U6IGZhbHNlIH0+KClcblx0KiBgYGBcblx0KiBAcmV0dXJucyBBIFBvc3RncmVzdEJ1aWxkZXIgaW5zdGFuY2Ugd2l0aCB0aGUgbmV3IHR5cGVcblx0Ki9cblx0b3ZlcnJpZGVUeXBlcygpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIudHNcbnZhciBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBQb3N0Z3Jlc3RCdWlsZGVyIHtcblx0LyoqXG5cdCogUGVyZm9ybSBhIFNFTEVDVCBvbiB0aGUgcXVlcnkgcmVzdWx0LlxuXHQqXG5cdCogQnkgZGVmYXVsdCwgYC5pbnNlcnQoKWAsIGAudXBkYXRlKClgLCBgLnVwc2VydCgpYCwgYW5kIGAuZGVsZXRlKClgIGRvIG5vdFxuXHQqIHJldHVybiBtb2RpZmllZCByb3dzLiBCeSBjYWxsaW5nIHRoaXMgbWV0aG9kLCBtb2RpZmllZCByb3dzIGFyZSByZXR1cm5lZCBpblxuXHQqIGBkYXRhYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW5zIC0gVGhlIGNvbHVtbnMgdG8gcmV0cmlldmUsIHNlcGFyYXRlZCBieSBjb21tYXNcblx0Ki9cblx0c2VsZWN0KGNvbHVtbnMpIHtcblx0XHRsZXQgcXVvdGVkID0gZmFsc2U7XG5cdFx0Y29uc3QgY2xlYW5lZENvbHVtbnMgPSAoY29sdW1ucyAhPT0gbnVsbCAmJiBjb2x1bW5zICE9PSB2b2lkIDAgPyBjb2x1bW5zIDogXCIqXCIpLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4ge1xuXHRcdFx0aWYgKC9cXHMvLnRlc3QoYykgJiYgIXF1b3RlZCkgcmV0dXJuIFwiXCI7XG5cdFx0XHRpZiAoYyA9PT0gXCJcXFwiXCIpIHF1b3RlZCA9ICFxdW90ZWQ7XG5cdFx0XHRyZXR1cm4gYztcblx0XHR9KS5qb2luKFwiXCIpO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJzZWxlY3RcIiwgY2xlYW5lZENvbHVtbnMpO1xuXHRcdHRoaXMuaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgXCJyZXR1cm49cmVwcmVzZW50YXRpb25cIik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT3JkZXIgdGhlIHF1ZXJ5IHJlc3VsdCBieSBgY29sdW1uYC5cblx0KlxuXHQqIFlvdSBjYW4gY2FsbCB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyB0byBvcmRlciBieSBtdWx0aXBsZSBjb2x1bW5zLlxuXHQqXG5cdCogWW91IGNhbiBvcmRlciByZWZlcmVuY2VkIHRhYmxlcywgYnV0IGl0IG9ubHkgYWZmZWN0cyB0aGUgb3JkZXJpbmcgb2YgdGhlXG5cdCogcGFyZW50IHRhYmxlIGlmIHlvdSB1c2UgYCFpbm5lcmAgaW4gdGhlIHF1ZXJ5LlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gb3JkZXIgYnlcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5hc2NlbmRpbmcgLSBJZiBgdHJ1ZWAsIHRoZSByZXN1bHQgd2lsbCBiZSBpbiBhc2NlbmRpbmcgb3JkZXJcblx0KiBAcGFyYW0gb3B0aW9ucy5udWxsc0ZpcnN0IC0gSWYgYHRydWVgLCBgbnVsbGBzIGFwcGVhciBmaXJzdC4gSWYgYGZhbHNlYCxcblx0KiBgbnVsbGBzIGFwcGVhciBsYXN0LlxuXHQqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIG9yZGVyIGEgcmVmZXJlbmNlZCB0YWJsZSBieVxuXHQqIGl0cyBjb2x1bW5zXG5cdCogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcblx0KiBpbnN0ZWFkXG5cdCovXG5cdG9yZGVyKGNvbHVtbiwgeyBhc2NlbmRpbmcgPSB0cnVlLCBudWxsc0ZpcnN0LCBmb3JlaWduVGFibGUsIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSB9ID0ge30pIHtcblx0XHRjb25zdCBrZXkgPSByZWZlcmVuY2VkVGFibGUgPyBgJHtyZWZlcmVuY2VkVGFibGV9Lm9yZGVyYCA6IFwib3JkZXJcIjtcblx0XHRjb25zdCBleGlzdGluZ09yZGVyID0gdGhpcy51cmwuc2VhcmNoUGFyYW1zLmdldChrZXkpO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCBgJHtleGlzdGluZ09yZGVyID8gYCR7ZXhpc3RpbmdPcmRlcn0sYCA6IFwiXCJ9JHtjb2x1bW59LiR7YXNjZW5kaW5nID8gXCJhc2NcIiA6IFwiZGVzY1wifSR7bnVsbHNGaXJzdCA9PT0gdm9pZCAwID8gXCJcIiA6IG51bGxzRmlyc3QgPyBcIi5udWxsc2ZpcnN0XCIgOiBcIi5udWxsc2xhc3RcIn1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBMaW1pdCB0aGUgcXVlcnkgcmVzdWx0IGJ5IGBjb3VudGAuXG5cdCpcblx0KiBAcGFyYW0gY291bnQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0byByZXR1cm5cblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBsaW1pdCByb3dzIG9mIHJlZmVyZW5jZWRcblx0KiB0YWJsZXMgaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG5cdCogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcblx0KiBpbnN0ZWFkXG5cdCovXG5cdGxpbWl0KGNvdW50LCB7IGZvcmVpZ25UYWJsZSwgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlIH0gPSB7fSkge1xuXHRcdGNvbnN0IGtleSA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09IFwidW5kZWZpbmVkXCIgPyBcImxpbWl0XCIgOiBgJHtyZWZlcmVuY2VkVGFibGV9LmxpbWl0YDtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgYCR7Y291bnR9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTGltaXQgdGhlIHF1ZXJ5IHJlc3VsdCBieSBzdGFydGluZyBhdCBhbiBvZmZzZXQgYGZyb21gIGFuZCBlbmRpbmcgYXQgdGhlIG9mZnNldCBgdG9gLlxuXHQqIE9ubHkgcmVjb3JkcyB3aXRoaW4gdGhpcyByYW5nZSBhcmUgcmV0dXJuZWQuXG5cdCogVGhpcyByZXNwZWN0cyB0aGUgcXVlcnkgb3JkZXIgYW5kIGlmIHRoZXJlIGlzIG5vIG9yZGVyIGNsYXVzZSB0aGUgcmFuZ2UgY291bGQgYmVoYXZlIHVuZXhwZWN0ZWRseS5cblx0KiBUaGUgYGZyb21gIGFuZCBgdG9gIHZhbHVlcyBhcmUgMC1iYXNlZCBhbmQgaW5jbHVzaXZlOiBgcmFuZ2UoMSwgMylgIHdpbGwgaW5jbHVkZSB0aGUgc2Vjb25kLCB0aGlyZFxuXHQqIGFuZCBmb3VydGggcm93cyBvZiB0aGUgcXVlcnkuXG5cdCpcblx0KiBAcGFyYW0gZnJvbSAtIFRoZSBzdGFydGluZyBpbmRleCBmcm9tIHdoaWNoIHRvIGxpbWl0IHRoZSByZXN1bHRcblx0KiBAcGFyYW0gdG8gLSBUaGUgbGFzdCBpbmRleCB0byB3aGljaCB0byBsaW1pdCB0aGUgcmVzdWx0XG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gbGltaXQgcm93cyBvZiByZWZlcmVuY2VkXG5cdCogdGFibGVzIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuXHQqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG5cdCogaW5zdGVhZFxuXHQqL1xuXHRyYW5nZShmcm9tLCB0bywgeyBmb3JlaWduVGFibGUsIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSB9ID0ge30pIHtcblx0XHRjb25zdCBrZXlPZmZzZXQgPSB0eXBlb2YgcmVmZXJlbmNlZFRhYmxlID09PSBcInVuZGVmaW5lZFwiID8gXCJvZmZzZXRcIiA6IGAke3JlZmVyZW5jZWRUYWJsZX0ub2Zmc2V0YDtcblx0XHRjb25zdCBrZXlMaW1pdCA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09IFwidW5kZWZpbmVkXCIgPyBcImxpbWl0XCIgOiBgJHtyZWZlcmVuY2VkVGFibGV9LmxpbWl0YDtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleU9mZnNldCwgYCR7ZnJvbX1gKTtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleUxpbWl0LCBgJHt0byAtIGZyb20gKyAxfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFNldCB0aGUgQWJvcnRTaWduYWwgZm9yIHRoZSBmZXRjaCByZXF1ZXN0LlxuXHQqXG5cdCogQHBhcmFtIHNpZ25hbCAtIFRoZSBBYm9ydFNpZ25hbCB0byB1c2UgZm9yIHRoZSBmZXRjaCByZXF1ZXN0XG5cdCovXG5cdGFib3J0U2lnbmFsKHNpZ25hbCkge1xuXHRcdHRoaXMuc2lnbmFsID0gc2lnbmFsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFJldHVybiBgZGF0YWAgYXMgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cblx0KlxuXHQqIFF1ZXJ5IHJlc3VsdCBtdXN0IGJlIG9uZSByb3cgKGUuZy4gdXNpbmcgYC5saW1pdCgxKWApLCBvdGhlcndpc2UgdGhpc1xuXHQqIHJldHVybnMgYW4gZXJyb3IuXG5cdCovXG5cdHNpbmdsZSgpIHtcblx0XHR0aGlzLmhlYWRlcnMuc2V0KFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uXCIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFJldHVybiBgZGF0YWAgYXMgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cblx0KlxuXHQqIFF1ZXJ5IHJlc3VsdCBtdXN0IGJlIHplcm8gb3Igb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZVxuXHQqIHRoaXMgcmV0dXJucyBhbiBlcnJvci5cblx0Ki9cblx0bWF5YmVTaW5nbGUoKSB7XG5cdFx0aWYgKHRoaXMubWV0aG9kID09PSBcIkdFVFwiKSB0aGlzLmhlYWRlcnMuc2V0KFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcblx0XHRlbHNlIHRoaXMuaGVhZGVycy5zZXQoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb25cIik7XG5cdFx0dGhpcy5pc01heWJlU2luZ2xlID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBSZXR1cm4gYGRhdGFgIGFzIGEgc3RyaW5nIGluIENTViBmb3JtYXQuXG5cdCovXG5cdGNzdigpIHtcblx0XHR0aGlzLmhlYWRlcnMuc2V0KFwiQWNjZXB0XCIsIFwidGV4dC9jc3ZcIik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogUmV0dXJuIGBkYXRhYCBhcyBhbiBvYmplY3QgaW4gW0dlb0pTT05dKGh0dHBzOi8vZ2VvanNvbi5vcmcpIGZvcm1hdC5cblx0Ki9cblx0Z2VvanNvbigpIHtcblx0XHR0aGlzLmhlYWRlcnMuc2V0KFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vZ2VvK2pzb25cIik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogUmV0dXJuIGBkYXRhYCBhcyB0aGUgRVhQTEFJTiBwbGFuIGZvciB0aGUgcXVlcnkuXG5cdCpcblx0KiBZb3UgbmVlZCB0byBlbmFibGUgdGhlXG5cdCogW2RiX3BsYW5fZW5hYmxlZF0oaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9ndWlkZXMvZGF0YWJhc2UvZGVidWdnaW5nLXBlcmZvcm1hbmNlI2VuYWJsaW5nLWV4cGxhaW4pXG5cdCogc2V0dGluZyBiZWZvcmUgdXNpbmcgdGhpcyBtZXRob2QuXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmFuYWx5emUgLSBJZiBgdHJ1ZWAsIHRoZSBxdWVyeSB3aWxsIGJlIGV4ZWN1dGVkIGFuZCB0aGVcblx0KiBhY3R1YWwgcnVuIHRpbWUgd2lsbCBiZSByZXR1cm5lZFxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMudmVyYm9zZSAtIElmIGB0cnVlYCwgdGhlIHF1ZXJ5IGlkZW50aWZpZXIgd2lsbCBiZSByZXR1cm5lZFxuXHQqIGFuZCBgZGF0YWAgd2lsbCBpbmNsdWRlIHRoZSBvdXRwdXQgY29sdW1ucyBvZiB0aGUgcXVlcnlcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLnNldHRpbmdzIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIGNvbmZpZ3VyYXRpb25cblx0KiBwYXJhbWV0ZXJzIHRoYXQgYWZmZWN0IHF1ZXJ5IHBsYW5uaW5nXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5idWZmZXJzIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIGJ1ZmZlciB1c2FnZVxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMud2FsIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIFdBTCByZWNvcmQgZ2VuZXJhdGlvblxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuZm9ybWF0IC0gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0LCBjYW4gYmUgYFwidGV4dFwiYCAoZGVmYXVsdClcblx0KiBvciBgXCJqc29uXCJgXG5cdCovXG5cdGV4cGxhaW4oeyBhbmFseXplID0gZmFsc2UsIHZlcmJvc2UgPSBmYWxzZSwgc2V0dGluZ3MgPSBmYWxzZSwgYnVmZmVycyA9IGZhbHNlLCB3YWwgPSBmYWxzZSwgZm9ybWF0ID0gXCJ0ZXh0XCIgfSA9IHt9KSB7XG5cdFx0dmFyIF90aGlzJGhlYWRlcnMkZ2V0O1xuXHRcdGNvbnN0IG9wdGlvbnMgPSBbXG5cdFx0XHRhbmFseXplID8gXCJhbmFseXplXCIgOiBudWxsLFxuXHRcdFx0dmVyYm9zZSA/IFwidmVyYm9zZVwiIDogbnVsbCxcblx0XHRcdHNldHRpbmdzID8gXCJzZXR0aW5nc1wiIDogbnVsbCxcblx0XHRcdGJ1ZmZlcnMgPyBcImJ1ZmZlcnNcIiA6IG51bGwsXG5cdFx0XHR3YWwgPyBcIndhbFwiIDogbnVsbFxuXHRcdF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJ8XCIpO1xuXHRcdGNvbnN0IGZvck1lZGlhdHlwZSA9IChfdGhpcyRoZWFkZXJzJGdldCA9IHRoaXMuaGVhZGVycy5nZXQoXCJBY2NlcHRcIikpICE9PSBudWxsICYmIF90aGlzJGhlYWRlcnMkZ2V0ICE9PSB2b2lkIDAgPyBfdGhpcyRoZWFkZXJzJGdldCA6IFwiYXBwbGljYXRpb24vanNvblwiO1xuXHRcdHRoaXMuaGVhZGVycy5zZXQoXCJBY2NlcHRcIiwgYGFwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5wbGFuKyR7Zm9ybWF0fTsgZm9yPVwiJHtmb3JNZWRpYXR5cGV9XCI7IG9wdGlvbnM9JHtvcHRpb25zfTtgKTtcblx0XHRpZiAoZm9ybWF0ID09PSBcImpzb25cIikgcmV0dXJuIHRoaXM7XG5cdFx0ZWxzZSByZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBSb2xsYmFjayB0aGUgcXVlcnkuXG5cdCpcblx0KiBgZGF0YWAgd2lsbCBzdGlsbCBiZSByZXR1cm5lZCwgYnV0IHRoZSBxdWVyeSBpcyBub3QgY29tbWl0dGVkLlxuXHQqL1xuXHRyb2xsYmFjaygpIHtcblx0XHR0aGlzLmhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIFwidHg9cm9sbGJhY2tcIik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGBkYXRhYC5cblx0KlxuXHQqIEB0eXBlUGFyYW0gTmV3UmVzdWx0IC0gVGhlIG5ldyByZXN1bHQgdHlwZSB0byBvdmVycmlkZSB3aXRoXG5cdCogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlVHlwZXM8eW91clR5cGUsIHsgbWVyZ2U6IGZhbHNlIH0+KCkgbWV0aG9kIGF0IHRoZSBlbmQgb2YgeW91ciBjYWxsIGNoYWluIGluc3RlYWRcblx0Ki9cblx0cmV0dXJucygpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBTZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJvd3MgdGhhdCBjYW4gYmUgYWZmZWN0ZWQgYnkgdGhlIHF1ZXJ5LlxuXHQqIE9ubHkgYXZhaWxhYmxlIGluIFBvc3RnUkVTVCB2MTMrIGFuZCBvbmx5IHdvcmtzIHdpdGggUEFUQ0ggYW5kIERFTEVURSBtZXRob2RzLlxuXHQqXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJvd3MgdGhhdCBjYW4gYmUgYWZmZWN0ZWRcblx0Ki9cblx0bWF4QWZmZWN0ZWQodmFsdWUpIHtcblx0XHR0aGlzLmhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIFwiaGFuZGxpbmc9c3RyaWN0XCIpO1xuXHRcdHRoaXMuaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgYG1heC1hZmZlY3RlZD0ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvUG9zdGdyZXN0RmlsdGVyQnVpbGRlci50c1xuY29uc3QgUG9zdGdyZXN0UmVzZXJ2ZWRDaGFyc1JlZ2V4cCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVnRXhwKFwiWywoKV1cIik7XG52YXIgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciB7XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBlcXVhbCB0byBgdmFsdWVgLlxuXHQqXG5cdCogVG8gY2hlY2sgaWYgdGhlIHZhbHVlIG9mIGBjb2x1bW5gIGlzIE5VTEwsIHlvdSBzaG91bGQgdXNlIGAuaXMoKWAgaW5zdGVhZC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRlcShjb2x1bW4sIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBlcS4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBub3QgZXF1YWwgdG8gYHZhbHVlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRuZXEoY29sdW1uLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbmVxLiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBgdmFsdWVgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGd0KGNvbHVtbiwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGd0LiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGd0ZShjb2x1bW4sIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBndGUuJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbGVzcyB0aGFuIGB2YWx1ZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0bHQoY29sdW1uLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbHQuJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0bHRlKGNvbHVtbiwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGx0ZS4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGBwYXR0ZXJuYCBjYXNlLXNlbnNpdGl2ZWx5LlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCB3aXRoXG5cdCovXG5cdGxpa2UoY29sdW1uLCBwYXR0ZXJuKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlLiR7cGF0dGVybn1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbGwgb2YgYHBhdHRlcm5zYCBjYXNlLXNlbnNpdGl2ZWx5LlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcblx0Ki9cblx0bGlrZUFsbE9mKGNvbHVtbiwgcGF0dGVybnMpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UoYWxsKS57JHtwYXR0ZXJucy5qb2luKFwiLFwiKX19YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYW55IG9mIGBwYXR0ZXJuc2AgY2FzZS1zZW5zaXRpdmVseS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG5cdCovXG5cdGxpa2VBbnlPZihjb2x1bW4sIHBhdHRlcm5zKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlKGFueSkueyR7cGF0dGVybnMuam9pbihcIixcIil9fWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGBwYXR0ZXJuYCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcGF0dGVybiAtIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdpdGhcblx0Ki9cblx0aWxpa2UoY29sdW1uLCBwYXR0ZXJuKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZS4ke3BhdHRlcm59YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYWxsIG9mIGBwYXR0ZXJuc2AgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcblx0Ki9cblx0aWxpa2VBbGxPZihjb2x1bW4sIHBhdHRlcm5zKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZShhbGwpLnske3BhdHRlcm5zLmpvaW4oXCIsXCIpfX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbnkgb2YgYHBhdHRlcm5zYCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRpbGlrZUFueU9mKGNvbHVtbiwgcGF0dGVybnMpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlKGFueSkueyR7cGF0dGVybnMuam9pbihcIixcIil9fWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIHRoZSBQb3N0Z3JlU1FMIHJlZ2V4IGBwYXR0ZXJuYFxuXHQqIGNhc2Utc2Vuc2l0aXZlbHkgKHVzaW5nIHRoZSBgfmAgb3BlcmF0b3IpLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHBhdHRlcm4gLSBUaGUgUG9zdGdyZVNRTCByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiB0byBtYXRjaCB3aXRoXG5cdCovXG5cdHJlZ2V4TWF0Y2goY29sdW1uLCBwYXR0ZXJuKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBtYXRjaC4ke3BhdHRlcm59YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgdGhlIFBvc3RncmVTUUwgcmVnZXggYHBhdHRlcm5gXG5cdCogY2FzZS1pbnNlbnNpdGl2ZWx5ICh1c2luZyB0aGUgYH4qYCBvcGVyYXRvcikuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcGF0dGVybiAtIFRoZSBQb3N0Z3JlU1FMIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIHRvIG1hdGNoIHdpdGhcblx0Ki9cblx0cmVnZXhJTWF0Y2goY29sdW1uLCBwYXR0ZXJuKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbWF0Y2guJHtwYXR0ZXJufWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBJUyBgdmFsdWVgLlxuXHQqXG5cdCogRm9yIG5vbi1ib29sZWFuIGNvbHVtbnMsIHRoaXMgaXMgb25seSByZWxldmFudCBmb3IgY2hlY2tpbmcgaWYgdGhlIHZhbHVlIG9mXG5cdCogYGNvbHVtbmAgaXMgTlVMTCBieSBzZXR0aW5nIGB2YWx1ZWAgdG8gYG51bGxgLlxuXHQqXG5cdCogRm9yIGJvb2xlYW4gY29sdW1ucywgeW91IGNhbiBhbHNvIHNldCBgdmFsdWVgIHRvIGB0cnVlYCBvciBgZmFsc2VgIGFuZCBpdFxuXHQqIHdpbGwgYmVoYXZlIHRoZSBzYW1lIHdheSBhcyBgLmVxKClgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGlzKGNvbHVtbiwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlzLiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIElTIERJU1RJTkNUIEZST00gYHZhbHVlYC5cblx0KlxuXHQqIFVubGlrZSBgLm5lcSgpYCwgdGhpcyB0cmVhdHMgYE5VTExgIGFzIGEgY29tcGFyYWJsZSB2YWx1ZS4gVHdvIGBOVUxMYCB2YWx1ZXNcblx0KiBhcmUgY29uc2lkZXJlZCBlcXVhbCAobm90IGRpc3RpbmN0KSwgYW5kIGNvbXBhcmluZyBgTlVMTGAgd2l0aCBhbnkgbm9uLU5VTExcblx0KiB2YWx1ZSByZXR1cm5zIHRydWUgKGRpc3RpbmN0KS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRpc0Rpc3RpbmN0KGNvbHVtbiwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlzZGlzdGluY3QuJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgaW5jbHVkZWQgaW4gdGhlIGB2YWx1ZXNgIGFycmF5LlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgYXJyYXkgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0aW4oY29sdW1uLCB2YWx1ZXMpIHtcblx0XHRjb25zdCBjbGVhbmVkVmFsdWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KHZhbHVlcykpLm1hcCgocykgPT4ge1xuXHRcdFx0aWYgKHR5cGVvZiBzID09PSBcInN0cmluZ1wiICYmIFBvc3RncmVzdFJlc2VydmVkQ2hhcnNSZWdleHAudGVzdChzKSkgcmV0dXJuIGBcIiR7c31cImA7XG5cdFx0XHRlbHNlIHJldHVybiBgJHtzfWA7XG5cdFx0fSkuam9pbihcIixcIik7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbi4oJHtjbGVhbmVkVmFsdWVzfSlgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgTk9UIGluY2x1ZGVkIGluIHRoZSBgdmFsdWVzYCBhcnJheS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIGFycmF5IHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdG5vdEluKGNvbHVtbiwgdmFsdWVzKSB7XG5cdFx0Y29uc3QgY2xlYW5lZFZhbHVlcyA9IEFycmF5LmZyb20obmV3IFNldCh2YWx1ZXMpKS5tYXAoKHMpID0+IHtcblx0XHRcdGlmICh0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIiAmJiBQb3N0Z3Jlc3RSZXNlcnZlZENoYXJzUmVnZXhwLnRlc3QocykpIHJldHVybiBgXCIke3N9XCJgO1xuXHRcdFx0ZWxzZSByZXR1cm4gYCR7c31gO1xuXHRcdH0pLmpvaW4oXCIsXCIpO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbm90LmluLigke2NsZWFuZWRWYWx1ZXN9KWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9ubHkgcmVsZXZhbnQgZm9yIGpzb25iLCBhcnJheSwgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuXHQqIGBjb2x1bW5gIGNvbnRhaW5zIGV2ZXJ5IGVsZW1lbnQgYXBwZWFyaW5nIGluIGB2YWx1ZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGNvbnRhaW5zKGNvbHVtbiwgdmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNzLiR7dmFsdWV9YCk7XG5cdFx0ZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MueyR7dmFsdWUuam9pbihcIixcIil9fWApO1xuXHRcdGVsc2UgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjcy4ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciBqc29uYiwgYXJyYXksIGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcblx0KiBldmVyeSBlbGVtZW50IGFwcGVhcmluZyBpbiBgY29sdW1uYCBpcyBjb250YWluZWQgYnkgYHZhbHVlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0Y29udGFpbmVkQnkoY29sdW1uLCB2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY2QuJHt2YWx1ZX1gKTtcblx0XHRlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjZC57JHt2YWx1ZS5qb2luKFwiLFwiKX19YCk7XG5cdFx0ZWxzZSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG5cdCogYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIGFueSBlbGVtZW50IGluIGByYW5nZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0cmFuZ2VHdChjb2x1bW4sIHJhbmdlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBzci4ke3JhbmdlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG5cdCogYGNvbHVtbmAgaXMgZWl0aGVyIGNvbnRhaW5lZCBpbiBgcmFuZ2VgIG9yIGdyZWF0ZXIgdGhhbiBhbnkgZWxlbWVudCBpblxuXHQqIGByYW5nZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0cmFuZ2VHdGUoY29sdW1uLCByYW5nZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbnhsLiR7cmFuZ2V9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cblx0KiBgY29sdW1uYCBpcyBsZXNzIHRoYW4gYW55IGVsZW1lbnQgaW4gYHJhbmdlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRyYW5nZUx0KGNvbHVtbiwgcmFuZ2UpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYHNsLiR7cmFuZ2V9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cblx0KiBgY29sdW1uYCBpcyBlaXRoZXIgY29udGFpbmVkIGluIGByYW5nZWAgb3IgbGVzcyB0aGFuIGFueSBlbGVtZW50IGluXG5cdCogYHJhbmdlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRyYW5nZUx0ZShjb2x1bW4sIHJhbmdlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBueHIuJHtyYW5nZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXNcblx0KiBtdXR1YWxseSBleGNsdXNpdmUgdG8gYHJhbmdlYCBhbmQgdGhlcmUgY2FuIGJlIG5vIGVsZW1lbnQgYmV0d2VlbiB0aGUgdHdvXG5cdCogcmFuZ2VzLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdHJhbmdlQWRqYWNlbnQoY29sdW1uLCByYW5nZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgYWRqLiR7cmFuZ2V9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IgYXJyYXkgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuXHQqIGBjb2x1bW5gIGFuZCBgdmFsdWVgIGhhdmUgYW4gZWxlbWVudCBpbiBjb21tb24uXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGFycmF5IG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgYXJyYXkgb3IgcmFuZ2UgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0b3ZlcmxhcHMoY29sdW1uLCB2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgb3YuJHt2YWx1ZX1gKTtcblx0XHRlbHNlIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgb3YueyR7dmFsdWUuam9pbihcIixcIil9fWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9ubHkgcmVsZXZhbnQgZm9yIHRleHQgYW5kIHRzdmVjdG9yIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuXHQqIGBjb2x1bW5gIG1hdGNoZXMgdGhlIHF1ZXJ5IHN0cmluZyBpbiBgcXVlcnlgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSB0ZXh0IG9yIHRzdmVjdG9yIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgdGV4dCB0byBtYXRjaCB3aXRoXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCogQHBhcmFtIG9wdGlvbnMuY29uZmlnIC0gVGhlIHRleHQgc2VhcmNoIGNvbmZpZ3VyYXRpb24gdG8gdXNlXG5cdCogQHBhcmFtIG9wdGlvbnMudHlwZSAtIENoYW5nZSBob3cgdGhlIGBxdWVyeWAgdGV4dCBpcyBpbnRlcnByZXRlZFxuXHQqL1xuXHR0ZXh0U2VhcmNoKGNvbHVtbiwgcXVlcnksIHsgY29uZmlnLCB0eXBlIH0gPSB7fSkge1xuXHRcdGxldCB0eXBlUGFydCA9IFwiXCI7XG5cdFx0aWYgKHR5cGUgPT09IFwicGxhaW5cIikgdHlwZVBhcnQgPSBcInBsXCI7XG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCJwaHJhc2VcIikgdHlwZVBhcnQgPSBcInBoXCI7XG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCJ3ZWJzZWFyY2hcIikgdHlwZVBhcnQgPSBcIndcIjtcblx0XHRjb25zdCBjb25maWdQYXJ0ID0gY29uZmlnID09PSB2b2lkIDAgPyBcIlwiIDogYCgke2NvbmZpZ30pYDtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYCR7dHlwZVBhcnR9ZnRzJHtjb25maWdQYXJ0fS4ke3F1ZXJ5fWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBlYWNoIGNvbHVtbiBpbiBgcXVlcnlgIGtleXMgaXMgZXF1YWwgdG8gaXRzXG5cdCogYXNzb2NpYXRlZCB2YWx1ZS4gU2hvcnRoYW5kIGZvciBtdWx0aXBsZSBgLmVxKClgcy5cblx0KlxuXHQqIEBwYXJhbSBxdWVyeSAtIFRoZSBvYmplY3QgdG8gZmlsdGVyIHdpdGgsIHdpdGggY29sdW1uIG5hbWVzIGFzIGtleXMgbWFwcGVkXG5cdCogdG8gdGhlaXIgZmlsdGVyIHZhbHVlc1xuXHQqL1xuXHRtYXRjaChxdWVyeSkge1xuXHRcdE9iamVjdC5lbnRyaWVzKHF1ZXJ5KS5mb3JFYWNoKChbY29sdW1uLCB2YWx1ZV0pID0+IHtcblx0XHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZXEuJHt2YWx1ZX1gKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggZG9lc24ndCBzYXRpc2Z5IHRoZSBmaWx0ZXIuXG5cdCpcblx0KiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgb3BlYXJhdG9yYCBhbmQgYHZhbHVlYCBhcmUgdXNlZCBhcy1pcyBhbmQgbmVlZCB0b1xuXHQqIGZvbGxvdyBbUG9zdGdSRVNUXG5cdCogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcblx0KiB0byBtYWtlIHN1cmUgdGhleSBhcmUgcHJvcGVybHkgc2FuaXRpemVkLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIG9wZXJhdG9yIC0gVGhlIG9wZXJhdG9yIHRvIGJlIG5lZ2F0ZWQgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZ1xuXHQqIFBvc3RnUkVTVCBzeW50YXhcblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG5cdCovXG5cdG5vdChjb2x1bW4sIG9wZXJhdG9yLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbm90LiR7b3BlcmF0b3J9LiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoaWNoIHNhdGlzZnkgYXQgbGVhc3Qgb25lIG9mIHRoZSBmaWx0ZXJzLlxuXHQqXG5cdCogVW5saWtlIG1vc3QgZmlsdGVycywgYGZpbHRlcnNgIGlzIHVzZWQgYXMtaXMgYW5kIG5lZWRzIHRvIGZvbGxvdyBbUG9zdGdSRVNUXG5cdCogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcblx0KiB0byBtYWtlIHN1cmUgaXQncyBwcm9wZXJseSBzYW5pdGl6ZWQuXG5cdCpcblx0KiBJdCdzIGN1cnJlbnRseSBub3QgcG9zc2libGUgdG8gZG8gYW4gYC5vcigpYCBmaWx0ZXIgYWNyb3NzIG11bHRpcGxlIHRhYmxlcy5cblx0KlxuXHQqIEBwYXJhbSBmaWx0ZXJzIC0gVGhlIGZpbHRlcnMgdG8gdXNlLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGZpbHRlciBvbiByZWZlcmVuY2VkIHRhYmxlc1xuXHQqIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuXHQqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgcmVmZXJlbmNlZFRhYmxlYCBpbnN0ZWFkXG5cdCovXG5cdG9yKGZpbHRlcnMsIHsgZm9yZWlnblRhYmxlLCByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUgfSA9IHt9KSB7XG5cdFx0Y29uc3Qga2V5ID0gcmVmZXJlbmNlZFRhYmxlID8gYCR7cmVmZXJlbmNlZFRhYmxlfS5vcmAgOiBcIm9yXCI7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIGAoJHtmaWx0ZXJzfSlgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggc2F0aXNmeSB0aGUgZmlsdGVyLiBUaGlzIGlzIGFuIGVzY2FwZSBoYXRjaCAtIHlvdVxuXHQqIHNob3VsZCB1c2UgdGhlIHNwZWNpZmljIGZpbHRlciBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLlxuXHQqXG5cdCogVW5saWtlIG1vc3QgZmlsdGVycywgYG9wZWFyYXRvcmAgYW5kIGB2YWx1ZWAgYXJlIHVzZWQgYXMtaXMgYW5kIG5lZWQgdG9cblx0KiBmb2xsb3cgW1Bvc3RnUkVTVFxuXHQqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG5cdCogdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHByb3Blcmx5IHNhbml0aXplZC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBvcGVyYXRvciAtIFRoZSBvcGVyYXRvciB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG5cdCovXG5cdGZpbHRlcihjb2x1bW4sIG9wZXJhdG9yLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgJHtvcGVyYXRvcn0uJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlci50c1xudmFyIFBvc3RncmVzdFF1ZXJ5QnVpbGRlciA9IGNsYXNzIHtcblx0LyoqXG5cdCogQ3JlYXRlcyBhIHF1ZXJ5IGJ1aWxkZXIgc2NvcGVkIHRvIGEgUG9zdGdyZXMgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHNcblx0KiBpbXBvcnQgUG9zdGdyZXN0UXVlcnlCdWlsZGVyIGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnXG5cdCpcblx0KiBjb25zdCBxdWVyeSA9IG5ldyBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIoXG5cdCogICBuZXcgVVJMKCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vcmVzdC92MS91c2VycycpLFxuXHQqICAgeyBoZWFkZXJzOiB7IGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScgfSB9XG5cdCogKVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIHsgaGVhZGVycyA9IHt9LCBzY2hlbWEsIGZldGNoOiBmZXRjaCQxIH0pIHtcblx0XHR0aGlzLnVybCA9IHVybDtcblx0XHR0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzKTtcblx0XHR0aGlzLnNjaGVtYSA9IHNjaGVtYTtcblx0XHR0aGlzLmZldGNoID0gZmV0Y2gkMTtcblx0fVxuXHQvKipcblx0KiBDbG9uZSBVUkwgYW5kIGhlYWRlcnMgdG8gcHJldmVudCBzaGFyZWQgc3RhdGUgYmV0d2VlbiBvcGVyYXRpb25zLlxuXHQqL1xuXHRjbG9uZVJlcXVlc3RTdGF0ZSgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dXJsOiBuZXcgVVJMKHRoaXMudXJsLnRvU3RyaW5nKCkpLFxuXHRcdFx0aGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKVxuXHRcdH07XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIFNFTEVDVCBxdWVyeSBvbiB0aGUgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW5zIC0gVGhlIGNvbHVtbnMgdG8gcmV0cmlldmUsIHNlcGFyYXRlZCBieSBjb21tYXMuIENvbHVtbnMgY2FuIGJlIHJlbmFtZWQgd2hlbiByZXR1cm5lZCB3aXRoIGBjdXN0b21OYW1lOmNvbHVtbk5hbWVgXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmhlYWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGBkYXRhYCB3aWxsIG5vdCBiZSByZXR1cm5lZC5cblx0KiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyBpbiB0aGUgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcblx0KiBob29kLlxuXHQqXG5cdCogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcblx0KiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuXHQqXG5cdCogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuXHQqIG51bWJlcnMuXG5cdCovXG5cdHNlbGVjdChjb2x1bW5zLCBvcHRpb25zKSB7XG5cdFx0Y29uc3QgeyBoZWFkID0gZmFsc2UsIGNvdW50IH0gPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcblx0XHRjb25zdCBtZXRob2QgPSBoZWFkID8gXCJIRUFEXCIgOiBcIkdFVFwiO1xuXHRcdGxldCBxdW90ZWQgPSBmYWxzZTtcblx0XHRjb25zdCBjbGVhbmVkQ29sdW1ucyA9IChjb2x1bW5zICE9PSBudWxsICYmIGNvbHVtbnMgIT09IHZvaWQgMCA/IGNvbHVtbnMgOiBcIipcIikuc3BsaXQoXCJcIikubWFwKChjKSA9PiB7XG5cdFx0XHRpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSByZXR1cm4gXCJcIjtcblx0XHRcdGlmIChjID09PSBcIlxcXCJcIikgcXVvdGVkID0gIXF1b3RlZDtcblx0XHRcdHJldHVybiBjO1xuXHRcdH0pLmpvaW4oXCJcIik7XG5cdFx0Y29uc3QgeyB1cmwsIGhlYWRlcnMgfSA9IHRoaXMuY2xvbmVSZXF1ZXN0U3RhdGUoKTtcblx0XHR1cmwuc2VhcmNoUGFyYW1zLnNldChcInNlbGVjdFwiLCBjbGVhbmVkQ29sdW1ucyk7XG5cdFx0aWYgKGNvdW50KSBoZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgY291bnQ9JHtjb3VudH1gKTtcblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0dXJsLFxuXHRcdFx0aGVhZGVycyxcblx0XHRcdHNjaGVtYTogdGhpcy5zY2hlbWEsXG5cdFx0XHRmZXRjaDogdGhpcy5mZXRjaFxuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIFBlcmZvcm0gYW4gSU5TRVJUIGludG8gdGhlIHRhYmxlIG9yIHZpZXcuXG5cdCpcblx0KiBCeSBkZWZhdWx0LCBpbnNlcnRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcblx0KiB3aXRoIGAuc2VsZWN0KClgLlxuXHQqXG5cdCogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gaW5zZXJ0LiBQYXNzIGFuIG9iamVjdCB0byBpbnNlcnQgYSBzaW5nbGUgcm93XG5cdCogb3IgYW4gYXJyYXkgdG8gaW5zZXJ0IG11bHRpcGxlIHJvd3MuXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCBpbnNlcnRlZCByb3dzLlxuXHQqXG5cdCogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuXHQqIGhvb2QuXG5cdCpcblx0KiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuXHQqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG5cdCpcblx0KiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG5cdCogbnVtYmVycy5cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmRlZmF1bHRUb051bGwgLSBNYWtlIG1pc3NpbmcgZmllbGRzIGRlZmF1bHQgdG8gYG51bGxgLlxuXHQqIE90aGVyd2lzZSwgdXNlIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgY29sdW1uLiBPbmx5IGFwcGxpZXMgZm9yIGJ1bGtcblx0KiBpbnNlcnRzLlxuXHQqL1xuXHRpbnNlcnQodmFsdWVzLCB7IGNvdW50LCBkZWZhdWx0VG9OdWxsID0gdHJ1ZSB9ID0ge30pIHtcblx0XHR2YXIgX3RoaXMkZmV0Y2g7XG5cdFx0Y29uc3QgbWV0aG9kID0gXCJQT1NUXCI7XG5cdFx0Y29uc3QgeyB1cmwsIGhlYWRlcnMgfSA9IHRoaXMuY2xvbmVSZXF1ZXN0U3RhdGUoKTtcblx0XHRpZiAoY291bnQpIGhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIGBjb3VudD0ke2NvdW50fWApO1xuXHRcdGlmICghZGVmYXVsdFRvTnVsbCkgaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgYG1pc3Npbmc9ZGVmYXVsdGApO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcblx0XHRcdGNvbnN0IGNvbHVtbnMgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYy5jb25jYXQoT2JqZWN0LmtleXMoeCkpLCBbXSk7XG5cdFx0XHRpZiAoY29sdW1ucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGNvbnN0IHVuaXF1ZUNvbHVtbnMgPSBbLi4ubmV3IFNldChjb2x1bW5zKV0ubWFwKChjb2x1bW4pID0+IGBcIiR7Y29sdW1ufVwiYCk7XG5cdFx0XHRcdHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiY29sdW1uc1wiLCB1bmlxdWVDb2x1bW5zLmpvaW4oXCIsXCIpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcblx0XHRcdG1ldGhvZCxcblx0XHRcdHVybCxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRzY2hlbWE6IHRoaXMuc2NoZW1hLFxuXHRcdFx0Ym9keTogdmFsdWVzLFxuXHRcdFx0ZmV0Y2g6IChfdGhpcyRmZXRjaCA9IHRoaXMuZmV0Y2gpICE9PSBudWxsICYmIF90aGlzJGZldGNoICE9PSB2b2lkIDAgPyBfdGhpcyRmZXRjaCA6IGZldGNoXG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhbiBVUFNFUlQgb24gdGhlIHRhYmxlIG9yIHZpZXcuIERlcGVuZGluZyBvbiB0aGUgY29sdW1uKHMpIHBhc3NlZFxuXHQqIHRvIGBvbkNvbmZsaWN0YCwgYC51cHNlcnQoKWAgYWxsb3dzIHlvdSB0byBwZXJmb3JtIHRoZSBlcXVpdmFsZW50IG9mXG5cdCogYC5pbnNlcnQoKWAgaWYgYSByb3cgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBgb25Db25mbGljdGAgY29sdW1ucyBkb2Vzbid0XG5cdCogZXhpc3QsIG9yIGlmIGl0IGRvZXMgZXhpc3QsIHBlcmZvcm0gYW4gYWx0ZXJuYXRpdmUgYWN0aW9uIGRlcGVuZGluZyBvblxuXHQqIGBpZ25vcmVEdXBsaWNhdGVzYC5cblx0KlxuXHQqIEJ5IGRlZmF1bHQsIHVwc2VydGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuXHQqIHdpdGggYC5zZWxlY3QoKWAuXG5cdCpcblx0KiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cHNlcnQgd2l0aC4gUGFzcyBhbiBvYmplY3QgdG8gdXBzZXJ0IGFcblx0KiBzaW5nbGUgcm93IG9yIGFuIGFycmF5IHRvIHVwc2VydCBtdWx0aXBsZSByb3dzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5vbkNvbmZsaWN0IC0gQ29tbWEtc2VwYXJhdGVkIFVOSVFVRSBjb2x1bW4ocykgdG8gc3BlY2lmeSBob3dcblx0KiBkdXBsaWNhdGUgcm93cyBhcmUgZGV0ZXJtaW5lZC4gVHdvIHJvd3MgYXJlIGR1cGxpY2F0ZXMgaWYgYWxsIHRoZVxuXHQqIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGFyZSBlcXVhbC5cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgLSBJZiBgdHJ1ZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBpZ25vcmVkLiBJZlxuXHQqIGBmYWxzZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBtZXJnZWQgd2l0aCBleGlzdGluZyByb3dzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwc2VydGVkIHJvd3MuXG5cdCpcblx0KiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG5cdCogaG9vZC5cblx0KlxuXHQqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG5cdCogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cblx0KlxuXHQqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcblx0KiBudW1iZXJzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdFRvTnVsbCAtIE1ha2UgbWlzc2luZyBmaWVsZHMgZGVmYXVsdCB0byBgbnVsbGAuXG5cdCogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIFRoaXMgb25seSBhcHBsaWVzIHdoZW5cblx0KiBpbnNlcnRpbmcgbmV3IHJvd3MsIG5vdCB3aGVuIG1lcmdpbmcgd2l0aCBleGlzdGluZyByb3dzIHVuZGVyXG5cdCogYGlnbm9yZUR1cGxpY2F0ZXM6IGZhbHNlYC4gVGhpcyBhbHNvIG9ubHkgYXBwbGllcyB3aGVuIGRvaW5nIGJ1bGsgdXBzZXJ0cy5cblx0KlxuXHQqIEBleGFtcGxlIFVwc2VydCBhIHNpbmdsZSByb3cgdXNpbmcgYSB1bmlxdWUga2V5XG5cdCogYGBgdHNcblx0KiAvLyBVcHNlcnRpbmcgYSBzaW5nbGUgcm93LCBvdmVyd3JpdGluZyBiYXNlZCBvbiB0aGUgJ3VzZXJuYW1lJyB1bmlxdWUgY29sdW1uXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5mcm9tKCd1c2VycycpXG5cdCogICAudXBzZXJ0KHsgdXNlcm5hbWU6ICdzdXBhYm90JyB9LCB7IG9uQ29uZmxpY3Q6ICd1c2VybmFtZScgfSlcblx0KlxuXHQqIC8vIEV4YW1wbGUgcmVzcG9uc2U6XG5cdCogLy8ge1xuXHQqIC8vICAgZGF0YTogW1xuXHQqIC8vICAgICB7IGlkOiA0LCBtZXNzYWdlOiAnYmFyJywgdXNlcm5hbWU6ICdzdXBhYm90JyB9XG5cdCogLy8gICBdLFxuXHQqIC8vICAgZXJyb3I6IG51bGxcblx0KiAvLyB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBVcHNlcnQgd2l0aCBjb25mbGljdCByZXNvbHV0aW9uIGFuZCBleGFjdCByb3cgY291bnRpbmdcblx0KiBgYGB0c1xuXHQqIC8vIFVwc2VydGluZyBhbmQgcmV0dXJuaW5nIGV4YWN0IGNvdW50XG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciwgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuZnJvbSgndXNlcnMnKVxuXHQqICAgLnVwc2VydChcblx0KiAgICAge1xuXHQqICAgICAgIGlkOiAzLFxuXHQqICAgICAgIG1lc3NhZ2U6ICdmb28nLFxuXHQqICAgICAgIHVzZXJuYW1lOiAnc3VwYWJvdCdcblx0KiAgICAgfSxcblx0KiAgICAge1xuXHQqICAgICAgIG9uQ29uZmxpY3Q6ICd1c2VybmFtZScsXG5cdCogICAgICAgY291bnQ6ICdleGFjdCdcblx0KiAgICAgfVxuXHQqICAgKVxuXHQqXG5cdCogLy8gRXhhbXBsZSByZXNwb25zZTpcblx0KiAvLyB7XG5cdCogLy8gICBkYXRhOiBbXG5cdCogLy8gICAgIHtcblx0KiAvLyAgICAgICBpZDogNDIsXG5cdCogLy8gICAgICAgaGFuZGxlOiBcInNhb2lyc2VcIixcblx0KiAvLyAgICAgICBkaXNwbGF5X25hbWU6IFwiU2FvaXJzZVwiXG5cdCogLy8gICAgIH1cblx0KiAvLyAgIF0sXG5cdCogLy8gICBjb3VudDogMSxcblx0KiAvLyAgIGVycm9yOiBudWxsXG5cdCogLy8gfVxuXHQqIGBgYFxuXHQqL1xuXHR1cHNlcnQodmFsdWVzLCB7IG9uQ29uZmxpY3QsIGlnbm9yZUR1cGxpY2F0ZXMgPSBmYWxzZSwgY291bnQsIGRlZmF1bHRUb051bGwgPSB0cnVlIH0gPSB7fSkge1xuXHRcdHZhciBfdGhpcyRmZXRjaDI7XG5cdFx0Y29uc3QgbWV0aG9kID0gXCJQT1NUXCI7XG5cdFx0Y29uc3QgeyB1cmwsIGhlYWRlcnMgfSA9IHRoaXMuY2xvbmVSZXF1ZXN0U3RhdGUoKTtcblx0XHRoZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgcmVzb2x1dGlvbj0ke2lnbm9yZUR1cGxpY2F0ZXMgPyBcImlnbm9yZVwiIDogXCJtZXJnZVwifS1kdXBsaWNhdGVzYCk7XG5cdFx0aWYgKG9uQ29uZmxpY3QgIT09IHZvaWQgMCkgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJvbl9jb25mbGljdFwiLCBvbkNvbmZsaWN0KTtcblx0XHRpZiAoY291bnQpIGhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIGBjb3VudD0ke2NvdW50fWApO1xuXHRcdGlmICghZGVmYXVsdFRvTnVsbCkgaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgXCJtaXNzaW5nPWRlZmF1bHRcIik7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuXHRcdFx0Y29uc3QgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdChPYmplY3Qua2V5cyh4KSksIFtdKTtcblx0XHRcdGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKTtcblx0XHRcdFx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJjb2x1bW5zXCIsIHVuaXF1ZUNvbHVtbnMuam9pbihcIixcIikpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0dXJsLFxuXHRcdFx0aGVhZGVycyxcblx0XHRcdHNjaGVtYTogdGhpcy5zY2hlbWEsXG5cdFx0XHRib2R5OiB2YWx1ZXMsXG5cdFx0XHRmZXRjaDogKF90aGlzJGZldGNoMiA9IHRoaXMuZmV0Y2gpICE9PSBudWxsICYmIF90aGlzJGZldGNoMiAhPT0gdm9pZCAwID8gX3RoaXMkZmV0Y2gyIDogZmV0Y2hcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBQZXJmb3JtIGFuIFVQREFURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIEJ5IGRlZmF1bHQsIHVwZGF0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG5cdCogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuXHQqXG5cdCogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gdXBkYXRlIHdpdGhcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwZGF0ZWQgcm93cy5cblx0KlxuXHQqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcblx0KiBob29kLlxuXHQqXG5cdCogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcblx0KiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuXHQqXG5cdCogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuXHQqIG51bWJlcnMuXG5cdCovXG5cdHVwZGF0ZSh2YWx1ZXMsIHsgY291bnQgfSA9IHt9KSB7XG5cdFx0dmFyIF90aGlzJGZldGNoMztcblx0XHRjb25zdCBtZXRob2QgPSBcIlBBVENIXCI7XG5cdFx0Y29uc3QgeyB1cmwsIGhlYWRlcnMgfSA9IHRoaXMuY2xvbmVSZXF1ZXN0U3RhdGUoKTtcblx0XHRpZiAoY291bnQpIGhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIGBjb3VudD0ke2NvdW50fWApO1xuXHRcdHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHR1cmwsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0c2NoZW1hOiB0aGlzLnNjaGVtYSxcblx0XHRcdGJvZHk6IHZhbHVlcyxcblx0XHRcdGZldGNoOiAoX3RoaXMkZmV0Y2gzID0gdGhpcy5mZXRjaCkgIT09IG51bGwgJiYgX3RoaXMkZmV0Y2gzICE9PSB2b2lkIDAgPyBfdGhpcyRmZXRjaDMgOiBmZXRjaFxuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIFBlcmZvcm0gYSBERUxFVEUgb24gdGhlIHRhYmxlIG9yIHZpZXcuXG5cdCpcblx0KiBCeSBkZWZhdWx0LCBkZWxldGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuXHQqIHdpdGggYC5zZWxlY3QoKWAgYWZ0ZXIgZmlsdGVycy5cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGRlbGV0ZWQgcm93cy5cblx0KlxuXHQqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcblx0KiBob29kLlxuXHQqXG5cdCogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcblx0KiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuXHQqXG5cdCogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuXHQqIG51bWJlcnMuXG5cdCovXG5cdGRlbGV0ZSh7IGNvdW50IH0gPSB7fSkge1xuXHRcdHZhciBfdGhpcyRmZXRjaDQ7XG5cdFx0Y29uc3QgbWV0aG9kID0gXCJERUxFVEVcIjtcblx0XHRjb25zdCB7IHVybCwgaGVhZGVycyB9ID0gdGhpcy5jbG9uZVJlcXVlc3RTdGF0ZSgpO1xuXHRcdGlmIChjb3VudCkgaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgYGNvdW50PSR7Y291bnR9YCk7XG5cdFx0cmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcblx0XHRcdG1ldGhvZCxcblx0XHRcdHVybCxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRzY2hlbWE6IHRoaXMuc2NoZW1hLFxuXHRcdFx0ZmV0Y2g6IChfdGhpcyRmZXRjaDQgPSB0aGlzLmZldGNoKSAhPT0gbnVsbCAmJiBfdGhpcyRmZXRjaDQgIT09IHZvaWQgMCA/IF90aGlzJGZldGNoNCA6IGZldGNoXG5cdFx0fSk7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9Qb3N0Z3Jlc3RDbGllbnQudHNcbi8qKlxuKiBQb3N0Z1JFU1QgY2xpZW50LlxuKlxuKiBAdHlwZVBhcmFtIERhdGFiYXNlIC0gVHlwZXMgZm9yIHRoZSBzY2hlbWEgZnJvbSB0aGUgW3R5cGVcbiogZ2VuZXJhdG9yXShodHRwczovL3N1cGFiYXNlLmNvbS9kb2NzL3JlZmVyZW5jZS9qYXZhc2NyaXB0L25leHQvdHlwZXNjcmlwdC1zdXBwb3J0KVxuKlxuKiBAdHlwZVBhcmFtIFNjaGVtYU5hbWUgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvLiBNdXN0IGJlIGEgc3RyaW5nXG4qIGxpdGVyYWwsIHRoZSBzYW1lIG9uZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiBJZiB0aGUgc2NoZW1hIGlzIG5vdFxuKiBgXCJwdWJsaWNcImAsIHRoaXMgbXVzdCBiZSBzdXBwbGllZCBtYW51YWxseS5cbiovXG52YXIgUG9zdGdyZXN0Q2xpZW50ID0gY2xhc3MgUG9zdGdyZXN0Q2xpZW50IHtcblx0LyoqXG5cdCogQ3JlYXRlcyBhIFBvc3RnUkVTVCBjbGllbnQuXG5cdCpcblx0KiBAcGFyYW0gdXJsIC0gVVJMIG9mIHRoZSBQb3N0Z1JFU1QgZW5kcG9pbnRcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5oZWFkZXJzIC0gQ3VzdG9tIGhlYWRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5zY2hlbWEgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvXG5cdCogQHBhcmFtIG9wdGlvbnMuZmV0Y2ggLSBDdXN0b20gZmV0Y2hcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHRzXG5cdCogaW1wb3J0IFBvc3RncmVzdENsaWVudCBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuXHQqXG5cdCogY29uc3QgcG9zdGdyZXN0ID0gbmV3IFBvc3RncmVzdENsaWVudCgnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvL3Jlc3QvdjEnLCB7XG5cdCogICBoZWFkZXJzOiB7IGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScgfSxcblx0KiAgIHNjaGVtYTogJ3B1YmxpYycsXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCB7IGhlYWRlcnMgPSB7fSwgc2NoZW1hLCBmZXRjaDogZmV0Y2gkMSB9ID0ge30pIHtcblx0XHR0aGlzLnVybCA9IHVybDtcblx0XHR0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzKTtcblx0XHR0aGlzLnNjaGVtYU5hbWUgPSBzY2hlbWE7XG5cdFx0dGhpcy5mZXRjaCA9IGZldGNoJDE7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuXHQqXG5cdCogQHBhcmFtIHJlbGF0aW9uIC0gVGhlIHRhYmxlIG9yIHZpZXcgbmFtZSB0byBxdWVyeVxuXHQqL1xuXHRmcm9tKHJlbGF0aW9uKSB7XG5cdFx0aWYgKCFyZWxhdGlvbiB8fCB0eXBlb2YgcmVsYXRpb24gIT09IFwic3RyaW5nXCIgfHwgcmVsYXRpb24udHJpbSgpID09PSBcIlwiKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlbGF0aW9uIG5hbWU6IHJlbGF0aW9uIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLlwiKTtcblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcihuZXcgVVJMKGAke3RoaXMudXJsfS8ke3JlbGF0aW9ufWApLCB7XG5cdFx0XHRoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuXHRcdFx0c2NoZW1hOiB0aGlzLnNjaGVtYU5hbWUsXG5cdFx0XHRmZXRjaDogdGhpcy5mZXRjaFxuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIFNlbGVjdCBhIHNjaGVtYSB0byBxdWVyeSBvciBwZXJmb3JtIGFuIGZ1bmN0aW9uIChycGMpIGNhbGwuXG5cdCpcblx0KiBUaGUgc2NoZW1hIG5lZWRzIHRvIGJlIG9uIHRoZSBsaXN0IG9mIGV4cG9zZWQgc2NoZW1hcyBpbnNpZGUgU3VwYWJhc2UuXG5cdCpcblx0KiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byBxdWVyeVxuXHQqL1xuXHRzY2hlbWEoc2NoZW1hKSB7XG5cdFx0cmV0dXJuIG5ldyBQb3N0Z3Jlc3RDbGllbnQodGhpcy51cmwsIHtcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdHNjaGVtYSxcblx0XHRcdGZldGNoOiB0aGlzLmZldGNoXG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIGZ1bmN0aW9uIGNhbGwuXG5cdCpcblx0KiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gbmFtZSB0byBjYWxsXG5cdCogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uIGNhbGxcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG5cdCogVXNlZnVsIGlmIHlvdSBvbmx5IG5lZWQgdGhlIGNvdW50LlxuXHQqIEBwYXJhbSBvcHRpb25zLmdldCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGhcblx0KiByZWFkLW9ubHkgYWNjZXNzIG1vZGUuXG5cdCogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHJvd3MgcmV0dXJuZWQgYnkgdGhlXG5cdCogZnVuY3Rpb24uIE9ubHkgYXBwbGljYWJsZSBmb3IgW3NldC1yZXR1cm5pbmdcblx0KiBmdW5jdGlvbnNdKGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9mdW5jdGlvbnMtc3JmLmh0bWwpLlxuXHQqXG5cdCogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuXHQqIGhvb2QuXG5cdCpcblx0KiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuXHQqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG5cdCpcblx0KiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG5cdCogbnVtYmVycy5cblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHNcblx0KiAvLyBGb3IgY3Jvc3Mtc2NoZW1hIGZ1bmN0aW9ucyB3aGVyZSB0eXBlIGluZmVyZW5jZSBmYWlscywgdXNlIG92ZXJyaWRlVHlwZXM6XG5cdCogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnNjaGVtYSgnc2NoZW1hX2InKVxuXHQqICAgLnJwYygnZnVuY3Rpb25fYScsIHt9KVxuXHQqICAgLm92ZXJyaWRlVHlwZXM8eyBpZDogc3RyaW5nOyB1c2VyX2lkOiBzdHJpbmcgfVtdPigpXG5cdCogYGBgXG5cdCovXG5cdHJwYyhmbiwgYXJncyA9IHt9LCB7IGhlYWQgPSBmYWxzZSwgZ2V0ID0gZmFsc2UsIGNvdW50IH0gPSB7fSkge1xuXHRcdHZhciBfdGhpcyRmZXRjaDtcblx0XHRsZXQgbWV0aG9kO1xuXHRcdGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9L3JwYy8ke2ZufWApO1xuXHRcdGxldCBib2R5O1xuXHRcdGNvbnN0IF9pc09iamVjdCA9ICh2KSA9PiB2ICE9PSBudWxsICYmIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmICghQXJyYXkuaXNBcnJheSh2KSB8fCB2LnNvbWUoX2lzT2JqZWN0KSk7XG5cdFx0Y29uc3QgX2hhc09iamVjdEFyZyA9IGhlYWQgJiYgT2JqZWN0LnZhbHVlcyhhcmdzKS5zb21lKF9pc09iamVjdCk7XG5cdFx0aWYgKF9oYXNPYmplY3RBcmcpIHtcblx0XHRcdG1ldGhvZCA9IFwiUE9TVFwiO1xuXHRcdFx0Ym9keSA9IGFyZ3M7XG5cdFx0fSBlbHNlIGlmIChoZWFkIHx8IGdldCkge1xuXHRcdFx0bWV0aG9kID0gaGVhZCA/IFwiSEVBRFwiIDogXCJHRVRcIjtcblx0XHRcdE9iamVjdC5lbnRyaWVzKGFyZ3MpLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdmFsdWUgIT09IHZvaWQgMCkubWFwKChbbmFtZSwgdmFsdWVdKSA9PiBbbmFtZSwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBgeyR7dmFsdWUuam9pbihcIixcIil9fWAgOiBgJHt2YWx1ZX1gXSkuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuXHRcdFx0XHR1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWV0aG9kID0gXCJQT1NUXCI7XG5cdFx0XHRib2R5ID0gYXJncztcblx0XHR9XG5cdFx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyk7XG5cdFx0aWYgKF9oYXNPYmplY3RBcmcpIGhlYWRlcnMuc2V0KFwiUHJlZmVyXCIsIGNvdW50ID8gYGNvdW50PSR7Y291bnR9LHJldHVybj1taW5pbWFsYCA6IFwicmV0dXJuPW1pbmltYWxcIik7XG5cdFx0ZWxzZSBpZiAoY291bnQpIGhlYWRlcnMuc2V0KFwiUHJlZmVyXCIsIGBjb3VudD0ke2NvdW50fWApO1xuXHRcdHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHR1cmwsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0c2NoZW1hOiB0aGlzLnNjaGVtYU5hbWUsXG5cdFx0XHRib2R5LFxuXHRcdFx0ZmV0Y2g6IChfdGhpcyRmZXRjaCA9IHRoaXMuZmV0Y2gpICE9PSBudWxsICYmIF90aGlzJGZldGNoICE9PSB2b2lkIDAgPyBfdGhpcyRmZXRjaCA6IGZldGNoXG5cdFx0fSk7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9pbmRleC50c1xudmFyIHNyY19kZWZhdWx0ID0ge1xuXHRQb3N0Z3Jlc3RDbGllbnQsXG5cdFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcblx0UG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcblx0UG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcblx0UG9zdGdyZXN0QnVpbGRlcixcblx0UG9zdGdyZXN0RXJyb3Jcbn07XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgUG9zdGdyZXN0QnVpbGRlciwgUG9zdGdyZXN0Q2xpZW50LCBQb3N0Z3Jlc3RFcnJvciwgUG9zdGdyZXN0RmlsdGVyQnVpbGRlciwgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLCBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLCBzcmNfZGVmYXVsdCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIlBvc3RncmVzdEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvbnRleHQiLCJtZXNzYWdlIiwibmFtZSIsImRldGFpbHMiLCJoaW50IiwiY29kZSIsIlBvc3RncmVzdEJ1aWxkZXIiLCJidWlsZGVyIiwiX2J1aWxkZXIkc2hvdWxkVGhyb3dPIiwiX2J1aWxkZXIkaXNNYXliZVNpbmdsIiwic2hvdWxkVGhyb3dPbkVycm9yIiwibWV0aG9kIiwidXJsIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJzY2hlbWEiLCJib2R5Iiwic2lnbmFsIiwiaXNNYXliZVNpbmdsZSIsImZldGNoIiwidGhyb3dPbkVycm9yIiwic2V0SGVhZGVyIiwidmFsdWUiLCJzZXQiLCJ0aGVuIiwib25mdWxmaWxsZWQiLCJvbnJlamVjdGVkIiwiX3RoaXMiLCJpbmNsdWRlcyIsIl9mZXRjaCIsInJlcyIsInRvU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlcyQxIiwiZXJyb3IiLCJkYXRhIiwiY291bnQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0Iiwib2siLCJfdGhpcyRoZWFkZXJzJGdldDIiLCJfcmVzJGhlYWRlcnMkZ2V0IiwiX3RoaXMkaGVhZGVycyRnZXQiLCJ0ZXh0IiwiZ2V0IiwicGFyc2UiLCJjb3VudEhlYWRlciIsIm1hdGNoIiwiY29udGVudFJhbmdlIiwic3BsaXQiLCJsZW5ndGgiLCJwYXJzZUludCIsIkFycmF5IiwiaXNBcnJheSIsIl9lcnJvciRkZXRhaWxzIiwiX3VudXNlZCIsImNhdGNoIiwiZmV0Y2hFcnJvciIsIl9mZXRjaEVycm9yJG5hbWUyIiwiZXJyb3JEZXRhaWxzIiwiY2F1c2UiLCJfY2F1c2UkbWVzc2FnZSIsIl9jYXVzZSRjb2RlIiwiX2ZldGNoRXJyb3IkbmFtZSIsIl9jYXVzZSRuYW1lIiwiY2F1c2VNZXNzYWdlIiwiY2F1c2VDb2RlIiwic3RhY2siLCJfZmV0Y2hFcnJvciRzdGFjayIsInJldHVybnMiLCJvdmVycmlkZVR5cGVzIiwiUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciIsInNlbGVjdCIsImNvbHVtbnMiLCJxdW90ZWQiLCJjbGVhbmVkQ29sdW1ucyIsIm1hcCIsImMiLCJ0ZXN0Iiwiam9pbiIsInNlYXJjaFBhcmFtcyIsImFwcGVuZCIsIm9yZGVyIiwiY29sdW1uIiwiYXNjZW5kaW5nIiwibnVsbHNGaXJzdCIsImZvcmVpZ25UYWJsZSIsInJlZmVyZW5jZWRUYWJsZSIsImtleSIsImV4aXN0aW5nT3JkZXIiLCJsaW1pdCIsInJhbmdlIiwiZnJvbSIsInRvIiwia2V5T2Zmc2V0Iiwia2V5TGltaXQiLCJhYm9ydFNpZ25hbCIsInNpbmdsZSIsIm1heWJlU2luZ2xlIiwiY3N2IiwiZ2VvanNvbiIsImV4cGxhaW4iLCJhbmFseXplIiwidmVyYm9zZSIsInNldHRpbmdzIiwiYnVmZmVycyIsIndhbCIsImZvcm1hdCIsIm9wdGlvbnMiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZm9yTWVkaWF0eXBlIiwicm9sbGJhY2siLCJtYXhBZmZlY3RlZCIsIlBvc3RncmVzdFJlc2VydmVkQ2hhcnNSZWdleHAiLCJSZWdFeHAiLCJQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyIiwiZXEiLCJuZXEiLCJndCIsImd0ZSIsImx0IiwibHRlIiwibGlrZSIsInBhdHRlcm4iLCJsaWtlQWxsT2YiLCJwYXR0ZXJucyIsImxpa2VBbnlPZiIsImlsaWtlIiwiaWxpa2VBbGxPZiIsImlsaWtlQW55T2YiLCJyZWdleE1hdGNoIiwicmVnZXhJTWF0Y2giLCJpcyIsImlzRGlzdGluY3QiLCJpbiIsInZhbHVlcyIsImNsZWFuZWRWYWx1ZXMiLCJTZXQiLCJzIiwibm90SW4iLCJjb250YWlucyIsImNvbnRhaW5lZEJ5IiwicmFuZ2VHdCIsInJhbmdlR3RlIiwicmFuZ2VMdCIsInJhbmdlTHRlIiwicmFuZ2VBZGphY2VudCIsIm92ZXJsYXBzIiwidGV4dFNlYXJjaCIsInF1ZXJ5IiwiY29uZmlnIiwidHlwZSIsInR5cGVQYXJ0IiwiY29uZmlnUGFydCIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwibm90Iiwib3BlcmF0b3IiLCJvciIsImZpbHRlcnMiLCJQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIiLCJmZXRjaCQxIiwiY2xvbmVSZXF1ZXN0U3RhdGUiLCJVUkwiLCJoZWFkIiwiaW5zZXJ0IiwiZGVmYXVsdFRvTnVsbCIsIl90aGlzJGZldGNoIiwicmVkdWNlIiwiYWNjIiwieCIsImNvbmNhdCIsImtleXMiLCJ1bmlxdWVDb2x1bW5zIiwidXBzZXJ0Iiwib25Db25mbGljdCIsImlnbm9yZUR1cGxpY2F0ZXMiLCJfdGhpcyRmZXRjaDIiLCJ1cGRhdGUiLCJfdGhpcyRmZXRjaDMiLCJkZWxldGUiLCJfdGhpcyRmZXRjaDQiLCJQb3N0Z3Jlc3RDbGllbnQiLCJzY2hlbWFOYW1lIiwicmVsYXRpb24iLCJ0cmltIiwicnBjIiwiZm4iLCJhcmdzIiwiX2lzT2JqZWN0IiwidiIsInNvbWUiLCJfaGFzT2JqZWN0QXJnIiwiXyIsInNyY19kZWZhdWx0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/postgrest-js/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/storage-js/dist/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageAnalyticsClient: () => (/* binding */ StorageAnalyticsClient),\n/* harmony export */   StorageApiError: () => (/* binding */ StorageApiError),\n/* harmony export */   StorageClient: () => (/* binding */ StorageClient),\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageUnknownError: () => (/* binding */ StorageUnknownError),\n/* harmony export */   StorageVectorsApiError: () => (/* binding */ StorageVectorsApiError),\n/* harmony export */   StorageVectorsClient: () => (/* binding */ StorageVectorsClient),\n/* harmony export */   StorageVectorsError: () => (/* binding */ StorageVectorsError),\n/* harmony export */   StorageVectorsErrorCode: () => (/* binding */ StorageVectorsErrorCode),\n/* harmony export */   StorageVectorsUnknownError: () => (/* binding */ StorageVectorsUnknownError),\n/* harmony export */   VectorBucketApi: () => (/* binding */ VectorBucketApi),\n/* harmony export */   VectorBucketScope: () => (/* binding */ VectorBucketScope),\n/* harmony export */   VectorDataApi: () => (/* binding */ VectorDataApi),\n/* harmony export */   VectorIndexApi: () => (/* binding */ VectorIndexApi),\n/* harmony export */   VectorIndexScope: () => (/* binding */ VectorIndexScope),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isStorageError: () => (/* binding */ isStorageError),\n/* harmony export */   isStorageVectorsError: () => (/* binding */ isStorageVectorsError),\n/* harmony export */   normalizeToFloat32: () => (/* binding */ normalizeToFloat32),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse),\n/* harmony export */   validateVectorDimension: () => (/* binding */ validateVectorDimension)\n/* harmony export */ });\n/* harmony import */ var iceberg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! iceberg-js */ \"(rsc)/./node_modules/iceberg-js/dist/index.mjs\");\n\n//#region src/lib/errors.ts\nvar StorageError = class extends Error {\n    constructor(message){\n        super(message);\n        this.__isStorageError = true;\n        this.name = \"StorageError\";\n    }\n};\nfunction isStorageError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageError\" in error;\n}\nvar StorageApiError = class extends StorageError {\n    constructor(message, status, statusCode){\n        super(message);\n        this.name = \"StorageApiError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode\n        };\n    }\n};\nvar StorageUnknownError = class extends StorageError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"StorageUnknownError\";\n        this.originalError = originalError;\n    }\n};\n//#endregion\n//#region src/lib/helpers.ts\nconst resolveFetch$1 = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\nconst resolveResponse$1 = ()=>{\n    return Response;\n};\nconst recursiveToCamel = (item)=>{\n    if (Array.isArray(item)) return item.map((el)=>recursiveToCamel(el));\n    else if (typeof item === \"function\" || item !== Object(item)) return item;\n    const result = {};\n    Object.entries(item).forEach(([key, value])=>{\n        const newKey = key.replace(/([-_][a-z])/gi, (c)=>c.toUpperCase().replace(/[-_]/g, \"\"));\n        result[newKey] = recursiveToCamel(value);\n    });\n    return result;\n};\n/**\n* Determine if input is a plain object\n* An object is plain if it's created by either {}, new Object(), or Object.create(null)\n* source: https://github.com/sindresorhus/is-plain-obj\n*/ const isPlainObject$1 = (value)=>{\n    if (typeof value !== \"object\" || value === null) return false;\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};\n/**\n* Validates if a given bucket name is valid according to Supabase Storage API rules\n* Mirrors backend validation from: storage/src/storage/limits.ts:isValidBucketName()\n*\n* Rules:\n* - Length: 1-100 characters\n* - Allowed characters: alphanumeric (a-z, A-Z, 0-9), underscore (_), and safe special characters\n* - Safe special characters: ! - . * ' ( ) space & $ @ = ; : + , ?\n* - Forbidden: path separators (/, \\), path traversal (..), leading/trailing whitespace\n*\n* AWS S3 Reference: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html\n*\n* @param bucketName - The bucket name to validate\n* @returns true if valid, false otherwise\n*/ const isValidBucketName = (bucketName)=>{\n    if (!bucketName || typeof bucketName !== \"string\") return false;\n    if (bucketName.length === 0 || bucketName.length > 100) return false;\n    if (bucketName.trim() !== bucketName) return false;\n    if (bucketName.includes(\"/\") || bucketName.includes(\"\\\\\")) return false;\n    return /^[\\w!.\\*'() &$@=;:+,?-]+$/.test(bucketName);\n};\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n        return typeof o$1;\n    } : function(o$1) {\n        return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, _typeof(o);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n    var i = toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r$1) {\n            return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n            _defineProperty(e, r$1, t[r$1]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n            Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n        });\n    }\n    return e;\n}\n//#endregion\n//#region src/lib/fetch.ts\nconst _getErrorMessage$1 = (err)=>{\n    var _err$error;\n    return err.msg || err.message || err.error_description || (typeof err.error === \"string\" ? err.error : (_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.message) || JSON.stringify(err);\n};\nconst handleError$1 = async (error, reject, options)=>{\n    if (error instanceof await resolveResponse$1() && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) error.json().then((err)=>{\n        const status = error.status || 500;\n        const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || status + \"\";\n        reject(new StorageApiError(_getErrorMessage$1(err), status, statusCode));\n    }).catch((err)=>{\n        reject(new StorageUnknownError(_getErrorMessage$1(err), err));\n    });\n    else reject(new StorageUnknownError(_getErrorMessage$1(error), error));\n};\nconst _getRequestParams$1 = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\" || !body) return params;\n    if (isPlainObject$1(body)) {\n        params.headers = _objectSpread2({\n            \"Content-Type\": \"application/json\"\n        }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    } else params.body = body;\n    if (options === null || options === void 0 ? void 0 : options.duplex) params.duplex = options.duplex;\n    return _objectSpread2(_objectSpread2({}, params), parameters);\n};\nasync function _handleRequest$1(fetcher, method, url, options, parameters, body) {\n    return new Promise((resolve, reject)=>{\n        fetcher(url, _getRequestParams$1(method, options, parameters, body)).then((result)=>{\n            if (!result.ok) throw result;\n            if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n            return result.json();\n        }).then((data)=>resolve(data)).catch((error)=>handleError$1(error, reject, options));\n    });\n}\nasync function get(fetcher, url, options, parameters) {\n    return _handleRequest$1(fetcher, \"GET\", url, options, parameters);\n}\nasync function post$1(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"POST\", url, options, parameters, body);\n}\nasync function put(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"PUT\", url, options, parameters, body);\n}\nasync function head(fetcher, url, options, parameters) {\n    return _handleRequest$1(fetcher, \"HEAD\", url, _objectSpread2(_objectSpread2({}, options), {}, {\n        noResolveJson: true\n    }), parameters);\n}\nasync function remove(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"DELETE\", url, options, parameters, body);\n}\n//#endregion\n//#region src/packages/StreamDownloadBuilder.ts\nvar StreamDownloadBuilder = class {\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n    }\n    then(onfulfilled, onrejected) {\n        return this.execute().then(onfulfilled, onrejected);\n    }\n    async execute() {\n        var _this = this;\n        try {\n            return {\n                data: (await _this.downloadFn()).body,\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/packages/BlobDownloadBuilder.ts\nlet _Symbol$toStringTag;\n_Symbol$toStringTag = Symbol.toStringTag;\nvar BlobDownloadBuilder = class {\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n        this[_Symbol$toStringTag] = \"BlobDownloadBuilder\";\n        this.promise = null;\n    }\n    asStream() {\n        return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);\n    }\n    then(onfulfilled, onrejected) {\n        return this.getPromise().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.getPromise().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.getPromise().finally(onfinally);\n    }\n    getPromise() {\n        if (!this.promise) this.promise = this.execute();\n        return this.promise;\n    }\n    async execute() {\n        var _this = this;\n        try {\n            return {\n                data: await (await _this.downloadFn()).blob(),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/packages/StorageFileApi.ts\nconst DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: \"name\",\n        order: \"asc\"\n    }\n};\nconst DEFAULT_FILE_OPTIONS = {\n    cacheControl: \"3600\",\n    contentType: \"text/plain;charset=UTF-8\",\n    upsert: false\n};\nvar StorageFileApi = class {\n    constructor(url, headers = {}, bucketId, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url;\n        this.headers = headers;\n        this.bucketId = bucketId;\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* Enable throwing errors instead of returning them.\n\t*\n\t* @category File Buckets\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n\t*\n\t* @param method HTTP method.\n\t* @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t*/ async uploadOrUpdate(method, path, fileBody, fileOptions) {\n        var _this = this;\n        try {\n            let body;\n            const options = _objectSpread2(_objectSpread2({}, DEFAULT_FILE_OPTIONS), fileOptions);\n            let headers = _objectSpread2(_objectSpread2({}, _this.headers), method === \"POST\" && {\n                \"x-upsert\": String(options.upsert)\n            });\n            const metadata = options.metadata;\n            if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                body = new FormData();\n                body.append(\"cacheControl\", options.cacheControl);\n                if (metadata) body.append(\"metadata\", _this.encodeMetadata(metadata));\n                body.append(\"\", fileBody);\n            } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                body = fileBody;\n                if (!body.has(\"cacheControl\")) body.append(\"cacheControl\", options.cacheControl);\n                if (metadata && !body.has(\"metadata\")) body.append(\"metadata\", _this.encodeMetadata(metadata));\n            } else {\n                body = fileBody;\n                headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                headers[\"content-type\"] = options.contentType;\n                if (metadata) headers[\"x-metadata\"] = _this.toBase64(_this.encodeMetadata(metadata));\n                if ((typeof ReadableStream !== \"undefined\" && body instanceof ReadableStream || body && typeof body === \"object\" && \"pipe\" in body && typeof body.pipe === \"function\") && !options.duplex) options.duplex = \"half\";\n            }\n            if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) headers = _objectSpread2(_objectSpread2({}, headers), fileOptions.headers);\n            const cleanPath = _this._removeEmptyFolders(path);\n            const _path = _this._getFinalPath(cleanPath);\n            const data = await (method == \"PUT\" ? put : post$1)(_this.fetch, `${_this.url}/object/${_path}`, body, _objectSpread2({\n                headers\n            }, (options === null || options === void 0 ? void 0 : options.duplex) ? {\n                duplex: options.duplex\n            } : {}));\n            return {\n                data: {\n                    path: cleanPath,\n                    id: data.Id,\n                    fullPath: data.Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Uploads a file to an existing bucket.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n\t* @returns Promise with response containing file path, id, and fullPath or error\n\t*\n\t* @example Upload file\n\t* ```js\n\t* const avatarFile = event.target.files[0]\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .upload('public/avatar1.png', avatarFile, {\n\t*     cacheControl: '3600',\n\t*     upsert: false\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"public/avatar1.png\",\n\t*     \"fullPath\": \"avatars/public/avatar1.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Upload file using `ArrayBuffer` from base64 file data\n\t* ```js\n\t* import { decode } from 'base64-arraybuffer'\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .upload('public/avatar1.png', decode('base64FileData'), {\n\t*     contentType: 'image/png'\n\t*   })\n\t* ```\n\t*/ async upload(path, fileBody, fileOptions) {\n        return this.uploadOrUpdate(\"POST\", path, fileBody, fileOptions);\n    }\n    /**\n\t* Upload a file with a token generated from `createSignedUploadUrl`.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param token The token generated from `createSignedUploadUrl`\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions HTTP headers (cacheControl, contentType, etc.).\n\t* **Note:** The `upsert` option has no effect here. To enable upsert behavior,\n\t* pass `{ upsert: true }` when calling `createSignedUploadUrl()` instead.\n\t* @returns Promise with response containing file path and fullPath or error\n\t*\n\t* @example Upload to a signed URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"folder/cat.jpg\",\n\t*     \"fullPath\": \"avatars/folder/cat.jpg\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async uploadToSignedUrl(path, token, fileBody, fileOptions) {\n        var _this3 = this;\n        const cleanPath = _this3._removeEmptyFolders(path);\n        const _path = _this3._getFinalPath(cleanPath);\n        const url = new URL(_this3.url + `/object/upload/sign/${_path}`);\n        url.searchParams.set(\"token\", token);\n        try {\n            let body;\n            const options = _objectSpread2({\n                upsert: DEFAULT_FILE_OPTIONS.upsert\n            }, fileOptions);\n            const headers = _objectSpread2(_objectSpread2({}, _this3.headers), {\n                \"x-upsert\": String(options.upsert)\n            });\n            if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                body = new FormData();\n                body.append(\"cacheControl\", options.cacheControl);\n                body.append(\"\", fileBody);\n            } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                body = fileBody;\n                body.append(\"cacheControl\", options.cacheControl);\n            } else {\n                body = fileBody;\n                headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                headers[\"content-type\"] = options.contentType;\n            }\n            return {\n                data: {\n                    path: cleanPath,\n                    fullPath: (await put(_this3.fetch, url.toString(), body, {\n                        headers\n                    })).Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a signed upload URL.\n\t* Signed upload URLs can be used to upload files to the bucket without further authentication.\n\t* They are valid for 2 hours.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the current file name. For example `folder/image.png`.\n\t* @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n\t* @returns Promise with response containing signed upload URL, token, and path or error\n\t*\n\t* @example Create Signed Upload URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUploadUrl('folder/cat.jpg')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/upload/sign/avatars/folder/cat.jpg?token=<TOKEN>\",\n\t*     \"path\": \"folder/cat.jpg\",\n\t*     \"token\": \"<TOKEN>\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createSignedUploadUrl(path, options) {\n        var _this4 = this;\n        try {\n            let _path = _this4._getFinalPath(path);\n            const headers = _objectSpread2({}, _this4.headers);\n            if (options === null || options === void 0 ? void 0 : options.upsert) headers[\"x-upsert\"] = \"true\";\n            const data = await post$1(_this4.fetch, `${_this4.url}/object/upload/sign/${_path}`, {}, {\n                headers\n            });\n            const url = new URL(_this4.url + data.url);\n            const token = url.searchParams.get(\"token\");\n            if (!token) throw new StorageError(\"No token returned by API\");\n            return {\n                data: {\n                    signedUrl: url.toString(),\n                    path,\n                    token\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Replaces an existing file at the specified path with a new one.\n\t*\n\t* @category File Buckets\n\t* @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n\t* @returns Promise with response containing file path, id, and fullPath or error\n\t*\n\t* @example Update file\n\t* ```js\n\t* const avatarFile = event.target.files[0]\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .update('public/avatar1.png', avatarFile, {\n\t*     cacheControl: '3600',\n\t*     upsert: true\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"public/avatar1.png\",\n\t*     \"fullPath\": \"avatars/public/avatar1.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Update file using `ArrayBuffer` from base64 file data\n\t* ```js\n\t* import {decode} from 'base64-arraybuffer'\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .update('public/avatar1.png', decode('base64FileData'), {\n\t*     contentType: 'image/png'\n\t*   })\n\t* ```\n\t*/ async update(path, fileBody, fileOptions) {\n        return this.uploadOrUpdate(\"PUT\", path, fileBody, fileOptions);\n    }\n    /**\n\t* Moves an existing file to a new path in the same bucket.\n\t*\n\t* @category File Buckets\n\t* @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n\t* @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n\t* @param options The destination options.\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Move file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .move('public/avatar1.png', 'private/avatar2.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully moved\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async move(fromPath, toPath, options) {\n        var _this6 = this;\n        try {\n            return {\n                data: await post$1(_this6.fetch, `${_this6.url}/object/move`, {\n                    bucketId: _this6.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                }, {\n                    headers: _this6.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this6.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Copies an existing file to a new path in the same bucket.\n\t*\n\t* @category File Buckets\n\t* @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n\t* @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n\t* @param options The destination options.\n\t* @returns Promise with response containing copied file path or error\n\t*\n\t* @example Copy file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .copy('public/avatar1.png', 'private/avatar2.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"avatars/private/avatar2.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async copy(fromPath, toPath, options) {\n        var _this7 = this;\n        try {\n            return {\n                data: {\n                    path: (await post$1(_this7.fetch, `${_this7.url}/object/copy`, {\n                        bucketId: _this7.bucketId,\n                        sourceKey: fromPath,\n                        destinationKey: toPath,\n                        destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                    }, {\n                        headers: _this7.headers\n                    })).Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this7.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the current file name. For example `folder/image.png`.\n\t* @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n\t* @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns Promise with response containing signed URL or error\n\t*\n\t* @example Create Signed URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Create a signed URL for an asset with transformations\n\t* ```js\n\t* const { data } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60, {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Create a signed URL which triggers the download of the asset\n\t* ```js\n\t* const { data } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60, {\n\t*     download: true,\n\t*   })\n\t* ```\n\t*/ async createSignedUrl(path, expiresIn, options) {\n        var _this8 = this;\n        try {\n            let _path = _this8._getFinalPath(path);\n            let data = await post$1(_this8.fetch, `${_this8.url}/object/sign/${_path}`, _objectSpread2({\n                expiresIn\n            }, (options === null || options === void 0 ? void 0 : options.transform) ? {\n                transform: options.transform\n            } : {}), {\n                headers: _this8.headers\n            });\n            const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n            data = {\n                signedUrl: encodeURI(`${_this8.url}${data.signedURL}${downloadQueryParam}`)\n            };\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            if (_this8.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n\t*\n\t* @category File Buckets\n\t* @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n\t* @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n\t* @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @returns Promise with response containing array of objects with signedUrl, path, and error or error\n\t*\n\t* @example Create Signed URLs\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"error\": null,\n\t*       \"path\": \"folder/avatar1.png\",\n\t*       \"signedURL\": \"/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\",\n\t*       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n\t*     },\n\t*     {\n\t*       \"error\": null,\n\t*       \"path\": \"folder/avatar2.png\",\n\t*       \"signedURL\": \"/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\",\n\t*       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\"\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createSignedUrls(paths, expiresIn, options) {\n        var _this9 = this;\n        try {\n            const data = await post$1(_this9.fetch, `${_this9.url}/object/sign/${_this9.bucketId}`, {\n                expiresIn,\n                paths\n            }, {\n                headers: _this9.headers\n            });\n            const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n            return {\n                data: data.map((datum)=>_objectSpread2(_objectSpread2({}, datum), {}, {\n                        signedUrl: datum.signedURL ? encodeURI(`${_this9.url}${datum.signedURL}${downloadQueryParam}`) : null\n                    })),\n                error: null\n            };\n        } catch (error) {\n            if (_this9.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n\t*\n\t* @category File Buckets\n\t* @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns BlobDownloadBuilder instance for downloading the file\n\t*\n\t* @example Download file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": <BLOB>,\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Download file with transformations\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png', {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*       quality: 80\n\t*     }\n\t*   })\n\t* ```\n\t*/ download(path, options) {\n        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\" ? \"render/image/authenticated\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        const queryString = transformationQuery ? `?${transformationQuery}` : \"\";\n        const _path = this._getFinalPath(path);\n        const downloadFn = ()=>get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n                headers: this.headers,\n                noResolveJson: true\n            });\n        return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError);\n    }\n    /**\n\t* Retrieves the details of an existing file.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. For example `folder/image.png`.\n\t* @returns Promise with response containing file metadata or error\n\t*\n\t* @example Get file info\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .info('folder/avatar1.png')\n\t* ```\n\t*/ async info(path) {\n        var _this10 = this;\n        const _path = _this10._getFinalPath(path);\n        try {\n            return {\n                data: recursiveToCamel(await get(_this10.fetch, `${_this10.url}/object/info/${_path}`, {\n                    headers: _this10.headers\n                })),\n                error: null\n            };\n        } catch (error) {\n            if (_this10.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Checks the existence of a file.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. For example `folder/image.png`.\n\t* @returns Promise with response containing boolean indicating file existence or error\n\t*\n\t* @example Check file existence\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .exists('folder/avatar1.png')\n\t* ```\n\t*/ async exists(path) {\n        var _this11 = this;\n        const _path = _this11._getFinalPath(path);\n        try {\n            await head(_this11.fetch, `${_this11.url}/object/${_path}`, {\n                headers: _this11.headers\n            });\n            return {\n                data: true,\n                error: null\n            };\n        } catch (error) {\n            if (_this11.shouldThrowOnError) throw error;\n            if (isStorageError(error) && error instanceof StorageUnknownError) {\n                const originalError = error.originalError;\n                if ([\n                    400,\n                    404\n                ].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) return {\n                    data: false,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n\t* A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n\t* This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n\t*\n\t* @category File Buckets\n\t* @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n\t* @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns Object with public URL\n\t*\n\t* @example Returns the URL for an asset in a public bucket\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"publicUrl\": \"https://example.supabase.co/storage/v1/object/public/public-bucket/folder/avatar1.png\"\n\t*   }\n\t* }\n\t* ```\n\t*\n\t* @example Returns the URL for an asset in a public bucket with transformations\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png', {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Returns the URL which triggers the download of an asset in a public bucket\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png', {\n\t*     download: true,\n\t*   })\n\t* ```\n\t*/ getPublicUrl(path, options) {\n        const _path = this._getFinalPath(path);\n        const _queryString = [];\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? \"\" : options.download}` : \"\";\n        if (downloadQueryParam !== \"\") _queryString.push(downloadQueryParam);\n        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\" ? \"render/image\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        if (transformationQuery !== \"\") _queryString.push(transformationQuery);\n        let queryString = _queryString.join(\"&\");\n        if (queryString !== \"\") queryString = `?${queryString}`;\n        return {\n            data: {\n                publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`)\n            }\n        };\n    }\n    /**\n\t* Deletes files within the same bucket\n\t*\n\t* @category File Buckets\n\t* @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n\t* @returns Promise with response containing array of deleted file objects or error\n\t*\n\t* @example Delete file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .remove(['folder/avatar1.png'])\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async remove(paths) {\n        var _this12 = this;\n        try {\n            return {\n                data: await remove(_this12.fetch, `${_this12.url}/object/${_this12.bucketId}`, {\n                    prefixes: paths\n                }, {\n                    headers: _this12.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this12.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Get file metadata\n\t* @param id the file id to retrieve metadata\n\t*/ /**\n\t* Update file metadata\n\t* @param id the file id to update metadata\n\t* @param meta the new file metadata\n\t*/ /**\n\t* Lists all the files and folders within a path of the bucket.\n\t*\n\t* @category File Buckets\n\t* @param path The folder path.\n\t* @param options Search options including limit (defaults to 100), offset, sortBy, and search\n\t* @param parameters Optional fetch parameters including signal for cancellation\n\t* @returns Promise with response containing array of files or error\n\t*\n\t* @example List files in a bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .list('folder', {\n\t*     limit: 100,\n\t*     offset: 0,\n\t*     sortBy: { column: 'name', order: 'asc' },\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"name\": \"avatar1.png\",\n\t*       \"id\": \"e668cf7f-821b-4a2f-9dce-7dfa5dd1cfd2\",\n\t*       \"updated_at\": \"2024-05-22T23:06:05.580Z\",\n\t*       \"created_at\": \"2024-05-22T23:04:34.443Z\",\n\t*       \"last_accessed_at\": \"2024-05-22T23:04:34.443Z\",\n\t*       \"metadata\": {\n\t*         \"eTag\": \"\\\"c5e8c553235d9af30ef4f6e280790b92\\\"\",\n\t*         \"size\": 32175,\n\t*         \"mimetype\": \"image/png\",\n\t*         \"cacheControl\": \"max-age=3600\",\n\t*         \"lastModified\": \"2024-05-22T23:06:05.574Z\",\n\t*         \"contentLength\": 32175,\n\t*         \"httpStatusCode\": 200\n\t*       }\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Search files in a bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .list('folder', {\n\t*     limit: 100,\n\t*     offset: 0,\n\t*     sortBy: { column: 'name', order: 'asc' },\n\t*     search: 'jon'\n\t*   })\n\t* ```\n\t*/ async list(path, options, parameters) {\n        var _this13 = this;\n        try {\n            const body = _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_SEARCH_OPTIONS), options), {}, {\n                prefix: path || \"\"\n            });\n            return {\n                data: await post$1(_this13.fetch, `${_this13.url}/object/list/${_this13.bucketId}`, body, {\n                    headers: _this13.headers\n                }, parameters),\n                error: null\n            };\n        } catch (error) {\n            if (_this13.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @experimental this method signature might change in the future\n\t*\n\t* @category File Buckets\n\t* @param options search options\n\t* @param parameters\n\t*/ async listV2(options, parameters) {\n        var _this14 = this;\n        try {\n            const body = _objectSpread2({}, options);\n            return {\n                data: await post$1(_this14.fetch, `${_this14.url}/object/list-v2/${_this14.bucketId}`, body, {\n                    headers: _this14.headers\n                }, parameters),\n                error: null\n            };\n        } catch (error) {\n            if (_this14.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    encodeMetadata(metadata) {\n        return JSON.stringify(metadata);\n    }\n    toBase64(data) {\n        if (typeof Buffer !== \"undefined\") return Buffer.from(data).toString(\"base64\");\n        return btoa(data);\n    }\n    _getFinalPath(path) {\n        return `${this.bucketId}/${path.replace(/^\\/+/, \"\")}`;\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, \"\").replace(/\\/+/g, \"/\");\n    }\n    transformOptsToQueryString(transform) {\n        const params = [];\n        if (transform.width) params.push(`width=${transform.width}`);\n        if (transform.height) params.push(`height=${transform.height}`);\n        if (transform.resize) params.push(`resize=${transform.resize}`);\n        if (transform.format) params.push(`format=${transform.format}`);\n        if (transform.quality) params.push(`quality=${transform.quality}`);\n        return params.join(\"&\");\n    }\n};\n//#endregion\n//#region src/lib/version.ts\nconst version = \"2.91.0\";\n//#endregion\n//#region src/lib/constants.ts\nconst DEFAULT_HEADERS$1 = {\n    \"X-Client-Info\": `storage-js/${version}`\n};\n//#endregion\n//#region src/packages/StorageBucketApi.ts\nvar StorageBucketApi = class {\n    constructor(url, headers = {}, fetch$1, opts){\n        this.shouldThrowOnError = false;\n        const baseUrl = new URL(url);\n        if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {\n            if (/supabase\\.(co|in|red)$/.test(baseUrl.hostname) && !baseUrl.hostname.includes(\"storage.supabase.\")) baseUrl.hostname = baseUrl.hostname.replace(\"supabase.\", \"storage.supabase.\");\n        }\n        this.url = baseUrl.href.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS$1), headers);\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* Enable throwing errors instead of returning them.\n\t*\n\t* @category File Buckets\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Retrieves the details of all Storage buckets within an existing project.\n\t*\n\t* @category File Buckets\n\t* @param options Query parameters for listing buckets\n\t* @param options.limit Maximum number of buckets to return\n\t* @param options.offset Number of buckets to skip\n\t* @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')\n\t* @param options.sortOrder Sort order ('asc' or 'desc')\n\t* @param options.search Search term to filter bucket names\n\t* @returns Promise with response containing array of buckets or error\n\t*\n\t* @example List buckets\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .listBuckets()\n\t* ```\n\t*\n\t* @example List buckets with options\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .listBuckets({\n\t*     limit: 10,\n\t*     offset: 0,\n\t*     sortColumn: 'created_at',\n\t*     sortOrder: 'desc',\n\t*     search: 'prod'\n\t*   })\n\t* ```\n\t*/ async listBuckets(options) {\n        var _this = this;\n        try {\n            const queryString = _this.listBucketOptionsToQueryString(options);\n            return {\n                data: await get(_this.fetch, `${_this.url}/bucket${queryString}`, {\n                    headers: _this.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Retrieves the details of an existing Storage bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to retrieve.\n\t* @returns Promise with response containing bucket details or error\n\t*\n\t* @example Get bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .getBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"id\": \"avatars\",\n\t*     \"name\": \"avatars\",\n\t*     \"owner\": \"\",\n\t*     \"public\": false,\n\t*     \"file_size_limit\": 1024,\n\t*     \"allowed_mime_types\": [\n\t*       \"image/png\"\n\t*     ],\n\t*     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async getBucket(id) {\n        var _this2 = this;\n        try {\n            return {\n                data: await get(_this2.fetch, `${_this2.url}/bucket/${id}`, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a new Storage bucket\n\t*\n\t* @category File Buckets\n\t* @param id A unique identifier for the bucket you are creating.\n\t* @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n\t* @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n\t* The global file size limit takes precedence over this value.\n\t* The default value is null, which doesn't set a per bucket file size limit.\n\t* @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n\t* The default value is null, which allows files with all mime types to be uploaded.\n\t* Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n\t* @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.\n\t*   - default bucket type is `STANDARD`\n\t* @returns Promise with response containing newly created bucket name or error\n\t*\n\t* @example Create bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .createBucket('avatars', {\n\t*     public: false,\n\t*     allowedMimeTypes: ['image/png'],\n\t*     fileSizeLimit: 1024\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"name\": \"avatars\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createBucket(id, options = {\n        public: false\n    }) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post$1(_this3.fetch, `${_this3.url}/bucket`, {\n                    id,\n                    name: id,\n                    type: options.type,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes\n                }, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Updates a Storage bucket\n\t*\n\t* @category File Buckets\n\t* @param id A unique identifier for the bucket you are updating.\n\t* @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n\t* @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n\t* The global file size limit takes precedence over this value.\n\t* The default value is null, which doesn't set a per bucket file size limit.\n\t* @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n\t* The default value is null, which allows files with all mime types to be uploaded.\n\t* Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Update bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .updateBucket('avatars', {\n\t*     public: false,\n\t*     allowedMimeTypes: ['image/png'],\n\t*     fileSizeLimit: 1024\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully updated\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async updateBucket(id, options) {\n        var _this4 = this;\n        try {\n            return {\n                data: await put(_this4.fetch, `${_this4.url}/bucket/${id}`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes\n                }, {\n                    headers: _this4.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Removes all objects inside a single bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to empty.\n\t* @returns Promise with success message or error\n\t*\n\t* @example Empty bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .emptyBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully emptied\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async emptyBucket(id) {\n        var _this5 = this;\n        try {\n            return {\n                data: await post$1(_this5.fetch, `${_this5.url}/bucket/${id}/empty`, {}, {\n                    headers: _this5.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this5.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n\t* You must first `empty()` the bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to delete.\n\t* @returns Promise with success message or error\n\t*\n\t* @example Delete bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .deleteBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully deleted\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async deleteBucket(id) {\n        var _this6 = this;\n        try {\n            return {\n                data: await remove(_this6.fetch, `${_this6.url}/bucket/${id}`, {}, {\n                    headers: _this6.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this6.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    listBucketOptionsToQueryString(options) {\n        const params = {};\n        if (options) {\n            if (\"limit\" in options) params.limit = String(options.limit);\n            if (\"offset\" in options) params.offset = String(options.offset);\n            if (options.search) params.search = options.search;\n            if (options.sortColumn) params.sortColumn = options.sortColumn;\n            if (options.sortOrder) params.sortOrder = options.sortOrder;\n        }\n        return Object.keys(params).length > 0 ? \"?\" + new URLSearchParams(params).toString() : \"\";\n    }\n};\n//#endregion\n//#region src/packages/StorageAnalyticsClient.ts\n/**\n* Client class for managing Analytics Buckets using Iceberg tables\n* Provides methods for creating, listing, and deleting analytics buckets\n*/ var StorageAnalyticsClient = class {\n    /**\n\t* @alpha\n\t*\n\t* Creates a new StorageAnalyticsClient instance\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param url - The base URL for the storage API\n\t* @param headers - HTTP headers to include in requests\n\t* @param fetch - Optional custom fetch implementation\n\t*\n\t* @example\n\t* ```typescript\n\t* const client = new StorageAnalyticsClient(url, headers)\n\t* ```\n\t*/ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS$1), headers);\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* @alpha\n\t*\n\t* Enable throwing errors instead of returning them in the response\n\t* When enabled, failed operations will throw instead of returning { data: null, error }\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @returns This instance for method chaining\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* @alpha\n\t*\n\t* Creates a new analytics bucket using Iceberg tables\n\t* Analytics buckets are optimized for analytical queries and data processing\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param name A unique name for the bucket you are creating\n\t* @returns Promise with response containing newly created analytics bucket or error\n\t*\n\t* @example Create analytics bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .createBucket('analytics-data')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"name\": \"analytics-data\",\n\t*     \"type\": \"ANALYTICS\",\n\t*     \"format\": \"iceberg\",\n\t*     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createBucket(name) {\n        var _this = this;\n        try {\n            return {\n                data: await post$1(_this.fetch, `${_this.url}/bucket`, {\n                    name\n                }, {\n                    headers: _this.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Retrieves the details of all Analytics Storage buckets within an existing project\n\t* Only returns buckets of type 'ANALYTICS'\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param options Query parameters for listing buckets\n\t* @param options.limit Maximum number of buckets to return\n\t* @param options.offset Number of buckets to skip\n\t* @param options.sortColumn Column to sort by ('name', 'created_at', 'updated_at')\n\t* @param options.sortOrder Sort order ('asc' or 'desc')\n\t* @param options.search Search term to filter bucket names\n\t* @returns Promise with response containing array of analytics buckets or error\n\t*\n\t* @example List analytics buckets\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .listBuckets({\n\t*     limit: 10,\n\t*     offset: 0,\n\t*     sortColumn: 'created_at',\n\t*     sortOrder: 'desc'\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"name\": \"analytics-data\",\n\t*       \"type\": \"ANALYTICS\",\n\t*       \"format\": \"iceberg\",\n\t*       \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*       \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async listBuckets(options) {\n        var _this2 = this;\n        try {\n            const queryParams = new URLSearchParams();\n            if ((options === null || options === void 0 ? void 0 : options.limit) !== void 0) queryParams.set(\"limit\", options.limit.toString());\n            if ((options === null || options === void 0 ? void 0 : options.offset) !== void 0) queryParams.set(\"offset\", options.offset.toString());\n            if (options === null || options === void 0 ? void 0 : options.sortColumn) queryParams.set(\"sortColumn\", options.sortColumn);\n            if (options === null || options === void 0 ? void 0 : options.sortOrder) queryParams.set(\"sortOrder\", options.sortOrder);\n            if (options === null || options === void 0 ? void 0 : options.search) queryParams.set(\"search\", options.search);\n            const queryString = queryParams.toString();\n            const url = queryString ? `${_this2.url}/bucket?${queryString}` : `${_this2.url}/bucket`;\n            return {\n                data: await get(_this2.fetch, url, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Deletes an existing analytics bucket\n\t* A bucket can't be deleted with existing objects inside it\n\t* You must first empty the bucket before deletion\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param bucketName The unique identifier of the bucket you would like to delete\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Delete analytics bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .deleteBucket('analytics-data')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully deleted\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async deleteBucket(bucketName) {\n        var _this3 = this;\n        try {\n            return {\n                data: await remove(_this3.fetch, `${_this3.url}/bucket/${bucketName}`, {}, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Get an Iceberg REST Catalog client configured for a specific analytics bucket\n\t* Use this to perform advanced table and namespace operations within the bucket\n\t* The returned client provides full access to the Apache Iceberg REST Catalog API\n\t* with the Supabase `{ data, error }` pattern for consistent error handling on all operations.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param bucketName - The name of the analytics bucket (warehouse) to connect to\n\t* @returns The wrapped Iceberg catalog client\n\t* @throws {StorageError} If the bucket name is invalid\n\t*\n\t* @example Get catalog and create table\n\t* ```js\n\t* // First, create an analytics bucket\n\t* const { data: bucket, error: bucketError } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .createBucket('analytics-data')\n\t*\n\t* // Get the Iceberg catalog for that bucket\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // Create a namespace\n\t* const { error: nsError } = await catalog.createNamespace({ namespace: ['default'] })\n\t*\n\t* // Create a table with schema\n\t* const { data: tableMetadata, error: tableError } = await catalog.createTable(\n\t*   { namespace: ['default'] },\n\t*   {\n\t*     name: 'events',\n\t*     schema: {\n\t*       type: 'struct',\n\t*       fields: [\n\t*         { id: 1, name: 'id', type: 'long', required: true },\n\t*         { id: 2, name: 'timestamp', type: 'timestamp', required: true },\n\t*         { id: 3, name: 'user_id', type: 'string', required: false }\n\t*       ],\n\t*       'schema-id': 0,\n\t*       'identifier-field-ids': [1]\n\t*     },\n\t*     'partition-spec': {\n\t*       'spec-id': 0,\n\t*       fields: []\n\t*     },\n\t*     'write-order': {\n\t*       'order-id': 0,\n\t*       fields: []\n\t*     },\n\t*     properties: {\n\t*       'write.format.default': 'parquet'\n\t*     }\n\t*   }\n\t* )\n\t* ```\n\t*\n\t* @example List tables in namespace\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // List all tables in the default namespace\n\t* const { data: tables, error: listError } = await catalog.listTables({ namespace: ['default'] })\n\t* if (listError) {\n\t*   if (listError.isNotFound()) {\n\t*     console.log('Namespace not found')\n\t*   }\n\t*   return\n\t* }\n\t* console.log(tables) // [{ namespace: ['default'], name: 'events' }]\n\t* ```\n\t*\n\t* @example Working with namespaces\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // List all namespaces\n\t* const { data: namespaces } = await catalog.listNamespaces()\n\t*\n\t* // Create namespace with properties\n\t* await catalog.createNamespace(\n\t*   { namespace: ['production'] },\n\t*   { properties: { owner: 'data-team', env: 'prod' } }\n\t* )\n\t* ```\n\t*\n\t* @example Cleanup operations\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // Drop table with purge option (removes all data)\n\t* const { error: dropError } = await catalog.dropTable(\n\t*   { namespace: ['default'], name: 'events' },\n\t*   { purge: true }\n\t* )\n\t*\n\t* if (dropError?.isNotFound()) {\n\t*   console.log('Table does not exist')\n\t* }\n\t*\n\t* // Drop namespace (must be empty)\n\t* await catalog.dropNamespace({ namespace: ['default'] })\n\t* ```\n\t*\n\t* @remarks\n\t* This method provides a bridge between Supabase's bucket management and the standard\n\t* Apache Iceberg REST Catalog API. The bucket name maps to the Iceberg warehouse parameter.\n\t* All authentication and configuration is handled automatically using your Supabase credentials.\n\t*\n\t* **Error Handling**: Invalid bucket names throw immediately. All catalog\n\t* operations return `{ data, error }` where errors are `IcebergError` instances from iceberg-js.\n\t* Use helper methods like `error.isNotFound()` or check `error.status` for specific error handling.\n\t* Use `.throwOnError()` on the analytics client if you prefer exceptions for catalog operations.\n\t*\n\t* **Cleanup Operations**: When using `dropTable`, the `purge: true` option permanently\n\t* deletes all table data. Without it, the table is marked as deleted but data remains.\n\t*\n\t* **Library Dependency**: The returned catalog wraps `IcebergRestCatalog` from iceberg-js.\n\t* For complete API documentation and advanced usage, refer to the\n\t* [iceberg-js documentation](https://supabase.github.io/iceberg-js/).\n\t*/ from(bucketName) {\n        var _this4 = this;\n        if (!isValidBucketName(bucketName)) throw new StorageError(\"Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.\");\n        const catalog = new iceberg_js__WEBPACK_IMPORTED_MODULE_0__.IcebergRestCatalog({\n            baseUrl: this.url,\n            catalogName: bucketName,\n            auth: {\n                type: \"custom\",\n                getHeaders: async ()=>_this4.headers\n            },\n            fetch: this.fetch\n        });\n        const shouldThrowOnError = this.shouldThrowOnError;\n        return new Proxy(catalog, {\n            get (target, prop) {\n                const value = target[prop];\n                if (typeof value !== \"function\") return value;\n                return async (...args)=>{\n                    try {\n                        return {\n                            data: await value.apply(target, args),\n                            error: null\n                        };\n                    } catch (error) {\n                        if (shouldThrowOnError) throw error;\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                };\n            }\n        });\n    }\n};\n//#endregion\n//#region src/lib/vectors/constants.ts\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `storage-js/${version}`,\n    \"Content-Type\": \"application/json\"\n};\n//#endregion\n//#region src/lib/vectors/errors.ts\n/**\n* Base error class for all Storage Vectors errors\n*/ var StorageVectorsError = class extends Error {\n    constructor(message){\n        super(message);\n        this.__isStorageVectorsError = true;\n        this.name = \"StorageVectorsError\";\n    }\n};\n/**\n* Type guard to check if an error is a StorageVectorsError\n* @param error - The error to check\n* @returns True if the error is a StorageVectorsError\n*/ function isStorageVectorsError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageVectorsError\" in error;\n}\n/**\n* API error returned from S3 Vectors service\n* Includes HTTP status code and service-specific error code\n*/ var StorageVectorsApiError = class extends StorageVectorsError {\n    constructor(message, status, statusCode){\n        super(message);\n        this.name = \"StorageVectorsApiError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode\n        };\n    }\n};\n/**\n* Unknown error that doesn't match expected error patterns\n* Wraps the original error for debugging\n*/ var StorageVectorsUnknownError = class extends StorageVectorsError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"StorageVectorsUnknownError\";\n        this.originalError = originalError;\n    }\n};\n/**\n* Error codes specific to S3 Vectors API\n* Maps AWS service errors to application-friendly error codes\n*/ let StorageVectorsErrorCode = /* @__PURE__ */ function(StorageVectorsErrorCode$1) {\n    /** Internal server fault (HTTP 500) */ StorageVectorsErrorCode$1[\"InternalError\"] = \"InternalError\";\n    /** Resource already exists / conflict (HTTP 409) */ StorageVectorsErrorCode$1[\"S3VectorConflictException\"] = \"S3VectorConflictException\";\n    /** Resource not found (HTTP 404) */ StorageVectorsErrorCode$1[\"S3VectorNotFoundException\"] = \"S3VectorNotFoundException\";\n    /** Delete bucket while not empty (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorBucketNotEmpty\"] = \"S3VectorBucketNotEmpty\";\n    /** Exceeds bucket quota/limit (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorMaxBucketsExceeded\"] = \"S3VectorMaxBucketsExceeded\";\n    /** Exceeds index quota/limit (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorMaxIndexesExceeded\"] = \"S3VectorMaxIndexesExceeded\";\n    return StorageVectorsErrorCode$1;\n}({});\n//#endregion\n//#region src/lib/vectors/helpers.ts\n/**\n* Resolves the fetch implementation to use\n* Uses custom fetch if provided, otherwise uses native fetch\n*\n* @param customFetch - Optional custom fetch implementation\n* @returns Resolved fetch function\n*/ const resolveFetch = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\n/**\n* Resolves the Response constructor to use\n* Returns native Response constructor\n*\n* @returns Response constructor\n*/ const resolveResponse = ()=>{\n    return Response;\n};\n/**\n* Determine if input is a plain object\n* An object is plain if it's created by either {}, new Object(), or Object.create(null)\n*\n* @param value - Value to check\n* @returns True if value is a plain object\n* @source https://github.com/sindresorhus/is-plain-obj\n*/ const isPlainObject = (value)=>{\n    if (typeof value !== \"object\" || value === null) return false;\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};\n/**\n* Normalizes a number array to float32 format\n* Ensures all vector values are valid 32-bit floats\n*\n* @param values - Array of numbers to normalize\n* @returns Normalized float32 array\n*/ const normalizeToFloat32 = (values)=>{\n    return Array.from(new Float32Array(values));\n};\n/**\n* Validates vector dimensions match expected dimension\n* Throws error if dimensions don't match\n*\n* @param vector - Vector data to validate\n* @param expectedDimension - Expected vector dimension\n* @throws Error if dimensions don't match\n*/ const validateVectorDimension = (vector, expectedDimension)=>{\n    if (expectedDimension !== void 0 && vector.float32.length !== expectedDimension) throw new Error(`Vector dimension mismatch: expected ${expectedDimension}, got ${vector.float32.length}`);\n};\n//#endregion\n//#region src/lib/vectors/fetch.ts\n/**\n* Extracts error message from various error response formats\n* @param err - Error object from API\n* @returns Human-readable error message\n*/ const _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\n/**\n* Handles fetch errors and converts them to StorageVectors error types\n* @param error - The error caught from fetch\n* @param reject - Promise rejection function\n* @param options - Fetch options that may affect error handling\n*/ const handleError = async (error, reject, options)=>{\n    if (error && typeof error === \"object\" && \"status\" in error && \"ok\" in error && typeof error.status === \"number\" && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {\n        const status = error.status || 500;\n        const responseError = error;\n        if (typeof responseError.json === \"function\") responseError.json().then((err)=>{\n            const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + \"\";\n            reject(new StorageVectorsApiError(_getErrorMessage(err), status, statusCode));\n        }).catch(()=>{\n            const statusCode = status + \"\";\n            reject(new StorageVectorsApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode));\n        });\n        else {\n            const statusCode = status + \"\";\n            reject(new StorageVectorsApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode));\n        }\n    } else reject(new StorageVectorsUnknownError(_getErrorMessage(error), error));\n};\n/**\n* Builds request parameters for fetch calls\n* @param method - HTTP method\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters like AbortSignal\n* @param body - Request body (will be JSON stringified if plain object)\n* @returns Complete fetch request parameters\n*/ const _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\" || !body) return params;\n    if (isPlainObject(body)) {\n        params.headers = _objectSpread2({\n            \"Content-Type\": \"application/json\"\n        }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    } else params.body = body;\n    return _objectSpread2(_objectSpread2({}, params), parameters);\n};\n/**\n* Internal request handler that wraps fetch with error handling\n* @param fetcher - Fetch function to use\n* @param method - HTTP method\n* @param url - Request URL\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters\n* @param body - Request body\n* @returns Promise with parsed response or error\n*/ async function _handleRequest(fetcher, method, url, options, parameters, body) {\n    return new Promise((resolve, reject)=>{\n        fetcher(url, _getRequestParams(method, options, parameters, body)).then((result)=>{\n            if (!result.ok) throw result;\n            if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n            const contentType = result.headers.get(\"content-type\");\n            if (!contentType || !contentType.includes(\"application/json\")) return {};\n            return result.json();\n        }).then((data)=>resolve(data)).catch((error)=>handleError(error, reject, options));\n    });\n}\n/**\n* Performs a POST request\n* @param fetcher - Fetch function to use\n* @param url - Request URL\n* @param body - Request body to be JSON stringified\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters\n* @returns Promise with parsed response\n*/ async function post(fetcher, url, body, options, parameters) {\n    return _handleRequest(fetcher, \"POST\", url, options, parameters, body);\n}\n//#endregion\n//#region src/lib/vectors/VectorIndexApi.ts\n/**\n* @hidden\n* Base implementation for vector index operations.\n* Use {@link VectorBucketScope} via `supabase.storage.vectors.from('bucket')` instead.\n*/ var VectorIndexApi = class {\n    /** Creates a new VectorIndexApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Creates a new vector index within a bucket */ async createIndex(options) {\n        var _this = this;\n        try {\n            return {\n                data: await post(_this.fetch, `${_this.url}/CreateIndex`, options, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves metadata for a specific vector index */ async getIndex(vectorBucketName, indexName) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetIndex`, {\n                    vectorBucketName,\n                    indexName\n                }, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vector indexes within a bucket with optional filtering and pagination */ async listIndexes(options) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListIndexes`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes a vector index and all its data */ async deleteIndex(vectorBucketName, indexName) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/DeleteIndex`, {\n                    vectorBucketName,\n                    indexName\n                }, {\n                    headers: _this4.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/VectorDataApi.ts\n/**\n* @hidden\n* Base implementation for vector data operations.\n* Use {@link VectorIndexScope} via `supabase.storage.vectors.from('bucket').index('idx')` instead.\n*/ var VectorDataApi = class {\n    /** Creates a new VectorDataApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Inserts or updates vectors in batch (1-500 per request) */ async putVectors(options) {\n        var _this = this;\n        try {\n            if (options.vectors.length < 1 || options.vectors.length > 500) throw new Error(\"Vector batch size must be between 1 and 500 items\");\n            return {\n                data: await post(_this.fetch, `${_this.url}/PutVectors`, options, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves vectors by their keys in batch */ async getVectors(options) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetVectors`, options, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vectors in an index with pagination */ async listVectors(options) {\n        var _this3 = this;\n        try {\n            if (options.segmentCount !== void 0) {\n                if (options.segmentCount < 1 || options.segmentCount > 16) throw new Error(\"segmentCount must be between 1 and 16\");\n                if (options.segmentIndex !== void 0) {\n                    if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);\n                }\n            }\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListVectors`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Queries for similar vectors using approximate nearest neighbor search */ async queryVectors(options) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/QueryVectors`, options, {\n                    headers: _this4.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes vectors by their keys in batch (1-500 per request) */ async deleteVectors(options) {\n        var _this5 = this;\n        try {\n            if (options.keys.length < 1 || options.keys.length > 500) throw new Error(\"Keys batch size must be between 1 and 500 items\");\n            return {\n                data: await post(_this5.fetch, `${_this5.url}/DeleteVectors`, options, {\n                    headers: _this5.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this5.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/VectorBucketApi.ts\n/**\n* @hidden\n* Base implementation for vector bucket operations.\n* Use {@link StorageVectorsClient} via `supabase.storage.vectors` instead.\n*/ var VectorBucketApi = class {\n    /** Creates a new VectorBucketApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Creates a new vector bucket */ async createBucket(vectorBucketName) {\n        var _this = this;\n        try {\n            return {\n                data: await post(_this.fetch, `${_this.url}/CreateVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves metadata for a specific vector bucket */ async getBucket(vectorBucketName) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vector buckets with optional filtering and pagination */ async listBuckets(options = {}) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListVectorBuckets`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes a vector bucket (must be empty first) */ async deleteBucket(vectorBucketName) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/DeleteVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this4.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/StorageVectorsClient.ts\n/**\n*\n* @alpha\n*\n* Main client for interacting with S3 Vectors API\n* Provides access to bucket, index, and vector data operations\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*\n* **Usage Patterns:**\n*\n* ```typescript\n* const { data, error } = await supabase\n*  .storage\n*  .vectors\n*  .createBucket('embeddings-prod')\n*\n* // Access index operations via buckets\n* const bucket = supabase.storage.vectors.from('embeddings-prod')\n* await bucket.createIndex({\n*   indexName: 'documents',\n*   dataType: 'float32',\n*   dimension: 1536,\n*   distanceMetric: 'cosine'\n* })\n*\n* // Access vector operations via index\n* const index = bucket.index('documents')\n* await index.putVectors({\n*   vectors: [\n*     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n*   ]\n* })\n*\n* // Query similar vectors\n* const { data } = await index.queryVectors({\n*   queryVector: { float32: [...] },\n*   topK: 5,\n*   returnDistance: true\n* })\n* ```\n*/ var StorageVectorsClient = class extends VectorBucketApi {\n    /**\n\t* @alpha\n\t*\n\t* Creates a StorageVectorsClient that can manage buckets, indexes, and vectors.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param url - Base URL of the Storage Vectors REST API.\n\t* @param options.headers - Optional headers (for example `Authorization`) applied to every request.\n\t* @param options.fetch - Optional custom `fetch` implementation for non-browser runtimes.\n\t*\n\t* @example\n\t* ```typescript\n\t* const client = new StorageVectorsClient(url, options)\n\t* ```\n\t*/ constructor(url, options = {}){\n        super(url, options.headers || {}, options.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access operations for a specific vector bucket\n\t* Returns a scoped client for index and vector operations within the bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket\n\t* @returns Bucket-scoped client with index and vector operations\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* ```\n\t*/ from(vectorBucketName) {\n        return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a new vector bucket\n\t* Vector buckets are containers for vector indexes and their data\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Unique name for the vector bucket\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .createBucket('embeddings-prod')\n\t* ```\n\t*/ async createBucket(vectorBucketName) {\n        var _superprop_getCreateBucket = ()=>super.createBucket, _this = this;\n        return _superprop_getCreateBucket().call(_this, vectorBucketName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves metadata for a specific vector bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket\n\t* @returns Promise with bucket metadata or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .getBucket('embeddings-prod')\n\t*\n\t* console.log('Bucket created:', data?.vectorBucket.creationTime)\n\t* ```\n\t*/ async getBucket(vectorBucketName) {\n        var _superprop_getGetBucket = ()=>super.getBucket, _this2 = this;\n        return _superprop_getGetBucket().call(_this2, vectorBucketName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists all vector buckets with optional filtering and pagination\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Optional filters (prefix, maxResults, nextToken)\n\t* @returns Promise with list of buckets or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .listBuckets({ prefix: 'embeddings-' })\n\t*\n\t* data?.vectorBuckets.forEach(bucket => {\n\t*   console.log(bucket.vectorBucketName)\n\t* })\n\t* ```\n\t*/ async listBuckets(options = {}) {\n        var _superprop_getListBuckets = ()=>super.listBuckets, _this3 = this;\n        return _superprop_getListBuckets().call(_this3, options);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes a vector bucket (bucket must be empty)\n\t* All indexes must be deleted before deleting the bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket to delete\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .deleteBucket('embeddings-old')\n\t* ```\n\t*/ async deleteBucket(vectorBucketName) {\n        var _superprop_getDeleteBucket = ()=>super.deleteBucket, _this4 = this;\n        return _superprop_getDeleteBucket().call(_this4, vectorBucketName);\n    }\n};\n/**\n*\n* @alpha\n*\n* Scoped client for operations within a specific vector bucket\n* Provides index management and access to vector operations\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*/ var VectorBucketScope = class extends VectorIndexApi {\n    /**\n\t* @alpha\n\t*\n\t* Creates a helper that automatically scopes all index operations to the provided bucket.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* ```\n\t*/ constructor(url, headers, vectorBucketName, fetch$1){\n        super(url, headers, fetch$1);\n        this.vectorBucketName = vectorBucketName;\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a new vector index in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Index configuration (vectorBucketName is automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* await bucket.createIndex({\n\t*   indexName: 'documents-openai',\n\t*   dataType: 'float32',\n\t*   dimension: 1536,\n\t*   distanceMetric: 'cosine',\n\t*   metadataConfiguration: {\n\t*     nonFilterableMetadataKeys: ['raw_text']\n\t*   }\n\t* })\n\t* ```\n\t*/ async createIndex(options) {\n        var _superprop_getCreateIndex = ()=>super.createIndex, _this5 = this;\n        return _superprop_getCreateIndex().call(_this5, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this5.vectorBucketName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists indexes in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Listing options (vectorBucketName is automatically set)\n\t* @returns Promise with response containing indexes array and pagination token or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* const { data } = await bucket.listIndexes({ prefix: 'documents-' })\n\t* ```\n\t*/ async listIndexes(options = {}) {\n        var _superprop_getListIndexes = ()=>super.listIndexes, _this6 = this;\n        return _superprop_getListIndexes().call(_this6, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this6.vectorBucketName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves metadata for a specific index in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index to retrieve\n\t* @returns Promise with index metadata or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* const { data } = await bucket.getIndex('documents-openai')\n\t* console.log('Dimension:', data?.index.dimension)\n\t* ```\n\t*/ async getIndex(indexName) {\n        var _superprop_getGetIndex = ()=>super.getIndex, _this7 = this;\n        return _superprop_getGetIndex().call(_this7, _this7.vectorBucketName, indexName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes an index from this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index to delete\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* await bucket.deleteIndex('old-index')\n\t* ```\n\t*/ async deleteIndex(indexName) {\n        var _superprop_getDeleteIndex = ()=>super.deleteIndex, _this8 = this;\n        return _superprop_getDeleteIndex().call(_this8, _this8.vectorBucketName, indexName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access operations for a specific index within this bucket\n\t* Returns a scoped client for vector data operations\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index\n\t* @returns Index-scoped client with vector data operations\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t*\n\t* // Insert vectors\n\t* await index.putVectors({\n\t*   vectors: [\n\t*     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n\t*   ]\n\t* })\n\t*\n\t* // Query similar vectors\n\t* const { data } = await index.queryVectors({\n\t*   queryVector: { float32: [...] },\n\t*   topK: 5\n\t* })\n\t* ```\n\t*/ index(indexName) {\n        return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);\n    }\n};\n/**\n*\n* @alpha\n*\n* Scoped client for operations within a specific vector index\n* Provides vector data operations (put, get, list, query, delete)\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*/ var VectorIndexScope = class extends VectorDataApi {\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a helper that automatically scopes all vector operations to the provided bucket/index names.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* ```\n\t*/ constructor(url, headers, vectorBucketName, indexName, fetch$1){\n        super(url, headers, fetch$1);\n        this.vectorBucketName = vectorBucketName;\n        this.indexName = indexName;\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Inserts or updates vectors in this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Vector insertion options (bucket and index names automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* await index.putVectors({\n\t*   vectors: [\n\t*     {\n\t*       key: 'doc-1',\n\t*       data: { float32: [0.1, 0.2, ...] },\n\t*       metadata: { title: 'Introduction', page: 1 }\n\t*     }\n\t*   ]\n\t* })\n\t* ```\n\t*/ async putVectors(options) {\n        var _superprop_getPutVectors = ()=>super.putVectors, _this9 = this;\n        return _superprop_getPutVectors().call(_this9, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this9.vectorBucketName,\n            indexName: _this9.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves vectors by keys from this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Vector retrieval options (bucket and index names automatically set)\n\t* @returns Promise with response containing vectors array or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.getVectors({\n\t*   keys: ['doc-1', 'doc-2'],\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async getVectors(options) {\n        var _superprop_getGetVectors = ()=>super.getVectors, _this10 = this;\n        return _superprop_getGetVectors().call(_this10, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this10.vectorBucketName,\n            indexName: _this10.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists vectors in this index with pagination\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Listing options (bucket and index names automatically set)\n\t* @returns Promise with response containing vectors array and pagination token or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.listVectors({\n\t*   maxResults: 500,\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async listVectors(options = {}) {\n        var _superprop_getListVectors = ()=>super.listVectors, _this11 = this;\n        return _superprop_getListVectors().call(_this11, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this11.vectorBucketName,\n            indexName: _this11.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Queries for similar vectors in this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Query options (bucket and index names automatically set)\n\t* @returns Promise with response containing matches array of similar vectors ordered by distance or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.queryVectors({\n\t*   queryVector: { float32: [0.1, 0.2, ...] },\n\t*   topK: 5,\n\t*   filter: { category: 'technical' },\n\t*   returnDistance: true,\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async queryVectors(options) {\n        var _superprop_getQueryVectors = ()=>super.queryVectors, _this12 = this;\n        return _superprop_getQueryVectors().call(_this12, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this12.vectorBucketName,\n            indexName: _this12.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes vectors by keys from this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Deletion options (bucket and index names automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* await index.deleteVectors({\n\t*   keys: ['doc-1', 'doc-2', 'doc-3']\n\t* })\n\t* ```\n\t*/ async deleteVectors(options) {\n        var _superprop_getDeleteVectors = ()=>super.deleteVectors, _this13 = this;\n        return _superprop_getDeleteVectors().call(_this13, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this13.vectorBucketName,\n            indexName: _this13.indexName\n        }));\n    }\n};\n//#endregion\n//#region src/StorageClient.ts\nvar StorageClient = class extends StorageBucketApi {\n    /**\n\t* Creates a client for Storage buckets, files, analytics, and vectors.\n\t*\n\t* @category File Buckets\n\t* @example\n\t* ```ts\n\t* import { StorageClient } from '@supabase/storage-js'\n\t*\n\t* const storage = new StorageClient('https://xyzcompany.supabase.co/storage/v1', {\n\t*   apikey: 'public-anon-key',\n\t* })\n\t* const avatars = storage.from('avatars')\n\t* ```\n\t*/ constructor(url, headers = {}, fetch$1, opts){\n        super(url, headers, fetch$1, opts);\n    }\n    /**\n\t* Perform file operation in a bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The bucket id to operate on.\n\t*\n\t* @example\n\t* ```typescript\n\t* const avatars = supabase.storage.from('avatars')\n\t* ```\n\t*/ from(id) {\n        return new StorageFileApi(this.url, this.headers, id, this.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access vector storage operations.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @returns A StorageVectorsClient instance configured with the current storage settings.\n\t*/ get vectors() {\n        return new StorageVectorsClient(this.url + \"/vector\", {\n            headers: this.headers,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access analytics storage operations using Iceberg tables.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @returns A StorageAnalyticsClient instance configured with the current storage settings.\n\t*/ get analytics() {\n        return new StorageAnalyticsClient(this.url + \"/iceberg\", this.headers, this.fetch);\n    }\n};\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFFaEQsMkJBQTJCO0FBQzNCLElBQUlDLGVBQWUsY0FBY0M7SUFDaENDLFlBQVlDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNDLElBQUksR0FBRztJQUNiO0FBQ0Q7QUFDQSxTQUFTQyxlQUFlQyxLQUFLO0lBQzVCLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsc0JBQXNCQTtBQUM3RTtBQUNBLElBQUlDLGtCQUFrQixjQUFjUjtJQUNuQ0UsWUFBWUMsT0FBTyxFQUFFTSxNQUFNLEVBQUVDLFVBQVUsQ0FBRTtRQUN4QyxLQUFLLENBQUNQO1FBQ04sSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNJLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFVBQVUsR0FBR0E7SUFDbkI7SUFDQUMsU0FBUztRQUNSLE9BQU87WUFDTk4sTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkYsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJNLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CQyxZQUFZLElBQUksQ0FBQ0EsVUFBVTtRQUM1QjtJQUNEO0FBQ0Q7QUFDQSxJQUFJRSxzQkFBc0IsY0FBY1o7SUFDdkNFLFlBQVlDLE9BQU8sRUFBRVUsYUFBYSxDQUFFO1FBQ25DLEtBQUssQ0FBQ1Y7UUFDTixJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ1EsYUFBYSxHQUFHQTtJQUN0QjtBQUNEO0FBRUEsWUFBWTtBQUNaLDRCQUE0QjtBQUM1QixNQUFNQyxpQkFBaUIsQ0FBQ0M7SUFDdkIsSUFBSUEsYUFBYSxPQUFPLENBQUMsR0FBR0MsT0FBU0QsZUFBZUM7SUFDcEQsT0FBTyxD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O1FBQzNFLE9BQU8yRyw4QkFBOEJwUSxJQUFJLENBQUN5SixTQUFTdkksZUFBZUEsZUFBZSxDQUFDLEdBQUdhLFVBQVUsQ0FBQyxHQUFHO1lBQ2xHdU0sa0JBQWtCN0UsUUFBUTZFLGdCQUFnQjtZQUMxQ0MsV0FBVzlFLFFBQVE4RSxTQUFTO1FBQzdCO0lBQ0Q7QUFDRDtBQUVBLFlBQVk7QUFDWiw4QkFBOEI7QUFDOUIsSUFBSThCLGdCQUFnQixjQUFjOUY7SUFDakM7Ozs7Ozs7Ozs7Ozs7Q0FhQSxHQUNBN04sWUFBWW1HLEdBQUcsRUFBRUosVUFBVSxDQUFDLENBQUMsRUFBRXlDLE9BQU8sRUFBRXNGLElBQUksQ0FBRTtRQUM3QyxLQUFLLENBQUMzSCxLQUFLSixTQUFTeUMsU0FBU3NGO0lBQzlCO0lBQ0E7Ozs7Ozs7Ozs7Q0FVQSxHQUNBVixLQUFLekQsRUFBRSxFQUFFO1FBQ1IsT0FBTyxJQUFJckIsZUFBZSxJQUFJLENBQUNuQyxHQUFHLEVBQUUsSUFBSSxDQUFDSixPQUFPLEVBQUU0RCxJQUFJLElBQUksQ0FBQzVJLEtBQUs7SUFDakU7SUFDQTs7Ozs7Ozs7OztDQVVBLEdBQ0EsSUFBSW1SLFVBQVU7UUFDYixPQUFPLElBQUlRLHFCQUFxQixJQUFJLENBQUN2TSxHQUFHLEdBQUcsV0FBVztZQUNyREosU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJoRixPQUFPLElBQUksQ0FBQ0EsS0FBSztRQUNsQjtJQUNEO0lBQ0E7Ozs7Ozs7Ozs7Q0FVQSxHQUNBLElBQUk2UyxZQUFZO1FBQ2YsT0FBTyxJQUFJdEUsdUJBQXVCLElBQUksQ0FBQ25KLEdBQUcsR0FBRyxZQUFZLElBQUksQ0FBQ0osT0FBTyxFQUFFLElBQUksQ0FBQ2hGLEtBQUs7SUFDbEY7QUFDRDtBQUVBLFlBQVk7QUFDd2EsQ0FDcGIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvaW5kZXgubWpzP2ViMzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSWNlYmVyZ1Jlc3RDYXRhbG9nIH0gZnJvbSBcImljZWJlcmctanNcIjtcblxuLy8jcmVnaW9uIHNyYy9saWIvZXJyb3JzLnRzXG52YXIgU3RvcmFnZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLl9faXNTdG9yYWdlRXJyb3IgPSB0cnVlO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZUVycm9yXCI7XG5cdH1cbn07XG5mdW5jdGlvbiBpc1N0b3JhZ2VFcnJvcihlcnJvcikge1xuXHRyZXR1cm4gdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIGVycm9yICE9PSBudWxsICYmIFwiX19pc1N0b3JhZ2VFcnJvclwiIGluIGVycm9yO1xufVxudmFyIFN0b3JhZ2VBcGlFcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBzdGF0dXNDb2RlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gXCJTdG9yYWdlQXBpRXJyb3JcIjtcblx0XHR0aGlzLnN0YXR1cyA9IHN0YXR1cztcblx0XHR0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuXHR9XG5cdHRvSlNPTigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXHRcdFx0bWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuXHRcdFx0c3RhdHVzOiB0aGlzLnN0YXR1cyxcblx0XHRcdHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZVxuXHRcdH07XG5cdH1cbn07XG52YXIgU3RvcmFnZVVua25vd25FcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZVVua25vd25FcnJvclwiO1xuXHRcdHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvaGVscGVycy50c1xuY29uc3QgcmVzb2x2ZUZldGNoJDEgPSAoY3VzdG9tRmV0Y2gpID0+IHtcblx0aWYgKGN1c3RvbUZldGNoKSByZXR1cm4gKC4uLmFyZ3MpID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpO1xuXHRyZXR1cm4gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xufTtcbmNvbnN0IHJlc29sdmVSZXNwb25zZSQxID0gKCkgPT4ge1xuXHRyZXR1cm4gUmVzcG9uc2U7XG59O1xuY29uc3QgcmVjdXJzaXZlVG9DYW1lbCA9IChpdGVtKSA9PiB7XG5cdGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSByZXR1cm4gaXRlbS5tYXAoKGVsKSA9PiByZWN1cnNpdmVUb0NhbWVsKGVsKSk7XG5cdGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIgfHwgaXRlbSAhPT0gT2JqZWN0KGl0ZW0pKSByZXR1cm4gaXRlbTtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuXHRcdGNvbnN0IG5ld0tleSA9IGtleS5yZXBsYWNlKC8oWy1fXVthLXpdKS9naSwgKGMpID0+IGMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9bLV9dL2csIFwiXCIpKTtcblx0XHRyZXN1bHRbbmV3S2V5XSA9IHJlY3Vyc2l2ZVRvQ2FtZWwodmFsdWUpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiogRGV0ZXJtaW5lIGlmIGlucHV0IGlzIGEgcGxhaW4gb2JqZWN0XG4qIEFuIG9iamVjdCBpcyBwbGFpbiBpZiBpdCdzIGNyZWF0ZWQgYnkgZWl0aGVyIHt9LCBuZXcgT2JqZWN0KCksIG9yIE9iamVjdC5jcmVhdGUobnVsbClcbiogc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2lzLXBsYWluLW9ialxuKi9cbmNvbnN0IGlzUGxhaW5PYmplY3QkMSA9ICh2YWx1ZSkgPT4ge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG5cdHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKTtcbn07XG4vKipcbiogVmFsaWRhdGVzIGlmIGEgZ2l2ZW4gYnVja2V0IG5hbWUgaXMgdmFsaWQgYWNjb3JkaW5nIHRvIFN1cGFiYXNlIFN0b3JhZ2UgQVBJIHJ1bGVzXG4qIE1pcnJvcnMgYmFja2VuZCB2YWxpZGF0aW9uIGZyb206IHN0b3JhZ2Uvc3JjL3N0b3JhZ2UvbGltaXRzLnRzOmlzVmFsaWRCdWNrZXROYW1lKClcbipcbiogUnVsZXM6XG4qIC0gTGVuZ3RoOiAxLTEwMCBjaGFyYWN0ZXJzXG4qIC0gQWxsb3dlZCBjaGFyYWN0ZXJzOiBhbHBoYW51bWVyaWMgKGEteiwgQS1aLCAwLTkpLCB1bmRlcnNjb3JlIChfKSwgYW5kIHNhZmUgc3BlY2lhbCBjaGFyYWN0ZXJzXG4qIC0gU2FmZSBzcGVjaWFsIGNoYXJhY3RlcnM6ICEgLSAuICogJyAoICkgc3BhY2UgJiAkIEAgPSA7IDogKyAsID9cbiogLSBGb3JiaWRkZW46IHBhdGggc2VwYXJhdG9ycyAoLywgXFwpLCBwYXRoIHRyYXZlcnNhbCAoLi4pLCBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2VcbipcbiogQVdTIFMzIFJlZmVyZW5jZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblMzL2xhdGVzdC91c2VyZ3VpZGUvb2JqZWN0LWtleXMuaHRtbFxuKlxuKiBAcGFyYW0gYnVja2V0TmFtZSAtIFRoZSBidWNrZXQgbmFtZSB0byB2YWxpZGF0ZVxuKiBAcmV0dXJucyB0cnVlIGlmIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiovXG5jb25zdCBpc1ZhbGlkQnVja2V0TmFtZSA9IChidWNrZXROYW1lKSA9PiB7XG5cdGlmICghYnVja2V0TmFtZSB8fCB0eXBlb2YgYnVja2V0TmFtZSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuXHRpZiAoYnVja2V0TmFtZS5sZW5ndGggPT09IDAgfHwgYnVja2V0TmFtZS5sZW5ndGggPiAxMDApIHJldHVybiBmYWxzZTtcblx0aWYgKGJ1Y2tldE5hbWUudHJpbSgpICE9PSBidWNrZXROYW1lKSByZXR1cm4gZmFsc2U7XG5cdGlmIChidWNrZXROYW1lLmluY2x1ZGVzKFwiL1wiKSB8fCBidWNrZXROYW1lLmluY2x1ZGVzKFwiXFxcXFwiKSkgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gL15bXFx3IS5cXConKCkgJiRAPTs6Kyw/LV0rJC8udGVzdChidWNrZXROYW1lKTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90eXBlb2YuanNcbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuXHRcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cdHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24obyQxKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBvJDE7XG5cdH0gOiBmdW5jdGlvbihvJDEpIHtcblx0XHRyZXR1cm4gbyQxICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8kMS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8kMSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbyQxO1xuXHR9LCBfdHlwZW9mKG8pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdG9QcmltaXRpdmUuanNcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcblx0aWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7XG5cdHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXHRpZiAodm9pZCAwICE9PSBlKSB7XG5cdFx0dmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG5cdFx0aWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuXHR9XG5cdHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzXG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcblx0dmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcblx0cmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuXHRyZXR1cm4gKHIgPSB0b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcblx0XHR2YWx1ZTogdCxcblx0XHRlbnVtZXJhYmxlOiAhMCxcblx0XHRjb25maWd1cmFibGU6ICEwLFxuXHRcdHdyaXRhYmxlOiAhMFxuXHR9KSA6IGVbcl0gPSB0LCBlO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvb2JqZWN0U3ByZWFkMi5qc1xuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG5cdHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG5cdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0dmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuXHRcdHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbihyJDEpIHtcblx0XHRcdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIkMSkuZW51bWVyYWJsZTtcblx0XHR9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcblx0fVxuXHRyZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcblx0Zm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcblx0XHR2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG5cdFx0ciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRfZGVmaW5lUHJvcGVydHkoZSwgciQxLCB0W3IkMV0pO1xuXHRcdH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbihyJDEpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByJDEsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgciQxKSk7XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIGU7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvZmV0Y2gudHNcbmNvbnN0IF9nZXRFcnJvck1lc3NhZ2UkMSA9IChlcnIpID0+IHtcblx0dmFyIF9lcnIkZXJyb3I7XG5cdHJldHVybiBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCAodHlwZW9mIGVyci5lcnJvciA9PT0gXCJzdHJpbmdcIiA/IGVyci5lcnJvciA6IChfZXJyJGVycm9yID0gZXJyLmVycm9yKSA9PT0gbnVsbCB8fCBfZXJyJGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyJGVycm9yLm1lc3NhZ2UpIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG59O1xuY29uc3QgaGFuZGxlRXJyb3IkMSA9IGFzeW5jIChlcnJvciwgcmVqZWN0LCBvcHRpb25zKSA9PiB7XG5cdGlmIChlcnJvciBpbnN0YW5jZW9mIGF3YWl0IHJlc29sdmVSZXNwb25zZSQxKCkgJiYgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikpIGVycm9yLmpzb24oKS50aGVuKChlcnIpID0+IHtcblx0XHRjb25zdCBzdGF0dXMgPSBlcnJvci5zdGF0dXMgfHwgNTAwO1xuXHRcdGNvbnN0IHN0YXR1c0NvZGUgPSAoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLnN0YXR1c0NvZGUpIHx8IHN0YXR1cyArIFwiXCI7XG5cdFx0cmVqZWN0KG5ldyBTdG9yYWdlQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZSQxKGVyciksIHN0YXR1cywgc3RhdHVzQ29kZSkpO1xuXHR9KS5jYXRjaCgoZXJyKSA9PiB7XG5cdFx0cmVqZWN0KG5ldyBTdG9yYWdlVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UkMShlcnIpLCBlcnIpKTtcblx0fSk7XG5cdGVsc2UgcmVqZWN0KG5ldyBTdG9yYWdlVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UkMShlcnJvciksIGVycm9yKSk7XG59O1xuY29uc3QgX2dldFJlcXVlc3RQYXJhbXMkMSA9IChtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpID0+IHtcblx0Y29uc3QgcGFyYW1zID0ge1xuXHRcdG1ldGhvZCxcblx0XHRoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9XG5cdH07XG5cdGlmIChtZXRob2QgPT09IFwiR0VUXCIgfHwgIWJvZHkpIHJldHVybiBwYXJhbXM7XG5cdGlmIChpc1BsYWluT2JqZWN0JDEoYm9keSkpIHtcblx0XHRwYXJhbXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuXHRcdHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG5cdH0gZWxzZSBwYXJhbXMuYm9keSA9IGJvZHk7XG5cdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZHVwbGV4KSBwYXJhbXMuZHVwbGV4ID0gb3B0aW9ucy5kdXBsZXg7XG5cdHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcGFyYW1zKSwgcGFyYW1ldGVycyk7XG59O1xuYXN5bmMgZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QkMShmZXRjaGVyLCBtZXRob2QsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGZldGNoZXIodXJsLCBfZ2V0UmVxdWVzdFBhcmFtcyQxKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuXHRcdFx0aWYgKCFyZXN1bHQub2spIHRocm93IHJlc3VsdDtcblx0XHRcdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikgcmV0dXJuIHJlc3VsdDtcblx0XHRcdHJldHVybiByZXN1bHQuanNvbigpO1xuXHRcdH0pLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlRXJyb3IkMShlcnJvciwgcmVqZWN0LCBvcHRpb25zKSk7XG5cdH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0KGZldGNoZXIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QkMShmZXRjaGVyLCBcIkdFVFwiLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9zdCQxKGZldGNoZXIsIHVybCwgYm9keSwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QkMShmZXRjaGVyLCBcIlBPU1RcIiwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHB1dChmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcblx0cmV0dXJuIF9oYW5kbGVSZXF1ZXN0JDEoZmV0Y2hlciwgXCJQVVRcIiwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhlYWQoZmV0Y2hlciwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBfaGFuZGxlUmVxdWVzdCQxKGZldGNoZXIsIFwiSEVBRFwiLCB1cmwsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHsgbm9SZXNvbHZlSnNvbjogdHJ1ZSB9KSwgcGFyYW1ldGVycyk7XG59XG5hc3luYyBmdW5jdGlvbiByZW1vdmUoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBfaGFuZGxlUmVxdWVzdCQxKGZldGNoZXIsIFwiREVMRVRFXCIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9wYWNrYWdlcy9TdHJlYW1Eb3dubG9hZEJ1aWxkZXIudHNcbnZhciBTdHJlYW1Eb3dubG9hZEJ1aWxkZXIgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKGRvd25sb2FkRm4sIHNob3VsZFRocm93T25FcnJvcikge1xuXHRcdHRoaXMuZG93bmxvYWRGbiA9IGRvd25sb2FkRm47XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBzaG91bGRUaHJvd09uRXJyb3I7XG5cdH1cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdHJldHVybiB0aGlzLmV4ZWN1dGUoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcblx0fVxuXHRhc3luYyBleGVjdXRlKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IChhd2FpdCBfdGhpcy5kb3dubG9hZEZuKCkpLmJvZHksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvQmxvYkRvd25sb2FkQnVpbGRlci50c1xubGV0IF9TeW1ib2wkdG9TdHJpbmdUYWc7XG5fU3ltYm9sJHRvU3RyaW5nVGFnID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xudmFyIEJsb2JEb3dubG9hZEJ1aWxkZXIgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKGRvd25sb2FkRm4sIHNob3VsZFRocm93T25FcnJvcikge1xuXHRcdHRoaXMuZG93bmxvYWRGbiA9IGRvd25sb2FkRm47XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBzaG91bGRUaHJvd09uRXJyb3I7XG5cdFx0dGhpc1tfU3ltYm9sJHRvU3RyaW5nVGFnXSA9IFwiQmxvYkRvd25sb2FkQnVpbGRlclwiO1xuXHRcdHRoaXMucHJvbWlzZSA9IG51bGw7XG5cdH1cblx0YXNTdHJlYW0oKSB7XG5cdFx0cmV0dXJuIG5ldyBTdHJlYW1Eb3dubG9hZEJ1aWxkZXIodGhpcy5kb3dubG9hZEZuLCB0aGlzLnNob3VsZFRocm93T25FcnJvcik7XG5cdH1cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdHJldHVybiB0aGlzLmdldFByb21pc2UoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcblx0fVxuXHRjYXRjaChvbnJlamVjdGVkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UHJvbWlzZSgpLmNhdGNoKG9ucmVqZWN0ZWQpO1xuXHR9XG5cdGZpbmFsbHkob25maW5hbGx5KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UHJvbWlzZSgpLmZpbmFsbHkob25maW5hbGx5KTtcblx0fVxuXHRnZXRQcm9taXNlKCkge1xuXHRcdGlmICghdGhpcy5wcm9taXNlKSB0aGlzLnByb21pc2UgPSB0aGlzLmV4ZWN1dGUoKTtcblx0XHRyZXR1cm4gdGhpcy5wcm9taXNlO1xuXHR9XG5cdGFzeW5jIGV4ZWN1dGUoKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgKGF3YWl0IF90aGlzLmRvd25sb2FkRm4oKSkuYmxvYigpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpLnRzXG5jb25zdCBERUZBVUxUX1NFQVJDSF9PUFRJT05TID0ge1xuXHRsaW1pdDogMTAwLFxuXHRvZmZzZXQ6IDAsXG5cdHNvcnRCeToge1xuXHRcdGNvbHVtbjogXCJuYW1lXCIsXG5cdFx0b3JkZXI6IFwiYXNjXCJcblx0fVxufTtcbmNvbnN0IERFRkFVTFRfRklMRV9PUFRJT05TID0ge1xuXHRjYWNoZUNvbnRyb2w6IFwiMzYwMFwiLFxuXHRjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIixcblx0dXBzZXJ0OiBmYWxzZVxufTtcbnZhciBTdG9yYWdlRmlsZUFwaSA9IGNsYXNzIHtcblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGJ1Y2tldElkLCBmZXRjaCQxKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHR0aGlzLnVybCA9IHVybDtcblx0XHR0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHRcdHRoaXMuYnVja2V0SWQgPSBidWNrZXRJZDtcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoJDEoZmV0Y2gkMSk7XG5cdH1cblx0LyoqXG5cdCogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqL1xuXHR0aHJvd09uRXJyb3IoKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFVwbG9hZHMgYSBmaWxlIHRvIGFuIGV4aXN0aW5nIGJ1Y2tldCBvciByZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cblx0KlxuXHQqIEBwYXJhbSBtZXRob2QgSFRUUCBtZXRob2QuXG5cdCogQHBhcmFtIHBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aC4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuXHQqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cblx0Ki9cblx0YXN5bmMgdXBsb2FkT3JVcGRhdGUobWV0aG9kLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRsZXQgYm9keTtcblx0XHRcdGNvbnN0IG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9GSUxFX09QVElPTlMpLCBmaWxlT3B0aW9ucyk7XG5cdFx0XHRsZXQgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpcy5oZWFkZXJzKSwgbWV0aG9kID09PSBcIlBPU1RcIiAmJiB7IFwieC11cHNlcnRcIjogU3RyaW5nKG9wdGlvbnMudXBzZXJ0KSB9KTtcblx0XHRcdGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YTtcblx0XHRcdGlmICh0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0Ym9keSA9IG5ldyBGb3JtRGF0YSgpO1xuXHRcdFx0XHRib2R5LmFwcGVuZChcImNhY2hlQ29udHJvbFwiLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG5cdFx0XHRcdGlmIChtZXRhZGF0YSkgYm9keS5hcHBlbmQoXCJtZXRhZGF0YVwiLCBfdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpO1xuXHRcdFx0XHRib2R5LmFwcGVuZChcIlwiLCBmaWxlQm9keSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0aWYgKCFib2R5LmhhcyhcImNhY2hlQ29udHJvbFwiKSkgYm9keS5hcHBlbmQoXCJjYWNoZUNvbnRyb2xcIiwgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuXHRcdFx0XHRpZiAobWV0YWRhdGEgJiYgIWJvZHkuaGFzKFwibWV0YWRhdGFcIikpIGJvZHkuYXBwZW5kKFwibWV0YWRhdGFcIiwgX3RoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0aGVhZGVyc1tcImNhY2hlLWNvbnRyb2xcIl0gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWA7XG5cdFx0XHRcdGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuXHRcdFx0XHRpZiAobWV0YWRhdGEpIGhlYWRlcnNbXCJ4LW1ldGFkYXRhXCJdID0gX3RoaXMudG9CYXNlNjQoX3RoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKTtcblx0XHRcdFx0aWYgKCh0eXBlb2YgUmVhZGFibGVTdHJlYW0gIT09IFwidW5kZWZpbmVkXCIgJiYgYm9keSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtIHx8IGJvZHkgJiYgdHlwZW9mIGJvZHkgPT09IFwib2JqZWN0XCIgJiYgXCJwaXBlXCIgaW4gYm9keSAmJiB0eXBlb2YgYm9keS5waXBlID09PSBcImZ1bmN0aW9uXCIpICYmICFvcHRpb25zLmR1cGxleCkgb3B0aW9ucy5kdXBsZXggPSBcImhhbGZcIjtcblx0XHRcdH1cblx0XHRcdGlmIChmaWxlT3B0aW9ucyA9PT0gbnVsbCB8fCBmaWxlT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsZU9wdGlvbnMuaGVhZGVycykgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBoZWFkZXJzKSwgZmlsZU9wdGlvbnMuaGVhZGVycyk7XG5cdFx0XHRjb25zdCBjbGVhblBhdGggPSBfdGhpcy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpO1xuXHRcdFx0Y29uc3QgX3BhdGggPSBfdGhpcy5fZ2V0RmluYWxQYXRoKGNsZWFuUGF0aCk7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgKG1ldGhvZCA9PSBcIlBVVFwiID8gcHV0IDogcG9zdCQxKShfdGhpcy5mZXRjaCwgYCR7X3RoaXMudXJsfS9vYmplY3QvJHtfcGF0aH1gLCBib2R5LCBfb2JqZWN0U3ByZWFkMih7IGhlYWRlcnMgfSwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kdXBsZXgpID8geyBkdXBsZXg6IG9wdGlvbnMuZHVwbGV4IH0gOiB7fSkpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YToge1xuXHRcdFx0XHRcdHBhdGg6IGNsZWFuUGF0aCxcblx0XHRcdFx0XHRpZDogZGF0YS5JZCxcblx0XHRcdFx0XHRmdWxsUGF0aDogZGF0YS5LZXlcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogVXBsb2FkcyBhIGZpbGUgdG8gYW4gZXhpc3RpbmcgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG5cdCogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuXHQqIEBwYXJhbSBmaWxlT3B0aW9ucyBPcHRpb25hbCBmaWxlIHVwbG9hZCBvcHRpb25zIGluY2x1ZGluZyBjYWNoZUNvbnRyb2wsIGNvbnRlbnRUeXBlLCB1cHNlcnQsIGFuZCBtZXRhZGF0YS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBmaWxlIHBhdGgsIGlkLCBhbmQgZnVsbFBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIFVwbG9hZCBmaWxlXG5cdCogYGBganNcblx0KiBjb25zdCBhdmF0YXJGaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzWzBdXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBsb2FkKCdwdWJsaWMvYXZhdGFyMS5wbmcnLCBhdmF0YXJGaWxlLCB7XG5cdCogICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuXHQqICAgICB1cHNlcnQ6IGZhbHNlXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwicGF0aFwiOiBcInB1YmxpYy9hdmF0YXIxLnBuZ1wiLFxuXHQqICAgICBcImZ1bGxQYXRoXCI6IFwiYXZhdGFycy9wdWJsaWMvYXZhdGFyMS5wbmdcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFVwbG9hZCBmaWxlIHVzaW5nIGBBcnJheUJ1ZmZlcmAgZnJvbSBiYXNlNjQgZmlsZSBkYXRhXG5cdCogYGBganNcblx0KiBpbXBvcnQgeyBkZWNvZGUgfSBmcm9tICdiYXNlNjQtYXJyYXlidWZmZXInXG5cdCpcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC51cGxvYWQoJ3B1YmxpYy9hdmF0YXIxLnBuZycsIGRlY29kZSgnYmFzZTY0RmlsZURhdGEnKSwge1xuXHQqICAgICBjb250ZW50VHlwZTogJ2ltYWdlL3BuZydcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHVwbG9hZChwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZShcIlBPU1RcIiwgcGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKTtcblx0fVxuXHQvKipcblx0KiBVcGxvYWQgYSBmaWxlIHdpdGggYSB0b2tlbiBnZW5lcmF0ZWQgZnJvbSBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsYC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuXHQqIEBwYXJhbSB0b2tlbiBUaGUgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGBcblx0KiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG5cdCogQHBhcmFtIGZpbGVPcHRpb25zIEhUVFAgaGVhZGVycyAoY2FjaGVDb250cm9sLCBjb250ZW50VHlwZSwgZXRjLikuXG5cdCogKipOb3RlOioqIFRoZSBgdXBzZXJ0YCBvcHRpb24gaGFzIG5vIGVmZmVjdCBoZXJlLiBUbyBlbmFibGUgdXBzZXJ0IGJlaGF2aW9yLFxuXHQqIHBhc3MgYHsgdXBzZXJ0OiB0cnVlIH1gIHdoZW4gY2FsbGluZyBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsKClgIGluc3RlYWQuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgZmlsZSBwYXRoIGFuZCBmdWxsUGF0aCBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgVXBsb2FkIHRvIGEgc2lnbmVkIFVSTFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBsb2FkVG9TaWduZWRVcmwoJ2ZvbGRlci9jYXQuanBnJywgJ3Rva2VuLWZyb20tY3JlYXRlU2lnbmVkVXBsb2FkVXJsJywgZmlsZSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInBhdGhcIjogXCJmb2xkZXIvY2F0LmpwZ1wiLFxuXHQqICAgICBcImZ1bGxQYXRoXCI6IFwiYXZhdGFycy9mb2xkZXIvY2F0LmpwZ1wiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyB1cGxvYWRUb1NpZ25lZFVybChwYXRoLCB0b2tlbiwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0Y29uc3QgY2xlYW5QYXRoID0gX3RoaXMzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCk7XG5cdFx0Y29uc3QgX3BhdGggPSBfdGhpczMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpO1xuXHRcdGNvbnN0IHVybCA9IG5ldyBVUkwoX3RoaXMzLnVybCArIGAvb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YCk7XG5cdFx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tlblwiLCB0b2tlbik7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBib2R5O1xuXHRcdFx0Y29uc3Qgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKHsgdXBzZXJ0OiBERUZBVUxUX0ZJTEVfT1BUSU9OUy51cHNlcnQgfSwgZmlsZU9wdGlvbnMpO1xuXHRcdFx0Y29uc3QgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpczMuaGVhZGVycyksIHsgXCJ4LXVwc2VydFwiOiBTdHJpbmcob3B0aW9ucy51cHNlcnQpIH0pO1xuXHRcdFx0aWYgKHR5cGVvZiBCbG9iICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRib2R5ID0gbmV3IEZvcm1EYXRhKCk7XG5cdFx0XHRcdGJvZHkuYXBwZW5kKFwiY2FjaGVDb250cm9sXCIsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcblx0XHRcdFx0Ym9keS5hcHBlbmQoXCJcIiwgZmlsZUJvZHkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0XHRib2R5ID0gZmlsZUJvZHk7XG5cdFx0XHRcdGJvZHkuYXBwZW5kKFwiY2FjaGVDb250cm9sXCIsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0aGVhZGVyc1tcImNhY2hlLWNvbnRyb2xcIl0gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWA7XG5cdFx0XHRcdGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YToge1xuXHRcdFx0XHRcdHBhdGg6IGNsZWFuUGF0aCxcblx0XHRcdFx0XHRmdWxsUGF0aDogKGF3YWl0IHB1dChfdGhpczMuZmV0Y2gsIHVybC50b1N0cmluZygpLCBib2R5LCB7IGhlYWRlcnMgfSkpLktleVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBhIHNpZ25lZCB1cGxvYWQgVVJMLlxuXHQqIFNpZ25lZCB1cGxvYWQgVVJMcyBjYW4gYmUgdXNlZCB0byB1cGxvYWQgZmlsZXMgdG8gdGhlIGJ1Y2tldCB3aXRob3V0IGZ1cnRoZXIgYXV0aGVudGljYXRpb24uXG5cdCogVGhleSBhcmUgdmFsaWQgZm9yIDIgaG91cnMuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBvcHRpb25zLnVwc2VydCBJZiBzZXQgdG8gdHJ1ZSwgYWxsb3dzIHRoZSBmaWxlIHRvIGJlIG92ZXJ3cml0dGVuIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHNpZ25lZCB1cGxvYWQgVVJMLCB0b2tlbiwgYW5kIHBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBTaWduZWQgVXBsb2FkIFVSTFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuY3JlYXRlU2lnbmVkVXBsb2FkVXJsKCdmb2xkZXIvY2F0LmpwZycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJzaWduZWRVcmxcIjogXCJodHRwczovL2V4YW1wbGUuc3VwYWJhc2UuY28vc3RvcmFnZS92MS9vYmplY3QvdXBsb2FkL3NpZ24vYXZhdGFycy9mb2xkZXIvY2F0LmpwZz90b2tlbj08VE9LRU4+XCIsXG5cdCogICAgIFwicGF0aFwiOiBcImZvbGRlci9jYXQuanBnXCIsXG5cdCogICAgIFwidG9rZW5cIjogXCI8VE9LRU4+XCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZVNpZ25lZFVwbG9hZFVybChwYXRoLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNCA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBfcGF0aCA9IF90aGlzNC5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdFx0Y29uc3QgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpczQuaGVhZGVycyk7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVwc2VydCkgaGVhZGVyc1tcIngtdXBzZXJ0XCJdID0gXCJ0cnVlXCI7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcG9zdCQxKF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YCwge30sIHsgaGVhZGVycyB9KTtcblx0XHRcdGNvbnN0IHVybCA9IG5ldyBVUkwoX3RoaXM0LnVybCArIGRhdGEudXJsKTtcblx0XHRcdGNvbnN0IHRva2VuID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ0b2tlblwiKTtcblx0XHRcdGlmICghdG9rZW4pIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXCJObyB0b2tlbiByZXR1cm5lZCBieSBBUElcIik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiB7XG5cdFx0XHRcdFx0c2lnbmVkVXJsOiB1cmwudG9TdHJpbmcoKSxcblx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdHRva2VuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM0LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBSZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgcmVsYXRpdmUgZmlsZSBwYXRoLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGRhdGUuXG5cdCogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuXHQqIEBwYXJhbSBmaWxlT3B0aW9ucyBPcHRpb25hbCBmaWxlIHVwbG9hZCBvcHRpb25zIGluY2x1ZGluZyBjYWNoZUNvbnRyb2wsIGNvbnRlbnRUeXBlLCB1cHNlcnQsIGFuZCBtZXRhZGF0YS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBmaWxlIHBhdGgsIGlkLCBhbmQgZnVsbFBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIFVwZGF0ZSBmaWxlXG5cdCogYGBganNcblx0KiBjb25zdCBhdmF0YXJGaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzWzBdXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBkYXRlKCdwdWJsaWMvYXZhdGFyMS5wbmcnLCBhdmF0YXJGaWxlLCB7XG5cdCogICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuXHQqICAgICB1cHNlcnQ6IHRydWVcblx0KiAgIH0pXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJwYXRoXCI6IFwicHVibGljL2F2YXRhcjEucG5nXCIsXG5cdCogICAgIFwiZnVsbFBhdGhcIjogXCJhdmF0YXJzL3B1YmxpYy9hdmF0YXIxLnBuZ1wiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgVXBkYXRlIGZpbGUgdXNpbmcgYEFycmF5QnVmZmVyYCBmcm9tIGJhc2U2NCBmaWxlIGRhdGFcblx0KiBgYGBqc1xuXHQqIGltcG9ydCB7ZGVjb2RlfSBmcm9tICdiYXNlNjQtYXJyYXlidWZmZXInXG5cdCpcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC51cGRhdGUoJ3B1YmxpYy9hdmF0YXIxLnBuZycsIGRlY29kZSgnYmFzZTY0RmlsZURhdGEnKSwge1xuXHQqICAgICBjb250ZW50VHlwZTogJ2ltYWdlL3BuZydcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHVwZGF0ZShwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZShcIlBVVFwiLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpO1xuXHR9XG5cdC8qKlxuXHQqIE1vdmVzIGFuIGV4aXN0aW5nIGZpbGUgdG8gYSBuZXcgcGF0aCBpbiB0aGUgc2FtZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cblx0KiBAcGFyYW0gdG9QYXRoIFRoZSBuZXcgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIG5ldyBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UtbmV3LnBuZ2AuXG5cdCogQHBhcmFtIG9wdGlvbnMgVGhlIGRlc3RpbmF0aW9uIG9wdGlvbnMuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBNb3ZlIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLm1vdmUoJ3B1YmxpYy9hdmF0YXIxLnBuZycsICdwcml2YXRlL2F2YXRhcjIucG5nJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgbW92ZWRcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbW92ZShmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNiA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczYuZmV0Y2gsIGAke190aGlzNi51cmx9L29iamVjdC9tb3ZlYCwge1xuXHRcdFx0XHRcdGJ1Y2tldElkOiBfdGhpczYuYnVja2V0SWQsXG5cdFx0XHRcdFx0c291cmNlS2V5OiBmcm9tUGF0aCxcblx0XHRcdFx0XHRkZXN0aW5hdGlvbktleTogdG9QYXRoLFxuXHRcdFx0XHRcdGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25CdWNrZXRcblx0XHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczYuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczYuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIENvcGllcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBmcm9tUGF0aCBUaGUgb3JpZ2luYWwgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLWNvcHkucG5nYC5cblx0KiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBjb3BpZWQgZmlsZSBwYXRoIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDb3B5IGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNvcHkoJ3B1YmxpYy9hdmF0YXIxLnBuZycsICdwcml2YXRlL2F2YXRhcjIucG5nJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInBhdGhcIjogXCJhdmF0YXJzL3ByaXZhdGUvYXZhdGFyMi5wbmdcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY29weShmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IHsgcGF0aDogKGF3YWl0IHBvc3QkMShfdGhpczcuZmV0Y2gsIGAke190aGlzNy51cmx9L29iamVjdC9jb3B5YCwge1xuXHRcdFx0XHRcdGJ1Y2tldElkOiBfdGhpczcuYnVja2V0SWQsXG5cdFx0XHRcdFx0c291cmNlS2V5OiBmcm9tUGF0aCxcblx0XHRcdFx0XHRkZXN0aW5hdGlvbktleTogdG9QYXRoLFxuXHRcdFx0XHRcdGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25CdWNrZXRcblx0XHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczcuaGVhZGVycyB9KSkuS2V5IH0sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM3LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBDcmVhdGVzIGEgc2lnbmVkIFVSTC4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMIGV4cGlyZXMuIEZvciBleGFtcGxlLCBgNjBgIGZvciBhIFVSTCB3aGljaCBpcyB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cblx0KiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHNpZ25lZCBVUkwgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBTaWduZWQgVVJMXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5jcmVhdGVTaWduZWRVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIDYwKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIGEgc2lnbmVkIFVSTCBmb3IgYW4gYXNzZXQgd2l0aCB0cmFuc2Zvcm1hdGlvbnNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuY3JlYXRlU2lnbmVkVXJsKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCA2MCwge1xuXHQqICAgICB0cmFuc2Zvcm06IHtcblx0KiAgICAgICB3aWR0aDogMTAwLFxuXHQqICAgICAgIGhlaWdodDogMTAwLFxuXHQqICAgICB9XG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIGEgc2lnbmVkIFVSTCB3aGljaCB0cmlnZ2VycyB0aGUgZG93bmxvYWQgb2YgdGhlIGFzc2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNyZWF0ZVNpZ25lZFVybCgnZm9sZGVyL2F2YXRhcjEucG5nJywgNjAsIHtcblx0KiAgICAgZG93bmxvYWQ6IHRydWUsXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjcmVhdGVTaWduZWRVcmwocGF0aCwgZXhwaXJlc0luLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzOCA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBfcGF0aCA9IF90aGlzOC5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdFx0bGV0IGRhdGEgPSBhd2FpdCBwb3N0JDEoX3RoaXM4LmZldGNoLCBgJHtfdGhpczgudXJsfS9vYmplY3Qvc2lnbi8ke19wYXRofWAsIF9vYmplY3RTcHJlYWQyKHsgZXhwaXJlc0luIH0sIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSA/IHsgdHJhbnNmb3JtOiBvcHRpb25zLnRyYW5zZm9ybSB9IDoge30pLCB7IGhlYWRlcnM6IF90aGlzOC5oZWFkZXJzIH0pO1xuXHRcdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/IFwiXCIgOiBvcHRpb25zLmRvd25sb2FkfWAgOiBcIlwiO1xuXHRcdFx0ZGF0YSA9IHsgc2lnbmVkVXJsOiBlbmNvZGVVUkkoYCR7X3RoaXM4LnVybH0ke2RhdGEuc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApIH07XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzOC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBtdWx0aXBsZSBzaWduZWQgVVJMcy4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGhzIFRoZSBmaWxlIHBhdGhzIHRvIGJlIGRvd25sb2FkZWQsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWVzLiBGb3IgZXhhbXBsZSBgWydmb2xkZXIvaW1hZ2UucG5nJywgJ2ZvbGRlcjIvaW1hZ2UyLnBuZyddYC5cblx0KiBAcGFyYW0gZXhwaXJlc0luIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCB0aGUgc2lnbmVkIFVSTHMgZXhwaXJlLiBGb3IgZXhhbXBsZSwgYDYwYCBmb3IgVVJMcyB3aGljaCBhcmUgdmFsaWQgZm9yIG9uZSBtaW51dGUuXG5cdCogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHNpZ25lZFVybCwgcGF0aCwgYW5kIGVycm9yIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDcmVhdGUgU2lnbmVkIFVSTHNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNyZWF0ZVNpZ25lZFVybHMoWydmb2xkZXIvYXZhdGFyMS5wbmcnLCAnZm9sZGVyL2F2YXRhcjIucG5nJ10sIDYwKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXG5cdCogICAgIHtcblx0KiAgICAgICBcImVycm9yXCI6IG51bGwsXG5cdCogICAgICAgXCJwYXRoXCI6IFwiZm9sZGVyL2F2YXRhcjEucG5nXCIsXG5cdCogICAgICAgXCJzaWduZWRVUkxcIjogXCIvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiLFxuXHQqICAgICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICAgIH0sXG5cdCogICAgIHtcblx0KiAgICAgICBcImVycm9yXCI6IG51bGwsXG5cdCogICAgICAgXCJwYXRoXCI6IFwiZm9sZGVyL2F2YXRhcjIucG5nXCIsXG5cdCogICAgICAgXCJzaWduZWRVUkxcIjogXCIvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMi5wbmc/dG9rZW49PFRPS0VOPlwiLFxuXHQqICAgICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMi5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICAgIH1cblx0KiAgIF0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZVNpZ25lZFVybHMocGF0aHMsIGV4cGlyZXNJbiwgb3B0aW9ucykge1xuXHRcdHZhciBfdGhpczkgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcG9zdCQxKF90aGlzOS5mZXRjaCwgYCR7X3RoaXM5LnVybH0vb2JqZWN0L3NpZ24vJHtfdGhpczkuYnVja2V0SWR9YCwge1xuXHRcdFx0XHRleHBpcmVzSW4sXG5cdFx0XHRcdHBhdGhzXG5cdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzOS5oZWFkZXJzIH0pO1xuXHRcdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/IFwiXCIgOiBvcHRpb25zLmRvd25sb2FkfWAgOiBcIlwiO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogZGF0YS5tYXAoKGRhdHVtKSA9PiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGF0dW0pLCB7fSwgeyBzaWduZWRVcmw6IGRhdHVtLnNpZ25lZFVSTCA/IGVuY29kZVVSSShgJHtfdGhpczkudXJsfSR7ZGF0dW0uc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApIDogbnVsbCB9KSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM5LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBEb3dubG9hZHMgYSBmaWxlIGZyb20gYSBwcml2YXRlIGJ1Y2tldC4gRm9yIHB1YmxpYyBidWNrZXRzLCBtYWtlIGEgcmVxdWVzdCB0byB0aGUgVVJMIHJldHVybmVkIGZyb20gYGdldFB1YmxpY1VybGAgaW5zdGVhZC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZnVsbCBwYXRoIGFuZCBmaWxlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYmUgZG93bmxvYWRlZC4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG5cdCogQHJldHVybnMgQmxvYkRvd25sb2FkQnVpbGRlciBpbnN0YW5jZSBmb3IgZG93bmxvYWRpbmcgdGhlIGZpbGVcblx0KlxuXHQqIEBleGFtcGxlIERvd25sb2FkIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmRvd25sb2FkKCdmb2xkZXIvYXZhdGFyMS5wbmcnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiA8QkxPQj4sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBEb3dubG9hZCBmaWxlIHdpdGggdHJhbnNmb3JtYXRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5kb3dubG9hZCgnZm9sZGVyL2F2YXRhcjEucG5nJywge1xuXHQqICAgICB0cmFuc2Zvcm06IHtcblx0KiAgICAgICB3aWR0aDogMTAwLFxuXHQqICAgICAgIGhlaWdodDogMTAwLFxuXHQqICAgICAgIHF1YWxpdHk6IDgwXG5cdCogICAgIH1cblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGRvd25sb2FkKHBhdGgsIG9wdGlvbnMpIHtcblx0XHRjb25zdCByZW5kZXJQYXRoID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gXCJ1bmRlZmluZWRcIiA/IFwicmVuZGVyL2ltYWdlL2F1dGhlbnRpY2F0ZWRcIiA6IFwib2JqZWN0XCI7XG5cdFx0Y29uc3QgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pIHx8IHt9KTtcblx0XHRjb25zdCBxdWVyeVN0cmluZyA9IHRyYW5zZm9ybWF0aW9uUXVlcnkgPyBgPyR7dHJhbnNmb3JtYXRpb25RdWVyeX1gIDogXCJcIjtcblx0XHRjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKTtcblx0XHRjb25zdCBkb3dubG9hZEZuID0gKCkgPT4gZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9LyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gLCB7XG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRub1Jlc29sdmVKc29uOiB0cnVlXG5cdFx0fSk7XG5cdFx0cmV0dXJuIG5ldyBCbG9iRG93bmxvYWRCdWlsZGVyKGRvd25sb2FkRm4sIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKTtcblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgZmlsZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGZpbGUgbWV0YWRhdGEgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIEdldCBmaWxlIGluZm9cblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmluZm8oJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGluZm8ocGF0aCkge1xuXHRcdHZhciBfdGhpczEwID0gdGhpcztcblx0XHRjb25zdCBfcGF0aCA9IF90aGlzMTAuX2dldEZpbmFsUGF0aChwYXRoKTtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogcmVjdXJzaXZlVG9DYW1lbChhd2FpdCBnZXQoX3RoaXMxMC5mZXRjaCwgYCR7X3RoaXMxMC51cmx9L29iamVjdC9pbmZvLyR7X3BhdGh9YCwgeyBoZWFkZXJzOiBfdGhpczEwLmhlYWRlcnMgfSkpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMTAuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIENoZWNrcyB0aGUgZXhpc3RlbmNlIG9mIGEgZmlsZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGJvb2xlYW4gaW5kaWNhdGluZyBmaWxlIGV4aXN0ZW5jZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgQ2hlY2sgZmlsZSBleGlzdGVuY2Vcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmV4aXN0cygnZm9sZGVyL2F2YXRhcjEucG5nJylcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZXhpc3RzKHBhdGgpIHtcblx0XHR2YXIgX3RoaXMxMSA9IHRoaXM7XG5cdFx0Y29uc3QgX3BhdGggPSBfdGhpczExLl9nZXRGaW5hbFBhdGgocGF0aCk7XG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IGhlYWQoX3RoaXMxMS5mZXRjaCwgYCR7X3RoaXMxMS51cmx9L29iamVjdC8ke19wYXRofWAsIHsgaGVhZGVyczogX3RoaXMxMS5oZWFkZXJzIH0pO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogdHJ1ZSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczExLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpICYmIGVycm9yIGluc3RhbmNlb2YgU3RvcmFnZVVua25vd25FcnJvcikge1xuXHRcdFx0XHRjb25zdCBvcmlnaW5hbEVycm9yID0gZXJyb3Iub3JpZ2luYWxFcnJvcjtcblx0XHRcdFx0aWYgKFs0MDAsIDQwNF0uaW5jbHVkZXMob3JpZ2luYWxFcnJvciA9PT0gbnVsbCB8fCBvcmlnaW5hbEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbEVycm9yLnN0YXR1cykpIHJldHVybiB7XG5cdFx0XHRcdFx0ZGF0YTogZmFsc2UsXG5cdFx0XHRcdFx0ZXJyb3Jcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBBIHNpbXBsZSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgdGhlIFVSTCBmb3IgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0LiBJZiB5b3UgZG8gbm90IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24sIHlvdSBjYW4gY29uc3RydWN0IHRoZSBwdWJsaWMgVVJMIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGJ1Y2tldCBVUkwgd2l0aCB0aGUgcGF0aCB0byB0aGUgYXNzZXQuXG5cdCogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB2ZXJpZnkgaWYgdGhlIGJ1Y2tldCBpcyBwdWJsaWMuIElmIGEgcHVibGljIFVSTCBpcyBjcmVhdGVkIGZvciBhIGJ1Y2tldCB3aGljaCBpcyBub3QgcHVibGljLCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZCB0aGUgYXNzZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIHBhdGggYW5kIG5hbWUgb2YgdGhlIGZpbGUgdG8gZ2VuZXJhdGUgdGhlIHB1YmxpYyBVUkwgZm9yLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgVHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG5cdCogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cblx0KiBAcmV0dXJucyBPYmplY3Qgd2l0aCBwdWJsaWMgVVJMXG5cdCpcblx0KiBAZXhhbXBsZSBSZXR1cm5zIHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhIH0gPSBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdwdWJsaWMtYnVja2V0Jylcblx0KiAgIC5nZXRQdWJsaWNVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJwdWJsaWNVcmxcIjogXCJodHRwczovL2V4YW1wbGUuc3VwYWJhc2UuY28vc3RvcmFnZS92MS9vYmplY3QvcHVibGljL3B1YmxpYy1idWNrZXQvZm9sZGVyL2F2YXRhcjEucG5nXCJcblx0KiAgIH1cblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBSZXR1cm5zIHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldCB3aXRoIHRyYW5zZm9ybWF0aW9uc1xuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhIH0gPSBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdwdWJsaWMtYnVja2V0Jylcblx0KiAgIC5nZXRQdWJsaWNVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIHtcblx0KiAgICAgdHJhbnNmb3JtOiB7XG5cdCogICAgICAgd2lkdGg6IDEwMCxcblx0KiAgICAgICBoZWlnaHQ6IDEwMCxcblx0KiAgICAgfVxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFJldHVybnMgdGhlIFVSTCB3aGljaCB0cmlnZ2VycyB0aGUgZG93bmxvYWQgb2YgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEgfSA9IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ3B1YmxpYy1idWNrZXQnKVxuXHQqICAgLmdldFB1YmxpY1VybCgnZm9sZGVyL2F2YXRhcjEucG5nJywge1xuXHQqICAgICBkb3dubG9hZDogdHJ1ZSxcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGdldFB1YmxpY1VybChwYXRoLCBvcHRpb25zKSB7XG5cdFx0Y29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG5cdFx0Y29uc3QgX3F1ZXJ5U3RyaW5nID0gW107XG5cdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gXCJcIiA6IG9wdGlvbnMuZG93bmxvYWR9YCA6IFwiXCI7XG5cdFx0aWYgKGRvd25sb2FkUXVlcnlQYXJhbSAhPT0gXCJcIikgX3F1ZXJ5U3RyaW5nLnB1c2goZG93bmxvYWRRdWVyeVBhcmFtKTtcblx0XHRjb25zdCByZW5kZXJQYXRoID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gXCJ1bmRlZmluZWRcIiA/IFwicmVuZGVyL2ltYWdlXCIgOiBcIm9iamVjdFwiO1xuXHRcdGNvbnN0IHRyYW5zZm9ybWF0aW9uUXVlcnkgPSB0aGlzLnRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSB8fCB7fSk7XG5cdFx0aWYgKHRyYW5zZm9ybWF0aW9uUXVlcnkgIT09IFwiXCIpIF9xdWVyeVN0cmluZy5wdXNoKHRyYW5zZm9ybWF0aW9uUXVlcnkpO1xuXHRcdGxldCBxdWVyeVN0cmluZyA9IF9xdWVyeVN0cmluZy5qb2luKFwiJlwiKTtcblx0XHRpZiAocXVlcnlTdHJpbmcgIT09IFwiXCIpIHF1ZXJ5U3RyaW5nID0gYD8ke3F1ZXJ5U3RyaW5nfWA7XG5cdFx0cmV0dXJuIHsgZGF0YTogeyBwdWJsaWNVcmw6IGVuY29kZVVSSShgJHt0aGlzLnVybH0vJHtyZW5kZXJQYXRofS9wdWJsaWMvJHtfcGF0aH0ke3F1ZXJ5U3RyaW5nfWApIH0gfTtcblx0fVxuXHQvKipcblx0KiBEZWxldGVzIGZpbGVzIHdpdGhpbiB0aGUgc2FtZSBidWNrZXRcblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aHMgQW4gYXJyYXkgb2YgZmlsZXMgdG8gZGVsZXRlLCBpbmNsdWRpbmcgdGhlIHBhdGggYW5kIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgW2AnZm9sZGVyL2ltYWdlLnBuZydgXS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBkZWxldGVkIGZpbGUgb2JqZWN0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgRGVsZXRlIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLnJlbW92ZShbJ2ZvbGRlci9hdmF0YXIxLnBuZyddKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgcmVtb3ZlKHBhdGhzKSB7XG5cdFx0dmFyIF90aGlzMTIgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCByZW1vdmUoX3RoaXMxMi5mZXRjaCwgYCR7X3RoaXMxMi51cmx9L29iamVjdC8ke190aGlzMTIuYnVja2V0SWR9YCwgeyBwcmVmaXhlczogcGF0aHMgfSwgeyBoZWFkZXJzOiBfdGhpczEyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMxMi5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogR2V0IGZpbGUgbWV0YWRhdGFcblx0KiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gcmV0cmlldmUgbWV0YWRhdGFcblx0Ki9cblx0LyoqXG5cdCogVXBkYXRlIGZpbGUgbWV0YWRhdGFcblx0KiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gdXBkYXRlIG1ldGFkYXRhXG5cdCogQHBhcmFtIG1ldGEgdGhlIG5ldyBmaWxlIG1ldGFkYXRhXG5cdCovXG5cdC8qKlxuXHQqIExpc3RzIGFsbCB0aGUgZmlsZXMgYW5kIGZvbGRlcnMgd2l0aGluIGEgcGF0aCBvZiB0aGUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmb2xkZXIgcGF0aC5cblx0KiBAcGFyYW0gb3B0aW9ucyBTZWFyY2ggb3B0aW9ucyBpbmNsdWRpbmcgbGltaXQgKGRlZmF1bHRzIHRvIDEwMCksIG9mZnNldCwgc29ydEJ5LCBhbmQgc2VhcmNoXG5cdCogQHBhcmFtIHBhcmFtZXRlcnMgT3B0aW9uYWwgZmV0Y2ggcGFyYW1ldGVycyBpbmNsdWRpbmcgc2lnbmFsIGZvciBjYW5jZWxsYXRpb25cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBmaWxlcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCBmaWxlcyBpbiBhIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAubGlzdCgnZm9sZGVyJywge1xuXHQqICAgICBsaW1pdDogMTAwLFxuXHQqICAgICBvZmZzZXQ6IDAsXG5cdCogICAgIHNvcnRCeTogeyBjb2x1bW46ICduYW1lJywgb3JkZXI6ICdhc2MnIH0sXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXG5cdCogICAgIHtcblx0KiAgICAgICBcIm5hbWVcIjogXCJhdmF0YXIxLnBuZ1wiLFxuXHQqICAgICAgIFwiaWRcIjogXCJlNjY4Y2Y3Zi04MjFiLTRhMmYtOWRjZS03ZGZhNWRkMWNmZDJcIixcblx0KiAgICAgICBcInVwZGF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIzOjA2OjA1LjU4MFpcIixcblx0KiAgICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIzOjA0OjM0LjQ0M1pcIixcblx0KiAgICAgICBcImxhc3RfYWNjZXNzZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIzOjA0OjM0LjQ0M1pcIixcblx0KiAgICAgICBcIm1ldGFkYXRhXCI6IHtcblx0KiAgICAgICAgIFwiZVRhZ1wiOiBcIlxcXCJjNWU4YzU1MzIzNWQ5YWYzMGVmNGY2ZTI4MDc5MGI5MlxcXCJcIixcblx0KiAgICAgICAgIFwic2l6ZVwiOiAzMjE3NSxcblx0KiAgICAgICAgIFwibWltZXR5cGVcIjogXCJpbWFnZS9wbmdcIixcblx0KiAgICAgICAgIFwiY2FjaGVDb250cm9sXCI6IFwibWF4LWFnZT0zNjAwXCIsXG5cdCogICAgICAgICBcImxhc3RNb2RpZmllZFwiOiBcIjIwMjQtMDUtMjJUMjM6MDY6MDUuNTc0WlwiLFxuXHQqICAgICAgICAgXCJjb250ZW50TGVuZ3RoXCI6IDMyMTc1LFxuXHQqICAgICAgICAgXCJodHRwU3RhdHVzQ29kZVwiOiAyMDBcblx0KiAgICAgICB9XG5cdCogICAgIH1cblx0KiAgIF0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBTZWFyY2ggZmlsZXMgaW4gYSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmxpc3QoJ2ZvbGRlcicsIHtcblx0KiAgICAgbGltaXQ6IDEwMCxcblx0KiAgICAgb2Zmc2V0OiAwLFxuXHQqICAgICBzb3J0Qnk6IHsgY29sdW1uOiAnbmFtZScsIG9yZGVyOiAnYXNjJyB9LFxuXHQqICAgICBzZWFyY2g6ICdqb24nXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0KHBhdGgsIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcblx0XHR2YXIgX3RoaXMxMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGJvZHkgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9TRUFSQ0hfT1BUSU9OUyksIG9wdGlvbnMpLCB7fSwgeyBwcmVmaXg6IHBhdGggfHwgXCJcIiB9KTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczEzLmZldGNoLCBgJHtfdGhpczEzLnVybH0vb2JqZWN0L2xpc3QvJHtfdGhpczEzLmJ1Y2tldElkfWAsIGJvZHksIHsgaGVhZGVyczogX3RoaXMxMy5oZWFkZXJzIH0sIHBhcmFtZXRlcnMpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMTMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEBleHBlcmltZW50YWwgdGhpcyBtZXRob2Qgc2lnbmF0dXJlIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgc2VhcmNoIG9wdGlvbnNcblx0KiBAcGFyYW0gcGFyYW1ldGVyc1xuXHQqL1xuXHRhc3luYyBsaXN0VjIob3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRcdHZhciBfdGhpczE0ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgYm9keSA9IF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczE0LmZldGNoLCBgJHtfdGhpczE0LnVybH0vb2JqZWN0L2xpc3QtdjIvJHtfdGhpczE0LmJ1Y2tldElkfWAsIGJvZHksIHsgaGVhZGVyczogX3RoaXMxNC5oZWFkZXJzIH0sIHBhcmFtZXRlcnMpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMTQuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdGVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKTtcblx0fVxuXHR0b0Jhc2U2NChkYXRhKSB7XG5cdFx0aWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZyhcImJhc2U2NFwiKTtcblx0XHRyZXR1cm4gYnRvYShkYXRhKTtcblx0fVxuXHRfZ2V0RmluYWxQYXRoKHBhdGgpIHtcblx0XHRyZXR1cm4gYCR7dGhpcy5idWNrZXRJZH0vJHtwYXRoLnJlcGxhY2UoL15cXC8rLywgXCJcIil9YDtcblx0fVxuXHRfcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpIHtcblx0XHRyZXR1cm4gcGF0aC5yZXBsYWNlKC9eXFwvfFxcLyQvZywgXCJcIikucmVwbGFjZSgvXFwvKy9nLCBcIi9cIik7XG5cdH1cblx0dHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcodHJhbnNmb3JtKSB7XG5cdFx0Y29uc3QgcGFyYW1zID0gW107XG5cdFx0aWYgKHRyYW5zZm9ybS53aWR0aCkgcGFyYW1zLnB1c2goYHdpZHRoPSR7dHJhbnNmb3JtLndpZHRofWApO1xuXHRcdGlmICh0cmFuc2Zvcm0uaGVpZ2h0KSBwYXJhbXMucHVzaChgaGVpZ2h0PSR7dHJhbnNmb3JtLmhlaWdodH1gKTtcblx0XHRpZiAodHJhbnNmb3JtLnJlc2l6ZSkgcGFyYW1zLnB1c2goYHJlc2l6ZT0ke3RyYW5zZm9ybS5yZXNpemV9YCk7XG5cdFx0aWYgKHRyYW5zZm9ybS5mb3JtYXQpIHBhcmFtcy5wdXNoKGBmb3JtYXQ9JHt0cmFuc2Zvcm0uZm9ybWF0fWApO1xuXHRcdGlmICh0cmFuc2Zvcm0ucXVhbGl0eSkgcGFyYW1zLnB1c2goYHF1YWxpdHk9JHt0cmFuc2Zvcm0ucXVhbGl0eX1gKTtcblx0XHRyZXR1cm4gcGFyYW1zLmpvaW4oXCImXCIpO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlcnNpb24udHNcbmNvbnN0IHZlcnNpb24gPSBcIjIuOTEuMFwiO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL2NvbnN0YW50cy50c1xuY29uc3QgREVGQVVMVF9IRUFERVJTJDEgPSB7IFwiWC1DbGllbnQtSW5mb1wiOiBgc3RvcmFnZS1qcy8ke3ZlcnNpb259YCB9O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaS50c1xudmFyIFN0b3JhZ2VCdWNrZXRBcGkgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxLCBvcHRzKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHRjb25zdCBiYXNlVXJsID0gbmV3IFVSTCh1cmwpO1xuXHRcdGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMudXNlTmV3SG9zdG5hbWUpIHtcblx0XHRcdGlmICgvc3VwYWJhc2VcXC4oY298aW58cmVkKSQvLnRlc3QoYmFzZVVybC5ob3N0bmFtZSkgJiYgIWJhc2VVcmwuaG9zdG5hbWUuaW5jbHVkZXMoXCJzdG9yYWdlLnN1cGFiYXNlLlwiKSkgYmFzZVVybC5ob3N0bmFtZSA9IGJhc2VVcmwuaG9zdG5hbWUucmVwbGFjZShcInN1cGFiYXNlLlwiLCBcInN0b3JhZ2Uuc3VwYWJhc2UuXCIpO1xuXHRcdH1cblx0XHR0aGlzLnVybCA9IGJhc2VVcmwuaHJlZi5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cdFx0dGhpcy5oZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfSEVBREVSUyQxKSwgaGVhZGVycyk7XG5cdFx0dGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaCQxKGZldGNoJDEpO1xuXHR9XG5cdC8qKlxuXHQqIEVuYWJsZSB0aHJvd2luZyBlcnJvcnMgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlbS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0Ki9cblx0dGhyb3dPbkVycm9yKCkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYWxsIFN0b3JhZ2UgYnVja2V0cyB3aXRoaW4gYW4gZXhpc3RpbmcgcHJvamVjdC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyBRdWVyeSBwYXJhbWV0ZXJzIGZvciBsaXN0aW5nIGJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucy5saW1pdCBNYXhpbXVtIG51bWJlciBvZiBidWNrZXRzIHRvIHJldHVyblxuXHQqIEBwYXJhbSBvcHRpb25zLm9mZnNldCBOdW1iZXIgb2YgYnVja2V0cyB0byBza2lwXG5cdCogQHBhcmFtIG9wdGlvbnMuc29ydENvbHVtbiBDb2x1bW4gdG8gc29ydCBieSAoJ2lkJywgJ25hbWUnLCAnY3JlYXRlZF9hdCcsICd1cGRhdGVkX2F0Jylcblx0KiBAcGFyYW0gb3B0aW9ucy5zb3J0T3JkZXIgU29ydCBvcmRlciAoJ2FzYycgb3IgJ2Rlc2MnKVxuXHQqIEBwYXJhbSBvcHRpb25zLnNlYXJjaCBTZWFyY2ggdGVybSB0byBmaWx0ZXIgYnVja2V0IG5hbWVzXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgYnVja2V0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCBidWNrZXRzXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5saXN0QnVja2V0cygpXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBMaXN0IGJ1Y2tldHMgd2l0aCBvcHRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5saXN0QnVja2V0cyh7XG5cdCogICAgIGxpbWl0OiAxMCxcblx0KiAgICAgb2Zmc2V0OiAwLFxuXHQqICAgICBzb3J0Q29sdW1uOiAnY3JlYXRlZF9hdCcsXG5cdCogICAgIHNvcnRPcmRlcjogJ2Rlc2MnLFxuXHQqICAgICBzZWFyY2g6ICdwcm9kJ1xuXHQqICAgfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdEJ1Y2tldHMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHF1ZXJ5U3RyaW5nID0gX3RoaXMubGlzdEJ1Y2tldE9wdGlvbnNUb1F1ZXJ5U3RyaW5nKG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgZ2V0KF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L2J1Y2tldCR7cXVlcnlTdHJpbmd9YCwgeyBoZWFkZXJzOiBfdGhpcy5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgU3RvcmFnZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIHJldHJpZXZlLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGJ1Y2tldCBkZXRhaWxzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBHZXQgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5nZXRCdWNrZXQoJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwiaWRcIjogXCJhdmF0YXJzXCIsXG5cdCogICAgIFwibmFtZVwiOiBcImF2YXRhcnNcIixcblx0KiAgICAgXCJvd25lclwiOiBcIlwiLFxuXHQqICAgICBcInB1YmxpY1wiOiBmYWxzZSxcblx0KiAgICAgXCJmaWxlX3NpemVfbGltaXRcIjogMTAyNCxcblx0KiAgICAgXCJhbGxvd2VkX21pbWVfdHlwZXNcIjogW1xuXHQqICAgICAgIFwiaW1hZ2UvcG5nXCJcblx0KiAgICAgXSxcblx0KiAgICAgXCJjcmVhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCIsXG5cdCogICAgIFwidXBkYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjI6MjY6MDUuMTAwWlwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBnZXRCdWNrZXQoaWQpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgZ2V0KF90aGlzMi5mZXRjaCwgYCR7X3RoaXMyLnVybH0vYnVja2V0LyR7aWR9YCwgeyBoZWFkZXJzOiBfdGhpczIuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczIuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBuZXcgU3RvcmFnZSBidWNrZXRcblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nLlxuXHQqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuIEJ5IGRlZmF1bHQsIGJ1Y2tldHMgYXJlIHByaXZhdGUuXG5cdCogQHBhcmFtIG9wdGlvbnMuZmlsZVNpemVMaW1pdCBzcGVjaWZpZXMgdGhlIG1heCBmaWxlIHNpemUgaW4gYnl0ZXMgdGhhdCBjYW4gYmUgdXBsb2FkZWQgdG8gdGhpcyBidWNrZXQuXG5cdCogVGhlIGdsb2JhbCBmaWxlIHNpemUgbGltaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgdmFsdWUuXG5cdCogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggZG9lc24ndCBzZXQgYSBwZXIgYnVja2V0IGZpbGUgc2l6ZSBsaW1pdC5cblx0KiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzIHNwZWNpZmllcyB0aGUgYWxsb3dlZCBtaW1lIHR5cGVzIHRoYXQgdGhpcyBidWNrZXQgY2FuIGFjY2VwdCBkdXJpbmcgdXBsb2FkLlxuXHQqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGFsbG93cyBmaWxlcyB3aXRoIGFsbCBtaW1lIHR5cGVzIHRvIGJlIHVwbG9hZGVkLlxuXHQqIEVhY2ggbWltZSB0eXBlIHNwZWNpZmllZCBjYW4gYmUgYSB3aWxkY2FyZCwgZS5nLiBpbWFnZS8qLCBvciBhIHNwZWNpZmljIG1pbWUgdHlwZSwgZS5nLiBpbWFnZS9wbmcuXG5cdCogQHBhcmFtIG9wdGlvbnMudHlwZSAocHJpdmF0ZS1iZXRhKSBzcGVjaWZpZXMgdGhlIGJ1Y2tldCB0eXBlLiBzZWUgYEJ1Y2tldFR5cGVgIGZvciBtb3JlIGRldGFpbHMuXG5cdCogICAtIGRlZmF1bHQgYnVja2V0IHR5cGUgaXMgYFNUQU5EQVJEYFxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIG5ld2x5IGNyZWF0ZWQgYnVja2V0IG5hbWUgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmNyZWF0ZUJ1Y2tldCgnYXZhdGFycycsIHtcblx0KiAgICAgcHVibGljOiBmYWxzZSxcblx0KiAgICAgYWxsb3dlZE1pbWVUeXBlczogWydpbWFnZS9wbmcnXSxcblx0KiAgICAgZmlsZVNpemVMaW1pdDogMTAyNFxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm5hbWVcIjogXCJhdmF0YXJzXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZUJ1Y2tldChpZCwgb3B0aW9ucyA9IHsgcHVibGljOiBmYWxzZSB9KSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczMuZmV0Y2gsIGAke190aGlzMy51cmx9L2J1Y2tldGAsIHtcblx0XHRcdFx0XHRpZCxcblx0XHRcdFx0XHRuYW1lOiBpZCxcblx0XHRcdFx0XHR0eXBlOiBvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0cHVibGljOiBvcHRpb25zLnB1YmxpYyxcblx0XHRcdFx0XHRmaWxlX3NpemVfbGltaXQ6IG9wdGlvbnMuZmlsZVNpemVMaW1pdCxcblx0XHRcdFx0XHRhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlc1xuXHRcdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzMy5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogVXBkYXRlcyBhIFN0b3JhZ2UgYnVja2V0XG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBidWNrZXQgeW91IGFyZSB1cGRhdGluZy5cblx0KiBAcGFyYW0gb3B0aW9ucy5wdWJsaWMgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGJ1Y2tldC4gUHVibGljIGJ1Y2tldHMgZG9uJ3QgcmVxdWlyZSBhbiBhdXRob3JpemF0aW9uIHRva2VuIHRvIGRvd25sb2FkIG9iamVjdHMsIGJ1dCBzdGlsbCByZXF1aXJlIGEgdmFsaWQgdG9rZW4gZm9yIGFsbCBvdGhlciBvcGVyYXRpb25zLlxuXHQqIEBwYXJhbSBvcHRpb25zLmZpbGVTaXplTGltaXQgc3BlY2lmaWVzIHRoZSBtYXggZmlsZSBzaXplIGluIGJ5dGVzIHRoYXQgY2FuIGJlIHVwbG9hZGVkIHRvIHRoaXMgYnVja2V0LlxuXHQqIFRoZSBnbG9iYWwgZmlsZSBzaXplIGxpbWl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHZhbHVlLlxuXHQqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGRvZXNuJ3Qgc2V0IGEgcGVyIGJ1Y2tldCBmaWxlIHNpemUgbGltaXQuXG5cdCogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyBzcGVjaWZpZXMgdGhlIGFsbG93ZWQgbWltZSB0eXBlcyB0aGF0IHRoaXMgYnVja2V0IGNhbiBhY2NlcHQgZHVyaW5nIHVwbG9hZC5cblx0KiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBhbGxvd3MgZmlsZXMgd2l0aCBhbGwgbWltZSB0eXBlcyB0byBiZSB1cGxvYWRlZC5cblx0KiBFYWNoIG1pbWUgdHlwZSBzcGVjaWZpZWQgY2FuIGJlIGEgd2lsZGNhcmQsIGUuZy4gaW1hZ2UvKiwgb3IgYSBzcGVjaWZpYyBtaW1lIHR5cGUsIGUuZy4gaW1hZ2UvcG5nLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHN1Y2Nlc3MgbWVzc2FnZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgVXBkYXRlIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAudXBkYXRlQnVja2V0KCdhdmF0YXJzJywge1xuXHQqICAgICBwdWJsaWM6IGZhbHNlLFxuXHQqICAgICBhbGxvd2VkTWltZVR5cGVzOiBbJ2ltYWdlL3BuZyddLFxuXHQqICAgICBmaWxlU2l6ZUxpbWl0OiAxMDI0XG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibWVzc2FnZVwiOiBcIlN1Y2Nlc3NmdWxseSB1cGRhdGVkXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHVwZGF0ZUJ1Y2tldChpZCwgb3B0aW9ucykge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwdXQoX3RoaXM0LmZldGNoLCBgJHtfdGhpczQudXJsfS9idWNrZXQvJHtpZH1gLCB7XG5cdFx0XHRcdFx0aWQsXG5cdFx0XHRcdFx0bmFtZTogaWQsXG5cdFx0XHRcdFx0cHVibGljOiBvcHRpb25zLnB1YmxpYyxcblx0XHRcdFx0XHRmaWxlX3NpemVfbGltaXQ6IG9wdGlvbnMuZmlsZVNpemVMaW1pdCxcblx0XHRcdFx0XHRhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlc1xuXHRcdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzNC5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogUmVtb3ZlcyBhbGwgb2JqZWN0cyBpbnNpZGUgYSBzaW5nbGUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byBlbXB0eS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBFbXB0eSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmVtcHR5QnVja2V0KCdhdmF0YXJzJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgZW1wdGllZFwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBlbXB0eUJ1Y2tldChpZCkge1xuXHRcdHZhciBfdGhpczUgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0JDEoX3RoaXM1LmZldGNoLCBgJHtfdGhpczUudXJsfS9idWNrZXQvJHtpZH0vZW1wdHlgLCB7fSwgeyBoZWFkZXJzOiBfdGhpczUuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczUuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIERlbGV0ZXMgYW4gZXhpc3RpbmcgYnVja2V0LiBBIGJ1Y2tldCBjYW4ndCBiZSBkZWxldGVkIHdpdGggZXhpc3Rpbmcgb2JqZWN0cyBpbnNpZGUgaXQuXG5cdCogWW91IG11c3QgZmlyc3QgYGVtcHR5KClgIHRoZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGRlbGV0ZS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBEZWxldGUgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5kZWxldGVCdWNrZXQoJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibWVzc2FnZVwiOiBcIlN1Y2Nlc3NmdWxseSBkZWxldGVkXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGRlbGV0ZUJ1Y2tldChpZCkge1xuXHRcdHZhciBfdGhpczYgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCByZW1vdmUoX3RoaXM2LmZldGNoLCBgJHtfdGhpczYudXJsfS9idWNrZXQvJHtpZH1gLCB7fSwgeyBoZWFkZXJzOiBfdGhpczYuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczYuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdGxpc3RCdWNrZXRPcHRpb25zVG9RdWVyeVN0cmluZyhvcHRpb25zKSB7XG5cdFx0Y29uc3QgcGFyYW1zID0ge307XG5cdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdGlmIChcImxpbWl0XCIgaW4gb3B0aW9ucykgcGFyYW1zLmxpbWl0ID0gU3RyaW5nKG9wdGlvbnMubGltaXQpO1xuXHRcdFx0aWYgKFwib2Zmc2V0XCIgaW4gb3B0aW9ucykgcGFyYW1zLm9mZnNldCA9IFN0cmluZyhvcHRpb25zLm9mZnNldCk7XG5cdFx0XHRpZiAob3B0aW9ucy5zZWFyY2gpIHBhcmFtcy5zZWFyY2ggPSBvcHRpb25zLnNlYXJjaDtcblx0XHRcdGlmIChvcHRpb25zLnNvcnRDb2x1bW4pIHBhcmFtcy5zb3J0Q29sdW1uID0gb3B0aW9ucy5zb3J0Q29sdW1uO1xuXHRcdFx0aWYgKG9wdGlvbnMuc29ydE9yZGVyKSBwYXJhbXMuc29ydE9yZGVyID0gb3B0aW9ucy5zb3J0T3JkZXI7XG5cdFx0fVxuXHRcdHJldHVybiBPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA+IDAgPyBcIj9cIiArIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKS50b1N0cmluZygpIDogXCJcIjtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1N0b3JhZ2VBbmFseXRpY3NDbGllbnQudHNcbi8qKlxuKiBDbGllbnQgY2xhc3MgZm9yIG1hbmFnaW5nIEFuYWx5dGljcyBCdWNrZXRzIHVzaW5nIEljZWJlcmcgdGFibGVzXG4qIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBsaXN0aW5nLCBhbmQgZGVsZXRpbmcgYW5hbHl0aWNzIGJ1Y2tldHNcbiovXG52YXIgU3RvcmFnZUFuYWx5dGljc0NsaWVudCA9IGNsYXNzIHtcblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgbmV3IFN0b3JhZ2VBbmFseXRpY3NDbGllbnQgaW5zdGFuY2Vcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcGFyYW0gdXJsIC0gVGhlIGJhc2UgVVJMIGZvciB0aGUgc3RvcmFnZSBBUElcblx0KiBAcGFyYW0gaGVhZGVycyAtIEhUVFAgaGVhZGVycyB0byBpbmNsdWRlIGluIHJlcXVlc3RzXG5cdCogQHBhcmFtIGZldGNoIC0gT3B0aW9uYWwgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBjbGllbnQgPSBuZXcgU3RvcmFnZUFuYWx5dGljc0NsaWVudCh1cmwsIGhlYWRlcnMpXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHR0aGlzLnVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cdFx0dGhpcy5oZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfSEVBREVSUyQxKSwgaGVhZGVycyk7XG5cdFx0dGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaCQxKGZldGNoJDEpO1xuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtIGluIHRoZSByZXNwb25zZVxuXHQqIFdoZW4gZW5hYmxlZCwgZmFpbGVkIG9wZXJhdGlvbnMgd2lsbCB0aHJvdyBpbnN0ZWFkIG9mIHJldHVybmluZyB7IGRhdGE6IG51bGwsIGVycm9yIH1cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcmV0dXJucyBUaGlzIGluc3RhbmNlIGZvciBtZXRob2QgY2hhaW5pbmdcblx0Ki9cblx0dGhyb3dPbkVycm9yKCkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBuZXcgYW5hbHl0aWNzIGJ1Y2tldCB1c2luZyBJY2ViZXJnIHRhYmxlc1xuXHQqIEFuYWx5dGljcyBidWNrZXRzIGFyZSBvcHRpbWl6ZWQgZm9yIGFuYWx5dGljYWwgcXVlcmllcyBhbmQgZGF0YSBwcm9jZXNzaW5nXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHBhcmFtIG5hbWUgQSB1bmlxdWUgbmFtZSBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgbmV3bHkgY3JlYXRlZCBhbmFseXRpY3MgYnVja2V0IG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDcmVhdGUgYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuYW5hbHl0aWNzXG5cdCogICAuY3JlYXRlQnVja2V0KCdhbmFseXRpY3MtZGF0YScpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJuYW1lXCI6IFwiYW5hbHl0aWNzLWRhdGFcIixcblx0KiAgICAgXCJ0eXBlXCI6IFwiQU5BTFlUSUNTXCIsXG5cdCogICAgIFwiZm9ybWF0XCI6IFwiaWNlYmVyZ1wiLFxuXHQqICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIixcblx0KiAgICAgXCJ1cGRhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZUJ1Y2tldChuYW1lKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdCQxKF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L2J1Y2tldGAsIHsgbmFtZSB9LCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFsbCBBbmFseXRpY3MgU3RvcmFnZSBidWNrZXRzIHdpdGhpbiBhbiBleGlzdGluZyBwcm9qZWN0XG5cdCogT25seSByZXR1cm5zIGJ1Y2tldHMgb2YgdHlwZSAnQU5BTFlUSUNTJ1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIFF1ZXJ5IHBhcmFtZXRlcnMgZm9yIGxpc3RpbmcgYnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zLmxpbWl0IE1heGltdW0gbnVtYmVyIG9mIGJ1Y2tldHMgdG8gcmV0dXJuXG5cdCogQHBhcmFtIG9wdGlvbnMub2Zmc2V0IE51bWJlciBvZiBidWNrZXRzIHRvIHNraXBcblx0KiBAcGFyYW0gb3B0aW9ucy5zb3J0Q29sdW1uIENvbHVtbiB0byBzb3J0IGJ5ICgnbmFtZScsICdjcmVhdGVkX2F0JywgJ3VwZGF0ZWRfYXQnKVxuXHQqIEBwYXJhbSBvcHRpb25zLnNvcnRPcmRlciBTb3J0IG9yZGVyICgnYXNjJyBvciAnZGVzYycpXG5cdCogQHBhcmFtIG9wdGlvbnMuc2VhcmNoIFNlYXJjaCB0ZXJtIHRvIGZpbHRlciBidWNrZXQgbmFtZXNcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBhbmFseXRpY3MgYnVja2V0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCBhbmFseXRpY3MgYnVja2V0c1xuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuYW5hbHl0aWNzXG5cdCogICAubGlzdEJ1Y2tldHMoe1xuXHQqICAgICBsaW1pdDogMTAsXG5cdCogICAgIG9mZnNldDogMCxcblx0KiAgICAgc29ydENvbHVtbjogJ2NyZWF0ZWRfYXQnLFxuXHQqICAgICBzb3J0T3JkZXI6ICdkZXNjJ1xuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjogW1xuXHQqICAgICB7XG5cdCogICAgICAgXCJuYW1lXCI6IFwiYW5hbHl0aWNzLWRhdGFcIixcblx0KiAgICAgICBcInR5cGVcIjogXCJBTkFMWVRJQ1NcIixcblx0KiAgICAgICBcImZvcm1hdFwiOiBcImljZWJlcmdcIixcblx0KiAgICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIixcblx0KiAgICAgICBcInVwZGF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIlxuXHQqICAgICB9XG5cdCogICBdLFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0QnVja2V0cyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXHRcdFx0aWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubGltaXQpICE9PSB2b2lkIDApIHF1ZXJ5UGFyYW1zLnNldChcImxpbWl0XCIsIG9wdGlvbnMubGltaXQudG9TdHJpbmcoKSk7XG5cdFx0XHRpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpICE9PSB2b2lkIDApIHF1ZXJ5UGFyYW1zLnNldChcIm9mZnNldFwiLCBvcHRpb25zLm9mZnNldC50b1N0cmluZygpKTtcblx0XHRcdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc29ydENvbHVtbikgcXVlcnlQYXJhbXMuc2V0KFwic29ydENvbHVtblwiLCBvcHRpb25zLnNvcnRDb2x1bW4pO1xuXHRcdFx0aWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zb3J0T3JkZXIpIHF1ZXJ5UGFyYW1zLnNldChcInNvcnRPcmRlclwiLCBvcHRpb25zLnNvcnRPcmRlcik7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNlYXJjaCkgcXVlcnlQYXJhbXMuc2V0KFwic2VhcmNoXCIsIG9wdGlvbnMuc2VhcmNoKTtcblx0XHRcdGNvbnN0IHF1ZXJ5U3RyaW5nID0gcXVlcnlQYXJhbXMudG9TdHJpbmcoKTtcblx0XHRcdGNvbnN0IHVybCA9IHF1ZXJ5U3RyaW5nID8gYCR7X3RoaXMyLnVybH0vYnVja2V0PyR7cXVlcnlTdHJpbmd9YCA6IGAke190aGlzMi51cmx9L2J1Y2tldGA7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBnZXQoX3RoaXMyLmZldGNoLCB1cmwsIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMyLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIERlbGV0ZXMgYW4gZXhpc3RpbmcgYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIEEgYnVja2V0IGNhbid0IGJlIGRlbGV0ZWQgd2l0aCBleGlzdGluZyBvYmplY3RzIGluc2lkZSBpdFxuXHQqIFlvdSBtdXN0IGZpcnN0IGVtcHR5IHRoZSBidWNrZXQgYmVmb3JlIGRlbGV0aW9uXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHBhcmFtIGJ1Y2tldE5hbWUgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gZGVsZXRlXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBEZWxldGUgYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuYW5hbHl0aWNzXG5cdCogICAuZGVsZXRlQnVja2V0KCdhbmFseXRpY3MtZGF0YScpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJtZXNzYWdlXCI6IFwiU3VjY2Vzc2Z1bGx5IGRlbGV0ZWRcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZGVsZXRlQnVja2V0KGJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3RoaXMzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcmVtb3ZlKF90aGlzMy5mZXRjaCwgYCR7X3RoaXMzLnVybH0vYnVja2V0LyR7YnVja2V0TmFtZX1gLCB7fSwgeyBoZWFkZXJzOiBfdGhpczMuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogR2V0IGFuIEljZWJlcmcgUkVTVCBDYXRhbG9nIGNsaWVudCBjb25maWd1cmVkIGZvciBhIHNwZWNpZmljIGFuYWx5dGljcyBidWNrZXRcblx0KiBVc2UgdGhpcyB0byBwZXJmb3JtIGFkdmFuY2VkIHRhYmxlIGFuZCBuYW1lc3BhY2Ugb3BlcmF0aW9ucyB3aXRoaW4gdGhlIGJ1Y2tldFxuXHQqIFRoZSByZXR1cm5lZCBjbGllbnQgcHJvdmlkZXMgZnVsbCBhY2Nlc3MgdG8gdGhlIEFwYWNoZSBJY2ViZXJnIFJFU1QgQ2F0YWxvZyBBUElcblx0KiB3aXRoIHRoZSBTdXBhYmFzZSBgeyBkYXRhLCBlcnJvciB9YCBwYXR0ZXJuIGZvciBjb25zaXN0ZW50IGVycm9yIGhhbmRsaW5nIG9uIGFsbCBvcGVyYXRpb25zLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEBwYXJhbSBidWNrZXROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGFuYWx5dGljcyBidWNrZXQgKHdhcmVob3VzZSkgdG8gY29ubmVjdCB0b1xuXHQqIEByZXR1cm5zIFRoZSB3cmFwcGVkIEljZWJlcmcgY2F0YWxvZyBjbGllbnRcblx0KiBAdGhyb3dzIHtTdG9yYWdlRXJyb3J9IElmIHRoZSBidWNrZXQgbmFtZSBpcyBpbnZhbGlkXG5cdCpcblx0KiBAZXhhbXBsZSBHZXQgY2F0YWxvZyBhbmQgY3JlYXRlIHRhYmxlXG5cdCogYGBganNcblx0KiAvLyBGaXJzdCwgY3JlYXRlIGFuIGFuYWx5dGljcyBidWNrZXRcblx0KiBjb25zdCB7IGRhdGE6IGJ1Y2tldCwgZXJyb3I6IGJ1Y2tldEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5hbmFseXRpY3Ncblx0KiAgIC5jcmVhdGVCdWNrZXQoJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIEdldCB0aGUgSWNlYmVyZyBjYXRhbG9nIGZvciB0aGF0IGJ1Y2tldFxuXHQqIGNvbnN0IGNhdGFsb2cgPSBzdXBhYmFzZS5zdG9yYWdlLmFuYWx5dGljcy5mcm9tKCdhbmFseXRpY3MtZGF0YScpXG5cdCpcblx0KiAvLyBDcmVhdGUgYSBuYW1lc3BhY2Vcblx0KiBjb25zdCB7IGVycm9yOiBuc0Vycm9yIH0gPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZSh7IG5hbWVzcGFjZTogWydkZWZhdWx0J10gfSlcblx0KlxuXHQqIC8vIENyZWF0ZSBhIHRhYmxlIHdpdGggc2NoZW1hXG5cdCogY29uc3QgeyBkYXRhOiB0YWJsZU1ldGFkYXRhLCBlcnJvcjogdGFibGVFcnJvciB9ID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVUYWJsZShcblx0KiAgIHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSB9LFxuXHQqICAge1xuXHQqICAgICBuYW1lOiAnZXZlbnRzJyxcblx0KiAgICAgc2NoZW1hOiB7XG5cdCogICAgICAgdHlwZTogJ3N0cnVjdCcsXG5cdCogICAgICAgZmllbGRzOiBbXG5cdCogICAgICAgICB7IGlkOiAxLCBuYW1lOiAnaWQnLCB0eXBlOiAnbG9uZycsIHJlcXVpcmVkOiB0cnVlIH0sXG5cdCogICAgICAgICB7IGlkOiAyLCBuYW1lOiAndGltZXN0YW1wJywgdHlwZTogJ3RpbWVzdGFtcCcsIHJlcXVpcmVkOiB0cnVlIH0sXG5cdCogICAgICAgICB7IGlkOiAzLCBuYW1lOiAndXNlcl9pZCcsIHR5cGU6ICdzdHJpbmcnLCByZXF1aXJlZDogZmFsc2UgfVxuXHQqICAgICAgIF0sXG5cdCogICAgICAgJ3NjaGVtYS1pZCc6IDAsXG5cdCogICAgICAgJ2lkZW50aWZpZXItZmllbGQtaWRzJzogWzFdXG5cdCogICAgIH0sXG5cdCogICAgICdwYXJ0aXRpb24tc3BlYyc6IHtcblx0KiAgICAgICAnc3BlYy1pZCc6IDAsXG5cdCogICAgICAgZmllbGRzOiBbXVxuXHQqICAgICB9LFxuXHQqICAgICAnd3JpdGUtb3JkZXInOiB7XG5cdCogICAgICAgJ29yZGVyLWlkJzogMCxcblx0KiAgICAgICBmaWVsZHM6IFtdXG5cdCogICAgIH0sXG5cdCogICAgIHByb3BlcnRpZXM6IHtcblx0KiAgICAgICAnd3JpdGUuZm9ybWF0LmRlZmF1bHQnOiAncGFycXVldCdcblx0KiAgICAgfVxuXHQqICAgfVxuXHQqIClcblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIExpc3QgdGFibGVzIGluIG5hbWVzcGFjZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgY2F0YWxvZyA9IHN1cGFiYXNlLnN0b3JhZ2UuYW5hbHl0aWNzLmZyb20oJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIExpc3QgYWxsIHRhYmxlcyBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2Vcblx0KiBjb25zdCB7IGRhdGE6IHRhYmxlcywgZXJyb3I6IGxpc3RFcnJvciB9ID0gYXdhaXQgY2F0YWxvZy5saXN0VGFibGVzKHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSB9KVxuXHQqIGlmIChsaXN0RXJyb3IpIHtcblx0KiAgIGlmIChsaXN0RXJyb3IuaXNOb3RGb3VuZCgpKSB7XG5cdCogICAgIGNvbnNvbGUubG9nKCdOYW1lc3BhY2Ugbm90IGZvdW5kJylcblx0KiAgIH1cblx0KiAgIHJldHVyblxuXHQqIH1cblx0KiBjb25zb2xlLmxvZyh0YWJsZXMpIC8vIFt7IG5hbWVzcGFjZTogWydkZWZhdWx0J10sIG5hbWU6ICdldmVudHMnIH1dXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBXb3JraW5nIHdpdGggbmFtZXNwYWNlc1xuXHQqIGBgYGpzXG5cdCogY29uc3QgY2F0YWxvZyA9IHN1cGFiYXNlLnN0b3JhZ2UuYW5hbHl0aWNzLmZyb20oJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIExpc3QgYWxsIG5hbWVzcGFjZXNcblx0KiBjb25zdCB7IGRhdGE6IG5hbWVzcGFjZXMgfSA9IGF3YWl0IGNhdGFsb2cubGlzdE5hbWVzcGFjZXMoKVxuXHQqXG5cdCogLy8gQ3JlYXRlIG5hbWVzcGFjZSB3aXRoIHByb3BlcnRpZXNcblx0KiBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZShcblx0KiAgIHsgbmFtZXNwYWNlOiBbJ3Byb2R1Y3Rpb24nXSB9LFxuXHQqICAgeyBwcm9wZXJ0aWVzOiB7IG93bmVyOiAnZGF0YS10ZWFtJywgZW52OiAncHJvZCcgfSB9XG5cdCogKVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ2xlYW51cCBvcGVyYXRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCBjYXRhbG9nID0gc3VwYWJhc2Uuc3RvcmFnZS5hbmFseXRpY3MuZnJvbSgnYW5hbHl0aWNzLWRhdGEnKVxuXHQqXG5cdCogLy8gRHJvcCB0YWJsZSB3aXRoIHB1cmdlIG9wdGlvbiAocmVtb3ZlcyBhbGwgZGF0YSlcblx0KiBjb25zdCB7IGVycm9yOiBkcm9wRXJyb3IgfSA9IGF3YWl0IGNhdGFsb2cuZHJvcFRhYmxlKFxuXHQqICAgeyBuYW1lc3BhY2U6IFsnZGVmYXVsdCddLCBuYW1lOiAnZXZlbnRzJyB9LFxuXHQqICAgeyBwdXJnZTogdHJ1ZSB9XG5cdCogKVxuXHQqXG5cdCogaWYgKGRyb3BFcnJvcj8uaXNOb3RGb3VuZCgpKSB7XG5cdCogICBjb25zb2xlLmxvZygnVGFibGUgZG9lcyBub3QgZXhpc3QnKVxuXHQqIH1cblx0KlxuXHQqIC8vIERyb3AgbmFtZXNwYWNlIChtdXN0IGJlIGVtcHR5KVxuXHQqIGF3YWl0IGNhdGFsb2cuZHJvcE5hbWVzcGFjZSh7IG5hbWVzcGFjZTogWydkZWZhdWx0J10gfSlcblx0KiBgYGBcblx0KlxuXHQqIEByZW1hcmtzXG5cdCogVGhpcyBtZXRob2QgcHJvdmlkZXMgYSBicmlkZ2UgYmV0d2VlbiBTdXBhYmFzZSdzIGJ1Y2tldCBtYW5hZ2VtZW50IGFuZCB0aGUgc3RhbmRhcmRcblx0KiBBcGFjaGUgSWNlYmVyZyBSRVNUIENhdGFsb2cgQVBJLiBUaGUgYnVja2V0IG5hbWUgbWFwcyB0byB0aGUgSWNlYmVyZyB3YXJlaG91c2UgcGFyYW1ldGVyLlxuXHQqIEFsbCBhdXRoZW50aWNhdGlvbiBhbmQgY29uZmlndXJhdGlvbiBpcyBoYW5kbGVkIGF1dG9tYXRpY2FsbHkgdXNpbmcgeW91ciBTdXBhYmFzZSBjcmVkZW50aWFscy5cblx0KlxuXHQqICoqRXJyb3IgSGFuZGxpbmcqKjogSW52YWxpZCBidWNrZXQgbmFtZXMgdGhyb3cgaW1tZWRpYXRlbHkuIEFsbCBjYXRhbG9nXG5cdCogb3BlcmF0aW9ucyByZXR1cm4gYHsgZGF0YSwgZXJyb3IgfWAgd2hlcmUgZXJyb3JzIGFyZSBgSWNlYmVyZ0Vycm9yYCBpbnN0YW5jZXMgZnJvbSBpY2ViZXJnLWpzLlxuXHQqIFVzZSBoZWxwZXIgbWV0aG9kcyBsaWtlIGBlcnJvci5pc05vdEZvdW5kKClgIG9yIGNoZWNrIGBlcnJvci5zdGF0dXNgIGZvciBzcGVjaWZpYyBlcnJvciBoYW5kbGluZy5cblx0KiBVc2UgYC50aHJvd09uRXJyb3IoKWAgb24gdGhlIGFuYWx5dGljcyBjbGllbnQgaWYgeW91IHByZWZlciBleGNlcHRpb25zIGZvciBjYXRhbG9nIG9wZXJhdGlvbnMuXG5cdCpcblx0KiAqKkNsZWFudXAgT3BlcmF0aW9ucyoqOiBXaGVuIHVzaW5nIGBkcm9wVGFibGVgLCB0aGUgYHB1cmdlOiB0cnVlYCBvcHRpb24gcGVybWFuZW50bHlcblx0KiBkZWxldGVzIGFsbCB0YWJsZSBkYXRhLiBXaXRob3V0IGl0LCB0aGUgdGFibGUgaXMgbWFya2VkIGFzIGRlbGV0ZWQgYnV0IGRhdGEgcmVtYWlucy5cblx0KlxuXHQqICoqTGlicmFyeSBEZXBlbmRlbmN5Kio6IFRoZSByZXR1cm5lZCBjYXRhbG9nIHdyYXBzIGBJY2ViZXJnUmVzdENhdGFsb2dgIGZyb20gaWNlYmVyZy1qcy5cblx0KiBGb3IgY29tcGxldGUgQVBJIGRvY3VtZW50YXRpb24gYW5kIGFkdmFuY2VkIHVzYWdlLCByZWZlciB0byB0aGVcblx0KiBbaWNlYmVyZy1qcyBkb2N1bWVudGF0aW9uXShodHRwczovL3N1cGFiYXNlLmdpdGh1Yi5pby9pY2ViZXJnLWpzLykuXG5cdCovXG5cdGZyb20oYnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdGlmICghaXNWYWxpZEJ1Y2tldE5hbWUoYnVja2V0TmFtZSkpIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXCJJbnZhbGlkIGJ1Y2tldCBuYW1lOiBGaWxlLCBmb2xkZXIsIGFuZCBidWNrZXQgbmFtZXMgbXVzdCBmb2xsb3cgQVdTIG9iamVjdCBrZXkgbmFtaW5nIGd1aWRlbGluZXMgYW5kIHNob3VsZCBhdm9pZCB0aGUgdXNlIG9mIGFueSBvdGhlciBjaGFyYWN0ZXJzLlwiKTtcblx0XHRjb25zdCBjYXRhbG9nID0gbmV3IEljZWJlcmdSZXN0Q2F0YWxvZyh7XG5cdFx0XHRiYXNlVXJsOiB0aGlzLnVybCxcblx0XHRcdGNhdGFsb2dOYW1lOiBidWNrZXROYW1lLFxuXHRcdFx0YXV0aDoge1xuXHRcdFx0XHR0eXBlOiBcImN1c3RvbVwiLFxuXHRcdFx0XHRnZXRIZWFkZXJzOiBhc3luYyAoKSA9PiBfdGhpczQuaGVhZGVyc1xuXHRcdFx0fSxcblx0XHRcdGZldGNoOiB0aGlzLmZldGNoXG5cdFx0fSk7XG5cdFx0Y29uc3Qgc2hvdWxkVGhyb3dPbkVycm9yID0gdGhpcy5zaG91bGRUaHJvd09uRXJyb3I7XG5cdFx0cmV0dXJuIG5ldyBQcm94eShjYXRhbG9nLCB7IGdldCh0YXJnZXQsIHByb3ApIHtcblx0XHRcdGNvbnN0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdmFsdWU7XG5cdFx0XHRyZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZGF0YTogYXdhaXQgdmFsdWUuYXBwbHkodGFyZ2V0LCBhcmdzKSxcblx0XHRcdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRpZiAoc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0XHRcdGVycm9yXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9IH0pO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlY3RvcnMvY29uc3RhbnRzLnRzXG5jb25zdCBERUZBVUxUX0hFQURFUlMgPSB7XG5cdFwiWC1DbGllbnQtSW5mb1wiOiBgc3RvcmFnZS1qcy8ke3ZlcnNpb259YCxcblx0XCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9lcnJvcnMudHNcbi8qKlxuKiBCYXNlIGVycm9yIGNsYXNzIGZvciBhbGwgU3RvcmFnZSBWZWN0b3JzIGVycm9yc1xuKi9cbnZhciBTdG9yYWdlVmVjdG9yc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLl9faXNTdG9yYWdlVmVjdG9yc0Vycm9yID0gdHJ1ZTtcblx0XHR0aGlzLm5hbWUgPSBcIlN0b3JhZ2VWZWN0b3JzRXJyb3JcIjtcblx0fVxufTtcbi8qKlxuKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGFuIGVycm9yIGlzIGEgU3RvcmFnZVZlY3RvcnNFcnJvclxuKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gY2hlY2tcbiogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSBTdG9yYWdlVmVjdG9yc0Vycm9yXG4qL1xuZnVuY3Rpb24gaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSB7XG5cdHJldHVybiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgZXJyb3IgIT09IG51bGwgJiYgXCJfX2lzU3RvcmFnZVZlY3RvcnNFcnJvclwiIGluIGVycm9yO1xufVxuLyoqXG4qIEFQSSBlcnJvciByZXR1cm5lZCBmcm9tIFMzIFZlY3RvcnMgc2VydmljZVxuKiBJbmNsdWRlcyBIVFRQIHN0YXR1cyBjb2RlIGFuZCBzZXJ2aWNlLXNwZWNpZmljIGVycm9yIGNvZGVcbiovXG52YXIgU3RvcmFnZVZlY3RvcnNBcGlFcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZVZlY3RvcnNFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgc3RhdHVzQ29kZSkge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZVZlY3RvcnNBcGlFcnJvclwiO1xuXHRcdHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuXHRcdHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG5cdH1cblx0dG9KU09OKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cdFx0XHRtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG5cdFx0XHRzdGF0dXM6IHRoaXMuc3RhdHVzLFxuXHRcdFx0c3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlXG5cdFx0fTtcblx0fVxufTtcbi8qKlxuKiBVbmtub3duIGVycm9yIHRoYXQgZG9lc24ndCBtYXRjaCBleHBlY3RlZCBlcnJvciBwYXR0ZXJuc1xuKiBXcmFwcyB0aGUgb3JpZ2luYWwgZXJyb3IgZm9yIGRlYnVnZ2luZ1xuKi9cbnZhciBTdG9yYWdlVmVjdG9yc1Vua25vd25FcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZVZlY3RvcnNFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLm5hbWUgPSBcIlN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yXCI7XG5cdFx0dGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcblx0fVxufTtcbi8qKlxuKiBFcnJvciBjb2RlcyBzcGVjaWZpYyB0byBTMyBWZWN0b3JzIEFQSVxuKiBNYXBzIEFXUyBzZXJ2aWNlIGVycm9ycyB0byBhcHBsaWNhdGlvbi1mcmllbmRseSBlcnJvciBjb2Rlc1xuKi9cbmxldCBTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxKSB7XG5cdC8qKiBJbnRlcm5hbCBzZXJ2ZXIgZmF1bHQgKEhUVFAgNTAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiSW50ZXJuYWxFcnJvclwiXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuXHQvKiogUmVzb3VyY2UgYWxyZWFkeSBleGlzdHMgLyBjb25mbGljdCAoSFRUUCA0MDkpICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJTM1ZlY3RvckNvbmZsaWN0RXhjZXB0aW9uXCJdID0gXCJTM1ZlY3RvckNvbmZsaWN0RXhjZXB0aW9uXCI7XG5cdC8qKiBSZXNvdXJjZSBub3QgZm91bmQgKEhUVFAgNDA0KSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvblwiXSA9IFwiUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvblwiO1xuXHQvKiogRGVsZXRlIGJ1Y2tldCB3aGlsZSBub3QgZW1wdHkgKEhUVFAgNDAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JCdWNrZXROb3RFbXB0eVwiXSA9IFwiUzNWZWN0b3JCdWNrZXROb3RFbXB0eVwiO1xuXHQvKiogRXhjZWVkcyBidWNrZXQgcXVvdGEvbGltaXQgKEhUVFAgNDAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JNYXhCdWNrZXRzRXhjZWVkZWRcIl0gPSBcIlMzVmVjdG9yTWF4QnVja2V0c0V4Y2VlZGVkXCI7XG5cdC8qKiBFeGNlZWRzIGluZGV4IHF1b3RhL2xpbWl0IChIVFRQIDQwMCkgKi9cblx0U3RvcmFnZVZlY3RvcnNFcnJvckNvZGUkMVtcIlMzVmVjdG9yTWF4SW5kZXhlc0V4Y2VlZGVkXCJdID0gXCJTM1ZlY3Rvck1heEluZGV4ZXNFeGNlZWRlZFwiO1xuXHRyZXR1cm4gU3RvcmFnZVZlY3RvcnNFcnJvckNvZGUkMTtcbn0oe30pO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlY3RvcnMvaGVscGVycy50c1xuLyoqXG4qIFJlc29sdmVzIHRoZSBmZXRjaCBpbXBsZW1lbnRhdGlvbiB0byB1c2VcbiogVXNlcyBjdXN0b20gZmV0Y2ggaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB1c2VzIG5hdGl2ZSBmZXRjaFxuKlxuKiBAcGFyYW0gY3VzdG9tRmV0Y2ggLSBPcHRpb25hbCBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb25cbiogQHJldHVybnMgUmVzb2x2ZWQgZmV0Y2ggZnVuY3Rpb25cbiovXG5jb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcblx0aWYgKGN1c3RvbUZldGNoKSByZXR1cm4gKC4uLmFyZ3MpID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpO1xuXHRyZXR1cm4gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xufTtcbi8qKlxuKiBSZXNvbHZlcyB0aGUgUmVzcG9uc2UgY29uc3RydWN0b3IgdG8gdXNlXG4qIFJldHVybnMgbmF0aXZlIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4qXG4qIEByZXR1cm5zIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4qL1xuY29uc3QgcmVzb2x2ZVJlc3BvbnNlID0gKCkgPT4ge1xuXHRyZXR1cm4gUmVzcG9uc2U7XG59O1xuLyoqXG4qIERldGVybWluZSBpZiBpbnB1dCBpcyBhIHBsYWluIG9iamVjdFxuKiBBbiBvYmplY3QgaXMgcGxhaW4gaWYgaXQncyBjcmVhdGVkIGJ5IGVpdGhlciB7fSwgbmV3IE9iamVjdCgpLCBvciBPYmplY3QuY3JlYXRlKG51bGwpXG4qXG4qIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrXG4qIEByZXR1cm5zIFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3RcbiogQHNvdXJjZSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2lzLXBsYWluLW9ialxuKi9cbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsdWUpID0+IHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuXHRyZXR1cm4gKHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSk7XG59O1xuLyoqXG4qIE5vcm1hbGl6ZXMgYSBudW1iZXIgYXJyYXkgdG8gZmxvYXQzMiBmb3JtYXRcbiogRW5zdXJlcyBhbGwgdmVjdG9yIHZhbHVlcyBhcmUgdmFsaWQgMzItYml0IGZsb2F0c1xuKlxuKiBAcGFyYW0gdmFsdWVzIC0gQXJyYXkgb2YgbnVtYmVycyB0byBub3JtYWxpemVcbiogQHJldHVybnMgTm9ybWFsaXplZCBmbG9hdDMyIGFycmF5XG4qL1xuY29uc3Qgbm9ybWFsaXplVG9GbG9hdDMyID0gKHZhbHVlcykgPT4ge1xuXHRyZXR1cm4gQXJyYXkuZnJvbShuZXcgRmxvYXQzMkFycmF5KHZhbHVlcykpO1xufTtcbi8qKlxuKiBWYWxpZGF0ZXMgdmVjdG9yIGRpbWVuc2lvbnMgbWF0Y2ggZXhwZWN0ZWQgZGltZW5zaW9uXG4qIFRocm93cyBlcnJvciBpZiBkaW1lbnNpb25zIGRvbid0IG1hdGNoXG4qXG4qIEBwYXJhbSB2ZWN0b3IgLSBWZWN0b3IgZGF0YSB0byB2YWxpZGF0ZVxuKiBAcGFyYW0gZXhwZWN0ZWREaW1lbnNpb24gLSBFeHBlY3RlZCB2ZWN0b3IgZGltZW5zaW9uXG4qIEB0aHJvd3MgRXJyb3IgaWYgZGltZW5zaW9ucyBkb24ndCBtYXRjaFxuKi9cbmNvbnN0IHZhbGlkYXRlVmVjdG9yRGltZW5zaW9uID0gKHZlY3RvciwgZXhwZWN0ZWREaW1lbnNpb24pID0+IHtcblx0aWYgKGV4cGVjdGVkRGltZW5zaW9uICE9PSB2b2lkIDAgJiYgdmVjdG9yLmZsb2F0MzIubGVuZ3RoICE9PSBleHBlY3RlZERpbWVuc2lvbikgdGhyb3cgbmV3IEVycm9yKGBWZWN0b3IgZGltZW5zaW9uIG1pc21hdGNoOiBleHBlY3RlZCAke2V4cGVjdGVkRGltZW5zaW9ufSwgZ290ICR7dmVjdG9yLmZsb2F0MzIubGVuZ3RofWApO1xufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi92ZWN0b3JzL2ZldGNoLnRzXG4vKipcbiogRXh0cmFjdHMgZXJyb3IgbWVzc2FnZSBmcm9tIHZhcmlvdXMgZXJyb3IgcmVzcG9uc2UgZm9ybWF0c1xuKiBAcGFyYW0gZXJyIC0gRXJyb3Igb2JqZWN0IGZyb20gQVBJXG4qIEByZXR1cm5zIEh1bWFuLXJlYWRhYmxlIGVycm9yIG1lc3NhZ2VcbiovXG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycikgPT4gZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG4vKipcbiogSGFuZGxlcyBmZXRjaCBlcnJvcnMgYW5kIGNvbnZlcnRzIHRoZW0gdG8gU3RvcmFnZVZlY3RvcnMgZXJyb3IgdHlwZXNcbiogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIGNhdWdodCBmcm9tIGZldGNoXG4qIEBwYXJhbSByZWplY3QgLSBQcm9taXNlIHJlamVjdGlvbiBmdW5jdGlvblxuKiBAcGFyYW0gb3B0aW9ucyAtIEZldGNoIG9wdGlvbnMgdGhhdCBtYXkgYWZmZWN0IGVycm9yIGhhbmRsaW5nXG4qL1xuY29uc3QgaGFuZGxlRXJyb3IgPSBhc3luYyAoZXJyb3IsIHJlamVjdCwgb3B0aW9ucykgPT4ge1xuXHRpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIFwic3RhdHVzXCIgaW4gZXJyb3IgJiYgXCJva1wiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikpIHtcblx0XHRjb25zdCBzdGF0dXMgPSBlcnJvci5zdGF0dXMgfHwgNTAwO1xuXHRcdGNvbnN0IHJlc3BvbnNlRXJyb3IgPSBlcnJvcjtcblx0XHRpZiAodHlwZW9mIHJlc3BvbnNlRXJyb3IuanNvbiA9PT0gXCJmdW5jdGlvblwiKSByZXNwb25zZUVycm9yLmpzb24oKS50aGVuKChlcnIpID0+IHtcblx0XHRcdGNvbnN0IHN0YXR1c0NvZGUgPSAoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLnN0YXR1c0NvZGUpIHx8IChlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIuY29kZSkgfHwgc3RhdHVzICsgXCJcIjtcblx0XHRcdHJlamVjdChuZXcgU3RvcmFnZVZlY3RvcnNBcGlFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVyciksIHN0YXR1cywgc3RhdHVzQ29kZSkpO1xuXHRcdH0pLmNhdGNoKCgpID0+IHtcblx0XHRcdGNvbnN0IHN0YXR1c0NvZGUgPSBzdGF0dXMgKyBcIlwiO1xuXHRcdFx0cmVqZWN0KG5ldyBTdG9yYWdlVmVjdG9yc0FwaUVycm9yKHJlc3BvbnNlRXJyb3Iuc3RhdHVzVGV4dCB8fCBgSFRUUCAke3N0YXR1c30gZXJyb3JgLCBzdGF0dXMsIHN0YXR1c0NvZGUpKTtcblx0XHR9KTtcblx0XHRlbHNlIHtcblx0XHRcdGNvbnN0IHN0YXR1c0NvZGUgPSBzdGF0dXMgKyBcIlwiO1xuXHRcdFx0cmVqZWN0KG5ldyBTdG9yYWdlVmVjdG9yc0FwaUVycm9yKHJlc3BvbnNlRXJyb3Iuc3RhdHVzVGV4dCB8fCBgSFRUUCAke3N0YXR1c30gZXJyb3JgLCBzdGF0dXMsIHN0YXR1c0NvZGUpKTtcblx0XHR9XG5cdH0gZWxzZSByZWplY3QobmV3IFN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCBlcnJvcikpO1xufTtcbi8qKlxuKiBCdWlsZHMgcmVxdWVzdCBwYXJhbWV0ZXJzIGZvciBmZXRjaCBjYWxsc1xuKiBAcGFyYW0gbWV0aG9kIC0gSFRUUCBtZXRob2RcbiogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZmV0Y2ggb3B0aW9uc1xuKiBAcGFyYW0gcGFyYW1ldGVycyAtIEFkZGl0aW9uYWwgZmV0Y2ggcGFyYW1ldGVycyBsaWtlIEFib3J0U2lnbmFsXG4qIEBwYXJhbSBib2R5IC0gUmVxdWVzdCBib2R5ICh3aWxsIGJlIEpTT04gc3RyaW5naWZpZWQgaWYgcGxhaW4gb2JqZWN0KVxuKiBAcmV0dXJucyBDb21wbGV0ZSBmZXRjaCByZXF1ZXN0IHBhcmFtZXRlcnNcbiovXG5jb25zdCBfZ2V0UmVxdWVzdFBhcmFtcyA9IChtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpID0+IHtcblx0Y29uc3QgcGFyYW1zID0ge1xuXHRcdG1ldGhvZCxcblx0XHRoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9XG5cdH07XG5cdGlmIChtZXRob2QgPT09IFwiR0VUXCIgfHwgIWJvZHkpIHJldHVybiBwYXJhbXM7XG5cdGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG5cdFx0cGFyYW1zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMih7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcblx0XHRwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuXHR9IGVsc2UgcGFyYW1zLmJvZHkgPSBib2R5O1xuXHRyZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHBhcmFtcyksIHBhcmFtZXRlcnMpO1xufTtcbi8qKlxuKiBJbnRlcm5hbCByZXF1ZXN0IGhhbmRsZXIgdGhhdCB3cmFwcyBmZXRjaCB3aXRoIGVycm9yIGhhbmRsaW5nXG4qIEBwYXJhbSBmZXRjaGVyIC0gRmV0Y2ggZnVuY3Rpb24gdG8gdXNlXG4qIEBwYXJhbSBtZXRob2QgLSBIVFRQIG1ldGhvZFxuKiBAcGFyYW0gdXJsIC0gUmVxdWVzdCBVUkxcbiogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZmV0Y2ggb3B0aW9uc1xuKiBAcGFyYW0gcGFyYW1ldGVycyAtIEFkZGl0aW9uYWwgZmV0Y2ggcGFyYW1ldGVyc1xuKiBAcGFyYW0gYm9keSAtIFJlcXVlc3QgYm9keVxuKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcGFyc2VkIHJlc3BvbnNlIG9yIGVycm9yXG4qL1xuYXN5bmMgZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRmZXRjaGVyKHVybCwgX2dldFJlcXVlc3RQYXJhbXMobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSkudGhlbigocmVzdWx0KSA9PiB7XG5cdFx0XHRpZiAoIXJlc3VsdC5vaykgdGhyb3cgcmVzdWx0O1xuXHRcdFx0aWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uKSByZXR1cm4gcmVzdWx0O1xuXHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSByZXN1bHQuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG5cdFx0XHRpZiAoIWNvbnRlbnRUeXBlIHx8ICFjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHJldHVybiB7fTtcblx0XHRcdHJldHVybiByZXN1bHQuanNvbigpO1xuXHRcdH0pLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlRXJyb3IoZXJyb3IsIHJlamVjdCwgb3B0aW9ucykpO1xuXHR9KTtcbn1cbi8qKlxuKiBQZXJmb3JtcyBhIFBPU1QgcmVxdWVzdFxuKiBAcGFyYW0gZmV0Y2hlciAtIEZldGNoIGZ1bmN0aW9uIHRvIHVzZVxuKiBAcGFyYW0gdXJsIC0gUmVxdWVzdCBVUkxcbiogQHBhcmFtIGJvZHkgLSBSZXF1ZXN0IGJvZHkgdG8gYmUgSlNPTiBzdHJpbmdpZmllZFxuKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4qIEBwYXJhbSBwYXJhbWV0ZXJzIC0gQWRkaXRpb25hbCBmZXRjaCBwYXJhbWV0ZXJzXG4qIEByZXR1cm5zIFByb21pc2Ugd2l0aCBwYXJzZWQgcmVzcG9uc2VcbiovXG5hc3luYyBmdW5jdGlvbiBwb3N0KGZldGNoZXIsIHVybCwgYm9keSwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgXCJQT1NUXCIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9WZWN0b3JJbmRleEFwaS50c1xuLyoqXG4qIEBoaWRkZW5cbiogQmFzZSBpbXBsZW1lbnRhdGlvbiBmb3IgdmVjdG9yIGluZGV4IG9wZXJhdGlvbnMuXG4qIFVzZSB7QGxpbmsgVmVjdG9yQnVja2V0U2NvcGV9IHZpYSBgc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2J1Y2tldCcpYCBpbnN0ZWFkLlxuKi9cbnZhciBWZWN0b3JJbmRleEFwaSA9IGNsYXNzIHtcblx0LyoqIENyZWF0ZXMgYSBuZXcgVmVjdG9ySW5kZXhBcGkgaW5zdGFuY2UgKi9cblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGZldGNoJDEpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuXHRcdHRoaXMudXJsID0gdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcblx0XHR0aGlzLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9IRUFERVJTKSwgaGVhZGVycyk7XG5cdFx0dGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCQxKTtcblx0fVxuXHQvKiogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtIGluIHRoZSByZXNwb25zZSAqL1xuXHR0aHJvd09uRXJyb3IoKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKiBDcmVhdGVzIGEgbmV3IHZlY3RvciBpbmRleCB3aXRoaW4gYSBidWNrZXQgKi9cblx0YXN5bmMgY3JlYXRlSW5kZXgob3B0aW9ucykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vQ3JlYXRlSW5kZXhgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSkgfHwge30sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogUmV0cmlldmVzIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIHZlY3RvciBpbmRleCAqL1xuXHRhc3luYyBnZXRJbmRleCh2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczIuZmV0Y2gsIGAke190aGlzMi51cmx9L0dldEluZGV4YCwge1xuXHRcdFx0XHRcdHZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRcdFx0aW5kZXhOYW1lXG5cdFx0XHRcdH0sIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMyLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIExpc3RzIHZlY3RvciBpbmRleGVzIHdpdGhpbiBhIGJ1Y2tldCB3aXRoIG9wdGlvbmFsIGZpbHRlcmluZyBhbmQgcGFnaW5hdGlvbiAqL1xuXHRhc3luYyBsaXN0SW5kZXhlcyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMzLmZldGNoLCBgJHtfdGhpczMudXJsfS9MaXN0SW5kZXhlc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMzLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIERlbGV0ZXMgYSB2ZWN0b3IgaW5kZXggYW5kIGFsbCBpdHMgZGF0YSAqL1xuXHRhc3luYyBkZWxldGVJbmRleCh2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUpIHtcblx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczQuZmV0Y2gsIGAke190aGlzNC51cmx9L0RlbGV0ZUluZGV4YCwge1xuXHRcdFx0XHRcdHZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRcdFx0aW5kZXhOYW1lXG5cdFx0XHRcdH0sIHsgaGVhZGVyczogX3RoaXM0LmhlYWRlcnMgfSkgfHwge30sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM0LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9WZWN0b3JEYXRhQXBpLnRzXG4vKipcbiogQGhpZGRlblxuKiBCYXNlIGltcGxlbWVudGF0aW9uIGZvciB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zLlxuKiBVc2Uge0BsaW5rIFZlY3RvckluZGV4U2NvcGV9IHZpYSBgc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2J1Y2tldCcpLmluZGV4KCdpZHgnKWAgaW5zdGVhZC5cbiovXG52YXIgVmVjdG9yRGF0YUFwaSA9IGNsYXNzIHtcblx0LyoqIENyZWF0ZXMgYSBuZXcgVmVjdG9yRGF0YUFwaSBpbnN0YW5jZSAqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG5cdFx0dGhpcy51cmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXHRcdHRoaXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoJDEpO1xuXHR9XG5cdC8qKiBFbmFibGUgdGhyb3dpbmcgZXJyb3JzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0gaW4gdGhlIHJlc3BvbnNlICovXG5cdHRocm93T25FcnJvcigpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqIEluc2VydHMgb3IgdXBkYXRlcyB2ZWN0b3JzIGluIGJhdGNoICgxLTUwMCBwZXIgcmVxdWVzdCkgKi9cblx0YXN5bmMgcHV0VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0aWYgKG9wdGlvbnMudmVjdG9ycy5sZW5ndGggPCAxIHx8IG9wdGlvbnMudmVjdG9ycy5sZW5ndGggPiA1MDApIHRocm93IG5ldyBFcnJvcihcIlZlY3RvciBiYXRjaCBzaXplIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA1MDAgaXRlbXNcIik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L1B1dFZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSkgfHwge30sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogUmV0cmlldmVzIHZlY3RvcnMgYnkgdGhlaXIga2V5cyBpbiBiYXRjaCAqL1xuXHRhc3luYyBnZXRWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczIuZmV0Y2gsIGAke190aGlzMi51cmx9L0dldFZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzMi5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMi5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBMaXN0cyB2ZWN0b3JzIGluIGFuIGluZGV4IHdpdGggcGFnaW5hdGlvbiAqL1xuXHRhc3luYyBsaXN0VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChvcHRpb25zLnNlZ21lbnRDb3VudCAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdGlmIChvcHRpb25zLnNlZ21lbnRDb3VudCA8IDEgfHwgb3B0aW9ucy5zZWdtZW50Q291bnQgPiAxNikgdGhyb3cgbmV3IEVycm9yKFwic2VnbWVudENvdW50IG11c3QgYmUgYmV0d2VlbiAxIGFuZCAxNlwiKTtcblx0XHRcdFx0aWYgKG9wdGlvbnMuc2VnbWVudEluZGV4ICE9PSB2b2lkIDApIHtcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5zZWdtZW50SW5kZXggPCAwIHx8IG9wdGlvbnMuc2VnbWVudEluZGV4ID49IG9wdGlvbnMuc2VnbWVudENvdW50KSB0aHJvdyBuZXcgRXJyb3IoYHNlZ21lbnRJbmRleCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgJHtvcHRpb25zLnNlZ21lbnRDb3VudCAtIDF9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMzLmZldGNoLCBgJHtfdGhpczMudXJsfS9MaXN0VmVjdG9yc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMzLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIFF1ZXJpZXMgZm9yIHNpbWlsYXIgdmVjdG9ycyB1c2luZyBhcHByb3hpbWF0ZSBuZWFyZXN0IG5laWdoYm9yIHNlYXJjaCAqL1xuXHRhc3luYyBxdWVyeVZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vUXVlcnlWZWN0b3JzYCwgb3B0aW9ucywgeyBoZWFkZXJzOiBfdGhpczQuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczQuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogRGVsZXRlcyB2ZWN0b3JzIGJ5IHRoZWlyIGtleXMgaW4gYmF0Y2ggKDEtNTAwIHBlciByZXF1ZXN0KSAqL1xuXHRhc3luYyBkZWxldGVWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXM1ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0aWYgKG9wdGlvbnMua2V5cy5sZW5ndGggPCAxIHx8IG9wdGlvbnMua2V5cy5sZW5ndGggPiA1MDApIHRocm93IG5ldyBFcnJvcihcIktleXMgYmF0Y2ggc2l6ZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNTAwIGl0ZW1zXCIpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczUuZmV0Y2gsIGAke190aGlzNS51cmx9L0RlbGV0ZVZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzNS5oZWFkZXJzIH0pIHx8IHt9LFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNS5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlY3RvcnMvVmVjdG9yQnVja2V0QXBpLnRzXG4vKipcbiogQGhpZGRlblxuKiBCYXNlIGltcGxlbWVudGF0aW9uIGZvciB2ZWN0b3IgYnVja2V0IG9wZXJhdGlvbnMuXG4qIFVzZSB7QGxpbmsgU3RvcmFnZVZlY3RvcnNDbGllbnR9IHZpYSBgc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzYCBpbnN0ZWFkLlxuKi9cbnZhciBWZWN0b3JCdWNrZXRBcGkgPSBjbGFzcyB7XG5cdC8qKiBDcmVhdGVzIGEgbmV3IFZlY3RvckJ1Y2tldEFwaSBpbnN0YW5jZSAqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG5cdFx0dGhpcy51cmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXHRcdHRoaXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoJDEpO1xuXHR9XG5cdC8qKiBFbmFibGUgdGhyb3dpbmcgZXJyb3JzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0gaW4gdGhlIHJlc3BvbnNlICovXG5cdHRocm93T25FcnJvcigpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGJ1Y2tldCAqL1xuXHRhc3luYyBjcmVhdGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vQ3JlYXRlVmVjdG9yQnVja2V0YCwgeyB2ZWN0b3JCdWNrZXROYW1lIH0sIHsgaGVhZGVyczogX3RoaXMuaGVhZGVycyB9KSB8fCB7fSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBSZXRyaWV2ZXMgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgdmVjdG9yIGJ1Y2tldCAqL1xuXHRhc3luYyBnZXRCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzMi5mZXRjaCwgYCR7X3RoaXMyLnVybH0vR2V0VmVjdG9yQnVja2V0YCwgeyB2ZWN0b3JCdWNrZXROYW1lIH0sIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMyLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIExpc3RzIHZlY3RvciBidWNrZXRzIHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uICovXG5cdGFzeW5jIGxpc3RCdWNrZXRzKG9wdGlvbnMgPSB7fSkge1xuXHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzMy5mZXRjaCwgYCR7X3RoaXMzLnVybH0vTGlzdFZlY3RvckJ1Y2tldHNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzMy5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBEZWxldGVzIGEgdmVjdG9yIGJ1Y2tldCAobXVzdCBiZSBlbXB0eSBmaXJzdCkgKi9cblx0YXN5bmMgZGVsZXRlQnVja2V0KHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczQuZmV0Y2gsIGAke190aGlzNC51cmx9L0RlbGV0ZVZlY3RvckJ1Y2tldGAsIHsgdmVjdG9yQnVja2V0TmFtZSB9LCB7IGhlYWRlcnM6IF90aGlzNC5oZWFkZXJzIH0pIHx8IHt9LFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlY3RvcnMvU3RvcmFnZVZlY3RvcnNDbGllbnQudHNcbi8qKlxuKlxuKiBAYWxwaGFcbipcbiogTWFpbiBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggUzMgVmVjdG9ycyBBUElcbiogUHJvdmlkZXMgYWNjZXNzIHRvIGJ1Y2tldCwgaW5kZXgsIGFuZCB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zXG4qXG4qICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4qXG4qICoqVXNhZ2UgUGF0dGVybnM6KipcbipcbiogYGBgdHlwZXNjcmlwdFxuKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuKiAgLnN0b3JhZ2VcbiogIC52ZWN0b3JzXG4qICAuY3JlYXRlQnVja2V0KCdlbWJlZGRpbmdzLXByb2QnKVxuKlxuKiAvLyBBY2Nlc3MgaW5kZXggb3BlcmF0aW9ucyB2aWEgYnVja2V0c1xuKiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcbiogYXdhaXQgYnVja2V0LmNyZWF0ZUluZGV4KHtcbiogICBpbmRleE5hbWU6ICdkb2N1bWVudHMnLFxuKiAgIGRhdGFUeXBlOiAnZmxvYXQzMicsXG4qICAgZGltZW5zaW9uOiAxNTM2LFxuKiAgIGRpc3RhbmNlTWV0cmljOiAnY29zaW5lJ1xuKiB9KVxuKlxuKiAvLyBBY2Nlc3MgdmVjdG9yIG9wZXJhdGlvbnMgdmlhIGluZGV4XG4qIGNvbnN0IGluZGV4ID0gYnVja2V0LmluZGV4KCdkb2N1bWVudHMnKVxuKiBhd2FpdCBpbmRleC5wdXRWZWN0b3JzKHtcbiogICB2ZWN0b3JzOiBbXG4qICAgICB7IGtleTogJ2RvYy0xJywgZGF0YTogeyBmbG9hdDMyOiBbLi4uXSB9LCBtZXRhZGF0YTogeyB0aXRsZTogJ0ludHJvJyB9IH1cbiogICBdXG4qIH0pXG4qXG4qIC8vIFF1ZXJ5IHNpbWlsYXIgdmVjdG9yc1xuKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4LnF1ZXJ5VmVjdG9ycyh7XG4qICAgcXVlcnlWZWN0b3I6IHsgZmxvYXQzMjogWy4uLl0gfSxcbiogICB0b3BLOiA1LFxuKiAgIHJldHVybkRpc3RhbmNlOiB0cnVlXG4qIH0pXG4qIGBgYFxuKi9cbnZhciBTdG9yYWdlVmVjdG9yc0NsaWVudCA9IGNsYXNzIGV4dGVuZHMgVmVjdG9yQnVja2V0QXBpIHtcblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgU3RvcmFnZVZlY3RvcnNDbGllbnQgdGhhdCBjYW4gbWFuYWdlIGJ1Y2tldHMsIGluZGV4ZXMsIGFuZCB2ZWN0b3JzLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSB1cmwgLSBCYXNlIFVSTCBvZiB0aGUgU3RvcmFnZSBWZWN0b3JzIFJFU1QgQVBJLlxuXHQqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgLSBPcHRpb25hbCBoZWFkZXJzIChmb3IgZXhhbXBsZSBgQXV0aG9yaXphdGlvbmApIGFwcGxpZWQgdG8gZXZlcnkgcmVxdWVzdC5cblx0KiBAcGFyYW0gb3B0aW9ucy5mZXRjaCAtIE9wdGlvbmFsIGN1c3RvbSBgZmV0Y2hgIGltcGxlbWVudGF0aW9uIGZvciBub24tYnJvd3NlciBydW50aW1lcy5cblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGNsaWVudCA9IG5ldyBTdG9yYWdlVmVjdG9yc0NsaWVudCh1cmwsIG9wdGlvbnMpXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0c3VwZXIodXJsLCBvcHRpb25zLmhlYWRlcnMgfHwge30sIG9wdGlvbnMuZmV0Y2gpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBBY2Nlc3Mgb3BlcmF0aW9ucyBmb3IgYSBzcGVjaWZpYyB2ZWN0b3IgYnVja2V0XG5cdCogUmV0dXJucyBhIHNjb3BlZCBjbGllbnQgZm9yIGluZGV4IGFuZCB2ZWN0b3Igb3BlcmF0aW9ucyB3aXRoaW4gdGhlIGJ1Y2tldFxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSB2ZWN0b3JCdWNrZXROYW1lIC0gTmFtZSBvZiB0aGUgdmVjdG9yIGJ1Y2tldFxuXHQqIEByZXR1cm5zIEJ1Y2tldC1zY29wZWQgY2xpZW50IHdpdGggaW5kZXggYW5kIHZlY3RvciBvcGVyYXRpb25zXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBgYGBcblx0Ki9cblx0ZnJvbSh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWN0b3JCdWNrZXRTY29wZSh0aGlzLnVybCwgdGhpcy5oZWFkZXJzLCB2ZWN0b3JCdWNrZXROYW1lLCB0aGlzLmZldGNoKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQ3JlYXRlcyBhIG5ldyB2ZWN0b3IgYnVja2V0XG5cdCogVmVjdG9yIGJ1Y2tldHMgYXJlIGNvbnRhaW5lcnMgZm9yIHZlY3RvciBpbmRleGVzIGFuZCB0aGVpciBkYXRhXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIHZlY3RvckJ1Y2tldE5hbWUgLSBVbmlxdWUgbmFtZSBmb3IgdGhlIHZlY3RvciBidWNrZXRcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAudmVjdG9yc1xuXHQqICAgLmNyZWF0ZUJ1Y2tldCgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY3JlYXRlQnVja2V0KHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRDcmVhdGVCdWNrZXQgPSAoKSA9PiBzdXBlci5jcmVhdGVCdWNrZXQsIF90aGlzID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRDcmVhdGVCdWNrZXQoKS5jYWxsKF90aGlzLCB2ZWN0b3JCdWNrZXROYW1lKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUmV0cmlldmVzIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIHZlY3RvciBidWNrZXRcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gdmVjdG9yQnVja2V0TmFtZSAtIE5hbWUgb2YgdGhlIHZlY3RvciBidWNrZXRcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggYnVja2V0IG1ldGFkYXRhIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC52ZWN0b3JzXG5cdCogICAuZ2V0QnVja2V0KCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqXG5cdCogY29uc29sZS5sb2coJ0J1Y2tldCBjcmVhdGVkOicsIGRhdGE/LnZlY3RvckJ1Y2tldC5jcmVhdGlvblRpbWUpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGdldEJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0R2V0QnVja2V0ID0gKCkgPT4gc3VwZXIuZ2V0QnVja2V0LCBfdGhpczIgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldEdldEJ1Y2tldCgpLmNhbGwoX3RoaXMyLCB2ZWN0b3JCdWNrZXROYW1lKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogTGlzdHMgYWxsIHZlY3RvciBidWNrZXRzIHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBmaWx0ZXJzIChwcmVmaXgsIG1heFJlc3VsdHMsIG5leHRUb2tlbilcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggbGlzdCBvZiBidWNrZXRzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC52ZWN0b3JzXG5cdCogICAubGlzdEJ1Y2tldHMoeyBwcmVmaXg6ICdlbWJlZGRpbmdzLScgfSlcblx0KlxuXHQqIGRhdGE/LnZlY3RvckJ1Y2tldHMuZm9yRWFjaChidWNrZXQgPT4ge1xuXHQqICAgY29uc29sZS5sb2coYnVja2V0LnZlY3RvckJ1Y2tldE5hbWUpXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdEJ1Y2tldHMob3B0aW9ucyA9IHt9KSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0TGlzdEJ1Y2tldHMgPSAoKSA9PiBzdXBlci5saXN0QnVja2V0cywgX3RoaXMzID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRMaXN0QnVja2V0cygpLmNhbGwoX3RoaXMzLCBvcHRpb25zKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRGVsZXRlcyBhIHZlY3RvciBidWNrZXQgKGJ1Y2tldCBtdXN0IGJlIGVtcHR5KVxuXHQqIEFsbCBpbmRleGVzIG11c3QgYmUgZGVsZXRlZCBiZWZvcmUgZGVsZXRpbmcgdGhlIGJ1Y2tldFxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSB2ZWN0b3JCdWNrZXROYW1lIC0gTmFtZSBvZiB0aGUgdmVjdG9yIGJ1Y2tldCB0byBkZWxldGVcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAudmVjdG9yc1xuXHQqICAgLmRlbGV0ZUJ1Y2tldCgnZW1iZWRkaW5ncy1vbGQnKVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBkZWxldGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldERlbGV0ZUJ1Y2tldCA9ICgpID0+IHN1cGVyLmRlbGV0ZUJ1Y2tldCwgX3RoaXM0ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXREZWxldGVCdWNrZXQoKS5jYWxsKF90aGlzNCwgdmVjdG9yQnVja2V0TmFtZSk7XG5cdH1cbn07XG4vKipcbipcbiogQGFscGhhXG4qXG4qIFNjb3BlZCBjbGllbnQgZm9yIG9wZXJhdGlvbnMgd2l0aGluIGEgc3BlY2lmaWMgdmVjdG9yIGJ1Y2tldFxuKiBQcm92aWRlcyBpbmRleCBtYW5hZ2VtZW50IGFuZCBhY2Nlc3MgdG8gdmVjdG9yIG9wZXJhdGlvbnNcbipcbiogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbiovXG52YXIgVmVjdG9yQnVja2V0U2NvcGUgPSBjbGFzcyBleHRlbmRzIFZlY3RvckluZGV4QXBpIHtcblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgaGVscGVyIHRoYXQgYXV0b21hdGljYWxseSBzY29wZXMgYWxsIGluZGV4IG9wZXJhdGlvbnMgdG8gdGhlIHByb3ZpZGVkIGJ1Y2tldC5cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzLCB2ZWN0b3JCdWNrZXROYW1lLCBmZXRjaCQxKSB7XG5cdFx0c3VwZXIodXJsLCBoZWFkZXJzLCBmZXRjaCQxKTtcblx0XHR0aGlzLnZlY3RvckJ1Y2tldE5hbWUgPSB2ZWN0b3JCdWNrZXROYW1lO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgbmV3IHZlY3RvciBpbmRleCBpbiB0aGlzIGJ1Y2tldFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgdGhlIGJ1Y2tldCBuYW1lXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBJbmRleCBjb25maWd1cmF0aW9uICh2ZWN0b3JCdWNrZXROYW1lIGlzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBhd2FpdCBidWNrZXQuY3JlYXRlSW5kZXgoe1xuXHQqICAgaW5kZXhOYW1lOiAnZG9jdW1lbnRzLW9wZW5haScsXG5cdCogICBkYXRhVHlwZTogJ2Zsb2F0MzInLFxuXHQqICAgZGltZW5zaW9uOiAxNTM2LFxuXHQqICAgZGlzdGFuY2VNZXRyaWM6ICdjb3NpbmUnLFxuXHQqICAgbWV0YWRhdGFDb25maWd1cmF0aW9uOiB7XG5cdCogICAgIG5vbkZpbHRlcmFibGVNZXRhZGF0YUtleXM6IFsncmF3X3RleHQnXVxuXHQqICAgfVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZUluZGV4KG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRDcmVhdGVJbmRleCA9ICgpID0+IHN1cGVyLmNyZWF0ZUluZGV4LCBfdGhpczUgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldENyZWF0ZUluZGV4KCkuY2FsbChfdGhpczUsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHsgdmVjdG9yQnVja2V0TmFtZTogX3RoaXM1LnZlY3RvckJ1Y2tldE5hbWUgfSkpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBMaXN0cyBpbmRleGVzIGluIHRoaXMgYnVja2V0XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIExpc3Rpbmcgb3B0aW9ucyAodmVjdG9yQnVja2V0TmFtZSBpcyBhdXRvbWF0aWNhbGx5IHNldClcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBpbmRleGVzIGFycmF5IGFuZCBwYWdpbmF0aW9uIHRva2VuIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGJ1Y2tldC5saXN0SW5kZXhlcyh7IHByZWZpeDogJ2RvY3VtZW50cy0nIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGxpc3RJbmRleGVzKG9wdGlvbnMgPSB7fSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldExpc3RJbmRleGVzID0gKCkgPT4gc3VwZXIubGlzdEluZGV4ZXMsIF90aGlzNiA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0TGlzdEluZGV4ZXMoKS5jYWxsKF90aGlzNiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwgeyB2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczYudmVjdG9yQnVja2V0TmFtZSB9KSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIFJldHJpZXZlcyBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyBpbmRleCBpbiB0aGlzIGJ1Y2tldFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgdGhlIGJ1Y2tldCBuYW1lXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIHJldHJpZXZlXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGluZGV4IG1ldGFkYXRhIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGJ1Y2tldC5nZXRJbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG5cdCogY29uc29sZS5sb2coJ0RpbWVuc2lvbjonLCBkYXRhPy5pbmRleC5kaW1lbnNpb24pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGdldEluZGV4KGluZGV4TmFtZSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldEdldEluZGV4ID0gKCkgPT4gc3VwZXIuZ2V0SW5kZXgsIF90aGlzNyA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0R2V0SW5kZXgoKS5jYWxsKF90aGlzNywgX3RoaXM3LnZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIERlbGV0ZXMgYW4gaW5kZXggZnJvbSB0aGlzIGJ1Y2tldFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgdGhlIGJ1Y2tldCBuYW1lXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIGRlbGV0ZVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBidWNrZXQgPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcblx0KiBhd2FpdCBidWNrZXQuZGVsZXRlSW5kZXgoJ29sZC1pbmRleCcpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGRlbGV0ZUluZGV4KGluZGV4TmFtZSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldERlbGV0ZUluZGV4ID0gKCkgPT4gc3VwZXIuZGVsZXRlSW5kZXgsIF90aGlzOCA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0RGVsZXRlSW5kZXgoKS5jYWxsKF90aGlzOCwgX3RoaXM4LnZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIEFjY2VzcyBvcGVyYXRpb25zIGZvciBhIHNwZWNpZmljIGluZGV4IHdpdGhpbiB0aGlzIGJ1Y2tldFxuXHQqIFJldHVybnMgYSBzY29wZWQgY2xpZW50IGZvciB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4XG5cdCogQHJldHVybnMgSW5kZXgtc2NvcGVkIGNsaWVudCB3aXRoIHZlY3RvciBkYXRhIG9wZXJhdGlvbnNcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KlxuXHQqIC8vIEluc2VydCB2ZWN0b3JzXG5cdCogYXdhaXQgaW5kZXgucHV0VmVjdG9ycyh7XG5cdCogICB2ZWN0b3JzOiBbXG5cdCogICAgIHsga2V5OiAnZG9jLTEnLCBkYXRhOiB7IGZsb2F0MzI6IFsuLi5dIH0sIG1ldGFkYXRhOiB7IHRpdGxlOiAnSW50cm8nIH0gfVxuXHQqICAgXVxuXHQqIH0pXG5cdCpcblx0KiAvLyBRdWVyeSBzaW1pbGFyIHZlY3RvcnNcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4LnF1ZXJ5VmVjdG9ycyh7XG5cdCogICBxdWVyeVZlY3RvcjogeyBmbG9hdDMyOiBbLi4uXSB9LFxuXHQqICAgdG9wSzogNVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGluZGV4KGluZGV4TmFtZSkge1xuXHRcdHJldHVybiBuZXcgVmVjdG9ySW5kZXhTY29wZSh0aGlzLnVybCwgdGhpcy5oZWFkZXJzLCB0aGlzLnZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSwgdGhpcy5mZXRjaCk7XG5cdH1cbn07XG4vKipcbipcbiogQGFscGhhXG4qXG4qIFNjb3BlZCBjbGllbnQgZm9yIG9wZXJhdGlvbnMgd2l0aGluIGEgc3BlY2lmaWMgdmVjdG9yIGluZGV4XG4qIFByb3ZpZGVzIHZlY3RvciBkYXRhIG9wZXJhdGlvbnMgKHB1dCwgZ2V0LCBsaXN0LCBxdWVyeSwgZGVsZXRlKVxuKlxuKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuKi9cbnZhciBWZWN0b3JJbmRleFNjb3BlID0gY2xhc3MgZXh0ZW5kcyBWZWN0b3JEYXRhQXBpIHtcblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBoZWxwZXIgdGhhdCBhdXRvbWF0aWNhbGx5IHNjb3BlcyBhbGwgdmVjdG9yIG9wZXJhdGlvbnMgdG8gdGhlIHByb3ZpZGVkIGJ1Y2tldC9pbmRleCBuYW1lcy5cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBpbmRleCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKS5pbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycywgdmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lLCBmZXRjaCQxKSB7XG5cdFx0c3VwZXIodXJsLCBoZWFkZXJzLCBmZXRjaCQxKTtcblx0XHR0aGlzLnZlY3RvckJ1Y2tldE5hbWUgPSB2ZWN0b3JCdWNrZXROYW1lO1xuXHRcdHRoaXMuaW5kZXhOYW1lID0gaW5kZXhOYW1lO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBJbnNlcnRzIG9yIHVwZGF0ZXMgdmVjdG9ycyBpbiB0aGlzIGluZGV4XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBWZWN0b3IgaW5zZXJ0aW9uIG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBhd2FpdCBpbmRleC5wdXRWZWN0b3JzKHtcblx0KiAgIHZlY3RvcnM6IFtcblx0KiAgICAge1xuXHQqICAgICAgIGtleTogJ2RvYy0xJyxcblx0KiAgICAgICBkYXRhOiB7IGZsb2F0MzI6IFswLjEsIDAuMiwgLi4uXSB9LFxuXHQqICAgICAgIG1ldGFkYXRhOiB7IHRpdGxlOiAnSW50cm9kdWN0aW9uJywgcGFnZTogMSB9XG5cdCogICAgIH1cblx0KiAgIF1cblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBwdXRWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRQdXRWZWN0b3JzID0gKCkgPT4gc3VwZXIucHV0VmVjdG9ycywgX3RoaXM5ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRQdXRWZWN0b3JzKCkuY2FsbChfdGhpczksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHtcblx0XHRcdHZlY3RvckJ1Y2tldE5hbWU6IF90aGlzOS52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczkuaW5kZXhOYW1lXG5cdFx0fSkpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBSZXRyaWV2ZXMgdmVjdG9ycyBieSBrZXlzIGZyb20gdGhpcyBpbmRleFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgYnVja2V0IGFuZCBpbmRleCBuYW1lc1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIC0gVmVjdG9yIHJldHJpZXZhbCBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHZlY3RvcnMgYXJyYXkgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4LmdldFZlY3RvcnMoe1xuXHQqICAga2V5czogWydkb2MtMScsICdkb2MtMiddLFxuXHQqICAgcmV0dXJuTWV0YWRhdGE6IHRydWVcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBnZXRWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRHZXRWZWN0b3JzID0gKCkgPT4gc3VwZXIuZ2V0VmVjdG9ycywgX3RoaXMxMCA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0R2V0VmVjdG9ycygpLmNhbGwoX3RoaXMxMCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXMxMC52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczEwLmluZGV4TmFtZVxuXHRcdH0pKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogTGlzdHMgdmVjdG9ycyBpbiB0aGlzIGluZGV4IHdpdGggcGFnaW5hdGlvblxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgYnVja2V0IGFuZCBpbmRleCBuYW1lc1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIC0gTGlzdGluZyBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHZlY3RvcnMgYXJyYXkgYW5kIHBhZ2luYXRpb24gdG9rZW4gb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4Lmxpc3RWZWN0b3JzKHtcblx0KiAgIG1heFJlc3VsdHM6IDUwMCxcblx0KiAgIHJldHVybk1ldGFkYXRhOiB0cnVlXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdFZlY3RvcnMob3B0aW9ucyA9IHt9KSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0TGlzdFZlY3RvcnMgPSAoKSA9PiBzdXBlci5saXN0VmVjdG9ycywgX3RoaXMxMSA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0TGlzdFZlY3RvcnMoKS5jYWxsKF90aGlzMTEsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHtcblx0XHRcdHZlY3RvckJ1Y2tldE5hbWU6IF90aGlzMTEudmVjdG9yQnVja2V0TmFtZSxcblx0XHRcdGluZGV4TmFtZTogX3RoaXMxMS5pbmRleE5hbWVcblx0XHR9KSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIFF1ZXJpZXMgZm9yIHNpbWlsYXIgdmVjdG9ycyBpbiB0aGlzIGluZGV4XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBRdWVyeSBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIG1hdGNoZXMgYXJyYXkgb2Ygc2ltaWxhciB2ZWN0b3JzIG9yZGVyZWQgYnkgZGlzdGFuY2Ugb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4LnF1ZXJ5VmVjdG9ycyh7XG5cdCogICBxdWVyeVZlY3RvcjogeyBmbG9hdDMyOiBbMC4xLCAwLjIsIC4uLl0gfSxcblx0KiAgIHRvcEs6IDUsXG5cdCogICBmaWx0ZXI6IHsgY2F0ZWdvcnk6ICd0ZWNobmljYWwnIH0sXG5cdCogICByZXR1cm5EaXN0YW5jZTogdHJ1ZSxcblx0KiAgIHJldHVybk1ldGFkYXRhOiB0cnVlXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgcXVlcnlWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRRdWVyeVZlY3RvcnMgPSAoKSA9PiBzdXBlci5xdWVyeVZlY3RvcnMsIF90aGlzMTIgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldFF1ZXJ5VmVjdG9ycygpLmNhbGwoX3RoaXMxMiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXMxMi52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczEyLmluZGV4TmFtZVxuXHRcdH0pKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRGVsZXRlcyB2ZWN0b3JzIGJ5IGtleXMgZnJvbSB0aGlzIGluZGV4XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBEZWxldGlvbiBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBpbmRleCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKS5pbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG5cdCogYXdhaXQgaW5kZXguZGVsZXRlVmVjdG9ycyh7XG5cdCogICBrZXlzOiBbJ2RvYy0xJywgJ2RvYy0yJywgJ2RvYy0zJ11cblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBkZWxldGVWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXREZWxldGVWZWN0b3JzID0gKCkgPT4gc3VwZXIuZGVsZXRlVmVjdG9ycywgX3RoaXMxMyA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0RGVsZXRlVmVjdG9ycygpLmNhbGwoX3RoaXMxMywgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXMxMy52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczEzLmluZGV4TmFtZVxuXHRcdH0pKTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1N0b3JhZ2VDbGllbnQudHNcbnZhciBTdG9yYWdlQ2xpZW50ID0gY2xhc3MgZXh0ZW5kcyBTdG9yYWdlQnVja2V0QXBpIHtcblx0LyoqXG5cdCogQ3JlYXRlcyBhIGNsaWVudCBmb3IgU3RvcmFnZSBidWNrZXRzLCBmaWxlcywgYW5hbHl0aWNzLCBhbmQgdmVjdG9ycy5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHRzXG5cdCogaW1wb3J0IHsgU3RvcmFnZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdG9yYWdlLWpzJ1xuXHQqXG5cdCogY29uc3Qgc3RvcmFnZSA9IG5ldyBTdG9yYWdlQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vc3RvcmFnZS92MScsIHtcblx0KiAgIGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScsXG5cdCogfSlcblx0KiBjb25zdCBhdmF0YXJzID0gc3RvcmFnZS5mcm9tKCdhdmF0YXJzJylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGZldGNoJDEsIG9wdHMpIHtcblx0XHRzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoJDEsIG9wdHMpO1xuXHR9XG5cdC8qKlxuXHQqIFBlcmZvcm0gZmlsZSBvcGVyYXRpb24gaW4gYSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIFRoZSBidWNrZXQgaWQgdG8gb3BlcmF0ZSBvbi5cblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGF2YXRhcnMgPSBzdXBhYmFzZS5zdG9yYWdlLmZyb20oJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqL1xuXHRmcm9tKGlkKSB7XG5cdFx0cmV0dXJuIG5ldyBTdG9yYWdlRmlsZUFwaSh0aGlzLnVybCwgdGhpcy5oZWFkZXJzLCBpZCwgdGhpcy5mZXRjaCk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIEFjY2VzcyB2ZWN0b3Igc3RvcmFnZSBvcGVyYXRpb25zLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEByZXR1cm5zIEEgU3RvcmFnZVZlY3RvcnNDbGllbnQgaW5zdGFuY2UgY29uZmlndXJlZCB3aXRoIHRoZSBjdXJyZW50IHN0b3JhZ2Ugc2V0dGluZ3MuXG5cdCovXG5cdGdldCB2ZWN0b3JzKCkge1xuXHRcdHJldHVybiBuZXcgU3RvcmFnZVZlY3RvcnNDbGllbnQodGhpcy51cmwgKyBcIi92ZWN0b3JcIiwge1xuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0ZmV0Y2g6IHRoaXMuZmV0Y2hcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQWNjZXNzIGFuYWx5dGljcyBzdG9yYWdlIG9wZXJhdGlvbnMgdXNpbmcgSWNlYmVyZyB0YWJsZXMuXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHJldHVybnMgQSBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50IGluc3RhbmNlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgY3VycmVudCBzdG9yYWdlIHNldHRpbmdzLlxuXHQqL1xuXHRnZXQgYW5hbHl0aWNzKCkge1xuXHRcdHJldHVybiBuZXcgU3RvcmFnZUFuYWx5dGljc0NsaWVudCh0aGlzLnVybCArIFwiL2ljZWJlcmdcIiwgdGhpcy5oZWFkZXJzLCB0aGlzLmZldGNoKTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50LCBTdG9yYWdlQXBpRXJyb3IsIFN0b3JhZ2VDbGllbnQsIFN0b3JhZ2VFcnJvciwgU3RvcmFnZVVua25vd25FcnJvciwgU3RvcmFnZVZlY3RvcnNBcGlFcnJvciwgU3RvcmFnZVZlY3RvcnNDbGllbnQsIFN0b3JhZ2VWZWN0b3JzRXJyb3IsIFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlLCBTdG9yYWdlVmVjdG9yc1Vua25vd25FcnJvciwgVmVjdG9yQnVja2V0QXBpLCBWZWN0b3JCdWNrZXRTY29wZSwgVmVjdG9yRGF0YUFwaSwgVmVjdG9ySW5kZXhBcGksIFZlY3RvckluZGV4U2NvcGUsIGlzUGxhaW5PYmplY3QsIGlzU3RvcmFnZUVycm9yLCBpc1N0b3JhZ2VWZWN0b3JzRXJyb3IsIG5vcm1hbGl6ZVRvRmxvYXQzMiwgcmVzb2x2ZUZldGNoLCByZXNvbHZlUmVzcG9uc2UsIHZhbGlkYXRlVmVjdG9yRGltZW5zaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIkljZWJlcmdSZXN0Q2F0YWxvZyIsIlN0b3JhZ2VFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiX19pc1N0b3JhZ2VFcnJvciIsIm5hbWUiLCJpc1N0b3JhZ2VFcnJvciIsImVycm9yIiwiU3RvcmFnZUFwaUVycm9yIiwic3RhdHVzIiwic3RhdHVzQ29kZSIsInRvSlNPTiIsIlN0b3JhZ2VVbmtub3duRXJyb3IiLCJvcmlnaW5hbEVycm9yIiwicmVzb2x2ZUZldGNoJDEiLCJjdXN0b21GZXRjaCIsImFyZ3MiLCJmZXRjaCIsInJlc29sdmVSZXNwb25zZSQxIiwiUmVzcG9uc2UiLCJyZWN1cnNpdmVUb0NhbWVsIiwiaXRlbSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImVsIiwiT2JqZWN0IiwicmVzdWx0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsIm5ld0tleSIsInJlcGxhY2UiLCJjIiwidG9VcHBlckNhc2UiLCJpc1BsYWluT2JqZWN0JDEiLCJwcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiaXRlcmF0b3IiLCJpc1ZhbGlkQnVja2V0TmFtZSIsImJ1Y2tldE5hbWUiLCJsZW5ndGgiLCJ0cmltIiwiaW5jbHVkZXMiLCJ0ZXN0IiwiX3R5cGVvZiIsIm8iLCJvJDEiLCJ0b1ByaW1pdGl2ZSIsInQiLCJyIiwiZSIsImkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwidG9Qcm9wZXJ0eUtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJyJDEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkMiIsImFyZ3VtZW50cyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2dldEVycm9yTWVzc2FnZSQxIiwiZXJyIiwiX2VyciRlcnJvciIsIm1zZyIsImVycm9yX2Rlc2NyaXB0aW9uIiwiSlNPTiIsInN0cmluZ2lmeSIsImhhbmRsZUVycm9yJDEiLCJyZWplY3QiLCJvcHRpb25zIiwibm9SZXNvbHZlSnNvbiIsImpzb24iLCJ0aGVuIiwiY2F0Y2giLCJfZ2V0UmVxdWVzdFBhcmFtcyQxIiwibWV0aG9kIiwicGFyYW1ldGVycyIsImJvZHkiLCJwYXJhbXMiLCJoZWFkZXJzIiwiZHVwbGV4IiwiX2hhbmRsZVJlcXVlc3QkMSIsImZldGNoZXIiLCJ1cmwiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm9rIiwiZGF0YSIsImdldCIsInBvc3QkMSIsInB1dCIsImhlYWQiLCJyZW1vdmUiLCJTdHJlYW1Eb3dubG9hZEJ1aWxkZXIiLCJkb3dubG9hZEZuIiwic2hvdWxkVGhyb3dPbkVycm9yIiwib25mdWxmaWxsZWQiLCJvbnJlamVjdGVkIiwiZXhlY3V0ZSIsIl90aGlzIiwiX1N5bWJvbCR0b1N0cmluZ1RhZyIsIkJsb2JEb3dubG9hZEJ1aWxkZXIiLCJwcm9taXNlIiwiYXNTdHJlYW0iLCJnZXRQcm9taXNlIiwiZmluYWxseSIsIm9uZmluYWxseSIsImJsb2IiLCJERUZBVUxUX1NFQVJDSF9PUFRJT05TIiwibGltaXQiLCJvZmZzZXQiLCJzb3J0QnkiLCJjb2x1bW4iLCJvcmRlciIsIkRFRkFVTFRfRklMRV9PUFRJT05TIiwiY2FjaGVDb250cm9sIiwiY29udGVudFR5cGUiLCJ1cHNlcnQiLCJTdG9yYWdlRmlsZUFwaSIsImJ1Y2tldElkIiwiZmV0Y2gkMSIsInRocm93T25FcnJvciIsInVwbG9hZE9yVXBkYXRlIiwicGF0aCIsImZpbGVCb2R5IiwiZmlsZU9wdGlvbnMiLCJtZXRhZGF0YSIsIkJsb2IiLCJGb3JtRGF0YSIsImFwcGVuZCIsImVuY29kZU1ldGFkYXRhIiwiaGFzIiwidG9CYXNlNjQiLCJSZWFkYWJsZVN0cmVhbSIsInBpcGUiLCJjbGVhblBhdGgiLCJfcmVtb3ZlRW1wdHlGb2xkZXJzIiwiX3BhdGgiLCJfZ2V0RmluYWxQYXRoIiwiaWQiLCJJZCIsImZ1bGxQYXRoIiwiS2V5IiwidXBsb2FkIiwidXBsb2FkVG9TaWduZWRVcmwiLCJ0b2tlbiIsIl90aGlzMyIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInNldCIsInRvU3RyaW5nIiwiY3JlYXRlU2lnbmVkVXBsb2FkVXJsIiwiX3RoaXM0Iiwic2lnbmVkVXJsIiwidXBkYXRlIiwibW92ZSIsImZyb21QYXRoIiwidG9QYXRoIiwiX3RoaXM2Iiwic291cmNlS2V5IiwiZGVzdGluYXRpb25LZXkiLCJkZXN0aW5hdGlvbkJ1Y2tldCIsImNvcHkiLCJfdGhpczciLCJjcmVhdGVTaWduZWRVcmwiLCJleHBpcmVzSW4iLCJfdGhpczgiLCJ0cmFuc2Zvcm0iLCJkb3dubG9hZFF1ZXJ5UGFyYW0iLCJkb3dubG9hZCIsImVuY29kZVVSSSIsInNpZ25lZFVSTCIsImNyZWF0ZVNpZ25lZFVybHMiLCJwYXRocyIsIl90aGlzOSIsImRhdHVtIiwicmVuZGVyUGF0aCIsInRyYW5zZm9ybWF0aW9uUXVlcnkiLCJ0cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZyIsInF1ZXJ5U3RyaW5nIiwiaW5mbyIsIl90aGlzMTAiLCJleGlzdHMiLCJfdGhpczExIiwiZ2V0UHVibGljVXJsIiwiX3F1ZXJ5U3RyaW5nIiwiam9pbiIsInB1YmxpY1VybCIsIl90aGlzMTIiLCJwcmVmaXhlcyIsImxpc3QiLCJfdGhpczEzIiwicHJlZml4IiwibGlzdFYyIiwiX3RoaXMxNCIsIkJ1ZmZlciIsImZyb20iLCJidG9hIiwid2lkdGgiLCJoZWlnaHQiLCJyZXNpemUiLCJmb3JtYXQiLCJxdWFsaXR5IiwidmVyc2lvbiIsIkRFRkFVTFRfSEVBREVSUyQxIiwiU3RvcmFnZUJ1Y2tldEFwaSIsIm9wdHMiLCJiYXNlVXJsIiwidXNlTmV3SG9zdG5hbWUiLCJob3N0bmFtZSIsImhyZWYiLCJsaXN0QnVja2V0cyIsImxpc3RCdWNrZXRPcHRpb25zVG9RdWVyeVN0cmluZyIsImdldEJ1Y2tldCIsIl90aGlzMiIsImNyZWF0ZUJ1Y2tldCIsInB1YmxpYyIsInR5cGUiLCJmaWxlX3NpemVfbGltaXQiLCJmaWxlU2l6ZUxpbWl0IiwiYWxsb3dlZF9taW1lX3R5cGVzIiwiYWxsb3dlZE1pbWVUeXBlcyIsInVwZGF0ZUJ1Y2tldCIsImVtcHR5QnVja2V0IiwiX3RoaXM1IiwiZGVsZXRlQnVja2V0Iiwic2VhcmNoIiwic29ydENvbHVtbiIsInNvcnRPcmRlciIsIlVSTFNlYXJjaFBhcmFtcyIsIlN0b3JhZ2VBbmFseXRpY3NDbGllbnQiLCJxdWVyeVBhcmFtcyIsImNhdGFsb2ciLCJjYXRhbG9nTmFtZSIsImF1dGgiLCJnZXRIZWFkZXJzIiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwiREVGQVVMVF9IRUFERVJTIiwiU3RvcmFnZVZlY3RvcnNFcnJvciIsIl9faXNTdG9yYWdlVmVjdG9yc0Vycm9yIiwiaXNTdG9yYWdlVmVjdG9yc0Vycm9yIiwiU3RvcmFnZVZlY3RvcnNBcGlFcnJvciIsIlN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yIiwiU3RvcmFnZVZlY3RvcnNFcnJvckNvZGUiLCJTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxIiwicmVzb2x2ZUZldGNoIiwicmVzb2x2ZVJlc3BvbnNlIiwiaXNQbGFpbk9iamVjdCIsIm5vcm1hbGl6ZVRvRmxvYXQzMiIsInZhbHVlcyIsIkZsb2F0MzJBcnJheSIsInZhbGlkYXRlVmVjdG9yRGltZW5zaW9uIiwidmVjdG9yIiwiZXhwZWN0ZWREaW1lbnNpb24iLCJmbG9hdDMyIiwiX2dldEVycm9yTWVzc2FnZSIsImhhbmRsZUVycm9yIiwicmVzcG9uc2VFcnJvciIsImNvZGUiLCJzdGF0dXNUZXh0IiwiX2dldFJlcXVlc3RQYXJhbXMiLCJfaGFuZGxlUmVxdWVzdCIsInBvc3QiLCJWZWN0b3JJbmRleEFwaSIsImNyZWF0ZUluZGV4IiwiZ2V0SW5kZXgiLCJ2ZWN0b3JCdWNrZXROYW1lIiwiaW5kZXhOYW1lIiwibGlzdEluZGV4ZXMiLCJkZWxldGVJbmRleCIsIlZlY3RvckRhdGFBcGkiLCJwdXRWZWN0b3JzIiwidmVjdG9ycyIsImdldFZlY3RvcnMiLCJsaXN0VmVjdG9ycyIsInNlZ21lbnRDb3VudCIsInNlZ21lbnRJbmRleCIsInF1ZXJ5VmVjdG9ycyIsImRlbGV0ZVZlY3RvcnMiLCJWZWN0b3JCdWNrZXRBcGkiLCJTdG9yYWdlVmVjdG9yc0NsaWVudCIsIlZlY3RvckJ1Y2tldFNjb3BlIiwiX3N1cGVycHJvcF9nZXRDcmVhdGVCdWNrZXQiLCJfc3VwZXJwcm9wX2dldEdldEJ1Y2tldCIsIl9zdXBlcnByb3BfZ2V0TGlzdEJ1Y2tldHMiLCJfc3VwZXJwcm9wX2dldERlbGV0ZUJ1Y2tldCIsIl9zdXBlcnByb3BfZ2V0Q3JlYXRlSW5kZXgiLCJfc3VwZXJwcm9wX2dldExpc3RJbmRleGVzIiwiX3N1cGVycHJvcF9nZXRHZXRJbmRleCIsIl9zdXBlcnByb3BfZ2V0RGVsZXRlSW5kZXgiLCJpbmRleCIsIlZlY3RvckluZGV4U2NvcGUiLCJfc3VwZXJwcm9wX2dldFB1dFZlY3RvcnMiLCJfc3VwZXJwcm9wX2dldEdldFZlY3RvcnMiLCJfc3VwZXJwcm9wX2dldExpc3RWZWN0b3JzIiwiX3N1cGVycHJvcF9nZXRRdWVyeVZlY3RvcnMiLCJfc3VwZXJwcm9wX2dldERlbGV0ZVZlY3RvcnMiLCJTdG9yYWdlQ2xpZW50IiwiYW5hbHl0aWNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/storage-js/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/supabase-js/dist/index.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/index.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionRegion: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_4__.FunctionRegion),\n/* harmony export */   FunctionsError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_4__.FunctionsError),\n/* harmony export */   FunctionsFetchError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_4__.FunctionsFetchError),\n/* harmony export */   FunctionsHttpError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_4__.FunctionsHttpError),\n/* harmony export */   FunctionsRelayError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_4__.FunctionsRelayError),\n/* harmony export */   PostgrestError: () => (/* reexport safe */ _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__.PostgrestError),\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeChannel),\n/* harmony export */   RealtimeClient: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeClient),\n/* harmony export */   RealtimePresence: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimePresence),\n/* harmony export */   SupabaseClient: () => (/* binding */ SupabaseClient),\n/* harmony export */   WebSocketFactory: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.WebSocketFactory),\n/* harmony export */   __esModule: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.__esModule),\n/* harmony export */   createClient: () => (/* binding */ createClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @supabase/functions-js */ \"(rsc)/./node_modules/@supabase/functions-js/dist/main/index.js\");\n/* harmony import */ var _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/postgrest-js */ \"(rsc)/./node_modules/@supabase/postgrest-js/dist/index.mjs\");\n/* harmony import */ var _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/realtime-js */ \"(rsc)/./node_modules/@supabase/realtime-js/dist/main/index.js\");\n/* harmony import */ var _supabase_storage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @supabase/storage-js */ \"(rsc)/./node_modules/@supabase/storage-js/dist/index.mjs\");\n/* harmony import */ var _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/auth-js */ \"(rsc)/./node_modules/@supabase/auth-js/dist/main/index.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__) if([\"default\",\"FunctionRegion\",\"FunctionsError\",\"FunctionsFetchError\",\"FunctionsHttpError\",\"FunctionsRelayError\",\"PostgrestError\",\"SupabaseClient\",\"createClient\",\"REALTIME_CHANNEL_STATES\",\"REALTIME_LISTEN_TYPES\",\"REALTIME_POSTGRES_CHANGES_LISTEN_EVENT\",\"REALTIME_PRESENCE_LISTEN_EVENTS\",\"REALTIME_SUBSCRIBE_STATES\",\"RealtimeChannel\",\"RealtimeClient\",\"RealtimePresence\",\"WebSocketFactory\",\"__esModule\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n\n\n\n\n//#region src/lib/version.ts\nconst version = \"2.91.0\";\n//#endregion\n//#region src/lib/constants.ts\nlet JS_ENV = \"\";\nif (typeof Deno !== \"undefined\") JS_ENV = \"deno\";\nelse if (typeof document !== \"undefined\") JS_ENV = \"web\";\nelse if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") JS_ENV = \"react-native\";\nelse JS_ENV = \"node\";\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `supabase-js-${JS_ENV}/${version}`\n};\nconst DEFAULT_GLOBAL_OPTIONS = {\n    headers: DEFAULT_HEADERS\n};\nconst DEFAULT_DB_OPTIONS = {\n    schema: \"public\"\n};\nconst DEFAULT_AUTH_OPTIONS = {\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    flowType: \"implicit\"\n};\nconst DEFAULT_REALTIME_OPTIONS = {};\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n        return typeof o$1;\n    } : function(o$1) {\n        return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, _typeof(o);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n    var i = toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r$1) {\n            return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n            _defineProperty(e, r$1, t[r$1]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n            Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n        });\n    }\n    return e;\n}\n//#endregion\n//#region src/lib/fetch.ts\nconst resolveFetch = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\nconst resolveHeadersConstructor = ()=>{\n    return Headers;\n};\nconst fetchWithAuth = (supabaseKey, getAccessToken, customFetch)=>{\n    const fetch$1 = resolveFetch(customFetch);\n    const HeadersConstructor = resolveHeadersConstructor();\n    return async (input, init)=>{\n        var _await$getAccessToken;\n        const accessToken = (_await$getAccessToken = await getAccessToken()) !== null && _await$getAccessToken !== void 0 ? _await$getAccessToken : supabaseKey;\n        let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n        if (!headers.has(\"apikey\")) headers.set(\"apikey\", supabaseKey);\n        if (!headers.has(\"Authorization\")) headers.set(\"Authorization\", `Bearer ${accessToken}`);\n        return fetch$1(input, _objectSpread2(_objectSpread2({}, init), {}, {\n            headers\n        }));\n    };\n};\n//#endregion\n//#region src/lib/helpers.ts\nfunction ensureTrailingSlash(url) {\n    return url.endsWith(\"/\") ? url : url + \"/\";\n}\nfunction applySettingDefaults(options, defaults) {\n    var _DEFAULT_GLOBAL_OPTIO, _globalOptions$header;\n    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;\n    const { db: DEFAULT_DB_OPTIONS$1, auth: DEFAULT_AUTH_OPTIONS$1, realtime: DEFAULT_REALTIME_OPTIONS$1, global: DEFAULT_GLOBAL_OPTIONS$1 } = defaults;\n    const result = {\n        db: _objectSpread2(_objectSpread2({}, DEFAULT_DB_OPTIONS$1), dbOptions),\n        auth: _objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS$1), authOptions),\n        realtime: _objectSpread2(_objectSpread2({}, DEFAULT_REALTIME_OPTIONS$1), realtimeOptions),\n        storage: {},\n        global: _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_GLOBAL_OPTIONS$1), globalOptions), {}, {\n            headers: _objectSpread2(_objectSpread2({}, (_DEFAULT_GLOBAL_OPTIO = DEFAULT_GLOBAL_OPTIONS$1 === null || DEFAULT_GLOBAL_OPTIONS$1 === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS$1.headers) !== null && _DEFAULT_GLOBAL_OPTIO !== void 0 ? _DEFAULT_GLOBAL_OPTIO : {}), (_globalOptions$header = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _globalOptions$header !== void 0 ? _globalOptions$header : {})\n        }),\n        accessToken: async ()=>\"\"\n    };\n    if (options.accessToken) result.accessToken = options.accessToken;\n    else delete result.accessToken;\n    return result;\n}\n/**\n* Validates a Supabase client URL\n*\n* @param {string} supabaseUrl - The Supabase client URL string.\n* @returns {URL} - The validated base URL.\n* @throws {Error}\n*/ function validateSupabaseUrl(supabaseUrl) {\n    const trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();\n    if (!trimmedUrl) throw new Error(\"supabaseUrl is required.\");\n    if (!trimmedUrl.match(/^https?:\\/\\//i)) throw new Error(\"Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.\");\n    try {\n        return new URL(ensureTrailingSlash(trimmedUrl));\n    } catch (_unused) {\n        throw Error(\"Invalid supabaseUrl: Provided URL is malformed.\");\n    }\n}\n//#endregion\n//#region src/lib/SupabaseAuthClient.ts\nvar SupabaseAuthClient = class extends _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthClient {\n    constructor(options){\n        super(options);\n    }\n};\n//#endregion\n//#region src/SupabaseClient.ts\n/**\n* Supabase Client.\n*\n* An isomorphic Javascript client for interacting with Postgres.\n*/ var SupabaseClient = class {\n    /**\n\t* Create a new client for use in the browser.\n\t* @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n\t* @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n\t* @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n\t* @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n\t* @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n\t* @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n\t* @param options.realtime Options passed along to realtime-js constructor.\n\t* @param options.storage Options passed along to the storage-js constructor.\n\t* @param options.global.fetch A custom fetch implementation.\n\t* @param options.global.headers Any additional headers to send with each network request.\n\t* @example\n\t* ```ts\n\t* import { createClient } from '@supabase/supabase-js'\n\t*\n\t* const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')\n\t* const { data } = await supabase.from('profiles').select('*')\n\t* ```\n\t*/ constructor(supabaseUrl, supabaseKey, options){\n        var _settings$auth$storag, _settings$global$head;\n        this.supabaseUrl = supabaseUrl;\n        this.supabaseKey = supabaseKey;\n        const baseUrl = validateSupabaseUrl(supabaseUrl);\n        if (!supabaseKey) throw new Error(\"supabaseKey is required.\");\n        this.realtimeUrl = new URL(\"realtime/v1\", baseUrl);\n        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace(\"http\", \"ws\");\n        this.authUrl = new URL(\"auth/v1\", baseUrl);\n        this.storageUrl = new URL(\"storage/v1\", baseUrl);\n        this.functionsUrl = new URL(\"functions/v1\", baseUrl);\n        const defaultStorageKey = `sb-${baseUrl.hostname.split(\".\")[0]}-auth-token`;\n        const DEFAULTS = {\n            db: DEFAULT_DB_OPTIONS,\n            realtime: DEFAULT_REALTIME_OPTIONS,\n            auth: _objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS), {}, {\n                storageKey: defaultStorageKey\n            }),\n            global: DEFAULT_GLOBAL_OPTIONS\n        };\n        const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n        this.storageKey = (_settings$auth$storag = settings.auth.storageKey) !== null && _settings$auth$storag !== void 0 ? _settings$auth$storag : \"\";\n        this.headers = (_settings$global$head = settings.global.headers) !== null && _settings$global$head !== void 0 ? _settings$global$head : {};\n        if (!settings.accessToken) {\n            var _settings$auth;\n            this.auth = this._initSupabaseAuthClient((_settings$auth = settings.auth) !== null && _settings$auth !== void 0 ? _settings$auth : {}, this.headers, settings.global.fetch);\n        } else {\n            this.accessToken = settings.accessToken;\n            this.auth = new Proxy({}, {\n                get: (_, prop)=>{\n                    throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);\n                }\n            });\n        }\n        this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);\n        this.realtime = this._initRealtimeClient(_objectSpread2({\n            headers: this.headers,\n            accessToken: this._getAccessToken.bind(this)\n        }, settings.realtime));\n        if (this.accessToken) Promise.resolve(this.accessToken()).then((token)=>this.realtime.setAuth(token)).catch((e)=>console.warn(\"Failed to set initial Realtime auth token:\", e));\n        this.rest = new _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__.PostgrestClient(new URL(\"rest/v1\", baseUrl).href, {\n            headers: this.headers,\n            schema: settings.db.schema,\n            fetch: this.fetch\n        });\n        this.storage = new _supabase_storage_js__WEBPACK_IMPORTED_MODULE_3__.StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);\n        if (!settings.accessToken) this._listenForAuthEvents();\n    }\n    /**\n\t* Supabase Functions allows you to deploy and invoke edge functions.\n\t*/ get functions() {\n        return new _supabase_functions_js__WEBPACK_IMPORTED_MODULE_4__.FunctionsClient(this.functionsUrl.href, {\n            headers: this.headers,\n            customFetch: this.fetch\n        });\n    }\n    /**\n\t* Perform a query on a table or a view.\n\t*\n\t* @param relation - The table or view name to query\n\t*/ from(relation) {\n        return this.rest.from(relation);\n    }\n    /**\n\t* Select a schema to query or perform an function (rpc) call.\n\t*\n\t* The schema needs to be on the list of exposed schemas inside Supabase.\n\t*\n\t* @param schema - The schema to query\n\t*/ schema(schema) {\n        return this.rest.schema(schema);\n    }\n    /**\n\t* Perform a function call.\n\t*\n\t* @param fn - The function name to call\n\t* @param args - The arguments to pass to the function call\n\t* @param options - Named parameters\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t* @param options.get - When set to `true`, the function will be called with\n\t* read-only access mode.\n\t* @param options.count - Count algorithm to use to count rows returned by the\n\t* function. Only applicable for [set-returning\n\t* functions](https://www.postgresql.org/docs/current/functions-srf.html).\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ rpc(fn, args = {}, options = {\n        head: false,\n        get: false,\n        count: void 0\n    }) {\n        return this.rest.rpc(fn, args, options);\n    }\n    /**\n\t* Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n\t*\n\t* @param {string} name - The name of the Realtime channel.\n\t* @param {Object} opts - The options to pass to the Realtime channel.\n\t*\n\t*/ channel(name, opts = {\n        config: {}\n    }) {\n        return this.realtime.channel(name, opts);\n    }\n    /**\n\t* Returns all Realtime channels.\n\t*/ getChannels() {\n        return this.realtime.getChannels();\n    }\n    /**\n\t* Unsubscribes and removes Realtime channel from Realtime client.\n\t*\n\t* @param {RealtimeChannel} channel - The name of the Realtime channel.\n\t*\n\t*/ removeChannel(channel) {\n        return this.realtime.removeChannel(channel);\n    }\n    /**\n\t* Unsubscribes and removes all Realtime channels from Realtime client.\n\t*/ removeAllChannels() {\n        return this.realtime.removeAllChannels();\n    }\n    async _getAccessToken() {\n        var _this = this;\n        var _data$session$access_, _data$session;\n        if (_this.accessToken) return await _this.accessToken();\n        const { data } = await _this.auth.getSession();\n        return (_data$session$access_ = (_data$session = data.session) === null || _data$session === void 0 ? void 0 : _data$session.access_token) !== null && _data$session$access_ !== void 0 ? _data$session$access_ : _this.supabaseKey;\n    }\n    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug, throwOnError }, headers, fetch$1) {\n        const authHeaders = {\n            Authorization: `Bearer ${this.supabaseKey}`,\n            apikey: `${this.supabaseKey}`\n        };\n        return new SupabaseAuthClient({\n            url: this.authUrl.href,\n            headers: _objectSpread2(_objectSpread2({}, authHeaders), headers),\n            storageKey,\n            autoRefreshToken,\n            persistSession,\n            detectSessionInUrl,\n            storage,\n            userStorage,\n            flowType,\n            lock,\n            debug,\n            throwOnError,\n            fetch: fetch$1,\n            hasCustomAuthorizationHeader: Object.keys(this.headers).some((key)=>key.toLowerCase() === \"authorization\")\n        });\n    }\n    _initRealtimeClient(options) {\n        return new _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeClient(this.realtimeUrl.href, _objectSpread2(_objectSpread2({}, options), {}, {\n            params: _objectSpread2(_objectSpread2({}, {\n                apikey: this.supabaseKey\n            }), options === null || options === void 0 ? void 0 : options.params)\n        }));\n    }\n    _listenForAuthEvents() {\n        return this.auth.onAuthStateChange((event, session)=>{\n            this._handleTokenChanged(event, \"CLIENT\", session === null || session === void 0 ? void 0 : session.access_token);\n        });\n    }\n    _handleTokenChanged(event, source, token) {\n        if ((event === \"TOKEN_REFRESHED\" || event === \"SIGNED_IN\") && this.changedAccessToken !== token) {\n            this.changedAccessToken = token;\n            this.realtime.setAuth(token);\n        } else if (event === \"SIGNED_OUT\") {\n            this.realtime.setAuth();\n            if (source == \"STORAGE\") this.auth.signOut();\n            this.changedAccessToken = void 0;\n        }\n    }\n};\n//#endregion\n//#region src/index.ts\n/**\n* Creates a new Supabase Client.\n*\n* @example\n* ```ts\n* import { createClient } from '@supabase/supabase-js'\n*\n* const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')\n* const { data, error } = await supabase.from('profiles').select('*')\n* ```\n*/ const createClient = (supabaseUrl, supabaseKey, options)=>{\n    return new SupabaseClient(supabaseUrl, supabaseKey, options);\n};\nfunction shouldShowDeprecationWarning() {\n    if (false) {}\n    const _process = globalThis[\"process\"];\n    if (!_process) return false;\n    const processVersion = _process[\"version\"];\n    if (processVersion === void 0 || processVersion === null) return false;\n    const versionMatch = processVersion.match(/^v(\\d+)\\./);\n    if (!versionMatch) return false;\n    return parseInt(versionMatch[1], 10) <= 18;\n}\nif (shouldShowDeprecationWarning()) console.warn(\"  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217\");\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVKO0FBQzlFO0FBQ2xCO0FBQ0Y7QUFDTjtBQUVWO0FBRUo7QUFFakMsNEJBQTRCO0FBQzVCLE1BQU1XLFVBQVU7QUFFaEIsWUFBWTtBQUNaLDhCQUE4QjtBQUM5QixJQUFJQyxTQUFTO0FBQ2IsSUFBSSxPQUFPQyxTQUFTLGFBQWFELFNBQVM7S0FDckMsSUFBSSxPQUFPRSxhQUFhLGFBQWFGLFNBQVM7S0FDOUMsSUFBSSxPQUFPRyxjQUFjLGVBQWVBLFVBQVVDLE9BQU8sS0FBSyxlQUFlSixTQUFTO0tBQ3RGQSxTQUFTO0FBQ2QsTUFBTUssa0JBQWtCO0lBQUUsaUJBQWlCLENBQUMsWUFBWSxFQUFFTCxPQUFPLENBQUMsRUFBRUQsUUFBUSxDQUFDO0FBQUM7QUFDOUUsTUFBTU8seUJBQXlCO0lBQUVDLFNBQVNGO0FBQWdCO0FBQzFELE1BQU1HLHFCQUFxQjtJQUFFQyxRQUFRO0FBQVM7QUFDOUMsTUFBTUMsdUJBQXVCO0lBQzVCQyxrQkFBa0I7SUFDbEJDLGdCQUFnQjtJQUNoQkMsb0JBQW9CO0lBQ3BCQyxVQUFVO0FBQ1g7QUFDQSxNQUFNQywyQkFBMkIsQ0FBQztBQUVsQyxZQUFZO0FBQ1osMERBQTBEO0FBQzFELFNBQVNDLFFBQVFDLENBQUM7SUFDakI7SUFDQSxPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFTQyxHQUFHO1FBQ2hHLE9BQU8sT0FBT0E7SUFDZixJQUFJLFNBQVNBLEdBQUc7UUFDZixPQUFPQSxPQUFPLGNBQWMsT0FBT0YsVUFBVUUsSUFBSUMsV0FBVyxLQUFLSCxVQUFVRSxRQUFRRixPQUFPSSxTQUFTLEdBQUcsV0FBVyxPQUFPRjtJQUN6SCxHQUFHSixRQUFRQztBQUNaO0FBRUEsWUFBWTtBQUNaLCtEQUErRDtBQUMvRCxTQUFTTSxZQUFZQyxDQUFDLEVBQUVDLENBQUM7SUFDeEIsSUFBSSxZQUFZVCxRQUFRUSxNQUFNLENBQUNBLEdBQUcsT0FBT0E7SUFDekMsSUFBSUUsSUFBSUYsQ0FBQyxDQUFDTixPQUFPSyxXQUFXLENBQUM7SUFDN0IsSUFBSSxLQUFLLE1BQU1HLEdBQUc7UUFDakIsSUFBSUMsSUFBSUQsRUFBRUUsSUFBSSxDQUFDSixHQUFHQyxLQUFLO1FBQ3ZCLElBQUksWUFBWVQsUUFBUVcsSUFBSSxPQUFPQTtRQUNuQyxNQUFNLElBQUlFLFVBQVU7SUFDckI7SUFDQSxPQUFPLENBQUMsYUFBYUosSUFBSUssU0FBU0MsTUFBSyxFQUFHUDtBQUMzQztBQUVBLFlBQVk7QUFDWixpRUFBaUU7QUFDakUsU0FBU1EsY0FBY1IsQ0FBQztJQUN2QixJQUFJRyxJQUFJSixZQUFZQyxHQUFHO0lBQ3ZCLE9BQU8sWUFBWVIsUUFBUVcsS0FBS0EsSUFBSUEsSUFBSTtBQUN6QztBQUVBLFlBQVk7QUFDWixrRUFBa0U7QUFDbEUsU0FBU00sZ0JBQWdCUCxDQUFDLEVBQUVELENBQUMsRUFBRUQsQ0FBQztJQUMvQixPQUFPLENBQUNDLElBQUlPLGNBQWNQLEVBQUMsS0FBTUMsSUFBSVEsT0FBT0MsY0FBYyxDQUFDVCxHQUFHRCxHQUFHO1FBQ2hFVyxPQUFPWjtRQUNQYSxZQUFZLENBQUM7UUFDYkMsY0FBYyxDQUFDO1FBQ2ZDLFVBQVUsQ0FBQztJQUNaLEtBQUtiLENBQUMsQ0FBQ0QsRUFBRSxHQUFHRCxHQUFHRTtBQUNoQjtBQUVBLFlBQVk7QUFDWixpRUFBaUU7QUFDakUsU0FBU2MsUUFBUWQsQ0FBQyxFQUFFRCxDQUFDO0lBQ3BCLElBQUlELElBQUlVLE9BQU9PLElBQUksQ0FBQ2Y7SUFDcEIsSUFBSVEsT0FBT1EscUJBQXFCLEVBQUU7UUFDakMsSUFBSXpCLElBQUlpQixPQUFPUSxxQkFBcUIsQ0FBQ2hCO1FBQ3JDRCxLQUFNUixDQUFBQSxJQUFJQSxFQUFFMEIsTUFBTSxDQUFDLFNBQVNDLEdBQUc7WUFDOUIsT0FBT1YsT0FBT1csd0JBQXdCLENBQUNuQixHQUFHa0IsS0FBS1AsVUFBVTtRQUMxRCxFQUFDLEdBQUliLEVBQUVzQixJQUFJLENBQUNDLEtBQUssQ0FBQ3ZCLEdBQUdQO0lBQ3RCO0lBQ0EsT0FBT087QUFDUjtBQUNBLFNBQVN3QixlQUFldEIsQ0FBQztJQUN4QixJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSXdCLFVBQVVDLE1BQU0sRUFBRXpCLElBQUs7UUFDMUMsSUFBSUQsSUFBSSxRQUFReUIsU0FBUyxDQUFDeEIsRUFBRSxHQUFHd0IsU0FBUyxDQUFDeEIsRUFBRSxHQUFHLENBQUM7UUFDL0NBLElBQUksSUFBSWUsUUFBUU4sT0FBT1YsSUFBSSxDQUFDLEdBQUcyQixPQUFPLENBQUMsU0FBU1AsR0FBRztZQUNsRFgsZ0JBQWdCUCxHQUFHa0IsS0FBS3BCLENBQUMsQ0FBQ29CLElBQUk7UUFDL0IsS0FBS1YsT0FBT2tCLHlCQUF5QixHQUFHbEIsT0FBT21CLGdCQUFnQixDQUFDM0IsR0FBR1EsT0FBT2tCLHlCQUF5QixDQUFDNUIsTUFBTWdCLFFBQVFOLE9BQU9WLElBQUkyQixPQUFPLENBQUMsU0FBU1AsR0FBRztZQUNoSlYsT0FBT0MsY0FBYyxDQUFDVCxHQUFHa0IsS0FBS1YsT0FBT1csd0JBQXdCLENBQUNyQixHQUFHb0I7UUFDbEU7SUFDRDtJQUNBLE9BQU9sQjtBQUNSO0FBRUEsWUFBWTtBQUNaLDBCQUEwQjtBQUMxQixNQUFNNEIsZUFBZSxDQUFDQztJQUNyQixJQUFJQSxhQUFhLE9BQU8sQ0FBQyxHQUFHQyxPQUFTRCxlQUFlQztJQUNwRCxPQUFPLENBQUMsR0FBR0EsT0FBU0MsU0FBU0Q7QUFDOUI7QUFDQSxNQUFNRSw0QkFBNEI7SUFDakMsT0FBT0M7QUFDUjtBQUNBLE1BQU1DLGdCQUFnQixDQUFDQyxhQUFhQyxnQkFBZ0JQO0lBQ25ELE1BQU1RLFVBQVVULGFBQWFDO0lBQzdCLE1BQU1TLHFCQUFxQk47SUFDM0IsT0FBTyxPQUFPTyxPQUFPQztRQUNwQixJQUFJQztRQUNKLE1BQU1DLGNBQWMsQ0FBQ0Qsd0JBQXdCLE1BQU1MLGdCQUFlLE1BQU8sUUFBUUssMEJBQTBCLEtBQUssSUFBSUEsd0JBQXdCTjtRQUM1SSxJQUFJdEQsVUFBVSxJQUFJeUQsbUJBQW1CRSxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBSzNELE9BQU87UUFDN0YsSUFBSSxDQUFDQSxRQUFROEQsR0FBRyxDQUFDLFdBQVc5RCxRQUFRK0QsR0FBRyxDQUFDLFVBQVVUO1FBQ2xELElBQUksQ0FBQ3RELFFBQVE4RCxHQUFHLENBQUMsa0JBQWtCOUQsUUFBUStELEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUVGLFlBQVksQ0FBQztRQUN2RixPQUFPTCxRQUFRRSxPQUFPakIsZUFBZUEsZUFBZSxDQUFDLEdBQUdrQixPQUFPLENBQUMsR0FBRztZQUFFM0Q7UUFBUTtJQUM5RTtBQUNEO0FBRUEsWUFBWTtBQUNaLDRCQUE0QjtBQUM1QixTQUFTZ0Usb0JBQW9CQyxHQUFHO0lBQy9CLE9BQU9BLElBQUlDLFFBQVEsQ0FBQyxPQUFPRCxNQUFNQSxNQUFNO0FBQ3hDO0FBQ0EsU0FBU0UscUJBQXFCQyxPQUFPLEVBQUVDLFFBQVE7SUFDOUMsSUFBSUMsdUJBQXVCQztJQUMzQixNQUFNLEVBQUVDLElBQUlDLFNBQVMsRUFBRUMsTUFBTUMsV0FBVyxFQUFFQyxVQUFVQyxlQUFlLEVBQUVDLFFBQVFDLGFBQWEsRUFBRSxHQUFHWDtJQUMvRixNQUFNLEVBQUVJLElBQUlRLG9CQUFvQixFQUFFTixNQUFNTyxzQkFBc0IsRUFBRUwsVUFBVU0sMEJBQTBCLEVBQUVKLFFBQVFLLHdCQUF3QixFQUFFLEdBQUdkO0lBQzNJLE1BQU1lLFNBQVM7UUFDZFosSUFBSS9CLGVBQWVBLGVBQWUsQ0FBQyxHQUFHdUMsdUJBQXVCUDtRQUM3REMsTUFBTWpDLGVBQWVBLGVBQWUsQ0FBQyxHQUFHd0MseUJBQXlCTjtRQUNqRUMsVUFBVW5DLGVBQWVBLGVBQWUsQ0FBQyxHQUFHeUMsNkJBQTZCTDtRQUN6RVEsU0FBUyxDQUFDO1FBQ1ZQLFFBQVFyQyxlQUFlQSxlQUFlQSxlQUFlLENBQUMsR0FBRzBDLDJCQUEyQkosZ0JBQWdCLENBQUMsR0FBRztZQUFFL0UsU0FBU3lDLGVBQWVBLGVBQWUsQ0FBQyxHQUFHLENBQUM2Qix3QkFBd0JhLDZCQUE2QixRQUFRQSw2QkFBNkIsS0FBSyxJQUFJLEtBQUssSUFBSUEseUJBQXlCbkYsT0FBTyxNQUFNLFFBQVFzRSwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0IsQ0FBQyxJQUFJLENBQUNDLHdCQUF3QlEsa0JBQWtCLFFBQVFBLGtCQUFrQixLQUFLLElBQUksS0FBSyxJQUFJQSxjQUFjL0UsT0FBTyxNQUFNLFFBQVF1RSwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0IsQ0FBQztRQUFHO1FBQ3ppQlYsYUFBYSxVQUFZO0lBQzFCO0lBQ0EsSUFBSU8sUUFBUVAsV0FBVyxFQUFFdUIsT0FBT3ZCLFdBQVcsR0FBR08sUUFBUVAsV0FBVztTQUM1RCxPQUFPdUIsT0FBT3ZCLFdBQVc7SUFDOUIsT0FBT3VCO0FBQ1I7QUFDQTs7Ozs7O0FBTUEsR0FDQSxTQUFTRSxvQkFBb0JDLFdBQVc7SUFDdkMsTUFBTUMsYUFBYUQsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLElBQUksS0FBSyxJQUFJQSxZQUFZRSxJQUFJO0lBQzdGLElBQUksQ0FBQ0QsWUFBWSxNQUFNLElBQUlFLE1BQU07SUFDakMsSUFBSSxDQUFDRixXQUFXRyxLQUFLLENBQUMsa0JBQWtCLE1BQU0sSUFBSUQsTUFBTTtJQUN4RCxJQUFJO1FBQ0gsT0FBTyxJQUFJRSxJQUFJNUIsb0JBQW9Cd0I7SUFDcEMsRUFBRSxPQUFPSyxTQUFTO1FBQ2pCLE1BQU1ILE1BQU07SUFDYjtBQUNEO0FBRUEsWUFBWTtBQUNaLHVDQUF1QztBQUN2QyxJQUFJSSxxQkFBcUIsY0FBY3ZHLHlEQUFVQTtJQUNoRHVCLFlBQVlzRCxPQUFPLENBQUU7UUFDcEIsS0FBSyxDQUFDQTtJQUNQO0FBQ0Q7QUFFQSxZQUFZO0FBQ1osK0JBQStCO0FBQy9COzs7O0FBSUEsR0FDQSxJQUFJMkIsaUJBQWlCO0lBQ3BCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJBLEdBQ0FqRixZQUFZeUUsV0FBVyxFQUFFakMsV0FBVyxFQUFFYyxPQUFPLENBQUU7UUFDOUMsSUFBSTRCLHVCQUF1QkM7UUFDM0IsSUFBSSxDQUFDVixXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ2pDLFdBQVcsR0FBR0E7UUFDbkIsTUFBTTRDLFVBQVVaLG9CQUFvQkM7UUFDcEMsSUFBSSxDQUFDakMsYUFBYSxNQUFNLElBQUlvQyxNQUFNO1FBQ2xDLElBQUksQ0FBQ1MsV0FBVyxHQUFHLElBQUlQLElBQUksZUFBZU07UUFDMUMsSUFBSSxDQUFDQyxXQUFXLENBQUNDLFFBQVEsR0FBRyxJQUFJLENBQUNELFdBQVcsQ0FBQ0MsUUFBUSxDQUFDQyxPQUFPLENBQUMsUUFBUTtRQUN0RSxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJVixJQUFJLFdBQVdNO1FBQ2xDLElBQUksQ0FBQ0ssVUFBVSxHQUFHLElBQUlYLElBQUksY0FBY007UUFDeEMsSUFBSSxDQUFDTSxZQUFZLEdBQUcsSUFBSVosSUFBSSxnQkFBZ0JNO1FBQzVDLE1BQU1PLG9CQUFvQixDQUFDLEdBQUcsRUFBRVAsUUFBUVEsUUFBUSxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUM7UUFDM0UsTUFBTUMsV0FBVztZQUNoQnBDLElBQUl2RTtZQUNKMkUsVUFBVXBFO1lBQ1ZrRSxNQUFNakMsZUFBZUEsZUFBZSxDQUFDLEdBQUd0Qyx1QkFBdUIsQ0FBQyxHQUFHO2dCQUFFMEcsWUFBWUo7WUFBa0I7WUFDbkczQixRQUFRL0U7UUFDVDtRQUNBLE1BQU0rRyxXQUFXM0MscUJBQXFCQyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJQSxVQUFVLENBQUMsR0FBR3dDO1FBQzdGLElBQUksQ0FBQ0MsVUFBVSxHQUFHLENBQUNiLHdCQUF3QmMsU0FBU3BDLElBQUksQ0FBQ21DLFVBQVUsTUFBTSxRQUFRYiwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0I7UUFDNUksSUFBSSxDQUFDaEcsT0FBTyxHQUFHLENBQUNpRyx3QkFBd0JhLFNBQVNoQyxNQUFNLENBQUM5RSxPQUFPLE1BQU0sUUFBUWlHLDBCQUEwQixLQUFLLElBQUlBLHdCQUF3QixDQUFDO1FBQ3pJLElBQUksQ0FBQ2EsU0FBU2pELFdBQVcsRUFBRTtZQUMxQixJQUFJa0Q7WUFDSixJQUFJLENBQUNyQyxJQUFJLEdBQUcsSUFBSSxDQUFDc0MsdUJBQXVCLENBQUMsQ0FBQ0QsaUJBQWlCRCxTQUFTcEMsSUFBSSxNQUFNLFFBQVFxQyxtQkFBbUIsS0FBSyxJQUFJQSxpQkFBaUIsQ0FBQyxHQUFHLElBQUksQ0FBQy9HLE9BQU8sRUFBRThHLFNBQVNoQyxNQUFNLENBQUM1QixLQUFLO1FBQzNLLE9BQU87WUFDTixJQUFJLENBQUNXLFdBQVcsR0FBR2lELFNBQVNqRCxXQUFXO1lBQ3ZDLElBQUksQ0FBQ2EsSUFBSSxHQUFHLElBQUl1QyxNQUFNLENBQUMsR0FBRztnQkFBRUMsS0FBSyxDQUFDQyxHQUFHQztvQkFDcEMsTUFBTSxJQUFJMUIsTUFBTSxDQUFDLDBHQUEwRyxFQUFFbkUsT0FBTzZGLE1BQU0sZ0JBQWdCLENBQUM7Z0JBQzVKO1lBQUU7UUFDSDtRQUNBLElBQUksQ0FBQ2xFLEtBQUssR0FBR0csY0FBY0MsYUFBYSxJQUFJLENBQUMrRCxlQUFlLENBQUNDLElBQUksQ0FBQyxJQUFJLEdBQUdSLFNBQVNoQyxNQUFNLENBQUM1QixLQUFLO1FBQzlGLElBQUksQ0FBQzBCLFFBQVEsR0FBRyxJQUFJLENBQUMyQyxtQkFBbUIsQ0FBQzlFLGVBQWU7WUFDdkR6QyxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQjZELGFBQWEsSUFBSSxDQUFDd0QsZUFBZSxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUM1QyxHQUFHUixTQUFTbEMsUUFBUTtRQUNwQixJQUFJLElBQUksQ0FBQ2YsV0FBVyxFQUFFMkQsUUFBUUMsT0FBTyxDQUFDLElBQUksQ0FBQzVELFdBQVcsSUFBSTZELElBQUksQ0FBQyxDQUFDQyxRQUFVLElBQUksQ0FBQy9DLFFBQVEsQ0FBQ2dELE9BQU8sQ0FBQ0QsUUFBUUUsS0FBSyxDQUFDLENBQUMxRyxJQUFNMkcsUUFBUUMsSUFBSSxDQUFDLDhDQUE4QzVHO1FBQ2hMLElBQUksQ0FBQzZHLElBQUksR0FBRyxJQUFJN0ksbUVBQWVBLENBQUMsSUFBSXlHLElBQUksV0FBV00sU0FBUytCLElBQUksRUFBRTtZQUNqRWpJLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCRSxRQUFRNEcsU0FBU3RDLEVBQUUsQ0FBQ3RFLE1BQU07WUFDMUJnRCxPQUFPLElBQUksQ0FBQ0EsS0FBSztRQUNsQjtRQUNBLElBQUksQ0FBQ21DLE9BQU8sR0FBRyxJQUFJL0YsK0RBQWFBLENBQUMsSUFBSSxDQUFDaUgsVUFBVSxDQUFDMEIsSUFBSSxFQUFFLElBQUksQ0FBQ2pJLE9BQU8sRUFBRSxJQUFJLENBQUNrRCxLQUFLLEVBQUVrQixZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUWlCLE9BQU87UUFDbEosSUFBSSxDQUFDeUIsU0FBU2pELFdBQVcsRUFBRSxJQUFJLENBQUNxRSxvQkFBb0I7SUFDckQ7SUFDQTs7Q0FFQSxHQUNBLElBQUlDLFlBQVk7UUFDZixPQUFPLElBQUlySixtRUFBZUEsQ0FBQyxJQUFJLENBQUMwSCxZQUFZLENBQUN5QixJQUFJLEVBQUU7WUFDbERqSSxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQmdELGFBQWEsSUFBSSxDQUFDRSxLQUFLO1FBQ3hCO0lBQ0Q7SUFDQTs7OztDQUlBLEdBQ0FrRixLQUFLQyxRQUFRLEVBQUU7UUFDZCxPQUFPLElBQUksQ0FBQ0wsSUFBSSxDQUFDSSxJQUFJLENBQUNDO0lBQ3ZCO0lBQ0E7Ozs7OztDQU1BLEdBQ0FuSSxPQUFPQSxNQUFNLEVBQUU7UUFDZCxPQUFPLElBQUksQ0FBQzhILElBQUksQ0FBQzlILE1BQU0sQ0FBQ0E7SUFDekI7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQSxHQUNBb0ksSUFBSUMsRUFBRSxFQUFFdEYsT0FBTyxDQUFDLENBQUMsRUFBRW1CLFVBQVU7UUFDNUJvRSxNQUFNO1FBQ050QixLQUFLO1FBQ0x1QixPQUFPLEtBQUs7SUFDYixDQUFDLEVBQUU7UUFDRixPQUFPLElBQUksQ0FBQ1QsSUFBSSxDQUFDTSxHQUFHLENBQUNDLElBQUl0RixNQUFNbUI7SUFDaEM7SUFDQTs7Ozs7O0NBTUEsR0FDQXNFLFFBQVFDLElBQUksRUFBRUMsT0FBTztRQUFFQyxRQUFRLENBQUM7SUFBRSxDQUFDLEVBQUU7UUFDcEMsT0FBTyxJQUFJLENBQUNqRSxRQUFRLENBQUM4RCxPQUFPLENBQUNDLE1BQU1DO0lBQ3BDO0lBQ0E7O0NBRUEsR0FDQUUsY0FBYztRQUNiLE9BQU8sSUFBSSxDQUFDbEUsUUFBUSxDQUFDa0UsV0FBVztJQUNqQztJQUNBOzs7OztDQUtBLEdBQ0FDLGNBQWNMLE9BQU8sRUFBRTtRQUN0QixPQUFPLElBQUksQ0FBQzlELFFBQVEsQ0FBQ21FLGFBQWEsQ0FBQ0w7SUFDcEM7SUFDQTs7Q0FFQSxHQUNBTSxvQkFBb0I7UUFDbkIsT0FBTyxJQUFJLENBQUNwRSxRQUFRLENBQUNvRSxpQkFBaUI7SUFDdkM7SUFDQSxNQUFNM0Isa0JBQWtCO1FBQ3ZCLElBQUk0QixRQUFRLElBQUk7UUFDaEIsSUFBSUMsdUJBQXVCQztRQUMzQixJQUFJRixNQUFNcEYsV0FBVyxFQUFFLE9BQU8sTUFBTW9GLE1BQU1wRixXQUFXO1FBQ3JELE1BQU0sRUFBRXVGLElBQUksRUFBRSxHQUFHLE1BQU1ILE1BQU12RSxJQUFJLENBQUMyRSxVQUFVO1FBQzVDLE9BQU8sQ0FBQ0gsd0JBQXdCLENBQUNDLGdCQUFnQkMsS0FBS0UsT0FBTyxNQUFNLFFBQVFILGtCQUFrQixLQUFLLElBQUksS0FBSyxJQUFJQSxjQUFjSSxZQUFZLE1BQU0sUUFBUUwsMEJBQTBCLEtBQUssSUFBSUEsd0JBQXdCRCxNQUFNM0YsV0FBVztJQUNwTztJQUNBMEQsd0JBQXdCLEVBQUU1RyxnQkFBZ0IsRUFBRUMsY0FBYyxFQUFFQyxrQkFBa0IsRUFBRStFLE9BQU8sRUFBRW1FLFdBQVcsRUFBRTNDLFVBQVUsRUFBRXRHLFFBQVEsRUFBRWtKLElBQUksRUFBRUMsS0FBSyxFQUFFQyxZQUFZLEVBQUUsRUFBRTNKLE9BQU8sRUFBRXdELE9BQU8sRUFBRTtRQUMxSyxNQUFNb0csY0FBYztZQUNuQkMsZUFBZSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUN2RyxXQUFXLENBQUMsQ0FBQztZQUMzQ3dHLFFBQVEsQ0FBQyxFQUFFLElBQUksQ0FBQ3hHLFdBQVcsQ0FBQyxDQUFDO1FBQzlCO1FBQ0EsT0FBTyxJQUFJd0MsbUJBQW1CO1lBQzdCN0IsS0FBSyxJQUFJLENBQUNxQyxPQUFPLENBQUMyQixJQUFJO1lBQ3RCakksU0FBU3lDLGVBQWVBLGVBQWUsQ0FBQyxHQUFHbUgsY0FBYzVKO1lBQ3pENkc7WUFDQXpHO1lBQ0FDO1lBQ0FDO1lBQ0ErRTtZQUNBbUU7WUFDQWpKO1lBQ0FrSjtZQUNBQztZQUNBQztZQUNBekcsT0FBT007WUFDUHVHLDhCQUE4QnBJLE9BQU9PLElBQUksQ0FBQyxJQUFJLENBQUNsQyxPQUFPLEVBQUVnSyxJQUFJLENBQUMsQ0FBQ0MsTUFBUUEsSUFBSUMsV0FBVyxPQUFPO1FBQzdGO0lBQ0Q7SUFDQTNDLG9CQUFvQm5ELE9BQU8sRUFBRTtRQUM1QixPQUFPLElBQUkvRSxpRUFBY0EsQ0FBQyxJQUFJLENBQUM4RyxXQUFXLENBQUM4QixJQUFJLEVBQUV4RixlQUFlQSxlQUFlLENBQUMsR0FBRzJCLFVBQVUsQ0FBQyxHQUFHO1lBQUUrRixRQUFRMUgsZUFBZUEsZUFBZSxDQUFDLEdBQUc7Z0JBQUVxSCxRQUFRLElBQUksQ0FBQ3hHLFdBQVc7WUFBQyxJQUFJYyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUStGLE1BQU07UUFBRTtJQUMvTztJQUNBakMsdUJBQXVCO1FBQ3RCLE9BQU8sSUFBSSxDQUFDeEQsSUFBSSxDQUFDMEYsaUJBQWlCLENBQUMsQ0FBQ0MsT0FBT2Y7WUFDMUMsSUFBSSxDQUFDZ0IsbUJBQW1CLENBQUNELE9BQU8sVUFBVWYsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFDLFlBQVk7UUFDakg7SUFDRDtJQUNBZSxvQkFBb0JELEtBQUssRUFBRUUsTUFBTSxFQUFFNUMsS0FBSyxFQUFFO1FBQ3pDLElBQUksQ0FBQzBDLFVBQVUscUJBQXFCQSxVQUFVLFdBQVUsS0FBTSxJQUFJLENBQUNHLGtCQUFrQixLQUFLN0MsT0FBTztZQUNoRyxJQUFJLENBQUM2QyxrQkFBa0IsR0FBRzdDO1lBQzFCLElBQUksQ0FBQy9DLFFBQVEsQ0FBQ2dELE9BQU8sQ0FBQ0Q7UUFDdkIsT0FBTyxJQUFJMEMsVUFBVSxjQUFjO1lBQ2xDLElBQUksQ0FBQ3pGLFFBQVEsQ0FBQ2dELE9BQU87WUFDckIsSUFBSTJDLFVBQVUsV0FBVyxJQUFJLENBQUM3RixJQUFJLENBQUMrRixPQUFPO1lBQzFDLElBQUksQ0FBQ0Qsa0JBQWtCLEdBQUcsS0FBSztRQUNoQztJQUNEO0FBQ0Q7QUFFQSxZQUFZO0FBQ1osc0JBQXNCO0FBQ3RCOzs7Ozs7Ozs7O0FBVUEsR0FDQSxNQUFNRSxlQUFlLENBQUNuRixhQUFhakMsYUFBYWM7SUFDL0MsT0FBTyxJQUFJMkIsZUFBZVIsYUFBYWpDLGFBQWFjO0FBQ3JEO0FBQ0EsU0FBU3VHO0lBQ1IsSUFBSSxLQUE2QixFQUFFLEVBQWE7SUFDaEQsTUFBTUMsV0FBV0MsVUFBVSxDQUFDLFVBQVU7SUFDdEMsSUFBSSxDQUFDRCxVQUFVLE9BQU87SUFDdEIsTUFBTUUsaUJBQWlCRixRQUFRLENBQUMsVUFBVTtJQUMxQyxJQUFJRSxtQkFBbUIsS0FBSyxLQUFLQSxtQkFBbUIsTUFBTSxPQUFPO0lBQ2pFLE1BQU1DLGVBQWVELGVBQWVuRixLQUFLLENBQUM7SUFDMUMsSUFBSSxDQUFDb0YsY0FBYyxPQUFPO0lBQzFCLE9BQU9DLFNBQVNELFlBQVksQ0FBQyxFQUFFLEVBQUUsT0FBTztBQUN6QztBQUNBLElBQUlKLGdDQUFnQzdDLFFBQVFDLElBQUksQ0FBQztBQUVqRCxZQUFZO0FBQzBJLENBQ3RKLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9pbmRleC5tanM/NDkzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGdW5jdGlvblJlZ2lvbiwgRnVuY3Rpb25zQ2xpZW50LCBGdW5jdGlvbnNFcnJvciwgRnVuY3Rpb25zRmV0Y2hFcnJvciwgRnVuY3Rpb25zSHR0cEVycm9yLCBGdW5jdGlvbnNSZWxheUVycm9yIH0gZnJvbSBcIkBzdXBhYmFzZS9mdW5jdGlvbnMtanNcIjtcbmltcG9ydCB7IFBvc3RncmVzdENsaWVudCwgUG9zdGdyZXN0RXJyb3IgfSBmcm9tIFwiQHN1cGFiYXNlL3Bvc3RncmVzdC1qc1wiO1xuaW1wb3J0IHsgUmVhbHRpbWVDbGllbnQgfSBmcm9tIFwiQHN1cGFiYXNlL3JlYWx0aW1lLWpzXCI7XG5pbXBvcnQgeyBTdG9yYWdlQ2xpZW50IH0gZnJvbSBcIkBzdXBhYmFzZS9zdG9yYWdlLWpzXCI7XG5pbXBvcnQgeyBBdXRoQ2xpZW50IH0gZnJvbSBcIkBzdXBhYmFzZS9hdXRoLWpzXCI7XG5cbmV4cG9ydCAqIGZyb20gXCJAc3VwYWJhc2UvcmVhbHRpbWUtanNcIlxuXG5leHBvcnQgKiBmcm9tIFwiQHN1cGFiYXNlL2F1dGgtanNcIlxuXG4vLyNyZWdpb24gc3JjL2xpYi92ZXJzaW9uLnRzXG5jb25zdCB2ZXJzaW9uID0gXCIyLjkxLjBcIjtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi9jb25zdGFudHMudHNcbmxldCBKU19FTlYgPSBcIlwiO1xuaWYgKHR5cGVvZiBEZW5vICE9PSBcInVuZGVmaW5lZFwiKSBKU19FTlYgPSBcImRlbm9cIjtcbmVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikgSlNfRU5WID0gXCJ3ZWJcIjtcbmVsc2UgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIikgSlNfRU5WID0gXCJyZWFjdC1uYXRpdmVcIjtcbmVsc2UgSlNfRU5WID0gXCJub2RlXCI7XG5jb25zdCBERUZBVUxUX0hFQURFUlMgPSB7IFwiWC1DbGllbnQtSW5mb1wiOiBgc3VwYWJhc2UtanMtJHtKU19FTlZ9LyR7dmVyc2lvbn1gIH07XG5jb25zdCBERUZBVUxUX0dMT0JBTF9PUFRJT05TID0geyBoZWFkZXJzOiBERUZBVUxUX0hFQURFUlMgfTtcbmNvbnN0IERFRkFVTFRfREJfT1BUSU9OUyA9IHsgc2NoZW1hOiBcInB1YmxpY1wiIH07XG5jb25zdCBERUZBVUxUX0FVVEhfT1BUSU9OUyA9IHtcblx0YXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcblx0cGVyc2lzdFNlc3Npb246IHRydWUsXG5cdGRldGVjdFNlc3Npb25JblVybDogdHJ1ZSxcblx0Zmxvd1R5cGU6IFwiaW1wbGljaXRcIlxufTtcbmNvbnN0IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyA9IHt9O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdHlwZW9mLmpzXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcblx0XCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXHRyZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG8kMSkge1xuXHRcdHJldHVybiB0eXBlb2YgbyQxO1xuXHR9IDogZnVuY3Rpb24obyQxKSB7XG5cdFx0cmV0dXJuIG8kMSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvJDEuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvJDEgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG8kMTtcblx0fSwgX3R5cGVvZihvKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL3RvUHJpbWl0aXZlLmpzXG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh0LCByKSB7XG5cdGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0O1xuXHR2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcblx0aWYgKHZvaWQgMCAhPT0gZSkge1xuXHRcdHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuXHRcdGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpO1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcblx0fVxuXHRyZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdG9Qcm9wZXJ0eUtleS5qc1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG5cdHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG5cdHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qc1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcblx0cmV0dXJuIChyID0gdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG5cdFx0dmFsdWU6IHQsXG5cdFx0ZW51bWVyYWJsZTogITAsXG5cdFx0Y29uZmlndXJhYmxlOiAhMCxcblx0XHR3cml0YWJsZTogITBcblx0fSkgOiBlW3JdID0gdCwgZTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL29iamVjdFNwcmVhZDIuanNcbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuXHR2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuXHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcblx0XHRyICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByJDEpLmVudW1lcmFibGU7XG5cdFx0fSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG5cdH1cblx0cmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG5cdGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG5cdFx0dmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuXHRcdHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIkMSkge1xuXHRcdFx0X2RlZmluZVByb3BlcnR5KGUsIHIkMSwgdFtyJDFdKTtcblx0XHR9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciQxLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIkMSkpO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBlO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL2ZldGNoLnRzXG5jb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcblx0aWYgKGN1c3RvbUZldGNoKSByZXR1cm4gKC4uLmFyZ3MpID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpO1xuXHRyZXR1cm4gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xufTtcbmNvbnN0IHJlc29sdmVIZWFkZXJzQ29uc3RydWN0b3IgPSAoKSA9PiB7XG5cdHJldHVybiBIZWFkZXJzO1xufTtcbmNvbnN0IGZldGNoV2l0aEF1dGggPSAoc3VwYWJhc2VLZXksIGdldEFjY2Vzc1Rva2VuLCBjdXN0b21GZXRjaCkgPT4ge1xuXHRjb25zdCBmZXRjaCQxID0gcmVzb2x2ZUZldGNoKGN1c3RvbUZldGNoKTtcblx0Y29uc3QgSGVhZGVyc0NvbnN0cnVjdG9yID0gcmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvcigpO1xuXHRyZXR1cm4gYXN5bmMgKGlucHV0LCBpbml0KSA9PiB7XG5cdFx0dmFyIF9hd2FpdCRnZXRBY2Nlc3NUb2tlbjtcblx0XHRjb25zdCBhY2Nlc3NUb2tlbiA9IChfYXdhaXQkZ2V0QWNjZXNzVG9rZW4gPSBhd2FpdCBnZXRBY2Nlc3NUb2tlbigpKSAhPT0gbnVsbCAmJiBfYXdhaXQkZ2V0QWNjZXNzVG9rZW4gIT09IHZvaWQgMCA/IF9hd2FpdCRnZXRBY2Nlc3NUb2tlbiA6IHN1cGFiYXNlS2V5O1xuXHRcdGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnNDb25zdHJ1Y3Rvcihpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycyk7XG5cdFx0aWYgKCFoZWFkZXJzLmhhcyhcImFwaWtleVwiKSkgaGVhZGVycy5zZXQoXCJhcGlrZXlcIiwgc3VwYWJhc2VLZXkpO1xuXHRcdGlmICghaGVhZGVycy5oYXMoXCJBdXRob3JpemF0aW9uXCIpKSBoZWFkZXJzLnNldChcIkF1dGhvcml6YXRpb25cIiwgYEJlYXJlciAke2FjY2Vzc1Rva2VufWApO1xuXHRcdHJldHVybiBmZXRjaCQxKGlucHV0LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgaW5pdCksIHt9LCB7IGhlYWRlcnMgfSkpO1xuXHR9O1xufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi9oZWxwZXJzLnRzXG5mdW5jdGlvbiBlbnN1cmVUcmFpbGluZ1NsYXNoKHVybCkge1xuXHRyZXR1cm4gdXJsLmVuZHNXaXRoKFwiL1wiKSA/IHVybCA6IHVybCArIFwiL1wiO1xufVxuZnVuY3Rpb24gYXBwbHlTZXR0aW5nRGVmYXVsdHMob3B0aW9ucywgZGVmYXVsdHMpIHtcblx0dmFyIF9ERUZBVUxUX0dMT0JBTF9PUFRJTywgX2dsb2JhbE9wdGlvbnMkaGVhZGVyO1xuXHRjb25zdCB7IGRiOiBkYk9wdGlvbnMsIGF1dGg6IGF1dGhPcHRpb25zLCByZWFsdGltZTogcmVhbHRpbWVPcHRpb25zLCBnbG9iYWw6IGdsb2JhbE9wdGlvbnMgfSA9IG9wdGlvbnM7XG5cdGNvbnN0IHsgZGI6IERFRkFVTFRfREJfT1BUSU9OUyQxLCBhdXRoOiBERUZBVUxUX0FVVEhfT1BUSU9OUyQxLCByZWFsdGltZTogREVGQVVMVF9SRUFMVElNRV9PUFRJT05TJDEsIGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OUyQxIH0gPSBkZWZhdWx0cztcblx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdGRiOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9EQl9PUFRJT05TJDEpLCBkYk9wdGlvbnMpLFxuXHRcdGF1dGg6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0FVVEhfT1BUSU9OUyQxKSwgYXV0aE9wdGlvbnMpLFxuXHRcdHJlYWx0aW1lOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9SRUFMVElNRV9PUFRJT05TJDEpLCByZWFsdGltZU9wdGlvbnMpLFxuXHRcdHN0b3JhZ2U6IHt9LFxuXHRcdGdsb2JhbDogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfR0xPQkFMX09QVElPTlMkMSksIGdsb2JhbE9wdGlvbnMpLCB7fSwgeyBoZWFkZXJzOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgKF9ERUZBVUxUX0dMT0JBTF9PUFRJTyA9IERFRkFVTFRfR0xPQkFMX09QVElPTlMkMSA9PT0gbnVsbCB8fCBERUZBVUxUX0dMT0JBTF9PUFRJT05TJDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IERFRkFVTFRfR0xPQkFMX09QVElPTlMkMS5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfREVGQVVMVF9HTE9CQUxfT1BUSU8gIT09IHZvaWQgMCA/IF9ERUZBVUxUX0dMT0JBTF9PUFRJTyA6IHt9KSwgKF9nbG9iYWxPcHRpb25zJGhlYWRlciA9IGdsb2JhbE9wdGlvbnMgPT09IG51bGwgfHwgZ2xvYmFsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2xvYmFsT3B0aW9ucy5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfZ2xvYmFsT3B0aW9ucyRoZWFkZXIgIT09IHZvaWQgMCA/IF9nbG9iYWxPcHRpb25zJGhlYWRlciA6IHt9KSB9KSxcblx0XHRhY2Nlc3NUb2tlbjogYXN5bmMgKCkgPT4gXCJcIlxuXHR9O1xuXHRpZiAob3B0aW9ucy5hY2Nlc3NUb2tlbikgcmVzdWx0LmFjY2Vzc1Rva2VuID0gb3B0aW9ucy5hY2Nlc3NUb2tlbjtcblx0ZWxzZSBkZWxldGUgcmVzdWx0LmFjY2Vzc1Rva2VuO1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4qIFZhbGlkYXRlcyBhIFN1cGFiYXNlIGNsaWVudCBVUkxcbipcbiogQHBhcmFtIHtzdHJpbmd9IHN1cGFiYXNlVXJsIC0gVGhlIFN1cGFiYXNlIGNsaWVudCBVUkwgc3RyaW5nLlxuKiBAcmV0dXJucyB7VVJMfSAtIFRoZSB2YWxpZGF0ZWQgYmFzZSBVUkwuXG4qIEB0aHJvd3Mge0Vycm9yfVxuKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU3VwYWJhc2VVcmwoc3VwYWJhc2VVcmwpIHtcblx0Y29uc3QgdHJpbW1lZFVybCA9IHN1cGFiYXNlVXJsID09PSBudWxsIHx8IHN1cGFiYXNlVXJsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdXBhYmFzZVVybC50cmltKCk7XG5cdGlmICghdHJpbW1lZFVybCkgdGhyb3cgbmV3IEVycm9yKFwic3VwYWJhc2VVcmwgaXMgcmVxdWlyZWQuXCIpO1xuXHRpZiAoIXRyaW1tZWRVcmwubWF0Y2goL15odHRwcz86XFwvXFwvL2kpKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN1cGFiYXNlVXJsOiBNdXN0IGJlIGEgdmFsaWQgSFRUUCBvciBIVFRQUyBVUkwuXCIpO1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgVVJMKGVuc3VyZVRyYWlsaW5nU2xhc2godHJpbW1lZFVybCkpO1xuXHR9IGNhdGNoIChfdW51c2VkKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJJbnZhbGlkIHN1cGFiYXNlVXJsOiBQcm92aWRlZCBVUkwgaXMgbWFsZm9ybWVkLlwiKTtcblx0fVxufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL1N1cGFiYXNlQXV0aENsaWVudC50c1xudmFyIFN1cGFiYXNlQXV0aENsaWVudCA9IGNsYXNzIGV4dGVuZHMgQXV0aENsaWVudCB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRzdXBlcihvcHRpb25zKTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1N1cGFiYXNlQ2xpZW50LnRzXG4vKipcbiogU3VwYWJhc2UgQ2xpZW50LlxuKlxuKiBBbiBpc29tb3JwaGljIEphdmFzY3JpcHQgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIFBvc3RncmVzLlxuKi9cbnZhciBTdXBhYmFzZUNsaWVudCA9IGNsYXNzIHtcblx0LyoqXG5cdCogQ3JlYXRlIGEgbmV3IGNsaWVudCBmb3IgdXNlIGluIHRoZSBicm93c2VyLlxuXHQqIEBwYXJhbSBzdXBhYmFzZVVybCBUaGUgdW5pcXVlIFN1cGFiYXNlIFVSTCB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuXHQqIEBwYXJhbSBzdXBhYmFzZUtleSBUaGUgdW5pcXVlIFN1cGFiYXNlIEtleSB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuXHQqIEBwYXJhbSBvcHRpb25zLmRiLnNjaGVtYSBZb3UgY2FuIHN3aXRjaCBpbiBiZXR3ZWVuIHNjaGVtYXMuIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5hdXRoLmF1dG9SZWZyZXNoVG9rZW4gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVmcmVzaCB0aGUgdG9rZW4gYmVmb3JlIGV4cGlyaW5nLlxuXHQqIEBwYXJhbSBvcHRpb25zLmF1dGgucGVyc2lzdFNlc3Npb24gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgc2F2ZSB0aGUgdXNlciBzZXNzaW9uIGludG8gbG9jYWwgc3RvcmFnZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5hdXRoLmRldGVjdFNlc3Npb25JblVybCBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSBkZXRlY3RzIE9BdXRoIGdyYW50cyBpbiB0aGUgVVJMIGFuZCBzaWducyBpbiB0aGUgdXNlci5cblx0KiBAcGFyYW0gb3B0aW9ucy5yZWFsdGltZSBPcHRpb25zIHBhc3NlZCBhbG9uZyB0byByZWFsdGltZS1qcyBjb25zdHJ1Y3Rvci5cblx0KiBAcGFyYW0gb3B0aW9ucy5zdG9yYWdlIE9wdGlvbnMgcGFzc2VkIGFsb25nIHRvIHRoZSBzdG9yYWdlLWpzIGNvbnN0cnVjdG9yLlxuXHQqIEBwYXJhbSBvcHRpb25zLmdsb2JhbC5mZXRjaCBBIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvbi5cblx0KiBAcGFyYW0gb3B0aW9ucy5nbG9iYWwuaGVhZGVycyBBbnkgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHNlbmQgd2l0aCBlYWNoIG5ldHdvcmsgcmVxdWVzdC5cblx0KiBAZXhhbXBsZVxuXHQqIGBgYHRzXG5cdCogaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xuXHQqXG5cdCogY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jbycsICdwdWJsaWMtYW5vbi1rZXknKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbSgncHJvZmlsZXMnKS5zZWxlY3QoJyonKVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3RvcihzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpIHtcblx0XHR2YXIgX3NldHRpbmdzJGF1dGgkc3RvcmFnLCBfc2V0dGluZ3MkZ2xvYmFsJGhlYWQ7XG5cdFx0dGhpcy5zdXBhYmFzZVVybCA9IHN1cGFiYXNlVXJsO1xuXHRcdHRoaXMuc3VwYWJhc2VLZXkgPSBzdXBhYmFzZUtleTtcblx0XHRjb25zdCBiYXNlVXJsID0gdmFsaWRhdGVTdXBhYmFzZVVybChzdXBhYmFzZVVybCk7XG5cdFx0aWYgKCFzdXBhYmFzZUtleSkgdGhyb3cgbmV3IEVycm9yKFwic3VwYWJhc2VLZXkgaXMgcmVxdWlyZWQuXCIpO1xuXHRcdHRoaXMucmVhbHRpbWVVcmwgPSBuZXcgVVJMKFwicmVhbHRpbWUvdjFcIiwgYmFzZVVybCk7XG5cdFx0dGhpcy5yZWFsdGltZVVybC5wcm90b2NvbCA9IHRoaXMucmVhbHRpbWVVcmwucHJvdG9jb2wucmVwbGFjZShcImh0dHBcIiwgXCJ3c1wiKTtcblx0XHR0aGlzLmF1dGhVcmwgPSBuZXcgVVJMKFwiYXV0aC92MVwiLCBiYXNlVXJsKTtcblx0XHR0aGlzLnN0b3JhZ2VVcmwgPSBuZXcgVVJMKFwic3RvcmFnZS92MVwiLCBiYXNlVXJsKTtcblx0XHR0aGlzLmZ1bmN0aW9uc1VybCA9IG5ldyBVUkwoXCJmdW5jdGlvbnMvdjFcIiwgYmFzZVVybCk7XG5cdFx0Y29uc3QgZGVmYXVsdFN0b3JhZ2VLZXkgPSBgc2ItJHtiYXNlVXJsLmhvc3RuYW1lLnNwbGl0KFwiLlwiKVswXX0tYXV0aC10b2tlbmA7XG5cdFx0Y29uc3QgREVGQVVMVFMgPSB7XG5cdFx0XHRkYjogREVGQVVMVF9EQl9PUFRJT05TLFxuXHRcdFx0cmVhbHRpbWU6IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyxcblx0XHRcdGF1dGg6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0FVVEhfT1BUSU9OUyksIHt9LCB7IHN0b3JhZ2VLZXk6IGRlZmF1bHRTdG9yYWdlS2V5IH0pLFxuXHRcdFx0Z2xvYmFsOiBERUZBVUxUX0dMT0JBTF9PUFRJT05TXG5cdFx0fTtcblx0XHRjb25zdCBzZXR0aW5ncyA9IGFwcGx5U2V0dGluZ0RlZmF1bHRzKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCBERUZBVUxUUyk7XG5cdFx0dGhpcy5zdG9yYWdlS2V5ID0gKF9zZXR0aW5ncyRhdXRoJHN0b3JhZyA9IHNldHRpbmdzLmF1dGguc3RvcmFnZUtleSkgIT09IG51bGwgJiYgX3NldHRpbmdzJGF1dGgkc3RvcmFnICE9PSB2b2lkIDAgPyBfc2V0dGluZ3MkYXV0aCRzdG9yYWcgOiBcIlwiO1xuXHRcdHRoaXMuaGVhZGVycyA9IChfc2V0dGluZ3MkZ2xvYmFsJGhlYWQgPSBzZXR0aW5ncy5nbG9iYWwuaGVhZGVycykgIT09IG51bGwgJiYgX3NldHRpbmdzJGdsb2JhbCRoZWFkICE9PSB2b2lkIDAgPyBfc2V0dGluZ3MkZ2xvYmFsJGhlYWQgOiB7fTtcblx0XHRpZiAoIXNldHRpbmdzLmFjY2Vzc1Rva2VuKSB7XG5cdFx0XHR2YXIgX3NldHRpbmdzJGF1dGg7XG5cdFx0XHR0aGlzLmF1dGggPSB0aGlzLl9pbml0U3VwYWJhc2VBdXRoQ2xpZW50KChfc2V0dGluZ3MkYXV0aCA9IHNldHRpbmdzLmF1dGgpICE9PSBudWxsICYmIF9zZXR0aW5ncyRhdXRoICE9PSB2b2lkIDAgPyBfc2V0dGluZ3MkYXV0aCA6IHt9LCB0aGlzLmhlYWRlcnMsIHNldHRpbmdzLmdsb2JhbC5mZXRjaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYWNjZXNzVG9rZW4gPSBzZXR0aW5ncy5hY2Nlc3NUb2tlbjtcblx0XHRcdHRoaXMuYXV0aCA9IG5ldyBQcm94eSh7fSwgeyBnZXQ6IChfLCBwcm9wKSA9PiB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL3N1cGFiYXNlLWpzOiBTdXBhYmFzZSBDbGllbnQgaXMgY29uZmlndXJlZCB3aXRoIHRoZSBhY2Nlc3NUb2tlbiBvcHRpb24sIGFjY2Vzc2luZyBzdXBhYmFzZS5hdXRoLiR7U3RyaW5nKHByb3ApfSBpcyBub3QgcG9zc2libGVgKTtcblx0XHRcdH0gfSk7XG5cdFx0fVxuXHRcdHRoaXMuZmV0Y2ggPSBmZXRjaFdpdGhBdXRoKHN1cGFiYXNlS2V5LCB0aGlzLl9nZXRBY2Nlc3NUb2tlbi5iaW5kKHRoaXMpLCBzZXR0aW5ncy5nbG9iYWwuZmV0Y2gpO1xuXHRcdHRoaXMucmVhbHRpbWUgPSB0aGlzLl9pbml0UmVhbHRpbWVDbGllbnQoX29iamVjdFNwcmVhZDIoe1xuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0YWNjZXNzVG9rZW46IHRoaXMuX2dldEFjY2Vzc1Rva2VuLmJpbmQodGhpcylcblx0XHR9LCBzZXR0aW5ncy5yZWFsdGltZSkpO1xuXHRcdGlmICh0aGlzLmFjY2Vzc1Rva2VuKSBQcm9taXNlLnJlc29sdmUodGhpcy5hY2Nlc3NUb2tlbigpKS50aGVuKCh0b2tlbikgPT4gdGhpcy5yZWFsdGltZS5zZXRBdXRoKHRva2VuKSkuY2F0Y2goKGUpID0+IGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBzZXQgaW5pdGlhbCBSZWFsdGltZSBhdXRoIHRva2VuOlwiLCBlKSk7XG5cdFx0dGhpcy5yZXN0ID0gbmV3IFBvc3RncmVzdENsaWVudChuZXcgVVJMKFwicmVzdC92MVwiLCBiYXNlVXJsKS5ocmVmLCB7XG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRzY2hlbWE6IHNldHRpbmdzLmRiLnNjaGVtYSxcblx0XHRcdGZldGNoOiB0aGlzLmZldGNoXG5cdFx0fSk7XG5cdFx0dGhpcy5zdG9yYWdlID0gbmV3IFN0b3JhZ2VDbGllbnQodGhpcy5zdG9yYWdlVXJsLmhyZWYsIHRoaXMuaGVhZGVycywgdGhpcy5mZXRjaCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0b3JhZ2UpO1xuXHRcdGlmICghc2V0dGluZ3MuYWNjZXNzVG9rZW4pIHRoaXMuX2xpc3RlbkZvckF1dGhFdmVudHMoKTtcblx0fVxuXHQvKipcblx0KiBTdXBhYmFzZSBGdW5jdGlvbnMgYWxsb3dzIHlvdSB0byBkZXBsb3kgYW5kIGludm9rZSBlZGdlIGZ1bmN0aW9ucy5cblx0Ki9cblx0Z2V0IGZ1bmN0aW9ucygpIHtcblx0XHRyZXR1cm4gbmV3IEZ1bmN0aW9uc0NsaWVudCh0aGlzLmZ1bmN0aW9uc1VybC5ocmVmLCB7XG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRjdXN0b21GZXRjaDogdGhpcy5mZXRjaFxuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIFBlcmZvcm0gYSBxdWVyeSBvbiBhIHRhYmxlIG9yIGEgdmlldy5cblx0KlxuXHQqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSB0YWJsZSBvciB2aWV3IG5hbWUgdG8gcXVlcnlcblx0Ki9cblx0ZnJvbShyZWxhdGlvbikge1xuXHRcdHJldHVybiB0aGlzLnJlc3QuZnJvbShyZWxhdGlvbik7XG5cdH1cblx0LyoqXG5cdCogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cblx0KlxuXHQqIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cblx0KlxuXHQqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHF1ZXJ5XG5cdCovXG5cdHNjaGVtYShzY2hlbWEpIHtcblx0XHRyZXR1cm4gdGhpcy5yZXN0LnNjaGVtYShzY2hlbWEpO1xuXHR9XG5cdC8qKlxuXHQqIFBlcmZvcm0gYSBmdW5jdGlvbiBjYWxsLlxuXHQqXG5cdCogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIG5hbWUgdG8gY2FsbFxuXHQqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuXHQqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cblx0KiBAcGFyYW0gb3B0aW9ucy5nZXQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoXG5cdCogcmVhZC1vbmx5IGFjY2VzcyBtb2RlLlxuXHQqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIHJldHVybmVkIGJ5IHRoZVxuXHQqIGZ1bmN0aW9uLiBPbmx5IGFwcGxpY2FibGUgZm9yIFtzZXQtcmV0dXJuaW5nXG5cdCogZnVuY3Rpb25zXShodHRwczovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzL2N1cnJlbnQvZnVuY3Rpb25zLXNyZi5odG1sKS5cblx0KlxuXHQqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcblx0KiBob29kLlxuXHQqXG5cdCogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcblx0KiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuXHQqXG5cdCogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuXHQqIG51bWJlcnMuXG5cdCovXG5cdHJwYyhmbiwgYXJncyA9IHt9LCBvcHRpb25zID0ge1xuXHRcdGhlYWQ6IGZhbHNlLFxuXHRcdGdldDogZmFsc2UsXG5cdFx0Y291bnQ6IHZvaWQgMFxuXHR9KSB7XG5cdFx0cmV0dXJuIHRoaXMucmVzdC5ycGMoZm4sIGFyZ3MsIG9wdGlvbnMpO1xuXHR9XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBSZWFsdGltZSBjaGFubmVsIHdpdGggQnJvYWRjYXN0LCBQcmVzZW5jZSwgYW5kIFBvc3RncmVzIENoYW5nZXMuXG5cdCpcblx0KiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cblx0KlxuXHQqL1xuXHRjaGFubmVsKG5hbWUsIG9wdHMgPSB7IGNvbmZpZzoge30gfSkge1xuXHRcdHJldHVybiB0aGlzLnJlYWx0aW1lLmNoYW5uZWwobmFtZSwgb3B0cyk7XG5cdH1cblx0LyoqXG5cdCogUmV0dXJucyBhbGwgUmVhbHRpbWUgY2hhbm5lbHMuXG5cdCovXG5cdGdldENoYW5uZWxzKCkge1xuXHRcdHJldHVybiB0aGlzLnJlYWx0aW1lLmdldENoYW5uZWxzKCk7XG5cdH1cblx0LyoqXG5cdCogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIFJlYWx0aW1lIGNoYW5uZWwgZnJvbSBSZWFsdGltZSBjbGllbnQuXG5cdCpcblx0KiBAcGFyYW0ge1JlYWx0aW1lQ2hhbm5lbH0gY2hhbm5lbCAtIFRoZSBuYW1lIG9mIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuXHQqXG5cdCovXG5cdHJlbW92ZUNoYW5uZWwoY2hhbm5lbCkge1xuXHRcdHJldHVybiB0aGlzLnJlYWx0aW1lLnJlbW92ZUNoYW5uZWwoY2hhbm5lbCk7XG5cdH1cblx0LyoqXG5cdCogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIGFsbCBSZWFsdGltZSBjaGFubmVscyBmcm9tIFJlYWx0aW1lIGNsaWVudC5cblx0Ki9cblx0cmVtb3ZlQWxsQ2hhbm5lbHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVhbHRpbWUucmVtb3ZlQWxsQ2hhbm5lbHMoKTtcblx0fVxuXHRhc3luYyBfZ2V0QWNjZXNzVG9rZW4oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgX2RhdGEkc2Vzc2lvbiRhY2Nlc3NfLCBfZGF0YSRzZXNzaW9uO1xuXHRcdGlmIChfdGhpcy5hY2Nlc3NUb2tlbikgcmV0dXJuIGF3YWl0IF90aGlzLmFjY2Vzc1Rva2VuKCk7XG5cdFx0Y29uc3QgeyBkYXRhIH0gPSBhd2FpdCBfdGhpcy5hdXRoLmdldFNlc3Npb24oKTtcblx0XHRyZXR1cm4gKF9kYXRhJHNlc3Npb24kYWNjZXNzXyA9IChfZGF0YSRzZXNzaW9uID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfZGF0YSRzZXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGF0YSRzZXNzaW9uLmFjY2Vzc190b2tlbikgIT09IG51bGwgJiYgX2RhdGEkc2Vzc2lvbiRhY2Nlc3NfICE9PSB2b2lkIDAgPyBfZGF0YSRzZXNzaW9uJGFjY2Vzc18gOiBfdGhpcy5zdXBhYmFzZUtleTtcblx0fVxuXHRfaW5pdFN1cGFiYXNlQXV0aENsaWVudCh7IGF1dG9SZWZyZXNoVG9rZW4sIHBlcnNpc3RTZXNzaW9uLCBkZXRlY3RTZXNzaW9uSW5VcmwsIHN0b3JhZ2UsIHVzZXJTdG9yYWdlLCBzdG9yYWdlS2V5LCBmbG93VHlwZSwgbG9jaywgZGVidWcsIHRocm93T25FcnJvciB9LCBoZWFkZXJzLCBmZXRjaCQxKSB7XG5cdFx0Y29uc3QgYXV0aEhlYWRlcnMgPSB7XG5cdFx0XHRBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5zdXBhYmFzZUtleX1gLFxuXHRcdFx0YXBpa2V5OiBgJHt0aGlzLnN1cGFiYXNlS2V5fWBcblx0XHR9O1xuXHRcdHJldHVybiBuZXcgU3VwYWJhc2VBdXRoQ2xpZW50KHtcblx0XHRcdHVybDogdGhpcy5hdXRoVXJsLmhyZWYsXG5cdFx0XHRoZWFkZXJzOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYXV0aEhlYWRlcnMpLCBoZWFkZXJzKSxcblx0XHRcdHN0b3JhZ2VLZXksXG5cdFx0XHRhdXRvUmVmcmVzaFRva2VuLFxuXHRcdFx0cGVyc2lzdFNlc3Npb24sXG5cdFx0XHRkZXRlY3RTZXNzaW9uSW5VcmwsXG5cdFx0XHRzdG9yYWdlLFxuXHRcdFx0dXNlclN0b3JhZ2UsXG5cdFx0XHRmbG93VHlwZSxcblx0XHRcdGxvY2ssXG5cdFx0XHRkZWJ1Zyxcblx0XHRcdHRocm93T25FcnJvcixcblx0XHRcdGZldGNoOiBmZXRjaCQxLFxuXHRcdFx0aGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcjogT2JqZWN0LmtleXModGhpcy5oZWFkZXJzKS5zb21lKChrZXkpID0+IGtleS50b0xvd2VyQ2FzZSgpID09PSBcImF1dGhvcml6YXRpb25cIilcblx0XHR9KTtcblx0fVxuXHRfaW5pdFJlYWx0aW1lQ2xpZW50KG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbmV3IFJlYWx0aW1lQ2xpZW50KHRoaXMucmVhbHRpbWVVcmwuaHJlZiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwgeyBwYXJhbXM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB7IGFwaWtleTogdGhpcy5zdXBhYmFzZUtleSB9KSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmFtcykgfSkpO1xuXHR9XG5cdF9saXN0ZW5Gb3JBdXRoRXZlbnRzKCkge1xuXHRcdHJldHVybiB0aGlzLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoKGV2ZW50LCBzZXNzaW9uKSA9PiB7XG5cdFx0XHR0aGlzLl9oYW5kbGVUb2tlbkNoYW5nZWQoZXZlbnQsIFwiQ0xJRU5UXCIsIHNlc3Npb24gPT09IG51bGwgfHwgc2Vzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuXHRcdH0pO1xuXHR9XG5cdF9oYW5kbGVUb2tlbkNoYW5nZWQoZXZlbnQsIHNvdXJjZSwgdG9rZW4pIHtcblx0XHRpZiAoKGV2ZW50ID09PSBcIlRPS0VOX1JFRlJFU0hFRFwiIHx8IGV2ZW50ID09PSBcIlNJR05FRF9JTlwiKSAmJiB0aGlzLmNoYW5nZWRBY2Nlc3NUb2tlbiAhPT0gdG9rZW4pIHtcblx0XHRcdHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuID0gdG9rZW47XG5cdFx0XHR0aGlzLnJlYWx0aW1lLnNldEF1dGgodG9rZW4pO1xuXHRcdH0gZWxzZSBpZiAoZXZlbnQgPT09IFwiU0lHTkVEX09VVFwiKSB7XG5cdFx0XHR0aGlzLnJlYWx0aW1lLnNldEF1dGgoKTtcblx0XHRcdGlmIChzb3VyY2UgPT0gXCJTVE9SQUdFXCIpIHRoaXMuYXV0aC5zaWduT3V0KCk7XG5cdFx0XHR0aGlzLmNoYW5nZWRBY2Nlc3NUb2tlbiA9IHZvaWQgMDtcblx0XHR9XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9pbmRleC50c1xuLyoqXG4qIENyZWF0ZXMgYSBuZXcgU3VwYWJhc2UgQ2xpZW50LlxuKlxuKiBAZXhhbXBsZVxuKiBgYGB0c1xuKiBpbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnXG4qXG4qIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28nLCAncHVibGljLWFub24ta2V5JylcbiogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbSgncHJvZmlsZXMnKS5zZWxlY3QoJyonKVxuKiBgYGBcbiovXG5jb25zdCBjcmVhdGVDbGllbnQgPSAoc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5LCBvcHRpb25zKSA9PiB7XG5cdHJldHVybiBuZXcgU3VwYWJhc2VDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5LCBvcHRpb25zKTtcbn07XG5mdW5jdGlvbiBzaG91bGRTaG93RGVwcmVjYXRpb25XYXJuaW5nKCkge1xuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCBfcHJvY2VzcyA9IGdsb2JhbFRoaXNbXCJwcm9jZXNzXCJdO1xuXHRpZiAoIV9wcm9jZXNzKSByZXR1cm4gZmFsc2U7XG5cdGNvbnN0IHByb2Nlc3NWZXJzaW9uID0gX3Byb2Nlc3NbXCJ2ZXJzaW9uXCJdO1xuXHRpZiAocHJvY2Vzc1ZlcnNpb24gPT09IHZvaWQgMCB8fCBwcm9jZXNzVmVyc2lvbiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCB2ZXJzaW9uTWF0Y2ggPSBwcm9jZXNzVmVyc2lvbi5tYXRjaCgvXnYoXFxkKylcXC4vKTtcblx0aWYgKCF2ZXJzaW9uTWF0Y2gpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIHBhcnNlSW50KHZlcnNpb25NYXRjaFsxXSwgMTApIDw9IDE4O1xufVxuaWYgKHNob3VsZFNob3dEZXByZWNhdGlvbldhcm5pbmcoKSkgY29uc29sZS53YXJuKFwi4pqg77iPICBOb2RlLmpzIDE4IGFuZCBiZWxvdyBhcmUgZGVwcmVjYXRlZCBhbmQgd2lsbCBubyBsb25nZXIgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBAc3VwYWJhc2Uvc3VwYWJhc2UtanMuIFBsZWFzZSB1cGdyYWRlIHRvIE5vZGUuanMgMjAgb3IgbGF0ZXIuIEZvciBtb3JlIGluZm9ybWF0aW9uLCB2aXNpdDogaHR0cHM6Ly9naXRodWIuY29tL29yZ3Mvc3VwYWJhc2UvZGlzY3Vzc2lvbnMvMzcyMTdcIik7XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgRnVuY3Rpb25SZWdpb24sIEZ1bmN0aW9uc0Vycm9yLCBGdW5jdGlvbnNGZXRjaEVycm9yLCBGdW5jdGlvbnNIdHRwRXJyb3IsIEZ1bmN0aW9uc1JlbGF5RXJyb3IsIFBvc3RncmVzdEVycm9yLCBTdXBhYmFzZUNsaWVudCwgY3JlYXRlQ2xpZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIkZ1bmN0aW9uUmVnaW9uIiwiRnVuY3Rpb25zQ2xpZW50IiwiRnVuY3Rpb25zRXJyb3IiLCJGdW5jdGlvbnNGZXRjaEVycm9yIiwiRnVuY3Rpb25zSHR0cEVycm9yIiwiRnVuY3Rpb25zUmVsYXlFcnJvciIsIlBvc3RncmVzdENsaWVudCIsIlBvc3RncmVzdEVycm9yIiwiUmVhbHRpbWVDbGllbnQiLCJTdG9yYWdlQ2xpZW50IiwiQXV0aENsaWVudCIsInZlcnNpb24iLCJKU19FTlYiLCJEZW5vIiwiZG9jdW1lbnQiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwiREVGQVVMVF9IRUFERVJTIiwiREVGQVVMVF9HTE9CQUxfT1BUSU9OUyIsImhlYWRlcnMiLCJERUZBVUxUX0RCX09QVElPTlMiLCJzY2hlbWEiLCJERUZBVUxUX0FVVEhfT1BUSU9OUyIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsImRldGVjdFNlc3Npb25JblVybCIsImZsb3dUeXBlIiwiREVGQVVMVF9SRUFMVElNRV9PUFRJT05TIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsIm8kMSIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwidG9QcmltaXRpdmUiLCJ0IiwiciIsImUiLCJpIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsInRvUHJvcGVydHlLZXkiLCJfZGVmaW5lUHJvcGVydHkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwib3duS2V5cyIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJyJDEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsInJlc29sdmVGZXRjaCIsImN1c3RvbUZldGNoIiwiYXJncyIsImZldGNoIiwicmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvciIsIkhlYWRlcnMiLCJmZXRjaFdpdGhBdXRoIiwic3VwYWJhc2VLZXkiLCJnZXRBY2Nlc3NUb2tlbiIsImZldGNoJDEiLCJIZWFkZXJzQ29uc3RydWN0b3IiLCJpbnB1dCIsImluaXQiLCJfYXdhaXQkZ2V0QWNjZXNzVG9rZW4iLCJhY2Nlc3NUb2tlbiIsImhhcyIsInNldCIsImVuc3VyZVRyYWlsaW5nU2xhc2giLCJ1cmwiLCJlbmRzV2l0aCIsImFwcGx5U2V0dGluZ0RlZmF1bHRzIiwib3B0aW9ucyIsImRlZmF1bHRzIiwiX0RFRkFVTFRfR0xPQkFMX09QVElPIiwiX2dsb2JhbE9wdGlvbnMkaGVhZGVyIiwiZGIiLCJkYk9wdGlvbnMiLCJhdXRoIiwiYXV0aE9wdGlvbnMiLCJyZWFsdGltZSIsInJlYWx0aW1lT3B0aW9ucyIsImdsb2JhbCIsImdsb2JhbE9wdGlvbnMiLCJERUZBVUxUX0RCX09QVElPTlMkMSIsIkRFRkFVTFRfQVVUSF9PUFRJT05TJDEiLCJERUZBVUxUX1JFQUxUSU1FX09QVElPTlMkMSIsIkRFRkFVTFRfR0xPQkFMX09QVElPTlMkMSIsInJlc3VsdCIsInN0b3JhZ2UiLCJ2YWxpZGF0ZVN1cGFiYXNlVXJsIiwic3VwYWJhc2VVcmwiLCJ0cmltbWVkVXJsIiwidHJpbSIsIkVycm9yIiwibWF0Y2giLCJVUkwiLCJfdW51c2VkIiwiU3VwYWJhc2VBdXRoQ2xpZW50IiwiU3VwYWJhc2VDbGllbnQiLCJfc2V0dGluZ3MkYXV0aCRzdG9yYWciLCJfc2V0dGluZ3MkZ2xvYmFsJGhlYWQiLCJiYXNlVXJsIiwicmVhbHRpbWVVcmwiLCJwcm90b2NvbCIsInJlcGxhY2UiLCJhdXRoVXJsIiwic3RvcmFnZVVybCIsImZ1bmN0aW9uc1VybCIsImRlZmF1bHRTdG9yYWdlS2V5IiwiaG9zdG5hbWUiLCJzcGxpdCIsIkRFRkFVTFRTIiwic3RvcmFnZUtleSIsInNldHRpbmdzIiwiX3NldHRpbmdzJGF1dGgiLCJfaW5pdFN1cGFiYXNlQXV0aENsaWVudCIsIlByb3h5IiwiZ2V0IiwiXyIsInByb3AiLCJfZ2V0QWNjZXNzVG9rZW4iLCJiaW5kIiwiX2luaXRSZWFsdGltZUNsaWVudCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsInRva2VuIiwic2V0QXV0aCIsImNhdGNoIiwiY29uc29sZSIsIndhcm4iLCJyZXN0IiwiaHJlZiIsIl9saXN0ZW5Gb3JBdXRoRXZlbnRzIiwiZnVuY3Rpb25zIiwiZnJvbSIsInJlbGF0aW9uIiwicnBjIiwiZm4iLCJoZWFkIiwiY291bnQiLCJjaGFubmVsIiwibmFtZSIsIm9wdHMiLCJjb25maWciLCJnZXRDaGFubmVscyIsInJlbW92ZUNoYW5uZWwiLCJyZW1vdmVBbGxDaGFubmVscyIsIl90aGlzIiwiX2RhdGEkc2Vzc2lvbiRhY2Nlc3NfIiwiX2RhdGEkc2Vzc2lvbiIsImRhdGEiLCJnZXRTZXNzaW9uIiwic2Vzc2lvbiIsImFjY2Vzc190b2tlbiIsInVzZXJTdG9yYWdlIiwibG9jayIsImRlYnVnIiwidGhyb3dPbkVycm9yIiwiYXV0aEhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwiYXBpa2V5IiwiaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciIsInNvbWUiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsInBhcmFtcyIsIm9uQXV0aFN0YXRlQ2hhbmdlIiwiZXZlbnQiLCJfaGFuZGxlVG9rZW5DaGFuZ2VkIiwic291cmNlIiwiY2hhbmdlZEFjY2Vzc1Rva2VuIiwic2lnbk91dCIsImNyZWF0ZUNsaWVudCIsInNob3VsZFNob3dEZXByZWNhdGlvbldhcm5pbmciLCJfcHJvY2VzcyIsImdsb2JhbFRoaXMiLCJwcm9jZXNzVmVyc2lvbiIsInZlcnNpb25NYXRjaCIsInBhcnNlSW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/supabase-js/dist/index.mjs\n");

/***/ })

};
;